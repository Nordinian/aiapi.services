"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getFontString = exports.measureTextCanvas = exports.measureTextDom = exports.testLetter = exports.getStrByWithCanvas = exports.getStrByWithDom = exports.prepareContext = exports.applyStrokeStyle = exports.applyFillStyle = exports.regFirstSpace = exports.regLetter = exports.DIRECTION_KEY = void 0;

const application_1 = require("../../application");

exports.DIRECTION_KEY = {
    horizontal: {
        width: "width",
        height: "height",
        left: "left",
        top: "top",
        x: "x",
        y: "y",
        bottom: "bottom"
    },
    vertical: {
        width: "height",
        height: "width",
        left: "top",
        top: "left",
        x: "y",
        y: "x",
        bottom: "right"
    }
};

const defaultFormatting = {
    fontSize: 16,
    fontFamily: "sans-serif",
    fill: !0,
    stroke: !1,
    fontWeight: "normal",
    lineHeight: "normal",
    fontStyle: "normal",
    textDecoration: "none",
    textAlign: "left",
    script: "normal"
}, nbsp = String.fromCharCode(160);

exports.regLetter = /\w|\(|\)|-/;

const regPunctuation = /[.?!,;:/，。？！、；：]/;

function applyFillStyle(ctx, character) {
    const fillStyle = character && character.fill || defaultFormatting.fill;
    if (!fillStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.fillStyle = fillStyle;
    let fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: character.textBaseline || "alphabetic",
        fontStyle: character.fontStyle || "",
        fontWeight: character.fontWeight || "",
        fontSize: fontSize,
        fontFamily: character.fontFamily || "sans-serif"
    });
}

function applyStrokeStyle(ctx, character) {
    const strokeStyle = character && character.stroke || defaultFormatting.stroke;
    if (!strokeStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.lineWidth = character && "number" == typeof character.lineHeight ? character.lineHeight : 1, 
    ctx.strokeStyle = strokeStyle;
    let fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: character.textBaseline || "alphabetic",
        fontStyle: character.fontStyle || "",
        fontWeight: character.fontWeight || "",
        fontSize: fontSize,
        fontFamily: character.fontFamily || "sans-serif"
    });
}

function prepareContext(ctx) {
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: "bottom"
    });
}

function getStrByWithDom(desc, width, style, guessIndex, needTestLetter) {
    desc = desc.replace(/\s/g, nbsp);
    const span = document.createElement("span");
    span.setAttribute("style", style), span.style.visibility = "hidden", span.style.whiteSpace = "nowrap", 
    document.body.appendChild(span);
    let index = guessIndex, temp = desc.slice(0, index);
    span.innerText = temp;
    let tempWidth = span.offsetWidth, tempNext = desc.slice(0, index + 1);
    span.innerText = tempNext;
    let tempWidthNext = span.offsetWidth;
    for (;tempWidth > width || tempWidthNext <= width; ) tempWidth > width ? index-- : index++, 
    temp = desc.slice(0, index), span.innerText = temp, tempWidth = span.offsetWidth, 
    tempNext = desc.slice(0, index + 1), span.innerText = tempNext, tempWidthNext = span.offsetWidth;
    return needTestLetter && (index = testLetter(desc, index)), document.body.removeChild(span), 
    index;
}

function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
    if (!width || width <= 0) return 0;
    const textMeasure = application_1.application.graphicUtil.textMeasure;
    let index = guessIndex, temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    for (;tempWidth > width || tempWidthNext <= width; ) {
        if (tempWidth > width ? index-- : index++, index > desc.length) {
            index = desc.length;
            break;
        }
        if (index < 0) {
            index = 0;
            break;
        }
        temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), 
        tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    }
    return needTestLetter && (index = testLetter(desc, index)), index;
}

function testLetter(string, index) {
    let i = index;
    for (;exports.regLetter.test(string[i - 1]) && exports.regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i--, 
    i <= 0) return index;
    return i;
}

function measureTextDom(text, style) {
    var _a;
    let div;
    const span = document.createElement("span"), block = document.createElement("div");
    div = document.createElement("div"), block.style.display = "inline-block", block.style.width = "1px", 
    block.style.height = "0", div.style.visibility = "hidden", div.style.position = "absolute", 
    div.style.top = "0", div.style.left = "0", div.style.width = "500px", div.style.height = "200px", 
    div.style.whiteSpace = "nowrap", div.appendChild(span), div.appendChild(block), 
    document.body.appendChild(div);
    const result = {};
    try {
        span.setAttribute("style", style), span.style.whiteSpace = "nowrap", span.style.display = "inline-block", 
        span.innerHTML = "", span.appendChild(document.createTextNode(text.replace(/\s/g, nbsp))), 
        block.style.verticalAlign = "baseline", result.ascent = block.offsetTop - span.offsetTop, 
        block.style.verticalAlign = "bottom", result.height = block.offsetTop - span.offsetTop, 
        result.descent = result.height - result.ascent, result.width = span.offsetWidth;
    } finally {
        null === (_a = div.parentNode) || void 0 === _a || _a.removeChild(div), div = null;
    }
    return result;
}

function measureTextCanvas(text, character) {
    const measurement = application_1.application.graphicUtil.textMeasure.measureText(text, character), result = {
        ascent: 0,
        height: 0,
        descent: 0,
        width: 0
    };
    return "number" != typeof measurement.actualBoundingBoxAscent || "number" != typeof measurement.actualBoundingBoxDescent ? (result.width = Math.floor(measurement.width), 
    result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), 
    result.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), 
    result.ascent = Math.floor(measurement.actualBoundingBoxAscent), result.descent = result.height - result.ascent), 
    result;
}

function getFontString(character, ctx) {
    let fontSize = character && character.fontSize || defaultFormatting.fontSize;
    if (character) switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    return (character && character.fontStyle || "") + " " + (character && character.fontWeight || "") + " " + (fontSize || 12) + "px " + (character && character.fontFamily || defaultFormatting.fontFamily);
}

exports.regFirstSpace = /\S/, exports.applyFillStyle = applyFillStyle, exports.applyStrokeStyle = applyStrokeStyle, 
exports.prepareContext = prepareContext, exports.getStrByWithDom = getStrByWithDom, 
exports.getStrByWithCanvas = getStrByWithCanvas, exports.testLetter = testLetter, 
exports.measureTextDom = measureTextDom, exports.measureTextCanvas = measureTextCanvas, 
exports.getFontString = getFontString;
//# sourceMappingURL=utils.js.map
