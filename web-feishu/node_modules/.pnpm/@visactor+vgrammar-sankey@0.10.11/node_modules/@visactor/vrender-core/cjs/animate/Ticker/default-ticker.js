"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ManualTicker = exports.DefaultTicker = exports.RAFTickHandler = exports.TimeOutTickHandler = exports.ManualTickHandler = void 0;

const vutils_1 = require("@visactor/vutils"), application_1 = require("../../application");

class ManualTickHandler {
    constructor() {
        this.time = 0;
    }
    static Avaliable() {
        return !0;
    }
    avaliable() {
        return ManualTickHandler.Avaliable();
    }
    tick(interval, cb) {
        this.time = Math.max(0, interval + this.time), cb(this, {
            once: !0
        });
    }
    tickTo(t, cb) {
        this.time = Math.max(0, t), cb(this, {
            once: !0
        });
    }
    release() {
        this.timerId > 0 && (this.timerId = -1);
    }
    getTime() {
        return this.time;
    }
}

exports.ManualTickHandler = ManualTickHandler;

class TimeOutTickHandler {
    static Avaliable() {
        return !0;
    }
    avaliable() {
        return TimeOutTickHandler.Avaliable();
    }
    tick(interval, cb) {
        this.timerId = setTimeout((() => {
            cb(this);
        }), interval);
    }
    release() {
        this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
    }
    getTime() {
        return Date.now();
    }
}

exports.TimeOutTickHandler = TimeOutTickHandler;

class RAFTickHandler {
    static Avaliable() {
        return !!application_1.application.global.getRequestAnimationFrame();
    }
    avaliable() {
        return RAFTickHandler.Avaliable();
    }
    tick(interval, cb) {
        application_1.application.global.getRequestAnimationFrame()((() => {
            this.released || cb(this);
        }));
    }
    release() {
        this.released = !0;
    }
    getTime() {
        return Date.now();
    }
}

var STATUS;

exports.RAFTickHandler = RAFTickHandler, function(STATUS) {
    STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", 
    STATUS[STATUS.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));

class DefaultTicker {
    set mode(m) {
        this._mode !== m && (this._mode = m, this.setupTickHandler());
    }
    get mode() {
        return this._mode;
    }
    constructor(timelines = []) {
        this.handleTick = (handler, params) => {
            const {once: once = !1} = null != params ? params : {};
            this.ifCanStop() ? this.stop() : (this._handlerTick(handler), once || handler.tick(this.interval, this.handleTick));
        }, this._handlerTick = handler => {
            const time = this.tickerHandler.getTime();
            let delta = 0;
            this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, 
            this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t => {
                t.tick(delta);
            })));
        }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, 
        this.autoStop = !0;
    }
    init() {
        this.interval = NaN, this.status = STATUS.INITIAL, application_1.application.global.hooks.onSetEnv.tap("default-ticker", (() => {
            this.initHandler();
        })), application_1.application.global.env && this.initHandler();
    }
    addTimeline(timeline) {
        this.timelines.push(timeline);
    }
    remTimeline(timeline) {
        this.timelines = this.timelines.filter((t => t !== timeline));
    }
    initHandler() {
        if (this._mode) return null;
        const ticks = [ {
            mode: "raf",
            cons: RAFTickHandler
        }, {
            mode: "timeout",
            cons: TimeOutTickHandler
        }, {
            mode: "manual",
            cons: ManualTickHandler
        } ];
        for (let i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {
            this.mode = ticks[i].mode;
            break;
        }
        return null;
    }
    setupTickHandler() {
        let handler;
        switch (this._mode) {
          case "raf":
            handler = new RAFTickHandler;
            break;

          case "timeout":
            handler = new TimeOutTickHandler;
            break;

          case "manual":
            handler = new ManualTickHandler;
            break;

          default:
            vutils_1.Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler;
        }
        return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), 
        this.tickerHandler = handler, !0);
    }
    setInterval(interval) {
        this.interval = interval;
    }
    getInterval() {
        return this.interval;
    }
    setFPS(fps) {
        this.setInterval(1e3 / fps);
    }
    getFPS() {
        return 1e3 / this.interval;
    }
    tick(interval) {
        this.tickerHandler.tick(interval, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    tickTo(t) {
        this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    pause() {
        return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, !0);
    }
    resume() {
        return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, !0);
    }
    ifCanStop() {
        if (this.autoStop) {
            if (!this.timelines.length) return !0;
            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !0;
        }
        return !1;
    }
    start(force = !1) {
        if (this.status === STATUS.RUNNING) return !1;
        if (!this.tickerHandler) return !1;
        if (!force) {
            if (this.status === STATUS.PAUSE) return !1;
            if (!this.timelines.length) return !1;
            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !1;
        }
        return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), 
        !0;
    }
    stop() {
        this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
    }
}

exports.DefaultTicker = DefaultTicker;

class ManualTicker extends DefaultTicker {
    set mode(m) {
        this.setupTickHandler();
    }
    get mode() {
        return this._mode;
    }
    initHandler() {
        return this.mode = "manual", null;
    }
    setupTickHandler() {
        const handler = new ManualTickHandler;
        return this._mode = "manual", this.tickerHandler && this.tickerHandler.release(), 
        this.tickerHandler = handler, !0;
    }
    tickAt(time) {
        this.tickerHandler.tick(time - this.lastFrameTime, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    ifCanStop() {
        return !1;
    }
}

exports.ManualTicker = ManualTicker;
//# sourceMappingURL=default-ticker.js.map
