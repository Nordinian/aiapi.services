var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

import { inject, injectable } from "../../common/inversify-lite";

import { AABBBounds, epsilon, isArray, pi2, transformBoundsWithMatrix } from "@visactor/vutils";

import { SyncHook } from "../../tapable";

import { textDrawOffsetX } from "../../common/text";

import { DefaultSymbolOuterBorderBoundsContribution } from "./symbol-contribution";

import { boundStroke } from "../tools";

import { mat4Allocate } from "../../allocator/matrix-allocate";

import { BoundsContext } from "../../common/bounds-context";

import { renderCommandList } from "../../common/render-command-list";

import { circleBounds } from "../../common/utils";

import { GraphicCreator } from "../constants";

import { DefaultOuterBorderBoundsContribution } from "./common-contribution";

function identity(out) {
    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, 
    out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, 
    out[14] = 0, out[15] = 1, out;
}

export function rotateX(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, 
    out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, 
    out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, 
    out[11] = a23 * c - a13 * s, out;
}

export function rotateY(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, 
    out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, 
    out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, 
    out[11] = a03 * s + a23 * c, out;
}

function rotateZ(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, 
    out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, 
    out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, 
    out[7] = a13 * c - a03 * s, out;
}

export function translate(out, a, v) {
    const x = v[0], y = v[1], z = v[2];
    let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
    return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], 
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], 
    a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], 
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, 
    out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, 
    out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], 
    out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], 
    out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
}

export function mat3Tomat4(out, b) {
    out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, 
    out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, 
    out[13] = b.f, out[14] = 0, out[15] = 1;
}

export function multiplyMat4Mat3(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b.a, b1 = b.b, b2 = 0, b3 = 0;
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b.c, b1 = b.d, b2 = 0, b3 = 0, out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = 0, b1 = 0, b2 = 1, b3 = 0, 
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b.e, b1 = b.f, b2 = 0, b3 = 1, out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

function scale(out, a, v) {
    const x = v[0], y = v[1], z = v[2];
    return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, 
    out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, 
    out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], 
    out[14] = a[14], out[15] = a[15], out;
}

export function multiplyMat4Mat4(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], 
    b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

export function getExtraModelMatrix(dx, dy, graphic) {
    const {alpha: alpha, beta: beta} = graphic.attribute;
    if (!alpha && !beta) return null;
    const {anchor3d: anchor3d = graphic.attribute.anchor} = graphic.attribute, _anchor = [ 0, 0 ];
    if (anchor3d) {
        if ("string" == typeof anchor3d[0]) {
            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[1] = anchor3d[1];
    }
    if ("text" === graphic.type) {
        const {textAlign: textAlign} = graphic.attribute;
        _anchor[0] += textDrawOffsetX(textAlign, graphic.clipedWidth);
    }
    _anchor[0] += dx, _anchor[1] += dy;
    const modelMatrix = mat4Allocate.allocate();
    return translate(modelMatrix, modelMatrix, [ _anchor[0], _anchor[1], 0 ]), beta && rotateX(modelMatrix, modelMatrix, beta), 
    alpha && rotateY(modelMatrix, modelMatrix, alpha), translate(modelMatrix, modelMatrix, [ -_anchor[0], -_anchor[1], 0 ]), 
    modelMatrix;
}

export function getModelMatrix(out, graphic, theme) {
    var _a;
    const {x: x = theme.x, y: y = theme.y, z: z = theme.z, dx: dx = theme.dx, dy: dy = theme.dy, dz: dz = theme.dz, scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, scaleZ: scaleZ = theme.scaleZ, alpha: alpha = theme.alpha, beta: beta = theme.beta, angle: angle = theme.angle, anchor3d: anchor3d = graphic.attribute.anchor, anchor: anchor} = graphic.attribute, _anchor = [ 0, 0, 0 ];
    if (anchor3d) {
        if ("string" == typeof anchor3d[0]) {
            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[1] = anchor3d[1];
        _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
    }
    if (identity(out), translate(out, out, [ x + dx, y + dy, z + dz ]), translate(out, out, [ _anchor[0], _anchor[1], _anchor[2] ]), 
    rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [ -_anchor[0], -_anchor[1], _anchor[2] ]), 
    scale(out, out, [ scaleX, scaleY, scaleZ ]), angle) {
        const m = mat4Allocate.allocate(), _anchor = [ 0, 0 ];
        if (anchor) {
            if ("string" == typeof anchor3d[0]) {
                const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[0] = anchor3d[0];
            if ("string" == typeof anchor3d[1]) {
                const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[1] = anchor3d[1];
        }
        translate(m, m, [ _anchor[0], _anchor[1], 0 ]), rotateZ(m, m, angle), translate(m, m, [ -_anchor[0], -_anchor[1], 0 ]), 
        multiplyMat4Mat4(out, out, m);
    }
}

export function shouldUseMat4(graphic) {
    const {alpha: alpha, beta: beta} = graphic.attribute;
    return alpha || beta;
}

let DefaultGraphicService = class {
    constructor(creator) {
        this.creator = creator, this.hooks = {
            onAttributeUpdate: new SyncHook([ "graphic" ]),
            onSetStage: new SyncHook([ "graphic", "stage" ]),
            onRemove: new SyncHook([ "graphic" ]),
            onRelease: new SyncHook([ "graphic" ]),
            onAddIncremental: new SyncHook([ "graphic", "group", "stage" ]),
            onClearIncremental: new SyncHook([ "graphic", "group", "stage" ]),
            beforeUpdateAABBBounds: new SyncHook([ "graphic", "stage", "willUpdate", "aabbBounds" ]),
            afterUpdateAABBBounds: new SyncHook([ "graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange" ])
        }, this.tempAABBBounds1 = new AABBBounds, this.tempAABBBounds2 = new AABBBounds, 
        this._rectBoundsContribitions = [ new DefaultOuterBorderBoundsContribution ], this._symbolBoundsContribitions = [ new DefaultSymbolOuterBorderBoundsContribution ], 
        this._circleBoundsContribitions = [ new DefaultOuterBorderBoundsContribution ], 
        this._arcBoundsContribitions = [ new DefaultOuterBorderBoundsContribution ], this._pathBoundsContribitions = [ new DefaultOuterBorderBoundsContribution ];
    }
    onAttributeUpdate(graphic) {
        this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
    }
    onSetStage(graphic, stage) {
        this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
    }
    onRemove(graphic) {
        this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
    }
    onRelease(graphic) {
        this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
    }
    onAddIncremental(graphic, group, stage) {
        this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
    }
    onClearIncremental(group, stage) {
        this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
    }
    beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
        this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
    }
    afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
        this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
    }
    updatePathProxyAABBBounds(aabbBounds, graphic) {
        const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        if (!path) return !1;
        const boundsContext = new BoundsContext(aabbBounds);
        return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
    }
    updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, rectTheme, aabbBounds, graphic)) return aabbBounds;
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
            let {width: width, height: height} = attribute;
            const {x1: x1, y1: y1, x: x, y: y} = attribute;
            width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, 
            aabbBounds.set(0, 0, width || 0, height || 0);
        }
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        })), this.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, graphic), aabbBounds;
    }
    updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
        const {width: width, height: height, path: path, clip: clip = groupTheme.clip} = attribute;
        path && path.length ? path.forEach((g => {
            aabbBounds.union(g.AABBBounds);
        })) : null != width && null != height && aabbBounds.set(0, 0, width, height), clip || graphic.forEachChildren((node => {
            aabbBounds.union(node.AABBBounds);
        }));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, graphic), 
        aabbBounds;
    }
    updateGlyphAABBBounds(attribute, theme, aabbBounds, graphic) {
        return this._validCheck(attribute, theme, aabbBounds, graphic) ? (graphic.getSubGraphic().forEach((node => {
            aabbBounds.union(node.AABBBounds);
        })), aabbBounds) : aabbBounds;
    }
    updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, richtextTheme, aabbBounds, graphic)) return aabbBounds;
        if (!graphic) return aabbBounds;
        const {width: width = richtextTheme.width, height: height = richtextTheme.height, maxWidth: maxWidth = richtextTheme.maxWidth, maxHeight: maxHeight = richtextTheme.maxHeight, textAlign: textAlign = richtextTheme.textAlign, textBaseline: textBaseline = richtextTheme.textBaseline} = attribute;
        if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height); else {
            const frameCache = graphic.getFrameCache(), {width: actualWidth, height: actualHeight} = frameCache.getActualSize();
            let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
            contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, 
            contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, 
            aabbBounds.set(0, 0, contentWidth, contentHeight);
        }
        let deltaY = 0;
        switch (textBaseline) {
          case "top":
            deltaY = 0;
            break;

          case "middle":
            deltaY = -aabbBounds.height() / 2;
            break;

          case "bottom":
            deltaY = -aabbBounds.height();
        }
        let deltaX = 0;
        switch (textAlign) {
          case "left":
            deltaX = 0;
            break;

          case "center":
            deltaX = -aabbBounds.width() / 2;
            break;

          case "right":
            deltaX = -aabbBounds.width();
        }
        aabbBounds.translate(deltaX, deltaY);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, graphic), 
        aabbBounds;
    }
    updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, textTheme, aabbBounds, graphic)) return aabbBounds;
        if (!graphic) return aabbBounds;
        const {text: text = textTheme.text} = graphic.attribute;
        Array.isArray(text) ? graphic.updateMultilineAABBBounds(text) : graphic.updateSingallineAABBBounds(text);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {scaleX: scaleX = textTheme.scaleX, scaleY: scaleY = textTheme.scaleY, shadowBlur: shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer: strokeBoundsBuffer = textTheme.strokeBoundsBuffer} = attribute;
        if (shadowBlur) {
            const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
            boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
        }
        return this.combindShadowAABBBounds(aabbBounds, graphic), transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix), 
        aabbBounds;
    }
    updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, pathTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = pathTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const pathShape = graphic.getParsedPathShape();
        return aabbBounds.union(pathShape.getBounds()), aabbBounds;
    }
    updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        graphic.findFace().vertices.forEach((v => {
            const x = v[0], y = v[1];
            aabbBounds.add(x, y);
        }));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, graphic), 
        aabbBounds;
    }
    updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        const {outerRadius: outerRadius = arcTheme.outerRadius, height: height = 0} = attribute, r = outerRadius + height;
        aabbBounds.setValue(-r, -r, r, r);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, graphic), 
        aabbBounds;
    }
    updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, polygonTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = polygonTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
        const {points: points = polygonTheme.points} = attribute;
        return points.forEach((p => {
            aabbBounds.add(p.x, p.y);
        })), aabbBounds;
    }
    updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, lineTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = lineTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        const {points: points = lineTheme.points} = attribute, b = aabbBounds;
        return points.forEach((p => {
            b.add(p.x, p.y);
        })), b;
    }
    updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        const {segments: segments = lineTheme.segments} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                b.add(p.x, p.y);
            }));
        })), b;
    }
    updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, areaTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = areaTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
        const {points: points = areaTheme.points} = attribute, b = aabbBounds;
        return points.forEach((p => {
            var _a, _b;
            b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        })), b;
    }
    updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
        const {segments: segments = areaTheme.segments} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                var _a, _b;
                b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
            }));
        })), b;
    }
    updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, circleTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        })), this.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, graphic), 
        aabbBounds;
    }
    updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
        const {radius: radius = circleTheme.radius} = attribute;
        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
    }
    updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
        const {startAngle: startAngle = circleTheme.startAngle, endAngle: endAngle = circleTheme.endAngle, radius: radius = circleTheme.radius} = attribute;
        return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), 
        aabbBounds;
    }
    updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, arcTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = arcTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
        const {innerRadius: innerRadius = arcTheme.innerRadius} = attribute;
        let {outerRadius: outerRadius = arcTheme.outerRadius} = attribute;
        return outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), 
        aabbBounds;
    }
    updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
        let {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = attribute;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius, innerRadius = temp;
        }
        let {endAngle: endAngle = arcTheme.endAngle, startAngle: startAngle = arcTheme.startAngle} = attribute;
        if (startAngle > endAngle) {
            const temp = startAngle;
            startAngle = endAngle, endAngle = temp;
        }
        return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), 
        circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
    }
    updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, symbolTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = symbolTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
        const {size: size = symbolTheme.size} = attribute;
        if (isArray(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2); else {
            const halfWH = size / 2;
            aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
    }
    updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const {size: size = symbolTheme.size} = attribute;
        return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;
    }
    updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, imageTheme, aabbBounds, graphic)) return aabbBounds;
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
            const {width: width = imageTheme.width, height: height = imageTheme.height} = attribute;
            aabbBounds.set(0, 0, width, height);
        }
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, graphic), 
        aabbBounds;
    }
    combindShadowAABBBounds(bounds, graphic) {
        if (graphic && graphic.shadowRoot) {
            const b = graphic.shadowRoot.AABBBounds;
            bounds.union(b);
        }
    }
    transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
        const {scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, stroke: stroke = theme.stroke, shadowBlur: shadowBlur = theme.shadowBlur, lineWidth: lineWidth = theme.lineWidth, pickStrokeBuffer: pickStrokeBuffer = theme.pickStrokeBuffer, strokeBoundsBuffer: strokeBoundsBuffer = theme.strokeBoundsBuffer} = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        if (stroke && lineWidth) {
            const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
            boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), 
            tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }
        if (shadowBlur) {
            const {shadowOffsetX: shadowOffsetX = theme.shadowOffsetX, shadowOffsetY: shadowOffsetY = theme.shadowOffsetY} = attribute, shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
            boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), 
            aabbBounds.union(tb1);
        }
        this.combindShadowAABBBounds(aabbBounds, graphic);
        let updateMatrix = !0;
        const m = graphic.transMatrix;
        graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), 
        updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
    }
    _validCheck(attribute, theme, aabbBounds, graphic) {
        if (!graphic) return !0;
        if (!graphic.valid) return aabbBounds.clear(), !1;
        const {visible: visible = theme.visible} = attribute;
        return !!visible || (aabbBounds.clear(), !1);
    }
};

DefaultGraphicService = __decorate([ injectable(), __param(0, inject(GraphicCreator)), __metadata("design:paramtypes", [ Object ]) ], DefaultGraphicService);

export { DefaultGraphicService };
//# sourceMappingURL=graphic-service.js.map
