export class CanvasTextLayout {
    constructor(fontFamily, options, textMeasure) {
        this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
    }
    LayoutBBox(bbox, textAlign, textBaseline) {
        if ("left" === textAlign || "start" === textAlign) bbox.xOffset = 0; else if ("center" === textAlign) bbox.xOffset = bbox.width / -2; else {
            if ("right" !== textAlign && "end" !== textAlign) throw new Error("非法的textAlign");
            bbox.xOffset = -bbox.width;
        }
        return bbox.yOffset = "top" === textBaseline ? 0 : "middle" === textBaseline ? bbox.height / -2 : "alphabetic" === textBaseline ? -.79 * bbox.height : -bbox.height, 
        bbox;
    }
    GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, wordBreak, suffixPosition) {
        const linesLayout = [], bboxWH = [ width, height ], bboxOffset = [ 0, 0 ];
        for (;str.length > 0; ) {
            const {str: clipText} = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix, wordBreak, suffixPosition);
            linesLayout.push({
                str: clipText,
                width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
            }), str = str.substring(clipText.length);
        }
        "left" === textAlign || "start" === textAlign || ("center" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : "right" !== textAlign && "end" !== textAlign || (bboxOffset[0] = -bboxWH[0])), 
        "top" === textBaseline || ("middle" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : "bottom" === textBaseline && (bboxOffset[1] = -bboxWH[1]));
        const bbox = {
            xOffset: bboxOffset[0],
            yOffset: bboxOffset[1],
            width: bboxWH[0],
            height: bboxWH[1]
        };
        return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    }
    GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, lineWidth, suffixPosition = "end") {
        lines = lines.map((l => l.toString()));
        const linesLayout = [], bboxWH = [ 0, 0 ];
        if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
            let width;
            for (let i = 0, len = lines.length; i < len; i++) width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth), 
            linesLayout.push({
                str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix, wordBreak, suffixPosition).str,
                width: width
            });
            bboxWH[0] = lineWidth;
        } else {
            let width, text;
            lineWidth = 0;
            for (let i = 0, len = lines.length; i < len; i++) text = lines[i], width = this.textMeasure.measureTextWidth(text, this.textOptions), 
            lineWidth = Math.max(lineWidth, width), linesLayout.push({
                str: text,
                width: width
            });
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce(((a, b) => Math.max(a, b.width)), 0);
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    }
    layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
        const origin = [ 0, 0 ], totalLineHeight = lines.length * lineHeight;
        "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
        for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
        return {
            bbox: bbox,
            lines: lines,
            fontFamily: this.fontFamily,
            fontSize: this.textOptions.fontSize,
            fontWeight: this.textOptions.fontWeight,
            lineHeight: lineHeight,
            textAlign: textAlign,
            textBaseline: textBaseline
        };
    }
    lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
        return "left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), 
        line.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + .79 * this.textOptions.fontSize + origin[1], 
        origin[1] += lineHeight, line;
    }
}
//# sourceMappingURL=layout.js.map
