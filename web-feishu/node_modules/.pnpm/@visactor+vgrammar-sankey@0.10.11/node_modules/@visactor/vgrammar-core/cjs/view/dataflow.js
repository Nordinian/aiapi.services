"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const vutils_1 = require("@visactor/vutils"), grammar_heap_1 = require("../util/grammar-heap"), unique_list_1 = require("../util/unique-list");

class Dataflow {
    constructor() {
        this.grammars = [], this.logger = vutils_1.Logger.getInstance(), this._curRank = 0, 
        this._committed = new unique_list_1.UniqueList((grammar => grammar.uid)), this._heap = new grammar_heap_1.Heap(((a, b) => (null == a ? void 0 : a.qrank) - (null == b ? void 0 : b.qrank))), 
        this._beforeRunner = null, this._afterRunner = null, this._isRunning = !1, this._updateCounter = 0, 
        this._finishFirstRender = !1;
    }
    asyncCallback(callback) {
        return __awaiter(this, void 0, void 0, (function*() {
            try {
                yield callback(this);
            } catch (err) {
                this.logger.error(err);
            }
        }));
    }
    add(grammar) {
        if (grammar) return this._setRankOfGrammar(grammar), this.commit(grammar), !this.grammars.includes(grammar) && (this.grammars.push(grammar), 
        !0);
    }
    remove(grammar) {
        grammar && (this._committed.remove(grammar), this._heap.remove(grammar), this.grammars = this.grammars.filter((storedGrammar => storedGrammar !== grammar)));
    }
    _setRankOfGrammar(grammar) {
        grammar && (grammar.rank = ++this._curRank);
    }
    _reRank(grammar) {
        const queue = [ grammar ];
        for (;queue.length; ) {
            const cur = queue.pop();
            this._setRankOfGrammar(cur);
            const list = cur.targets;
            list && list.forEach((entry => {
                queue.push(entry), entry === grammar && this.logger.error("Cycle detected in dataflow graph.");
            }));
        }
    }
    _enqueue(grammar) {
        grammar && (grammar.qrank = grammar.rank, this._heap.push(grammar));
    }
    _logGrammarRunInfo(grammar) {
        if (this.logger.canLogError()) {
            const debugStr = [ {
                key: "id",
                value: grammar.id()
            }, {
                key: "name",
                value: grammar.name()
            } ].reduce(((str, entry, index) => (0, vutils_1.isNil)(entry.value) ? str : `${str}${index ? " , " : ""}${entry.key}: ${entry.value}`), "");
            this.logger.debug("Run Operator: ", grammar, debugStr);
        }
    }
    hasCommitted() {
        return !!this._committed.length;
    }
    commit(grammar) {
        return this._isRunning ? this._enqueue(grammar) : this._committed.add(grammar), 
        this;
    }
    _beforeEvaluate() {
        this.grammars.forEach((grammar => {
            grammar.targets.some((target => (null == target ? void 0 : target.rank) < (null == grammar ? void 0 : grammar.rank))) && this._reRank(grammar);
        })), this._committed.forEach((grammar => this._enqueue(grammar))), this._committed = new unique_list_1.UniqueList((grammar => grammar.uid));
    }
    _enqueueTargets(grammar) {
        grammar.targets && grammar.targets.length && this._finishFirstRender && grammar.targets.forEach((target => this._enqueue(target)));
    }
    evaluate() {
        return __awaiter(this, void 0, void 0, (function*() {
            if (this._isReleased) return;
            if (this._beforeRunner && (yield this.asyncCallback(this._beforeRunner)), !this._committed.length) return this.logger.info("Dataflow invoked, but nothing to do."), 
            !1;
            this._isRunning = !0, this._updateCounter += 1;
            let grammar, next, dt, error, count = 0;
            this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), 
            this._beforeEvaluate();
            try {
                for (;this._heap.size() > 0 && !this._isReleased; ) if (grammar = this._heap.pop(), 
                grammar) if (grammar.rank === grammar.qrank) {
                    if (next = grammar.run(), next && next.then && (next = yield next), !this._isRunning) return !1;
                    this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1;
                } else this._enqueue(grammar);
            } catch (err) {
                this._heap.clear(), error = err;
            }
            return !this._isReleased && (this._isRunning = !1, this.logger.canLogInfo() && (dt = Date.now() - dt, 
            this.logger.info(`> ${count} grammars; ${dt} ms`)), error ? this.logger.error(error) : this._afterRunner && (yield this.asyncCallback(this._afterRunner)), 
            this._finishFirstRender = !0, !0);
        }));
    }
    evaluateSync() {
        if (this._beforeRunner && this._beforeRunner(this), !this._committed.length) return this.logger.info("Dataflow invoked, but nothing to do."), 
        !1;
        this._isRunning = !0, this._updateCounter += 1;
        let grammar, dt, count = 0;
        for (this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), 
        this._beforeEvaluate(); this._heap.size() > 0; ) grammar = this._heap.pop(), grammar && (grammar.rank === grammar.qrank ? (grammar.runSync(), 
        this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1) : this._enqueue(grammar));
        return this._isRunning = !1, this.logger.canLogInfo() && (dt = Date.now() - dt, 
        this.logger.info(`> ${count} grammars updated; ${dt} ms`)), this._afterRunner && this._afterRunner(this), 
        this._finishFirstRender = !0, !0;
    }
    stop() {
        this._isRunning && (this._isRunning = !1);
    }
    runBefore(callback) {
        this._beforeRunner = callback;
    }
    runAfter(callback) {
        this._afterRunner = callback;
    }
    release() {
        this.stop(), this._isReleased = !0, this._heap && (this._heap.clear(), this._heap = null), 
        this.logger = null, this._committed = null;
    }
}

exports.default = Dataflow;
//# sourceMappingURL=dataflow.js.map
