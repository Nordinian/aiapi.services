"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ContentColumnModel = void 0;

const vutils_1 = require("@visactor/vutils"), style_constants_1 = require("./style-constants"), base_tooltip_model_1 = require("./base-tooltip-model"), shape_model_1 = require("./shape-model"), text_model_1 = require("./text-model"), constants_1 = require("../../constants"), util_1 = require("../util"), merge_spec_1 = require("../../../../../util/spec/merge-spec"), defaultLabelStyle = {
    overflowWrap: "normal",
    wordWrap: "normal"
};

class ContentColumnModel extends base_tooltip_model_1.BaseTooltipModel {
    constructor(parent, option, className, childIndex) {
        super(parent, option, childIndex), this.className = className;
    }
    init() {
        var _a, _b;
        this.product || (this.product = this.createElement("div", [ this.className ]));
        const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
        if ("shape-box" !== this.className || renderContent.some((c => c.hasShape && c.shapeType))) {
            Object.keys(this.children).forEach((key => {
                const i = (0, vutils_1.toNumber)(key);
                i >= renderContent.length && (this.children[i].release(), delete this.children[i]);
            }));
            for (let i = 0; i < renderContent.length; i++) if (!this.children[i]) if ("key-box" === this.className || "value-box" === this.className) {
                const text = new text_model_1.TextModel(this.product, this._option, i);
                text.init([ this.className.substring(0, this.className.indexOf("-")) ], void 0, "div"), 
                this.children[i] = text;
            } else if ("shape-box" === this.className) {
                const shape = new shape_model_1.ShapeModel(this.product, this._option, i);
                shape.init([ "shape" ], void 0, "div"), this.children[i] = shape;
            }
        } else Object.keys(this.children).forEach((key => {
            const i = (0, vutils_1.toNumber)(key);
            this.children[i].release(), delete this.children[i];
        }));
    }
    setStyle() {
        var _a, _b, _c, _d;
        const tooltipStyle = this._option.getTooltipStyle();
        super.setStyle((0, merge_spec_1.mergeSpec)({}, style_constants_1.defaultContentColumnStyle, tooltipStyle.content, this._getContentColumnStyle()));
        const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [];
        renderContent.forEach(((line, i) => {
            var _a, _b, _c, _d, _e;
            let childStyle = {};
            if ("key-box" === this.className) {
                const {key: key, isKeyAdaptive: isKeyAdaptive} = line;
                childStyle = (0, merge_spec_1.mergeSpec)({}, isKeyAdaptive ? style_constants_1.defaultAdaptiveKeyStyle : style_constants_1.defaultKeyStyle, Object.assign(Object.assign(Object.assign({
                    height: (0, util_1.getPixelPropertyStr)(contentAttributes[i].height)
                }, defaultLabelStyle), tooltipStyle.keyColumn.common), null === (_a = tooltipStyle.keyColumn.items) || void 0 === _a ? void 0 : _a[i]));
                (0, vutils_1.isString)(key) && "" !== (null === (_b = null == key ? void 0 : key.trim) || void 0 === _b ? void 0 : _b.call(key)) || (0, 
                vutils_1.isNumber)(key) || childStyle.visibility ? childStyle.visibility = "visible" : childStyle.visibility = "hidden", 
                this.children[i].setStyle(childStyle);
            } else "value-box" === this.className ? (childStyle = (0, merge_spec_1.mergeSpec)({}, style_constants_1.defaultValueStyle, Object.assign(Object.assign(Object.assign({
                height: (0, util_1.getPixelPropertyStr)(contentAttributes[i].height)
            }, defaultLabelStyle), tooltipStyle.valueColumn.common), null === (_c = tooltipStyle.valueColumn.items) || void 0 === _c ? void 0 : _c[i])), 
            this.children[i].setStyle(childStyle)) : "shape-box" === this.className && (childStyle = (0, 
            merge_spec_1.mergeSpec)({}, style_constants_1.defaultShapeStyle, Object.assign(Object.assign({
                height: (0, util_1.getPixelPropertyStr)(contentAttributes[i].height + contentAttributes[i].spaceRow)
            }, tooltipStyle.shapeColumn.common), null === (_d = tooltipStyle.shapeColumn.items) || void 0 === _d ? void 0 : _d[i])), 
            null === (_e = this.children[i]) || void 0 === _e || _e.setStyle(childStyle, this._getShapeSvgOption(line, i)));
        }));
    }
    setContent() {
        var _a, _b, _c, _d;
        const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [];
        renderContent.forEach(((line, i) => {
            var _a, _b, _c, _d, _e, _f, _g;
            let childContent;
            if ("key-box" === this.className) {
                const keyContent = line.key;
                childContent = (0, vutils_1.isString)(keyContent) && "" !== (null === (_a = null == keyContent ? void 0 : keyContent.trim) || void 0 === _a ? void 0 : _a.call(keyContent)) || (0, 
                vutils_1.isNumber)(keyContent) ? keyContent : constants_1.TOOLTIP_EMPTY_STRING, 
                null === (_b = this.children[i]) || void 0 === _b || _b.setContent(childContent, null === (_c = contentAttributes[i].key) || void 0 === _c ? void 0 : _c.multiLine);
            } else if ("value-box" === this.className) {
                const valueContent = line.value;
                childContent = (0, vutils_1.isString)(valueContent) && "" !== (null === (_d = null == valueContent ? void 0 : valueContent.trim) || void 0 === _d ? void 0 : _d.call(valueContent)) || (0, 
                vutils_1.isNumber)(valueContent) ? valueContent : constants_1.TOOLTIP_EMPTY_STRING, 
                null === (_e = this.children[i]) || void 0 === _e || _e.setContent(childContent, null === (_f = contentAttributes[i].value) || void 0 === _f ? void 0 : _f.multiLine);
            } else "shape-box" === this.className && (childContent = this._getShapeSvgOption(line, i), 
            null === (_g = this.children[i]) || void 0 === _g || _g.setContent(childContent));
        }));
    }
    _getContentColumnStyle() {
        var _a, _b;
        const tooltipStyle = this._option.getTooltipStyle();
        switch (this.className) {
          case "shape-box":
            const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
            return Object.assign(Object.assign({}, tooltipStyle.shapeColumn), "shape-box" !== this.className || renderContent.some((c => c.hasShape && c.shapeType)) ? {} : {
                display: "none"
            });

          case "key-box":
            return tooltipStyle.keyColumn;

          case "value-box":
            return tooltipStyle.valueColumn;
        }
    }
    _getShapeSvgOption(line, index) {
        var _a, _b, _c, _d, _e, _f;
        const tooltipStyle = this._option.getTooltipStyle(), shapeColumn = Object.assign(Object.assign({}, tooltipStyle.shapeColumn), null === (_a = tooltipStyle.shapeColumn.items) || void 0 === _a ? void 0 : _a[index]), keyColumn = Object.assign(Object.assign({}, tooltipStyle.keyColumn), null === (_b = tooltipStyle.keyColumn.items) || void 0 === _b ? void 0 : _b[index]);
        return {
            hasShape: line.hasShape,
            symbolType: line.shapeType,
            size: shapeColumn.width,
            fill: null !== (_c = line.shapeFill) && void 0 !== _c ? _c : line.shapeColor,
            stroke: line.shapeStroke,
            lineWidth: line.shapeLineWidth,
            hollow: line.shapeHollow,
            marginTop: `calc((${null !== (_e = null !== (_d = keyColumn.lineHeight) && void 0 !== _d ? _d : keyColumn.fontSize) && void 0 !== _e ? _e : "18px"} - ${null !== (_f = shapeColumn.width) && void 0 !== _f ? _f : "8px"}) / 2)`,
            index: index
        };
    }
}

exports.ContentColumnModel = ContentColumnModel;
//# sourceMappingURL=content-column-model.js.map
