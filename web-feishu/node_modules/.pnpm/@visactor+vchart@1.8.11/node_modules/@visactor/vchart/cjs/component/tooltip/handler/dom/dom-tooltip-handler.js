"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DomTooltipHandler = void 0;

const base_1 = require("../base"), util_1 = require("./util"), tooltip_model_1 = require("./model/tooltip-model"), constants_1 = require("../constants"), env_1 = require("../../../../util/env");

class DomTooltipHandler extends base_1.BaseTooltipHandler {
    getVisibility() {
        var _a;
        return !!(null === (_a = this.model) || void 0 === _a ? void 0 : _a.getVisibility());
    }
    setVisibility(_value) {
        var _a;
        _value !== this.getVisibility() && (null === (_a = this.model) || void 0 === _a || _a.setVisibility(_value));
    }
    constructor(tooltipId, component) {
        super(tooltipId, component), this.type = constants_1.TooltipHandlerType.dom, this._tooltipContainer = null === env_1.domDocument || void 0 === env_1.domDocument ? void 0 : env_1.domDocument.body, 
        this._initStyle(), this.initEl();
    }
    initEl() {
        const tooltipSpec = this._component.getSpec(), parentElement = tooltipSpec.parentElement;
        if (env_1.domDocument && parentElement) {
            for (let i = 0; i < parentElement.children.length; i++) if (parentElement.children[i].classList.contains(constants_1.TOOLTIP_CONTAINER_EL_CLASS_NAME)) {
                this._container = parentElement.children[i];
                break;
            }
            this._container || (this._container = env_1.domDocument.createElement("div"), this._container.style.position = "relative", 
            this._container.classList.add(constants_1.TOOLTIP_CONTAINER_EL_CLASS_NAME), parentElement.appendChild(this._container)), 
            this.model = new tooltip_model_1.TooltipModel(this._container, {
                valueToHtml: this._option.sanitize,
                getTooltipStyle: () => this._domStyle,
                getTooltipActual: () => this._tooltipActual,
                getTooltipAttributes: () => this._attributes
            }, [ tooltipSpec.className ], this.id);
        }
    }
    _removeTooltip() {
        var _a;
        null === (_a = this.model) || void 0 === _a || _a.release(), this._container = null;
    }
    _updateTooltip(visible, params, actualTooltip) {
        var _a, _b;
        if (visible && this.model) {
            params.changePositionOnly || (this._tooltipActual = actualTooltip, this._initStyle(), 
            this.model.initAll(), this.model.setStyle(), this.model.setContent()), this.setVisibility(visible);
            let {x: x = 0, y: y = 0} = null !== (_a = actualTooltip.position) && void 0 !== _a ? _a : {};
            const el = this.model.product;
            if (el) {
                if (null === (_b = this._cacheViewSpec) || void 0 === _b ? void 0 : _b.updateElement) {
                    this._cacheViewSpec.updateElement(el, actualTooltip, params);
                    const position = this._getActualTooltipPosition(actualTooltip, params, {
                        width: el.offsetWidth,
                        height: el.offsetHeight
                    });
                    x = position.x, y = position.y;
                }
                el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            }
        } else this.setVisibility(visible);
    }
    _initStyle() {
        this._domStyle = (0, util_1.getDomStyles)(this._attributes);
    }
    _getParentElement(spec) {
        var _a;
        return null !== (_a = this._container) && void 0 !== _a ? _a : super._getParentElement(spec);
    }
    isTooltipShown() {
        return this.getVisibility();
    }
    reInit() {
        super.reInit(), this._initStyle();
    }
}

exports.DomTooltipHandler = DomTooltipHandler;
//# sourceMappingURL=dom-tooltip-handler.js.map
