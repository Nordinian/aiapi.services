"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.measureTooltipText = exports.getScale = exports.convertToColorString = exports.pickFirstValidValue = exports.getFirstDatumFromTooltipData = exports.getTooltipPatternValue = exports.getTooltipContentValue = exports.escapeHTML = void 0;

const vutils_1 = require("@visactor/vutils"), vrender_core_1 = require("@visactor/vrender-core");

function escapeHTML(value) {
    return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\(/g, "&#40;").replace(/  /g, " &nbsp;");
}

exports.escapeHTML = escapeHTML;

const getTooltipContentValue = (field, datum, params) => (0, vutils_1.isNil)(field) ? field : (0, 
vutils_1.isFunction)(field) ? field(datum, params) : field;

exports.getTooltipContentValue = getTooltipContentValue;

const getTooltipPatternValue = (field, data, params) => {
    if ((0, vutils_1.isNil)(field)) return field;
    if ((0, vutils_1.isArray)(field)) {
        const result = [];
        return field.forEach((item => {
            if ((0, vutils_1.isFunction)(item)) {
                const value = item(data, params);
                (0, vutils_1.isValid)(value) && result.push(value);
            } else result.push(item);
        })), result;
    }
    return (0, vutils_1.isFunction)(field) ? field(data, params) : field;
};

function getFirstDatumFromTooltipData(data) {
    var _a;
    const dimInfoList = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.series) ? [ {
        data: data,
        value: ""
    } ] : data;
    for (const {data: dataList} of dimInfoList) for (const {datum: datumList} of dataList) for (const datumItem of null != datumList ? datumList : []) if (datumItem) return datumItem;
}

function pickFirstValidValue(isValid, ...elements) {
    for (const ele of elements) if (isValid(ele)) return ele;
}

function convertToColorString(color, defaultColor = "#000") {
    return color ? (0, vutils_1.isString)(color) ? color : (0, vutils_1.isObject)(color) && color.stops && color.stops[0] && color.stops[0].color || defaultColor : defaultColor;
}

exports.getTooltipPatternValue = getTooltipPatternValue, exports.getFirstDatumFromTooltipData = getFirstDatumFromTooltipData, 
exports.pickFirstValidValue = pickFirstValidValue, exports.convertToColorString = convertToColorString;

const getScale = (element, boundingClientRect) => element ? (boundingClientRect || (boundingClientRect = element.getBoundingClientRect()), 
element.offsetWidth > 0 ? boundingClientRect.width / element.offsetWidth : boundingClientRect.height / element.offsetHeight) : 1;

exports.getScale = getScale;

const measureTooltipText = (text, style) => {
    var _a;
    let textLines, textConfig;
    "rich" !== (null == text ? void 0 : text.type) && "html" !== (null == text ? void 0 : text.type) ? (text = (null != text ? text : "").toString(), 
    style.multiLine ? (textLines = text.split("\n"), textLines = textLines.map(((line, i) => i < textLines.length - 1 ? line + "\n" : line))) : textLines = [ text ], 
    textConfig = textLines.map((line => Object.assign(Object.assign({}, style), {
        text: line
    })))) : (textConfig = text.text, textLines = text);
    const bound = (0, vrender_core_1.getRichTextBounds)({
        wordBreak: null !== (_a = style.wordBreak) && void 0 !== _a ? _a : "break-word",
        maxWidth: style.maxWidth ? style.maxWidth : void 0,
        width: 0,
        height: 0,
        textConfig: textConfig
    });
    return {
        width: bound.width(),
        height: bound.height(),
        text: textLines
    };
};

exports.measureTooltipText = measureTooltipText;
//# sourceMappingURL=common.js.map
