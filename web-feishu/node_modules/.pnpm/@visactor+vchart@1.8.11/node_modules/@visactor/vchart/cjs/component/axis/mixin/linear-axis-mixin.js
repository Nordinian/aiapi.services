"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LinearAxisMixin = exports.e2 = exports.e5 = exports.e10 = void 0;

const vutils_1 = require("@visactor/vutils"), array_1 = require("../../../util/array"), util_1 = require("../util"), constant_1 = require("../../../constant"), common_1 = require("../cartesian/util/common");

exports.e10 = Math.sqrt(50), exports.e5 = Math.sqrt(10), exports.e2 = Math.sqrt(2);

const DEFAULT_TICK_COUNT = 5;

class LinearAxisMixin {
    constructor() {
        this._extend = {};
    }
    setExtraAttrFromSpec() {
        (0, vutils_1.isValid)(this._spec.nice) && (this._nice = this._spec.nice), (0, vutils_1.isValid)(this._spec.zero) && (this._zero = this._spec.zero), 
        this._expand = this._spec.expand, this._domain = (0, util_1.getLinearAxisSpecDomain)(this._spec);
    }
    transformScaleDomain() {
        this.setScaleNice();
    }
    setLinearScaleNice() {
        var _a;
        let tickCount = 5;
        const tick = this._spec.tick || {};
        if ((0, vutils_1.isValidNumber)(tick.forceTickCount)) tickCount = tick.forceTickCount; else if ((0, 
        vutils_1.isFunction)(tick.tickCount)) {
            const range = this._scale.range();
            let rangeSize = Math.abs(range[range.length - 1] - range[0]);
            if (1 === rangeSize && this._option) {
                rangeSize = (0, common_1.isXAxis)(this._orient) ? this._option.getChartViewRect().width : this._option.getChartViewRect().height;
            }
            tickCount = tick.tickCount({
                rangeSize: rangeSize,
                labelStyle: this._spec.label && this._spec.label.style
            });
        } else tickCount = (0, vutils_1.isValidNumber)(tick.tickCount) ? tick.tickCount : 5;
        "accurateFirst" === this._spec.niceType && (tickCount = Math.max(5, tickCount));
        const {min: min, max: max} = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
        (0, vutils_1.isNil)(min) && (0, vutils_1.isNil)(max) ? this._nice && this._scale.nice(tickCount) : (0, 
        vutils_1.isValid)(min) && (0, vutils_1.isNil)(max) ? this._nice && this._scale.niceMax(tickCount) : (0, 
        vutils_1.isNil)(min) && (0, vutils_1.isValid)(max) && this._nice && this._scale.niceMin(tickCount);
    }
    setLogScaleNice() {
        var _a;
        const {min: min, max: max} = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
        (0, vutils_1.isNil)(min) && (0, vutils_1.isNil)(max) ? this._nice && this._scale.nice() : (0, 
        vutils_1.isValid)(min) && (0, vutils_1.isNil)(max) ? this._nice && this._scale.niceMax() : (0, 
        vutils_1.isNil)(min) && (0, vutils_1.isValid)(max) && this._nice && this._scale.niceMin();
    }
    setScaleNice() {
        "log" === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
    }
    dataToPosition(values, cfg) {
        return this.valueToPosition(values[0]);
    }
    valueToPosition(value) {
        return "log" !== this._spec.type || (0, vutils_1.isNil)(value) || 0 !== value && 0 !== value[0] ? this._scale.scale(value) : this._scale.range()[0];
    }
    computeLinearDomain(data) {
        const domain = [];
        return data.length ? data.forEach((d => {
            const {min: min, max: max} = d;
            domain[0] = void 0 === domain[0] ? min : Math.min(domain[0], min), domain[1] = void 0 === domain[1] ? max : Math.max(domain[1], max);
        })) : (domain[0] = 0, domain[1] = 0), this.expandDomain(domain), this.includeZero(domain), 
        this.setDomainMinMax(domain), domain;
    }
    expandDomain(domain) {
        if (!this._expand) return;
        let domainMin = domain[0], domainMax = domain[domain.length - 1];
        domainMin === domainMax && (0 === domainMax ? domainMax = 1 : domainMax > 0 ? domainMin = 0 : domainMax < 0 && (domainMax = 0)), 
        (0, vutils_1.isValid)(this._expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this._expand.min), 
        (0, vutils_1.isValid)(this._expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this._expand.max);
    }
    niceDomain(domain) {
        const {min: userMin, max: userMax} = (0, util_1.getLinearAxisSpecDomain)(this._spec);
        if ((0, vutils_1.isValid)(userMin) || (0, vutils_1.isValid)(userMax) || "linear" !== this._spec.type) return domain;
        if (Math.abs((0, array_1.minInArr)(domain) - (0, array_1.maxInArr)(domain)) <= 1e-12) {
            let num = domain[0];
            const flag = num >= 0 ? 1 : -1;
            if (num = Math.abs(num), num < 1) domain[0] = 0, domain[1] = 1; else {
                let step = num / 5;
                const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
                step = (err >= exports.e10 ? 10 : err >= exports.e5 ? 5 : err >= exports.e2 ? 2 : 1) * Math.pow(10, power), 
                domain[0] = 0, domain[1] = 10 * step;
            }
            flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
        }
        return domain;
    }
    includeZero(domain) {
        this._zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
    }
    setExtendDomain(key, value) {
        if (void 0 === value) return void delete this._extend[key];
        this._extend[key] = value;
        const domain = this._scale.domain();
        this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), 
        this.niceDomain(domain), this._scale.domain(domain, this._nice), this.setScaleNice(), 
        this.event.emit(constant_1.ChartEvent.scaleUpdate, {
            model: this,
            value: "domain"
        });
    }
    extendDomain(domain) {
        let temp;
        const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min = reverse ? domainLast : 0, max = reverse ? 0 : domainLast;
        for (const key in this._extend) temp = this._extend[key], temp > domain[max] && (domain[max] = temp), 
        temp < domain[min] && (domain[min] = temp);
    }
    getDomainSpec() {
        return this._domain;
    }
    setDomainMinMax(domain) {
        if (!this._domain) return;
        const {min: min, max: max} = this._domain;
        (0, vutils_1.isValid)(min) && (domain[0] = min), (0, vutils_1.isValid)(max) && (domain[1] = max);
    }
    setZero(zero) {
        this._zero !== zero && (this._zero = zero, this.updateScaleDomain());
    }
    updateScaleDomain() {
        if (!this.isSeriesDataEnable()) return;
        const data = this.collectData(), domain = this.computeDomain(data);
        this.updateScaleDomainByModel(domain);
    }
    updateScaleDomainByModel(domain) {
        domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), 
        this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), 
        this._scale.domain(domain, this._nice), this.setScaleNice(), this.event.emit(constant_1.ChartEvent.scaleDomainUpdate, {
            model: this
        }), this.event.emit(constant_1.ChartEvent.scaleUpdate, {
            model: this,
            value: "domain"
        });
    }
}

exports.LinearAxisMixin = LinearAxisMixin;
//# sourceMappingURL=linear-axis-mixin.js.map
