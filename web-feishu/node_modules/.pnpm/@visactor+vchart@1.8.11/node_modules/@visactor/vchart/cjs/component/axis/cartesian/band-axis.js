"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerCartesianBandAxis = exports.CartesianBandAxis = void 0;

const vscale_1 = require("@visactor/vscale"), axis_1 = require("./axis"), interface_1 = require("../../interface"), vutils_1 = require("@visactor/vutils"), band_axis_mixin_1 = require("../mixin/band-axis-mixin"), factory_1 = require("../../../core/factory"), base_axis_1 = require("../base-axis");

class CartesianBandAxis extends axis_1.CartesianAxis {
    constructor() {
        super(...arguments), this.type = interface_1.ComponentTypeEnum.cartesianBandAxis, 
        this._scale = new vscale_1.BandScale;
    }
    computeDomain(data) {
        return this.computeBandDomain(data);
    }
    updateScaleRange() {
        const isChanged = super.updateScaleRange();
        return this.updateGroupScaleRange(), isChanged;
    }
    initScales() {
        super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
    }
    axisHelper() {
        const getScale = depth => this._scales[depth];
        return {
            isContinuous: !1,
            dataToPosition: this.dataToPosition.bind(this),
            getScale: getScale,
            getBandwidth: depth => getScale(depth).bandwidth(),
            getAxisType: () => this.type,
            getAxisId: () => this.id,
            isInverse: () => this._inverse
        };
    }
    transformScaleDomain() {
        this.updateFixedWholeLength();
    }
    updateFixedWholeLength() {
        var _a;
        if (this._scale && (this._spec.bandSize && this._scale.bandwidth(this._spec.bandSize), 
        this._spec.maxBandSize && this._scale.maxBandwidth(this._spec.maxBandSize), this._spec.minBandSize && this._scale.minBandwidth(this._spec.minBandSize), 
        this._scale.isBandwidthFixed() && this._spec.autoRegionSize && (this._spec.bandSize || this._spec.maxBandSize))) {
            const rangeSize = (0, vscale_1.scaleWholeRangeSize)(this._scale.domain().length, null !== (_a = this._spec.bandSize) && void 0 !== _a ? _a : this._spec.maxBandSize, this._scale.paddingInner(), this._scale.paddingOuter());
            [ "bottom", "top" ].includes(this._orient) ? this._regions.forEach((region => region.setMaxWidth(rangeSize))) : [ "left", "right" ].includes(this._orient) && this._regions.forEach((region => region.setMaxHeight(rangeSize)));
        }
    }
}

exports.CartesianBandAxis = CartesianBandAxis, CartesianBandAxis.type = interface_1.ComponentTypeEnum.cartesianBandAxis, 
CartesianBandAxis.specKey = "axes", (0, vutils_1.mixin)(CartesianBandAxis, band_axis_mixin_1.BandAxisMixin);

const registerCartesianBandAxis = () => {
    (0, base_axis_1.registerAxis)(), factory_1.Factory.registerComponent(CartesianBandAxis.type, CartesianBandAxis);
};

exports.registerCartesianBandAxis = registerCartesianBandAxis;
//# sourceMappingURL=band-axis.js.map
