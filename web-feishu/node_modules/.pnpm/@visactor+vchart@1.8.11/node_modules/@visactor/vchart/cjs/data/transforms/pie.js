"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.pie = void 0;

const type_1 = require("../../util/type"), math_1 = require("../../util/math"), polar_1 = require("../../constant/polar");

function transformInvalidValue(value) {
    return (0, type_1.couldBeValidNumber)(value) ? Number.parseFloat(value) : 0;
}

const pie = (originData, op) => {
    const data = originData.map((datum => Object.assign({}, datum)));
    if (!data || 0 === data.length) return data;
    const {angleField: angleField, startAngle: startAngle, endAngle: endAngle, minAngle: minAngle, asStartAngle: asStartAngle, asEndAngle: asEndAngle, asMiddleAngle: asMiddleAngle, asRadian: asRadian, asRatio: asRatio, asQuadrant: asQuadrant, asK: asK} = op, appendArcInfo = (data, startAngle, angle) => {
        data[asStartAngle] = startAngle, data[asEndAngle] = startAngle + angle, data[asMiddleAngle] = startAngle + angle / 2, 
        data[asRadian] = angle, data[asQuadrant] = (0, math_1.computeQuadrant)(startAngle + angle / 2);
    };
    let total = 0, max = -1 / 0;
    for (let index = 0; index < data.length; index++) {
        const angleFieldValue = transformInvalidValue(data[index][angleField]);
        total += angleFieldValue, max = Math.max(angleFieldValue, max), data[index][polar_1.ARC_TRANSFORM_VALUE] = angleFieldValue;
    }
    const angleRange = endAngle - startAngle;
    let lastAngle = startAngle, restAngle = angleRange, largeThanMinAngleTotal = 0;
    if (data.forEach((d => {
        const angleFieldValue = d[polar_1.ARC_TRANSFORM_VALUE], ratio = total ? angleFieldValue / total : 0;
        let radian = ratio * angleRange;
        radian < minAngle ? (radian = minAngle, restAngle -= minAngle) : largeThanMinAngleTotal += angleFieldValue;
        const dStartAngle = lastAngle, dEndAngle = lastAngle + radian;
        d[asRatio] = ratio, d[asK] = max ? angleFieldValue / max : 0, appendArcInfo(d, dStartAngle, radian), 
        lastAngle = dEndAngle;
    })), restAngle < angleRange) if (restAngle <= .001) {
        const angle = angleRange / data.length;
        data.forEach(((d, index) => {
            appendArcInfo(d, startAngle + index * angle, angle);
        }));
    } else {
        const unitRadian = restAngle / largeThanMinAngleTotal;
        lastAngle = startAngle, data.forEach((d => {
            const angle = d[asRadian] === minAngle ? minAngle : d[polar_1.ARC_TRANSFORM_VALUE] * unitRadian;
            appendArcInfo(d, lastAngle, angle), lastAngle += angle;
        }));
    }
    return 0 !== total && (data[data.length - 1][asEndAngle] = endAngle), data;
};

exports.pie = pie;
//# sourceMappingURL=pie.js.map
