import { isValid } from "@visactor/vutils";

import { TooltipResult } from "../interface/common";

import { ChartEvent } from "../../../constant";

import { getPolarDimensionInfo } from "../../../event/events/dimension/util/polar";

import { getCartesianDimensionInfo } from "../../../event/events/dimension/util/cartesian";

import { isDiscrete } from "@visactor/vscale";

export class BaseTooltipProcessor {
    constructor(component) {
        this._showTooltipByHandler = (data, params) => {
            var _a, _b;
            return this.component.event.emit(ChartEvent.tooltipShow, Object.assign(Object.assign({}, params), {
                tooltipData: data,
                activeType: this.activeType,
                tooltip: this.component
            })), (null === (_a = this.component.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip) && isValid(data) ? null !== (_b = this.component.tooltipHandler.showTooltip(this.activeType, data, params)) && void 0 !== _b ? _b : TooltipResult.success : TooltipResult.failed;
        }, this.component = component;
    }
    _preprocessDimensionInfo(dimensionInfo) {
        const newDimensionInfo = [];
        if (null == dimensionInfo || dimensionInfo.forEach((info => {
            const di = Object.assign(Object.assign({}, info), {
                data: info.data.filter((({series: series}) => {
                    var _a, _b;
                    return !1 !== (null === (_b = null === (_a = series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) || void 0 === _b ? void 0 : _b.visible);
                }))
            });
            di.data.length > 0 && newDimensionInfo.push(di);
        })), newDimensionInfo.length > 0) return newDimensionInfo;
    }
    _getDimensionInfo(params) {
        var _a, _b;
        let targetDimensionInfo;
        const chart = this.component.getChart(), layer = chart.getCompiler().getStage().getLayer(void 0), point = {
            x: params.event.viewX,
            y: params.event.viewY
        };
        if (layer.globalTransMatrix.transformPoint({
            x: params.event.viewX,
            y: params.event.viewY
        }, point), targetDimensionInfo = [ ...null !== (_a = getCartesianDimensionInfo(chart, point)) && void 0 !== _a ? _a : [], ...null !== (_b = getPolarDimensionInfo(chart, point)) && void 0 !== _b ? _b : [] ], 
        0 === targetDimensionInfo.length) targetDimensionInfo = void 0; else if (targetDimensionInfo.length > 1) {
            const dimensionAxisInfo = targetDimensionInfo.filter((info => {
                var _a;
                const axis = info.axis;
                if (!isDiscrete(axis.getScale().type)) return !1;
                let firstSeries;
                for (const region of null !== (_a = null == axis ? void 0 : axis.getRegions()) && void 0 !== _a ? _a : []) {
                    for (const series of region.getSeries()) if ("cartesian" === series.coordinate) {
                        firstSeries = series;
                        break;
                    }
                    if (isValid(firstSeries)) break;
                }
                return isValid(firstSeries) && firstSeries.getDimensionField()[0] === firstSeries.fieldY[0] ? "left" === axis.getOrient() || "right" === axis.getOrient() : "bottom" === axis.getOrient() || "top" === axis.getOrient();
            }));
            targetDimensionInfo = dimensionAxisInfo.length ? dimensionAxisInfo : targetDimensionInfo.slice(0, 1);
        }
        return targetDimensionInfo;
    }
}
//# sourceMappingURL=base.js.map
