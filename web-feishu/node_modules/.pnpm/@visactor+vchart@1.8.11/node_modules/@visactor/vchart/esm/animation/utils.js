import { isFunction, isValidNumber } from "../util/type";

import { DEFAULT_DATA_INDEX } from "../constant";

import { DEFAULT_ANIMATION_CONFIG } from "./config";

import { cloneDeep, isArray, isObject, isValid } from "@visactor/vutils";

import { mergeSpec } from "../util/spec/merge-spec";

export const AnimationStates = [ "appear", "enter", "update", "exit", "disappear", "normal" ];

export function animationConfig(defaultConfig = {}, userConfig, params) {
    const config = {};
    for (let i = 0; i < AnimationStates.length; i++) {
        const state = AnimationStates[i], userStateConfig = userConfig ? userConfig[state] : void 0;
        if (!1 === userStateConfig) continue;
        if ("normal" === state) {
            userStateConfig && (config.normal = userStateConfig);
            continue;
        }
        if ("update" !== state && !userStateConfig && !defaultConfig[state]) continue;
        let defaultStateConfig, stateConfig;
        (defaultStateConfig = isArray(defaultConfig[state]) ? defaultConfig[state] : [ Object.assign(Object.assign({}, DEFAULT_ANIMATION_CONFIG[state]), defaultConfig[state]) ], 
        "exit" === state && defaultStateConfig.forEach((exitConfig => {
            exitConfig.controlOptions = {
                stopWhenStateChange: !0
            };
        })), userStateConfig) ? (stateConfig = isArray(userStateConfig) ? userStateConfig.map(((userConfig, i) => {
            var _a;
            let singleConfig = userConfig;
            return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params ? void 0 : params.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params ? void 0 : params.dataCount)), 
            singleConfig;
        })) : defaultStateConfig.map(((stateConfig, i) => {
            var _a;
            let singleConfig = mergeSpec({}, defaultStateConfig[i], userStateConfig);
            return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params ? void 0 : params.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params ? void 0 : params.dataCount)), 
            singleConfig;
        })), config[state] = stateConfig) : config[state] = defaultStateConfig;
    }
    return config.state = config.update, config;
}

export function userAnimationConfig(markName, spec, ctx) {
    var _a, _b, _c, _d, _e;
    const userConfig = {};
    return spec.animationAppear && (userConfig.appear = null !== (_a = spec.animationAppear[markName]) && void 0 !== _a ? _a : spec.animationAppear), 
    spec.animationDisappear && (userConfig.disappear = null !== (_b = spec.animationDisappear[markName]) && void 0 !== _b ? _b : spec.animationDisappear), 
    spec.animationEnter && (userConfig.enter = null !== (_c = spec.animationEnter[markName]) && void 0 !== _c ? _c : spec.animationEnter), 
    spec.animationExit && (userConfig.exit = null !== (_d = spec.animationExit[markName]) && void 0 !== _d ? _d : spec.animationExit), 
    spec.animationUpdate && (userConfig.update = null !== (_e = spec.animationUpdate[markName]) && void 0 !== _e ? _e : spec.animationUpdate), 
    spec.animationNormal && spec.animationNormal[markName] && (userConfig.normal = spec.animationNormal[markName]), 
    uniformAnimationConfig(userConfig, ctx);
}

function produceOneByOne(stateConfig, dataIndex, dataCount) {
    const {oneByOne: oneByOne, duration: duration, delay: delay, delayAfter: delayAfter} = stateConfig;
    return stateConfig.delay = (datum, element, params) => {
        const index = dataIndex(datum), durationTime = isFunction(duration) ? duration(datum, element, params) : isValidNumber(duration) ? duration : 0, userDelay = isFunction(delay) ? delay(datum, element, params) : isValidNumber(delay) ? delay : 0;
        let oneByOneTime = isFunction(oneByOne) ? oneByOne(datum, element, params) : oneByOne;
        return !1 === oneByOneTime ? userDelay : (oneByOneTime = !0 === oneByOneTime ? 0 : oneByOneTime, 
        userDelay + index * (durationTime + oneByOneTime));
    }, stateConfig.delayAfter = (datum, element, params) => {
        const index = dataIndex(datum), durationTime = isFunction(duration) ? duration(datum, element, params) : isValidNumber(duration) ? duration : 0, userDelayAfter = isFunction(delayAfter) ? delayAfter(datum, element, params) : isValidNumber(delayAfter) ? delayAfter : 0;
        let oneByOneTime = isFunction(oneByOne) ? oneByOne(datum, element, params) : oneByOne;
        if (!1 === oneByOneTime) return userDelayAfter;
        return oneByOneTime = !0 === oneByOneTime ? 0 : oneByOneTime, userDelayAfter + ((dataCount ? dataCount() : element.mark.elements.length) - index) * (durationTime + oneByOneTime);
    }, delete stateConfig.oneByOne, stateConfig;
}

function defaultDataIndex(datum) {
    return null == datum ? void 0 : datum[DEFAULT_DATA_INDEX];
}

export function shouldMarkDoMorph(spec, markName) {
    var _a, _b, _c, _d, _e;
    if (!1 === spec.animation) return !1;
    if (!1 === (null === (_a = spec.morph) || void 0 === _a ? void 0 : _a.enable)) return !1;
    const appearAnimationEnabled = !1 !== (null !== (_c = null === (_b = spec.animationAppear) || void 0 === _b ? void 0 : _b[markName]) && void 0 !== _c ? _c : spec.animationAppear), updateAnimationEnabled = !1 !== (null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d[markName]) && void 0 !== _e ? _e : spec.animationUpdate);
    return !(!appearAnimationEnabled || !updateAnimationEnabled);
}

export function isTimeLineAnimation(animationConfig) {
    return isValid(animationConfig.timeSlices);
}

export function isChannelAnimation(animationConfig) {
    return !isTimeLineAnimation(animationConfig) && isValid(animationConfig.channel);
}

export function uniformAnimationConfig(config, ctx) {
    return config ? (traverseSpec(config = cloneDeep(config), (node => {
        var _a;
        if (isFunction(node) && (null === (_a = node.prototype) || void 0 === _a ? void 0 : _a.constructor) !== node) {
            return (...args) => node(...args, ctx);
        }
        return node;
    })), config) : config;
}

function traverseSpec(spec, transform) {
    if (isArray(spec)) spec.forEach(((i, index) => {
        spec[index] = transform(spec[index], index), traverseSpec(spec[index], transform);
    })); else if (isObject(spec)) for (const key in spec) spec[key] = transform(spec[key], key), 
    traverseSpec(spec[key], transform);
}

export function isAnimationEnabledForSeries(series) {
    return !1 !== series.getSpec().animation && isValid(series.getRegion().animate);
}
//# sourceMappingURL=utils.js.map