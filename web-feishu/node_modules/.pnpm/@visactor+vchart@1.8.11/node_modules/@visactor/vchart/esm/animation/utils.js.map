{"version":3,"sources":["../src/animation/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import type { IAnimationConfig } from '@visactor/vgrammar-core';\n// eslint-disable-next-line no-duplicate-imports\nimport type {\n  IElement,\n  IAnimationTypeConfig,\n  IStateAnimationConfig,\n  IAnimationTimeline\n} from '@visactor/vgrammar-core';\nimport type { MarkAnimationSpec, IAnimationState } from './interface';\nimport type { IStateAnimateSpec, IAnimationSpec } from './spec';\nimport { isFunction, isValidNumber } from '../util/type';\nimport { DEFAULT_DATA_INDEX } from '../constant';\nimport { DEFAULT_ANIMATION_CONFIG } from './config';\nimport { cloneDeep, isArray, isObject, isValid } from '@visactor/vutils';\nimport type { SeriesMarkNameEnum } from '../series/interface/type';\nimport { mergeSpec } from '../util/spec/merge-spec';\nimport type { ISeries } from '../series';\nimport type { ISeriesSpec } from '../typings';\nimport type { ISeriesMarkAttributeContext } from '../compile/mark';\n\nexport const AnimationStates = ['appear', 'enter', 'update', 'exit', 'disappear', 'normal'];\n\nexport function animationConfig<Preset extends string>(\n  defaultConfig: MarkAnimationSpec = {},\n  userConfig?: Partial<\n    Record<IAnimationState, boolean | IStateAnimateSpec<Preset> | IAnimationConfig | IAnimationConfig[]>\n  >,\n  params?: {\n    dataIndex: (datum: any) => number;\n    dataCount: () => number;\n  }\n) {\n  const config = {} as MarkAnimationSpec;\n  for (let i = 0; i < AnimationStates.length; i++) {\n    const state = AnimationStates[i];\n    const userStateConfig = userConfig ? userConfig[state] : undefined;\n\n    if (userStateConfig === false) {\n      continue;\n    }\n\n    if (state === 'normal') {\n      userStateConfig && (config.normal = userStateConfig as IAnimationTypeConfig);\n      continue;\n    }\n\n    if (state !== 'update' && !userStateConfig && !defaultConfig[state]) {\n      // no user config and default config\n      continue;\n    }\n\n    // 开始处理默认动画逻辑\n    let defaultStateConfig: IAnimationConfig[];\n    if (isArray(defaultConfig[state])) {\n      defaultStateConfig = defaultConfig[state] as IAnimationConfig[];\n    } else {\n      defaultStateConfig = [{ ...DEFAULT_ANIMATION_CONFIG[state], ...defaultConfig[state] } as any];\n    }\n    // FIXME: 用来控制当动画状态发生变更时是否清除正在执行的动画。\n    // 现在 vrender 对于同一个视觉通道的 tween 不会做覆盖的处理。若不做动画清空同时 exit 动画比 update 动画时间长的情况下，效果会不正确\n    if (state === 'exit') {\n      defaultStateConfig.forEach(exitConfig => {\n        exitConfig.controlOptions = { stopWhenStateChange: true };\n      });\n    }\n\n    if (!userStateConfig) {\n      config[state] = defaultStateConfig;\n      continue;\n    }\n\n    // 开始处理用户配置的动画逻辑\n    let stateConfig: IAnimationConfig[];\n    if (isArray(userStateConfig)) {\n      stateConfig = userStateConfig.map((userConfig, i) => {\n        let singleConfig: IAnimationConfig = userConfig;\n        // not merge default config when user animation config is array\n        if (isChannelAnimation(singleConfig)) {\n          // `type` and `channel` is conflict, and `type` has a higher priority.\n          // here if user configured `channel`, we should remove `type` which will come from default animation config\n          delete (singleConfig as IAnimationTypeConfig).type;\n        }\n        if (singleConfig.oneByOne) {\n          singleConfig = produceOneByOne(\n            singleConfig as IAnimationTypeConfig,\n            params?.dataIndex ?? defaultDataIndex,\n            params?.dataCount\n          );\n        }\n        return singleConfig;\n      });\n    } else {\n      stateConfig = defaultStateConfig.map((stateConfig, i) => {\n        let singleConfig: IAnimationConfig = mergeSpec({}, defaultStateConfig[i], userStateConfig) as IAnimationConfig;\n        if (isChannelAnimation(singleConfig)) {\n          // `type` and `channel` is conflict, and `type` has a higher priority.\n          // here if user configured `channel`, we should remove `type` which will come from default animation config\n          delete (singleConfig as IAnimationTypeConfig).type;\n        }\n\n        if (singleConfig.oneByOne) {\n          singleConfig = produceOneByOne(\n            singleConfig as IAnimationTypeConfig,\n            params?.dataIndex ?? defaultDataIndex,\n            params?.dataCount\n          );\n        }\n        return singleConfig;\n      });\n    }\n\n    config[state] = stateConfig;\n  }\n\n  // 将 update copy 到 state 保证 useState 效果与 update 对齐\n  config.state = config.update as IStateAnimationConfig;\n  return config;\n}\n\nexport function userAnimationConfig<M extends string, Preset extends string>(\n  markName: SeriesMarkNameEnum | string,\n  spec: IAnimationSpec<M, Preset>,\n  ctx: ISeriesMarkAttributeContext\n) {\n  const userConfig: Partial<\n    Record<IAnimationState, boolean | IStateAnimateSpec<Preset> | IAnimationConfig | IAnimationConfig[]>\n  > = {};\n\n  if (spec.animationAppear) {\n    userConfig.appear = spec.animationAppear[markName] ?? spec.animationAppear;\n  }\n\n  if (spec.animationDisappear) {\n    userConfig.disappear = spec.animationDisappear[markName] ?? spec.animationDisappear;\n  }\n  if (spec.animationEnter) {\n    userConfig.enter = spec.animationEnter[markName] ?? spec.animationEnter;\n  }\n\n  if (spec.animationExit) {\n    userConfig.exit = spec.animationExit[markName] ?? spec.animationExit;\n  }\n  if (spec.animationUpdate) {\n    userConfig.update = spec.animationUpdate[markName] ?? spec.animationUpdate;\n  }\n  if (spec.animationNormal && spec.animationNormal[markName]) {\n    userConfig.normal = spec.animationNormal[markName];\n  }\n\n  return uniformAnimationConfig(userConfig, ctx);\n}\n\n/**\n * oneByOne\n */\nfunction produceOneByOne(\n  stateConfig: IAnimationTypeConfig,\n  dataIndex: (datum: any) => number,\n  dataCount?: () => number\n) {\n  const { oneByOne, duration, delay, delayAfter } = stateConfig;\n  stateConfig.delay = (datum: any, element: IElement, params: any) => {\n    const index = dataIndex(datum);\n    const durationTime = isFunction(duration)\n      ? duration(datum, element, params)\n      : isValidNumber(duration)\n      ? duration\n      : 0;\n    const userDelay = isFunction(delay) ? delay(datum, element, params) : isValidNumber(delay) ? delay : 0;\n    let oneByOneTime = isFunction(oneByOne) ? oneByOne(datum, element, params) : oneByOne;\n    if (oneByOneTime === false) {\n      return userDelay;\n    }\n    oneByOneTime = oneByOneTime === true ? 0 : oneByOneTime;\n    return userDelay + index * (durationTime + oneByOneTime);\n  };\n  stateConfig.delayAfter = (datum: any, element: IElement, params: any) => {\n    const index = dataIndex(datum);\n    const durationTime = isFunction(duration)\n      ? duration(datum, element, params)\n      : isValidNumber(duration)\n      ? duration\n      : 0;\n    const userDelayAfter = isFunction(delayAfter)\n      ? delayAfter(datum, element, params)\n      : isValidNumber(delayAfter)\n      ? delayAfter\n      : 0;\n    let oneByOneTime = isFunction(oneByOne) ? oneByOne(datum, element, params) : oneByOne;\n    if (oneByOneTime === false) {\n      return userDelayAfter;\n    }\n    const indexCount = dataCount ? dataCount() : element.mark.elements.length;\n    oneByOneTime = oneByOneTime === true ? 0 : oneByOneTime;\n    return userDelayAfter + (indexCount - index) * (durationTime + oneByOneTime);\n  };\n  delete stateConfig.oneByOne;\n  return stateConfig;\n}\n\nfunction defaultDataIndex(datum: any) {\n  return datum?.[DEFAULT_DATA_INDEX];\n}\n\nexport function shouldMarkDoMorph(spec: ISeriesSpec & IAnimationSpec<string, string>, markName: string) {\n  if (spec.animation === false) {\n    return false;\n  }\n\n  if (spec.morph?.enable === false) {\n    return false;\n  }\n\n  const appearAnimationEnabled = (spec.animationAppear?.[markName] ?? spec.animationAppear) !== false;\n  const updateAnimationEnabled = (spec.animationUpdate?.[markName] ?? spec.animationUpdate) !== false;\n\n  if (!appearAnimationEnabled || !updateAnimationEnabled) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isTimeLineAnimation(animationConfig: IAnimationConfig) {\n  return isValid((animationConfig as IAnimationTimeline).timeSlices);\n}\n\nexport function isChannelAnimation(animationConfig: IAnimationConfig) {\n  return !isTimeLineAnimation(animationConfig) && isValid((animationConfig as IAnimationTypeConfig).channel);\n}\n\nexport function uniformAnimationConfig<Preset extends string>(\n  config: Partial<Record<IAnimationState, boolean | IStateAnimateSpec<Preset> | IAnimationConfig | IAnimationConfig[]>>,\n  ctx: ISeriesMarkAttributeContext\n) {\n  if (!config) {\n    return config;\n  }\n  config = cloneDeep(config);\n  traverseSpec(config, (node: any) => {\n    // 将函数转换为 vchart 代理的函数\n    // 这里可能会传自定义动画的构造函数，不能被代理\n    if (isFunction(node) && node.prototype?.constructor !== node) {\n      const name = (...args: any) => {\n        return node(...args, ctx);\n      };\n      return name;\n    }\n    return node;\n  });\n\n  return config;\n}\n\nfunction traverseSpec(spec: any, transform: (node: any, key: string | number) => any) {\n  if (isArray(spec)) {\n    spec.forEach((i: any, index: number) => {\n      spec[index] = transform(spec[index], index);\n      traverseSpec(spec[index], transform);\n    });\n  } else if (isObject(spec)) {\n    for (const key in spec) {\n      spec[key] = transform(spec[key], key);\n      traverseSpec(spec[key], transform);\n    }\n  }\n}\n\nexport function isAnimationEnabledForSeries(series: ISeries) {\n  return series.getSpec().animation !== false && isValid(series.getRegion().animate);\n}\n"]}