import { DataView } from "@visactor/vdataset";

import { ComponentTypeEnum } from "../../interface/type";

import { markerAggregation } from "../../../data/transforms/aggregation";

import { computeClipRange, coordinateLayout, positionLayout, xyLayout, transformLabelAttributes } from "../utils";

import { registerDataSetInstanceTransform } from "../../../data/register";

import { MarkArea as MarkAreaComponent } from "@visactor/vrender-components";

import { isEmpty, isValid, isArray } from "@visactor/vutils";

import { transformToGraphic } from "../../../util/style";

import { BaseMarker } from "../base-marker";

import { LayoutZIndex } from "../../../constant";

import { Factory } from "../../../core/factory";

import { markerFilter } from "../../../data/transforms/marker-filter";

export class MarkArea extends BaseMarker {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.markArea, this.name = ComponentTypeEnum.markArea, 
        this.specKey = "markArea", this.layoutZIndex = LayoutZIndex.MarkArea;
    }
    static getSpecInfo(chartSpec) {
        const markAreaSpec = chartSpec[this.specKey];
        if (isEmpty(markAreaSpec)) return;
        if (!isArray(markAreaSpec) && !1 !== markAreaSpec.visible) return [ {
            spec: markAreaSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.markArea
        } ];
        const specInfos = [];
        return markAreaSpec.forEach(((m, i) => {
            !1 !== m.visible && specInfos.push({
                spec: m,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.markArea
            });
        })), specInfos;
    }
    _createMarkerComponent() {
        var _a, _b, _c, _d;
        const label = null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}, markAreaAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null !== (_b = this._spec.interactive) && void 0 !== _b && _b,
            points: [ {
                x: 0,
                y: 0
            } ],
            areaStyle: transformToGraphic(null === (_c = this._spec.area) || void 0 === _c ? void 0 : _c.style),
            clipInRange: null !== (_d = this._spec.clip) && void 0 !== _d && _d,
            label: transformLabelAttributes(label)
        };
        return new MarkAreaComponent(markAreaAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d, _e;
        const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isXLayout = isValid(spec.x) && isValid(spec.x1), isYLayout = isValid(spec.y) && isValid(spec.y1), isXYLayout = isXLayout && isYLayout, isCoordinateLayout = isValid(spec.coordinates), isPositionLayout = isValid(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
        let points = [], lines = [];
        isXYLayout ? (lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), 
        points = [ {
            x: lines[0][0].x,
            y: lines[1][0].y
        }, lines[0][0], {
            x: lines[1][0].x,
            y: lines[0][0].y
        }, lines[1][0] ]) : isXLayout || isYLayout ? (lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), 
        points = [ ...lines[0], lines[1][1], lines[1][0] ]) : isCoordinateLayout ? points = coordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
        const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
        let limitRect;
        if (spec.clip || (null === (_b = spec.label) || void 0 === _b ? void 0 : _b.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = computeClipRange([ startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        this._markerComponent && this._markerComponent.setAttributes({
            points: points,
            label: Object.assign(Object.assign({}, null === (_c = this._markerComponent.attribute) || void 0 === _c ? void 0 : _c.label), {
                text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_e = null === (_d = this._markerComponent.attribute) || void 0 === _d ? void 0 : _d.label) || void 0 === _e ? void 0 : _e.text
            }),
            limitRect: limitRect,
            dx: this._layoutOffsetX,
            dy: this._layoutOffsetY
        });
    }
    _initDataView() {
        const spec = this._spec, relativeSeries = this._relativeSeries, isXProcess = isValid(spec.x) && isValid(spec.x1), isYProcess = isValid(spec.y) && isValid(spec.y1), isXYProcess = isXProcess && isYProcess, isCoordinateProcess = isValid(spec.coordinates);
        if (!isXProcess && !isYProcess && !isCoordinateProcess) return null;
        let options;
        isXYProcess ? options = [ this._processSpecXY(spec.x, spec.y), this._processSpecXY(spec.x1, spec.y1) ] : isXProcess ? options = [ this._processSpecX(spec.x), this._processSpecX(spec.x1) ] : isYProcess ? options = [ this._processSpecY(spec.y), this._processSpecY(spec.y1) ] : isCoordinateProcess && (options = this._processSpecCoo(spec));
        const seriesData = relativeSeries.getViewData();
        registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), 
        registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
        const data = new DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        data.parse([ seriesData ], {
            type: "dataview"
        }), data.transform({
            type: "markerAggregation",
            options: options
        }), options && data.transform({
            type: "markerFilter",
            options: this._getAllRelativeSeries()
        }), data.target.on("change", (() => {
            this._markerLayout();
        })), this._markerData = data;
    }
}

MarkArea.type = ComponentTypeEnum.markArea, MarkArea.specKey = "markArea";

export const registerMarkArea = () => {
    Factory.registerComponent(MarkArea.type, MarkArea);
};
//# sourceMappingURL=mark-area.js.map
