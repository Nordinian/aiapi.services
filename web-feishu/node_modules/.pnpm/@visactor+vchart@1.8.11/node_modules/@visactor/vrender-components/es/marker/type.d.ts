import type { IGroup, IGroupGraphicAttribute, IImageGraphicAttribute, IPolygonAttribute, IRichTextGraphicAttribute, ISymbolGraphicAttribute } from '@visactor/vrender-core';
import type { SegmentAttributes, SymbolAttributes } from '../segment';
import type { TagAttributes } from '../tag';
import type { Point } from '../core/type';
export declare enum IMarkLineLabelPosition {
    start = "start",
    middle = "middle",
    end = "end",
    insideStartTop = "insideStartTop",
    insideStartBottom = "insideStartBottom",
    insideMiddleTop = "insideMiddleTop",
    insideMiddleBottom = "insideMiddleBottom",
    insideEndTop = "insideEndTop",
    insideEndBottom = "insideEndBottom"
}
export declare enum IMarkAreaLabelPosition {
    left = "left",
    right = "right",
    top = "top",
    bottom = "bottom",
    middle = "middle",
    insideLeft = "insideLeft",
    insideRight = "insideRight",
    insideTop = "insideTop",
    insideBottom = "insideBottom"
}
export declare enum IMarkPointItemPosition {
    top = "top",
    bottom = "bottom",
    middle = "middle",
    insideTop = "insideTop",
    insideBottom = "insideBottom",
    insideMiddle = "insideMiddle"
}
export type IMarkBackgroundAttributes = {
    visible: boolean;
    autoHeight?: boolean;
    autoWidth?: boolean;
} & Partial<SymbolAttributes>;
export type IMarkLabel = Omit<TagAttributes, 'x' | 'y' | 'panel'> & {
    panel?: IMarkBackgroundAttributes;
};
export type IMarkRef = {
    autoRotate?: boolean;
    refX?: number;
    refY?: number;
    refAngle?: number;
};
export type MarkerAttrs = IGroupGraphicAttribute & {
    type?: 'line' | 'area' | 'point';
    interactive?: boolean;
    visible?: boolean;
    clipInRange?: boolean;
    limitRect?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
};
export type MarkLineAttrs = MarkerAttrs & SegmentAttributes & {
    type?: 'line';
    points: Point[] | Point[][];
    label?: {
        position?: keyof typeof IMarkLineLabelPosition;
        confine?: boolean;
    } & IMarkRef & IMarkLabel;
};
export type MarkAreaAttrs = MarkerAttrs & {
    type?: 'area';
    points: Point[];
    label?: {
        position?: keyof typeof IMarkAreaLabelPosition;
        confine?: boolean;
    } & IMarkLabel;
    areaStyle?: IPolygonAttribute;
};
export type IItemContent = IMarkRef & {
    type?: 'symbol' | 'text' | 'image' | 'richText' | 'custom';
    position?: keyof typeof IMarkPointItemPosition;
    offsetX?: number;
    offsetY?: number;
    symbolStyle?: ISymbolGraphicAttribute;
    imageStyle?: IImageGraphicAttribute;
    textStyle?: IMarkLabel;
    richTextStyle?: IRichTextGraphicAttribute;
    renderCustomCallback?: () => IGroup;
    confine?: boolean;
};
export type IItemLine = {
    type?: 'type-s' | 'type-do' | 'type-po' | 'type-op';
    visible?: boolean;
    decorativeLine?: {
        visible?: boolean;
        length?: number;
    };
} & Omit<SegmentAttributes, 'points'>;
export type MarkPointAttrs = Omit<MarkerAttrs, 'labelStyle'> & {
    position: Point;
    itemLine?: IItemLine;
    itemContent?: IItemContent;
};
