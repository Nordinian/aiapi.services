{"version":3,"sources":["../src/axis/overlap/auto-limit.ts"],"names":[],"mappings":";;;AAIA,6CAAiE;AASjE,SAAgB,SAAS,CAAC,MAAe,EAAE,MAAmB;IAC5D,MAAM,EAAE,WAAW,EAAE,mBAAmB,EAAE,QAAQ,GAAG,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;IAE9E,IAAI,IAAA,gBAAO,EAAC,MAAM,CAAC,IAAI,CAAC,IAAA,sBAAa,EAAC,WAAW,CAAC,EAAE;QAClD,OAAO;KACR;IAED,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACrB,IAAI,CAAC,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,IAAI,WAAW,EAAE;YACrG,OAAO;SACR;QACD,MAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,SAAS,CAAC;QAC5C,IACE,CAAC,MAAM,KAAK,MAAM,IAAI,MAAM,KAAK,OAAO,CAAC;YACzC,CAAC,CAAC,SAAS,KAAK,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,IAAI,mBAAmB,CAAC;gBACzF,CAAC,SAAS,KAAK,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,IAAI,WAAW,CAAC,CAAC,EACpF;YACA,OAAO;SACR;QAED,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;QAGpC,IAAI,gBAAgB,GAClB,KAAK,KAAK,CAAC,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC;YACzB,CAAC,CAAC,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,QAAQ;gBACvC,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,SAAS,KAAK,UAAU;oBAC1B,CAAC,CAAC,mBAAmB;oBACrB,CAAC,CAAC,WAAW;YACf,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;QAE9C,IAAI,IAAA,sBAAa,EAAC,KAAK,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE;YAC/C,gBAAgB,GAAG,IAAA,sBAAa,EAAC,gBAAgB,CAAC;gBAChD,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,YAAY,EAAE,gBAAgB,CAAC;gBAC1D,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,YAAY,CAAC;SAClC;QACD,KAAK,CAAC,aAAa,CAAC;YAClB,YAAY,EAAE,gBAAgB;YAC9B,QAAQ,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,IAAI,QAAQ;SAC/C,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AA1CD,8BA0CC","file":"auto-limit.js","sourcesContent":["/**\n * 自动省略\n */\nimport type { IText } from '@visactor/vrender-core';\nimport { isEmpty, isNil, isValidNumber } from '@visactor/vutils';\n\ntype LimitConfig = {\n  orient: string;\n  limitLength: number;\n  verticalLimitLength?: number;\n  ellipsis?: string;\n};\n\nexport function autoLimit(labels: IText[], config: LimitConfig) {\n  const { limitLength, verticalLimitLength, ellipsis = '...', orient } = config;\n\n  if (isEmpty(labels) || !isValidNumber(limitLength)) {\n    return;\n  }\n\n  labels.forEach(label => {\n    if ((orient === 'top' || orient === 'bottom') && Math.floor(label.AABBBounds.height()) <= limitLength) {\n      return;\n    }\n    const direction = label.attribute.direction;\n    if (\n      (orient === 'left' || orient === 'right') &&\n      ((direction === 'vertical' && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) ||\n        (direction !== 'vertical' && Math.floor(label.AABBBounds.width()) <= limitLength))\n    ) {\n      return;\n    }\n\n    const angle = label.attribute.angle;\n\n    // 如果水平并且文本未发生旋转，则不配置 maxLineWidth\n    let limitLabelLength =\n      angle === 0 || isNil(angle)\n        ? orient === 'top' || orient === 'bottom'\n          ? null\n          : direction === 'vertical'\n          ? verticalLimitLength\n          : limitLength\n        : Math.abs(limitLength / Math.sin(angle));\n\n    if (isValidNumber(label.attribute.maxLineWidth)) {\n      limitLabelLength = isValidNumber(limitLabelLength)\n        ? Math.min(label.attribute.maxLineWidth, limitLabelLength)\n        : label.attribute.maxLineWidth;\n    }\n    label.setAttributes({\n      maxLineWidth: limitLabelLength,\n      ellipsis: label.attribute.ellipsis || ellipsis\n    });\n  });\n}\n"]}