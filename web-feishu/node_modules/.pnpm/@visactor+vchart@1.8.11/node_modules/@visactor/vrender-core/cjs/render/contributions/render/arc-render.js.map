{"version":3,"sources":["../src/render/contributions/render/arc-render.ts"],"names":[],"mappings":"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","file":"arc-render.js","sourcesContent":["import { abs, acos, atan2, cos, epsilon, min, pi, sin, sqrt, pi2, isBoolean } from '@visactor/vutils';\nimport { inject, injectable, named } from '../../../common/inversify-lite';\nimport { getTheme } from '../../../graphic/theme';\nimport { parseStroke } from '../../../common/utils';\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport { ContributionProvider } from '../../../common/contribution-provider';\nimport type {\n  IContext2d,\n  IArc,\n  IPath2D,\n  IGraphicAttribute,\n  IMarkAttribute,\n  IThemeAttribute,\n  IGradientColor,\n  IArcRenderContribution,\n  IDrawContext,\n  IRenderService,\n  IGraphicRender,\n  IGraphicRenderDrawParams,\n  IContributionProvider,\n  IConicalGradient\n} from '../../../interface';\nimport {\n  cornerTangents,\n  drawArcPath,\n  drawPathProxy,\n  fillVisible,\n  intersect,\n  runFill,\n  runStroke,\n  strokeVisible\n} from './utils';\nimport { getConicGradientAt } from '../../../canvas/conical-gradient';\nimport { ArcRenderContribution } from './contributions/constants';\nimport { BaseRenderContributionTime } from '../../../common/enums';\nimport { ARC_NUMBER_TYPE } from '../../../graphic/constants';\nimport { BaseRender } from './base-render';\nimport {\n  defaultArcBackgroundRenderContribution,\n  defaultArcRenderContribution,\n  defaultArcTextureRenderContribution\n} from './contributions';\n/**\n * 部分源码参考 https://github.com/d3/d3-shape/\n * Copyright 2010-2022 Mike Bostock\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n */\n\n@injectable()\nexport class DefaultCanvasArcRender extends BaseRender<IArc> implements IGraphicRender {\n  type: 'arc';\n  numberType: number = ARC_NUMBER_TYPE;\n\n  constructor(\n    @inject(ContributionProvider)\n    @named(ArcRenderContribution)\n    protected readonly arcRenderContribitions: IContributionProvider<IArcRenderContribution>\n  ) {\n    super();\n    this.builtinContributions = [\n      defaultArcRenderContribution,\n      defaultArcBackgroundRenderContribution,\n      defaultArcTextureRenderContribution\n    ];\n    this.init(arcRenderContribitions);\n  }\n\n  // 绘制尾部cap\n  drawArcTailCapPath(\n    arc: IArc,\n    context: IContext2d | IPath2D,\n    cx: number,\n    cy: number,\n    outerRadius: number,\n    innerRadius: number,\n    _sa: number,\n    _ea: number\n  ) {\n    const capAngle = _ea - _sa;\n    const data = arc.getParsedAngle();\n    const startAngle = data.startAngle;\n    let endAngle = data.endAngle;\n    endAngle = _ea;\n    const deltaAngle = abs(endAngle - startAngle);\n    const clockwise: boolean = endAngle > startAngle;\n    let collapsedToLine: boolean = false;\n    // 规范化outerRadius和innerRadius\n    if (outerRadius < innerRadius) {\n      const temp = outerRadius;\n      outerRadius = innerRadius;\n      innerRadius = temp;\n    }\n\n    const cornerRadius = arc.getParsedCornerRadius();\n    // Or is it a circular or annular sector?\n    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } =\n      arc.getParsePadAngle(startAngle, endAngle);\n\n    const outerCornerRadiusStart = cornerRadius;\n    const outerCornerRadiusEnd = cornerRadius;\n    const innerCornerRadiusEnd = cornerRadius;\n    const innerCornerRadiusStart = cornerRadius;\n    const maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart);\n    const maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);\n    let limitedOcr = maxOuterCornerRadius;\n    let limitedIcr = maxInnerCornerRadius;\n\n    const xors = outerRadius * cos(outerStartAngle);\n    const yors = outerRadius * sin(outerStartAngle);\n    const xire = innerRadius * cos(innerEndAngle);\n    const yire = innerRadius * sin(innerEndAngle);\n\n    // Apply rounded corners?\n    let xore: number;\n    let yore: number;\n    let xirs: number;\n    let yirs: number;\n\n    if (maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) {\n      xore = outerRadius * cos(outerEndAngle);\n      yore = outerRadius * sin(outerEndAngle);\n      xirs = innerRadius * cos(innerStartAngle);\n      yirs = innerRadius * sin(innerStartAngle);\n\n      // Restrict the corner radius according to the sector angle.\n      if (deltaAngle < pi) {\n        const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);\n\n        if (oc) {\n          const ax = xors - oc[0];\n          const ay = yors - oc[1];\n          const bx = xore - oc[0];\n          const by = yore - oc[1];\n          const kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2);\n          const lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n\n          limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1));\n          limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));\n        }\n      }\n    }\n\n    if (limitedOcr > epsilon) {\n      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr);\n      const cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr);\n      // Does the sector’s outer ring have rounded corners?\n      const t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise));\n      const t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));\n\n      // Have the corners merged?\n      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) {\n        context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);\n        context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);\n      } else {\n        const a1 = endAngle - capAngle - 0.03;\n        const a2 = atan2(t1.y11, t1.x11);\n        context.arc(cx, cy, outerRadius, a1, a2, !clockwise);\n        cornerRadiusEnd > 0 &&\n          context.arc(\n            cx + t1.cx,\n            cy + t1.cy,\n            cornerRadiusEnd,\n            atan2(t1.y11, t1.x11),\n            atan2(t1.y01, t1.x01),\n            !clockwise\n          );\n      }\n    } else {\n      context.moveTo(cx + xors, cy + yors);\n    }\n    //   else {\n    //     // Or is the outer ring just a circular arc?\n    //     if (!partStroke || partStroke[0]) {\n    //       context.moveTo(cx + xors, cy + yors);\n    //       context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise);\n    //     } else {\n    //       // context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + yore);\n    //     }\n    //   }\n    //   // Is there no inner ring, and it’s a circular sector?\n    //   // Or perhaps it’s an annular sector collapsed due to padding?\n    if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {\n      context.lineTo(cx + xire, cy + yire);\n      collapsedToLine = true;\n    } else if (limitedIcr > epsilon) {\n      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr);\n      const cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr);\n      // Does the sector’s inner ring (or point) have rounded corners?\n      const t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise));\n      const t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));\n\n      context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);\n\n      // Have the corners merged?\n      if (limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {\n        const arcEndAngle = atan2(t1.y01, t1.x01);\n        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);\n      } else {\n        cornerRadiusEnd > 0 &&\n          context.arc(\n            cx + t0.cx,\n            cy + t0.cy,\n            cornerRadiusEnd,\n            atan2(t0.y01, t0.x01),\n            atan2(t0.y11, t0.x11),\n            !clockwise\n          );\n        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11);\n        const a2 = endAngle - capAngle - 0.03;\n        context.arc(cx, cy, innerRadius, a1, a2, clockwise);\n      }\n    } else {\n      context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));\n    }\n\n    return collapsedToLine;\n  }\n\n  drawShape(\n    arc: IArc,\n    context: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    // const arcAttribute = graphicService.themeService.getCurrentTheme().arcAttribute;\n    const arcAttribute = getTheme(arc, params?.theme).arc;\n    const {\n      fill = arcAttribute.fill,\n      stroke = arcAttribute.stroke,\n      x: originX = arcAttribute.x,\n      y: originY = arcAttribute.y\n    } = arc.attribute;\n    const data = this.valid(arc, arcAttribute, fillCb, strokeCb);\n    if (!data) {\n      return;\n    }\n    const { fVisible, sVisible, doFill, doStroke } = data;\n\n    const {\n      outerRadius = arcAttribute.outerRadius,\n      innerRadius = arcAttribute.innerRadius,\n      cap = arcAttribute.cap,\n      forceShowCap = arcAttribute.forceShowCap\n    } = arc.attribute;\n    // 判断是否是环形渐变，且有头部cap，那就偏移渐变色角度\n    let conicalOffset = 0;\n    const tempChangeConicalColor =\n      ((isBoolean(cap) && cap) || cap[0]) && (fill as IGradientColor).gradient === 'conical';\n    if (tempChangeConicalColor) {\n      const { sc, startAngle, endAngle } = arc.getParsedAngle();\n      if (abs(endAngle - startAngle) < pi2 - epsilon) {\n        conicalOffset = sc || 0;\n        (fill as IConicalGradient).startAngle -= conicalOffset;\n        (fill as IConicalGradient).endAngle -= conicalOffset;\n      }\n    }\n\n    let beforeRenderContribitionsRuned = false;\n    const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke);\n    if (doFill || isFullStroke) {\n      context.beginPath();\n      // if (arc.shouldUpdateShape()) {\n      //   // 更新shape\n      //   arc.cache = new Path2D(context);\n      //   this.drawArcPath(arc, arc.cache, x, y, outerRadius, innerRadius);\n      //   arc.clearUpdateShapeTag();\n      // } else {\n      //   if (arc.cache) {\n      //     renderCommandList(arc.cache.commandList, context);\n      //   }\n      // }\n      // 测试后，cache对于重绘性能提升不大，但是在首屏有一定性能损耗，因此arc不再使用cache\n      drawArcPath(arc, context, x, y, outerRadius, innerRadius);\n\n      beforeRenderContribitionsRuned = true;\n      // shadow\n      context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute);\n      this.beforeRenderStep(\n        arc,\n        context,\n        x,\n        y,\n        doFill,\n        doStroke,\n        fVisible,\n        sVisible,\n        arcAttribute,\n        drawContext,\n        fillCb,\n        strokeCb\n      );\n\n      if (doFill) {\n        if (fillCb) {\n          fillCb(context, arc.attribute, arcAttribute);\n        } else if (fVisible) {\n          context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute);\n          context.fill();\n        }\n      }\n\n      if (doStroke && isFullStroke) {\n        if (strokeCb) {\n          strokeCb(context, arc.attribute, arcAttribute);\n        } else if (sVisible) {\n          context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute);\n          context.stroke();\n        }\n      }\n    }\n\n    // 需要局部渲染描边的时候\n    if (!isFullStroke && doStroke) {\n      context.beginPath();\n      const collapsedToLine = drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);\n\n      if (!beforeRenderContribitionsRuned) {\n        this.beforeRenderStep(\n          arc,\n          context,\n          x,\n          y,\n          doFill,\n          doStroke,\n          fVisible,\n          sVisible,\n          arcAttribute,\n          drawContext,\n          fillCb,\n          strokeCb\n        );\n      }\n\n      if (strokeCb) {\n        strokeCb(context, arc.attribute, arcAttribute);\n      } else if (sVisible) {\n        context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);\n        context.stroke();\n      }\n    }\n\n    // 绘制cap\n    if (((isBoolean(cap) && cap) || cap[1]) && forceShowCap) {\n      const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();\n      const deltaAngle = abs(ea - sa);\n      if (deltaAngle >= pi2 - epsilon) {\n        context.beginPath();\n        const capWidth = Math.abs(outerRadius - innerRadius) / 2;\n        // 以外边界长度为准\n        const capAngle = capWidth / outerRadius;\n        const { endAngle = arcAttribute.endAngle, fill = arcAttribute.fill } = arc.attribute;\n        const startAngle = endAngle;\n        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle);\n\n        if (!beforeRenderContribitionsRuned) {\n          this.beforeRenderStep(\n            arc,\n            context,\n            x,\n            y,\n            doFill,\n            doStroke,\n            fVisible,\n            sVisible,\n            arcAttribute,\n            drawContext,\n            fillCb,\n            strokeCb\n          );\n        }\n\n        if (doFill) {\n          // 获取渐变色最后一个颜色\n          const color = fill;\n          if ((color as IGradientColor).gradient === 'conical') {\n            const lastColor = getConicGradientAt(0, 0, endAngle, color as any);\n            if (fillCb) {\n              // fillCb(context, arc.attribute, arcAttribute);\n            } else if (fillVisible) {\n              // context.closePath();\n              context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);\n              context.fillStyle = lastColor as string;\n              context.fill();\n            }\n          }\n        }\n        if (doStroke) {\n          if (strokeCb) {\n            // fillCb(context, arc.attribute, arcAttribute);\n          } else if (sVisible) {\n            context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);\n            // context.strokeStyle = 'red';\n            context.stroke();\n          }\n        }\n      }\n    }\n\n    this.afterRenderStep(\n      arc,\n      context,\n      x,\n      y,\n      doFill,\n      doStroke,\n      fVisible,\n      sVisible,\n      arcAttribute,\n      drawContext,\n      fillCb,\n      strokeCb\n    );\n\n    if (tempChangeConicalColor) {\n      (fill as IConicalGradient).startAngle += conicalOffset;\n      (fill as IConicalGradient).endAngle += conicalOffset;\n    }\n  }\n\n  draw(arc: IArc, renderService: IRenderService, drawContext: IDrawContext, params?: IGraphicRenderDrawParams) {\n    const arcAttribute = getTheme(arc, params?.theme).arc;\n    this._draw(arc, arcAttribute, false, drawContext, params);\n  }\n}\n"]}