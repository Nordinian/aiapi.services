import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { DefaultImageAttribute } from "./config";

import { getTheme } from "./theme";

import { application } from "../application";

import { parsePadding } from "../common/utils";

import { IMAGE_NUMBER_TYPE } from "./constants";

const IMAGE_UPDATE_TAG_KEY = [ "width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Image extends Graphic {
    constructor(params) {
        super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
    }
    get width() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;
    }
    set width(width) {
        this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());
    }
    get height() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;
    }
    set height(height) {
        this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());
    }
    get repeatX() {
        var _a;
        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatX(repeatX) {
        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
    }
    get repeatY() {
        var _a;
        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatY(repeatY) {
        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
    }
    get image() {
        return this.attribute.image;
    }
    set image(image) {
        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
    }
    imageLoadSuccess(url, image, cb) {
        super.imageLoadSuccess(url, image, (() => {
            this.successCallback && this.successCallback();
        }));
    }
    imageLoadFail(url, cb) {
        super.imageLoadFail(url, (() => {
            this.failCallback && this.failCallback();
        }));
    }
    setAttributes(params, forceUpdateTag, context) {
        return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
    }
    setAttribute(key, value, forceUpdateTag, context) {
        return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
    }
    doUpdateAABBBounds() {
        const imageTheme = getTheme(this).image;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application.graphicService.updateImageAABBBounds(attribute, getTheme(this).image, this._AABBBounds, this), {boundsPadding: boundsPadding = imageTheme.boundsPadding} = attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return DefaultImageAttribute[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
    }
    clone() {
        return new Image(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Image.NOWORK_ANIMATE_ATTR;
    }
}

Image.NOWORK_ANIMATE_ATTR = Object.assign({
    image: 1,
    repeatX: 1,
    repeatY: 1
}, NOWORK_ANIMATE_ATTR);

export function createImage(attributes) {
    return new Image(attributes);
}
//# sourceMappingURL=image.js.map
