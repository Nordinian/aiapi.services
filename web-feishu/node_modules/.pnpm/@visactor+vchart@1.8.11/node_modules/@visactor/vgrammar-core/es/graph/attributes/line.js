import { isNil, isString } from "@visactor/vutils";

import { transformAttributes } from "./transform";

import { GrammarMarkType } from "../enums";

const isStopsEqual = (prev, next) => {
    var _a, _b;
    if (prev === next) return !0;
    const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
    return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every(((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset));
}, isColorAttrEqual = (prev, next) => {
    if (prev === next) return !0;
    if (typeof prev != typeof next) return !1;
    if (isString(prev)) return !1;
    if (prev.gradient !== next.gradient) return !1;
    const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
    return prevKeys.length === nextKeys.length && prevKeys.every((key => "stops" === key ? isStopsEqual(prev[key], next[key]) : prev[key] === next[key]));
}, isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-"), isSegmentAttrEqual = (prev, next, key) => !(!isNil(prev) || !isNil(next)) || !isNil(prev) && (!isNil(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next)), fillAttrs = [ "fill", "fillOpacity", "background", "texture", "texturePadding", "textureSize", "textureColor" ], strokeAttrs = [ "stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit" ], areaAttrs = fillAttrs.concat(strokeAttrs);

export function getLineSegmentConfigs(items, points, element) {
    var _a;
    if (!items || items.length <= 1) return null;
    const checkAttributes = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? areaAttrs : strokeAttrs, segments = [];
    let prevSegmentAttrs = null;
    return items.forEach(((item, index) => {
        prevSegmentAttrs && checkAttributes.every((key => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key))) || (segments.length && (segments[segments.length - 1].endIndex = index), 
        prevSegmentAttrs = item, segments.push({
            attrs: prevSegmentAttrs,
            startIndex: index
        }));
    })), segments.length >= 2 ? segments.map((entry => {
        const res = transformAttributes(GrammarMarkType.line, parseCollectionMarkAttributes(entry.attrs), element);
        return res.points = points.slice(entry.startIndex, isNil(entry.endIndex) ? points.length : entry.endIndex), 
        res;
    })) : null;
}

export function getLinePointsFromSegments(segments) {
    return segments ? segments.reduce(((points, segment) => points.concat(segment.points)), []) : null;
}

export function parseCollectionMarkAttributes(itemNextAttrs) {
    const result = {};
    return itemNextAttrs ? (Object.keys(itemNextAttrs).forEach((key => {
        "x" !== key && "y" !== key && "x1" !== key && "y1" !== key && "defined" !== key && "size" !== key && "width" !== key && "height" !== key && "context" !== key && (result[key] = itemNextAttrs[key]);
    })), result) : result;
}
//# sourceMappingURL=line.js.map
