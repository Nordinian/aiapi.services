"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Canvas3DPickItemInterceptor = exports.InteractivePickItemInterceptorContribution = exports.ShadowRootPickItemInterceptorContribution = exports.PickItemInterceptor = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_lite_1 = require("../common/inversify-lite"), constants_1 = require("../graphic/constants"), matrix_allocate_1 = require("../allocator/matrix-allocate");

exports.PickItemInterceptor = Symbol.for("PickItemInterceptor");

let ShadowRootPickItemInterceptorContribution = class {
    constructor() {
        this.order = 1;
    }
    afterPickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
    }
    _pickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.shadowRoot) return null;
        const {parentMatrix: parentMatrix} = params || {};
        if (!parentMatrix) return null;
        const context = pickerService.pickContext;
        context.highPerformanceSave();
        const g = graphic.shadowRoot, currentGroupMatrix = matrix_allocate_1.matrixAllocate.allocateByObj(parentMatrix), newPoint = new vutils_1.Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f), result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
        return context.highPerformanceRestore(), result;
    }
};

ShadowRootPickItemInterceptorContribution = __decorate([ (0, inversify_lite_1.injectable)() ], ShadowRootPickItemInterceptorContribution), 
exports.ShadowRootPickItemInterceptorContribution = ShadowRootPickItemInterceptorContribution;

let InteractivePickItemInterceptorContribution = class {
    constructor() {
        this.order = 1;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        const originGraphic = graphic.baseGraphic;
        if (originGraphic && originGraphic.parent) {
            const newPoint = new vutils_1.Point(point.x, point.y), context = pickerService.pickContext;
            context.highPerformanceSave();
            const parentMatrix = originGraphic.parent.globalTransMatrix;
            parentMatrix.transformPoint(newPoint, newPoint);
            const result = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
            return context.highPerformanceRestore(), result;
        }
        return null;
    }
};

InteractivePickItemInterceptorContribution = __decorate([ (0, inversify_lite_1.injectable)() ], InteractivePickItemInterceptorContribution), 
exports.InteractivePickItemInterceptorContribution = InteractivePickItemInterceptorContribution;

let Canvas3DPickItemInterceptor = class {
    constructor() {
        this.order = 1;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
        const context = pickerService.pickContext, stage = graphic.stage;
        if (!context || !stage) return null;
        if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), 
        context.camera = stage.camera, graphic.isContainer) {
            let result, isPie = !1, is3d = !1;
            if (graphic.forEachChildren((c => (isPie = c.numberType === constants_1.ARC3D_NUMBER_TYPE, 
            !isPie))), graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {
                const children = graphic.getChildren(), sortedChildren = [ ...children ];
                sortedChildren.sort(((a, b) => {
                    var _a, _b, _c, _d;
                    let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
                    for (;angle1 < 0; ) angle1 += vutils_1.pi2;
                    for (;angle2 < 0; ) angle2 += vutils_1.pi2;
                    return angle2 - angle1;
                })), sortedChildren.forEach((c => {
                    c._next = null, c._prev = null;
                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {
                    graphic.appendChild(c);
                })), pickParams.hack_pieFace = "outside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), 
                result.graphic || (pickParams.hack_pieFace = "inside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), 
                result.graphic || (pickParams.hack_pieFace = "top", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), 
                graphic.removeAllChild(), children.forEach((c => {
                    c._next = null, c._prev = null;
                })), children.forEach((c => {
                    graphic.appendChild(c);
                }));
            } else if (is3d) {
                const children = graphic.getChildren(), zChildren = children.map((g => ({
                    ave_z: g.findFace().vertices.map((v => {
                        var _a;
                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                    })).reduce(((a, b) => a + b), 0),
                    g: g
                })));
                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {
                    i.g._next = null, i.g._prev = null;
                })), graphic.update(), zChildren.forEach((i => {
                    graphic.add(i.g);
                })), result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), 
                graphic.removeAllChild(), children.forEach((g => {
                    g._next = null, g._prev = null;
                })), graphic.update(), children.forEach((g => {
                    graphic.add(g);
                }));
            } else result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
            return context.camera = null, pickParams.in3dInterceptor = !1, context.restore(), 
            result;
        }
        return context.restore(), null;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
};

Canvas3DPickItemInterceptor = __decorate([ (0, inversify_lite_1.injectable)() ], Canvas3DPickItemInterceptor), 
exports.Canvas3DPickItemInterceptor = Canvas3DPickItemInterceptor;
//# sourceMappingURL=pick-interceptor.js.map
