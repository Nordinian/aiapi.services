import { max, isArray } from "@visactor/vutils";

import { getContextFont, textDrawOffsetX, textLayoutOffsetY } from "../common/text";

import { CanvasTextLayout } from "../core/contributions/textMeasure/layout";

import { application } from "../application";

import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { getTheme } from "./theme";

import { calculateLineHeight, parsePadding } from "../common/utils";

import { TEXT_NUMBER_TYPE } from "./constants";

import { TextDirection, verticalLayout } from "./tools";

const TEXT_UPDATE_TAG_KEY = [ "text", "maxLineWidth", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Text extends Graphic {
    get font() {
        const textTheme = getTheme(this).text;
        return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
    }
    get clipedText() {
        var _a;
        const attribute = this.attribute, textTheme = getTheme(this).text;
        if (!this.isSimplify()) return;
        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;
        return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
    }
    get clipedWidth() {
        if (this.isSimplify()) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
    }
    get cliped() {
        const textTheme = getTheme(this).text, attribute = this.attribute;
        if (this.isMultiLine) return;
        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;
        return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map((item => item.text)).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString());
    }
    get multilineLayout() {
        if (this.isMultiLine) return this.tryUpdateAABBBounds(), this.cache.layoutData;
    }
    isSimplify() {
        return !this.isMultiLine && "vertical" !== this.attribute.direction;
    }
    get isMultiLine() {
        return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
    }
    constructor(params = {
        text: "",
        fontSize: 16
    }) {
        super(params), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {text: text} = this.attribute;
        return isArray(text) ? !text.every((t => null == t || "" === t)) : null != text && "" !== text;
    }
    doUpdateAABBBounds() {
        const textTheme = getTheme(this).text;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this), {boundsPadding: boundsPadding = textTheme.boundsPadding} = this.attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    updateWrapAABBBounds(text) {
        var _a, _b, _c, _d;
        const textTheme = getTheme(this).text, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, wordBreak: wordBreak = textTheme.wordBreak, fontWeight: fontWeight = textTheme.fontWeight, ignoreBuf: ignoreBuf = textTheme.ignoreBuf, suffixPosition: suffixPosition = textTheme.suffixPosition, heightLimit: heightLimit = 0, lineClamp: lineClamp} = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
        }, textMeasure), lines = isArray(text) ? text.map((l => l.toString())) : [ text.toString() ], linesLayout = [], bboxWH = [ 0, 0 ];
        let lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), 
        lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
            if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
                const str = lines[i];
                let needCut = !0;
                if (i === lineCountLimit - 1) {
                    const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width
                    });
                    break;
                }
                const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
                if ("" !== str && "" === clip.str) {
                    if (ellipsis) {
                        const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                        clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
                    } else clip.str = "", clip.width = 0;
                    needCut = !1;
                }
                if (linesLayout.push({
                    str: clip.str,
                    width: clip.width
                }), clip.str.length === str.length) ; else if (needCut) {
                    const newStr = str.substring(clip.str.length);
                    lines.splice(i + 1, 0, newStr);
                }
            }
            let maxWidth = 0;
            linesLayout.forEach((layout => {
                maxWidth = Math.max(maxWidth, layout.width);
            })), bboxWH[0] = maxWidth;
        } else {
            let width, text, lineWidth = 0;
            for (let i = 0, len = lines.length; i < len; i++) {
                if (i === lineCountLimit - 1) {
                    const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width
                    }), lineWidth = Math.max(lineWidth, clip.width);
                    break;
                }
                text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, "break-word" === wordBreak), 
                lineWidth = Math.max(lineWidth, width), linesLayout.push({
                    str: text,
                    width: width
                });
            }
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + buf);
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    updateSingallineAABBBounds(text) {
        const textTheme = getTheme(this).text, {direction: direction = textTheme.direction} = this.attribute;
        return "horizontal" === direction ? this.updateHorizontalSinglelineAABBBounds(text) : this.updateVerticalSinglelineAABBBounds(text);
    }
    updateMultilineAABBBounds(text) {
        const textTheme = getTheme(this).text, {direction: direction = textTheme.direction} = this.attribute;
        return "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
    }
    updateHorizontalSinglelineAABBBounds(text) {
        var _a, _b;
        const textTheme = getTheme(this).text, {wrap: wrap = textTheme.wrap} = this.attribute;
        if (wrap) return this.updateWrapAABBBounds([ text ]);
        const textMeasure = application.graphicUtil.textMeasure;
        let width, str;
        const attribute = this.attribute, {maxLineWidth: maxLineWidth = textTheme.maxLineWidth, ellipsis: ellipsis = textTheme.ellipsis, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontFamily: fontFamily = textTheme.fontFamily, fontSize: fontSize = textTheme.fontSize, fontWeight: fontWeight = textTheme.fontWeight, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, ignoreBuf: ignoreBuf = textTheme.ignoreBuf, whiteSpace: whiteSpace = textTheme.whiteSpace, suffixPosition: suffixPosition = textTheme.suffixPosition} = attribute;
        if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text);
        const buf = ignoreBuf ? 0 : Math.max(2, .075 * fontSize), textFontSize = attribute.fontSize || textTheme.fontSize, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, textFontSize)) && void 0 !== _a ? _a : textFontSize + buf;
        if (!this.shouldUpdateShape() && this.cache) {
            width = null !== (_b = this.cache.clipedWidth) && void 0 !== _b ? _b : 0;
            const dx = textDrawOffsetX(textAlign, width), dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
            return this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), 
            this._AABBBounds;
        }
        if (Number.isFinite(maxLineWidth)) {
            if (ellipsis) {
                const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffix(text.toString(), {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, strEllipsis, !1, suffixPosition);
                str = data.str, width = data.width;
            } else {
                const data = textMeasure.clipText(text.toString(), {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, !1);
                str = data.str, width = data.width;
            }
            this.cache.clipedText = str, this.cache.clipedWidth = width;
        } else width = textMeasure.measureTextWidth(text.toString(), {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
        }), this.cache.clipedText = text.toString(), this.cache.clipedWidth = width;
        this.clearUpdateShapeTag();
        const dx = textDrawOffsetX(textAlign, width);
        let lh = lineHeight;
        application.global && application.global.isSafari() && (lh += .2 * fontSize);
        const dy = textLayoutOffsetY(textBaseline, lh, fontSize, buf);
        return this._AABBBounds.set(dx, dy, dx + width, dy + lh), stroke && this._AABBBounds.expand(lineWidth / 2), 
        this._AABBBounds;
    }
    getBaselineMapAlign() {
        return Text.baselineMapAlign;
    }
    getAlignMapBaseline() {
        return Text.alignMapBaseline;
    }
    updateVerticalSinglelineAABBBounds(text) {
        var _a, _b, _c;
        const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
        let width;
        const attribute = this.attribute, {ignoreBuf: ignoreBuf = textTheme.ignoreBuf} = attribute, buf = ignoreBuf ? 0 : 2, {maxLineWidth: maxLineWidth = textTheme.maxLineWidth, ellipsis: ellipsis = textTheme.ellipsis, fontSize: fontSize = textTheme.fontSize, fontWeight: fontWeight = textTheme.fontWeight, fontFamily: fontFamily = textTheme.fontFamily, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, verticalMode: verticalMode = textTheme.verticalMode, suffixPosition: suffixPosition = textTheme.suffixPosition} = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
        let {textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline} = attribute;
        if (!verticalMode) {
            const t = textAlign;
            textAlign = null !== (_b = Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", 
            textBaseline = null !== (_c = Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
        }
        if (!this.shouldUpdateShape() && this.cache) {
            width = this.cache.clipedWidth;
            const dx = textDrawOffsetX(textAlign, width), dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
            return this._AABBBounds.set(dy, dx, dy + lineHeight, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), 
            this._AABBBounds;
        }
        let verticalList = [ verticalLayout(text.toString()) ];
        if (Number.isFinite(maxLineWidth)) {
            if (ellipsis) {
                const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalList[0], {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, strEllipsis, !1, suffixPosition);
                verticalList = [ data.verticalList ], width = data.width;
            } else {
                const data = textMeasure.clipTextVertical(verticalList[0], {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, !1);
                verticalList = [ data.verticalList ], width = data.width;
            }
            this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
        } else width = 0, verticalList[0].forEach((t => {
            const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
                fontSize: fontSize,
                fontWeight: fontWeight,
                fontFamily: fontFamily
            });
            width += w, t.width = w;
        })), this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
        this.clearUpdateShapeTag();
        const dx = textDrawOffsetX(textAlign, width), dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
        return this._AABBBounds.set(dy, dx, dy + lineHeight, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), 
        this._AABBBounds;
    }
    updateHorizontalMultilineAABBBounds(text) {
        var _a, _b;
        const textTheme = getTheme(this).text, {wrap: wrap = textTheme.wrap} = this.attribute;
        if (wrap) return this.updateWrapAABBBounds(text);
        const attribute = this.attribute, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, fontWeight: fontWeight = textTheme.fontWeight, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, whiteSpace: whiteSpace = textTheme.whiteSpace, suffixPosition: suffixPosition = textTheme.suffixPosition} = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : attribute.fontSize || textTheme.fontSize;
        if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text);
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure, layoutData = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
        }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, maxLineWidth, suffixPosition), {bbox: bbox} = layoutData;
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    updateVerticalMultilineAABBBounds(text) {
        var _a, _b, _c;
        const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
        let width;
        const attribute = this.attribute, {ignoreBuf: ignoreBuf = textTheme.ignoreBuf} = attribute, buf = ignoreBuf ? 0 : 2, {maxLineWidth: maxLineWidth = textTheme.maxLineWidth, ellipsis: ellipsis = textTheme.ellipsis, fontFamily: fontFamily = textTheme.fontFamily, fontSize: fontSize = textTheme.fontSize, fontWeight: fontWeight = textTheme.fontWeight, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, verticalMode: verticalMode = textTheme.verticalMode, suffixPosition: suffixPosition = textTheme.suffixPosition} = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
        let {textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline} = attribute;
        if (!verticalMode) {
            const t = textAlign;
            textAlign = null !== (_b = Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", 
            textBaseline = null !== (_c = Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
        }
        if (width = 0, !this.shouldUpdateShape() && this.cache) {
            this.cache.verticalList.forEach((item => {
                const w = item.reduce(((a, b) => a + b.width), 0);
                width = max(w, width);
            }));
            const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
            return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), 
            this._AABBBounds;
        }
        const verticalLists = text.map((str => verticalLayout(str.toString())));
        verticalLists.forEach(((verticalData, i) => {
            if (Number.isFinite(maxLineWidth)) if (ellipsis) {
                const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalData, {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, strEllipsis, !1, suffixPosition);
                verticalLists[i] = data.verticalList, width = data.width;
            } else {
                const data = textMeasure.clipTextVertical(verticalData, {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                }, maxLineWidth, !1);
                verticalLists[i] = data.verticalList, width = data.width;
            } else width = 0, verticalData.forEach((t => {
                const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
                    fontSize: fontSize,
                    fontWeight: fontWeight,
                    fontFamily: fontFamily
                });
                width += w, t.width = w;
            }));
        })), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach((item => {
            const w = item.reduce(((a, b) => a + b.width), 0);
            width = max(w, width);
        }));
        const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
        return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), 
        this._AABBBounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return getTheme(this).text[name];
    }
    needUpdateTags(keys, k = TEXT_UPDATE_TAG_KEY) {
        return super.needUpdateTags(keys, k);
    }
    needUpdateTag(key, k = TEXT_UPDATE_TAG_KEY) {
        return super.needUpdateTag(key, k);
    }
    clone() {
        return new Text(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Text.NOWORK_ANIMATE_ATTR;
    }
}

Text.NOWORK_ANIMATE_ATTR = Object.assign({
    ellipsis: 1,
    wordBreak: 1,
    direction: 1,
    textAlign: 1,
    textBaseline: 1,
    fontFamily: 1,
    fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
    top: "left",
    bottom: "right",
    middle: "center"
}, Text.alignMapBaseline = {
    left: "top",
    right: "bottom",
    center: "middle"
};

export function createText(attributes) {
    return new Text(attributes);
}
//# sourceMappingURL=text.js.map
