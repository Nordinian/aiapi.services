{"version":3,"sources":["../src/marker/type.ts"],"names":[],"mappings":"AAYA,MAAM,CAAN,IAAY,sBAUX;AAVD,WAAY,sBAAsB;IAChC,yCAAe,CAAA;IACf,2CAAiB,CAAA;IACjB,qCAAW,CAAA;IACX,2DAAiC,CAAA;IACjC,iEAAuC,CAAA;IACvC,6DAAmC,CAAA;IACnC,mEAAyC,CAAA;IACzC,uDAA6B,CAAA;IAC7B,6DAAmC,CAAA;AACrC,CAAC,EAVW,sBAAsB,KAAtB,sBAAsB,QAUjC;AAED,MAAM,CAAN,IAAY,sBAUX;AAVD,WAAY,sBAAsB;IAChC,uCAAa,CAAA;IACb,yCAAe,CAAA;IACf,qCAAW,CAAA;IACX,2CAAiB,CAAA;IACjB,2CAAiB,CAAA;IACjB,mDAAyB,CAAA;IACzB,qDAA2B,CAAA;IAC3B,iDAAuB,CAAA;IACvB,uDAA6B,CAAA;AAC/B,CAAC,EAVW,sBAAsB,KAAtB,sBAAsB,QAUjC;AAED,MAAM,CAAN,IAAY,sBAOX;AAPD,WAAY,sBAAsB;IAChC,qCAAW,CAAA;IACX,2CAAiB,CAAA;IACjB,2CAAiB,CAAA;IACjB,iDAAuB,CAAA;IACvB,uDAA6B,CAAA;IAC7B,uDAA6B,CAAA;AAC/B,CAAC,EAPW,sBAAsB,KAAtB,sBAAsB,QAOjC","file":"type.js","sourcesContent":["import type {\n  IGroup,\n  IGroupGraphicAttribute,\n  IImageGraphicAttribute,\n  IPolygonAttribute,\n  IRichTextGraphicAttribute,\n  ISymbolGraphicAttribute\n} from '@visactor/vrender-core';\nimport type { SegmentAttributes, SymbolAttributes } from '../segment';\nimport type { TagAttributes } from '../tag';\nimport type { Point } from '../core/type';\n\nexport enum IMarkLineLabelPosition {\n  start = 'start',\n  middle = 'middle',\n  end = 'end',\n  insideStartTop = 'insideStartTop',\n  insideStartBottom = 'insideStartBottom',\n  insideMiddleTop = 'insideMiddleTop',\n  insideMiddleBottom = 'insideMiddleBottom',\n  insideEndTop = 'insideEndTop',\n  insideEndBottom = 'insideEndBottom'\n}\n\nexport enum IMarkAreaLabelPosition {\n  left = 'left',\n  right = 'right',\n  top = 'top',\n  bottom = 'bottom',\n  middle = 'middle',\n  insideLeft = 'insideLeft',\n  insideRight = 'insideRight',\n  insideTop = 'insideTop',\n  insideBottom = 'insideBottom'\n}\n\nexport enum IMarkPointItemPosition {\n  top = 'top',\n  bottom = 'bottom',\n  middle = 'middle',\n  insideTop = 'insideTop',\n  insideBottom = 'insideBottom',\n  insideMiddle = 'insideMiddle'\n}\n\nexport type IMarkBackgroundAttributes = {\n  /**\n   * 是否绘制背景层\n   */\n  visible: boolean;\n  /**\n   * TODO: 根据文字宽度进行背景 panel size自适应\n   */\n  autoHeight?: boolean;\n  /**\n   * TODO: 根据文高度度进行背景 panel size自适应\n   */\n  autoWidth?: boolean;\n} & Partial<SymbolAttributes>;\n\nexport type IMarkLabel = Omit<TagAttributes, 'x' | 'y' | 'panel'> & {\n  /**\n   * 标签的背景面板配置\n   */\n  panel?: IMarkBackgroundAttributes;\n};\n\nexport type IMarkRef = {\n  /**\n   * 自动旋转，沿着线的方向，默认 true\n   */\n  autoRotate?: boolean;\n  /**\n   * label 相对line平行方向上的偏移\n   */\n  refX?: number;\n  /**\n   * label 相对line正交方向上的偏移\n   */\n  refY?: number;\n  /**\n   * label 相对默认角度的偏移 （label跟随line的角度做自动旋转时，默认按照line的平行向量作为初始角度）\n   */\n  refAngle?: number;\n};\n\nexport type MarkerAttrs = IGroupGraphicAttribute & {\n  type?: 'line' | 'area' | 'point';\n  /**\n   * 是否支持交互\n   * @default false\n   */\n  interactive?: boolean;\n  /**\n   * 是否显示marker组件\n   * @default true\n   */\n  visible?: boolean;\n  /**\n   * 是否将组件在绘制区域内进行剪切\n   * @default true\n   */\n  clipInRange?: boolean;\n  /**\n   * 组件绘制范围配置\n   */\n  limitRect?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n};\n\nexport type MarkLineAttrs = MarkerAttrs &\n  SegmentAttributes & {\n    type?: 'line';\n    /**\n     * 构成line的点: 如果是两个点，则为直线；多个点则为曲线\n     */\n    points: Point[] | Point[][];\n\n    /**\n     * 标签\n     */\n    label?: {\n      /**\n       * label 相对line的位置\n       */\n      position?: keyof typeof IMarkLineLabelPosition;\n      /**\n       * 当 mark 配置了 limitRect 之后，label 是否自动调整位置\n       * @default false\n       */\n      confine?: boolean;\n    } & IMarkRef &\n      IMarkLabel;\n  };\n\nexport type MarkAreaAttrs = MarkerAttrs & {\n  type?: 'area';\n  /**\n   * 构成area的点\n   */\n  points: Point[];\n  /**\n   * 标签\n   */\n  label?: {\n    position?: keyof typeof IMarkAreaLabelPosition;\n    /**\n     * 当 mark 配置了 limitRect 之后，label 是否自动调整位置\n     * @default false\n     */\n    confine?: boolean;\n  } & IMarkLabel;\n  /**\n   * area的样式\n   */\n  areaStyle?: IPolygonAttribute;\n};\n\nexport type IItemContent = IMarkRef & {\n  /**\n   * 标注类型\n   * Tips: 保留'richText'与之前的定义做兼容\n   */\n  type?: 'symbol' | 'text' | 'image' | 'richText' | 'custom';\n  position?: keyof typeof IMarkPointItemPosition;\n  /**\n   * x 方向偏移量\n   */\n  offsetX?: number;\n  /**\n   * y 方向偏移量\n   */\n  offsetY?: number;\n  /**\n   * type为symbol时, symbol的样式\n   */\n  symbolStyle?: ISymbolGraphicAttribute;\n  /**\n   * type为image时, image的样式\n   */\n  imageStyle?: IImageGraphicAttribute;\n  /**\n   * type为text时, text的配置\n   * 'text'类型的ItemContent新增三种子类型：'text','rich','html'。配置在textStyle.type上，继承自TagAttributes。\n   */\n  textStyle?: IMarkLabel;\n  /**\n   * type为rich text时, rich text的样式\n   */\n  richTextStyle?: IRichTextGraphicAttribute;\n  /**\n   * type为custom时，允许以callback的方式传入需要render的item\n   */\n  renderCustomCallback?: () => IGroup;\n  /**\n   * 当 mark 配置了 limitRect 之后，label 是否自动调整位置\n   * @default false\n   */\n  confine?: boolean;\n};\n\nexport type IItemLine = {\n  /** TODO：'type-opo' */\n  type?: 'type-s' | 'type-do' | 'type-po' | 'type-op';\n  visible?: boolean;\n  /**\n   * 垂直于引导线的装饰线，参考案例: https://observablehq.com/@mikelotis/edmonton-population-history-line-chart\n   */\n  decorativeLine?: {\n    visible?: boolean;\n    length?: number;\n  };\n} & Omit<SegmentAttributes, 'points'>;\n\nexport type MarkPointAttrs = Omit<MarkerAttrs, 'labelStyle'> & {\n  /**\n   * markPoint的位置（也是path的起点）\n   */\n  position: Point;\n  /**\n   * 标注引导线\n   */\n  itemLine?: IItemLine;\n\n  /**\n   * 标注内容\n   */\n  itemContent?: IItemContent;\n};\n"]}