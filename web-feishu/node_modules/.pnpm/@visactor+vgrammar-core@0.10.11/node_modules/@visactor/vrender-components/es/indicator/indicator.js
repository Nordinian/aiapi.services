import { merge, isValid, array, isValidNumber, get } from "@visactor/vutils";

import { AbstractComponent } from "../core/base";

import { measureTextSize } from "../util";

import { DEFAULT_INDICATOR_THEME } from "./config";

import { DEFAULT_HTML_TEXT_SPEC } from "../constant";

import { loadIndicatorComponent } from "./register";

loadIndicatorComponent();

export class Indicator extends AbstractComponent {
    constructor() {
        super(...arguments), this.name = "indicator";
    }
    render() {
        var _a, _b, _c;
        const {visible: visible, title: title = {}, content: content, size: size, limitRatio: limitRatio = 1 / 0} = this.attribute, limit = Math.min(size.width, size.height) * limitRatio, group = this.createOrUpdateChild("indicator-container", {
            x: 0,
            y: 0,
            zIndex: 1
        }, "group");
        if (!0 !== visible) return void (group && group.hideAll());
        if (isValid(title)) if (!1 !== title.visible) {
            const titleStyle = merge({}, get(DEFAULT_INDICATOR_THEME, "title.style"), title.style);
            "rich" === titleStyle.type ? this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({
                textConfig: titleStyle.text
            }, titleStyle), {
                visible: title.visible,
                x: 0,
                y: 0,
                width: null !== (_a = titleStyle.width) && void 0 !== _a ? _a : 0,
                height: null !== (_b = titleStyle.height) && void 0 !== _b ? _b : 0
            }), "richtext") : "html" === titleStyle.type ? this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({
                textConfig: [],
                html: Object.assign(Object.assign({
                    dom: titleStyle.text
                }, DEFAULT_HTML_TEXT_SPEC), titleStyle)
            }, titleStyle), {
                visible: title.visible,
                x: 0,
                y: 0
            }), "richtext") : this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({}, titleStyle), {
                lineHeight: isValid(titleStyle.lineHeight) ? titleStyle.lineHeight : titleStyle.fontSize,
                visible: title.visible,
                x: 0,
                y: 0
            }), "text"), title.autoFit && isValidNumber(limit) && this._setLocalAutoFit(limit, this._title, title), 
            title.autoLimit && isValidNumber(limitRatio) && this._title.setAttribute("maxLineWidth", limit);
        } else {
            const titleNode = group.find((node => "indicator-title" === node.name), !1);
            titleNode && group.removeChild(titleNode), this._title = void 0;
        }
        if (isValid(content)) {
            const contents = array(content), contentComponents = [];
            contents.forEach(((contentItem, i) => {
                var _a, _b;
                if (!1 !== contentItem.visible) {
                    const contentStyle = merge({}, get(DEFAULT_INDICATOR_THEME, "content.style"), contentItem.style);
                    let contentComponent;
                    contentComponent = "rich" === contentStyle.type ? group.createOrUpdateChild("indicator-content-" + i, Object.assign(Object.assign({
                        textConfig: contentStyle.text
                    }, contentStyle), {
                        visible: title.visible,
                        x: 0,
                        y: 0,
                        width: null !== (_a = contentStyle.width) && void 0 !== _a ? _a : 0,
                        height: null !== (_b = contentStyle.height) && void 0 !== _b ? _b : 0
                    }), "richtext") : "html" === contentStyle.type ? group.createOrUpdateChild("indicator-content-" + i, Object.assign(Object.assign({
                        textConfig: [],
                        html: Object.assign(Object.assign({
                            dom: contentStyle.text
                        }, DEFAULT_HTML_TEXT_SPEC), contentStyle)
                    }, contentStyle), {
                        visible: title.visible,
                        x: 0,
                        y: 0
                    }), "richtext") : group.createOrUpdateChild("indicator-content-" + i, Object.assign(Object.assign({}, contentStyle), {
                        lineHeight: isValid(contentStyle.lineHeight) ? contentStyle.lineHeight : contentStyle.fontSize,
                        visible: contentItem.visible,
                        x: 0,
                        y: 0
                    }), "text"), contentItem.autoFit && isValidNumber(limit) && this._setLocalAutoFit(limit, contentComponent, contentItem), 
                    contentItem.autoLimit && isValidNumber(limitRatio) && contentComponent.setAttribute("maxLineWidth", limit), 
                    contentComponents.push(contentComponent);
                } else {
                    const contentItemNode = group.find((node => node.name === "indicator-content-" + i), !1);
                    contentItemNode && group.removeChild(contentItemNode);
                }
            })), this._content = contentComponents;
        }
        this._setGlobalAutoFit(limit), this._setYPosition();
        const totalHeight = null !== (_c = null == group ? void 0 : group.AABBBounds.height()) && void 0 !== _c ? _c : 0;
        group.setAttribute("y", size.height / 2 - totalHeight / 2), group.setAttribute("x", size.width / 2);
    }
    _setLocalAutoFit(limit, indicatorItem, indicatorItemSpec) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ("default" !== (null !== (_a = indicatorItemSpec.fitStrategy) && void 0 !== _a ? _a : "default")) return;
        const originWidth = measureTextSize(null !== (_c = null === (_b = indicatorItemSpec.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "", null !== (_d = indicatorItemSpec.style) && void 0 !== _d ? _d : {}, null === (_e = this.stage) || void 0 === _e ? void 0 : _e.getTheme().text.fontFamily).width;
        if (originWidth > 0) {
            const ratio = limit * (null !== (_f = indicatorItemSpec.fitPercent) && void 0 !== _f ? _f : .5) / originWidth, fontSize = Math.floor((null !== (_h = null === (_g = indicatorItemSpec.style) || void 0 === _g ? void 0 : _g.fontSize) && void 0 !== _h ? _h : 20) * ratio);
            indicatorItem.setAttribute("fontSize", fontSize), indicatorItem.setAttribute("lineHeight", isValid(indicatorItemSpec.style.lineHeight) ? indicatorItemSpec.style.lineHeight : fontSize);
        }
    }
    _setGlobalAutoFit(limit) {
        var _a, _b, _c, _d, _e, _f, _g;
        const r = limit / 2, autoFitTexts = [];
        let otherHeight = 0;
        const titleSpec = null !== (_a = this.attribute.title) && void 0 !== _a ? _a : {};
        titleSpec.autoFit && "inscribed" === titleSpec.fitStrategy ? (this._title.setAttribute("fontSize", 12), 
        autoFitTexts.push({
            text: this._title,
            spec: null !== (_b = this.attribute.title) && void 0 !== _b ? _b : {}
        })) : otherHeight += null !== (_f = null === (_e = null === (_d = null === (_c = this._title) || void 0 === _c ? void 0 : _c.AABBBounds) || void 0 === _d ? void 0 : _d.height) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : 0;
        const titleSpace = null !== (_g = titleSpec.space) && void 0 !== _g ? _g : 0;
        if (otherHeight += titleSpace, array(this.attribute.content).filter((contentSpec => !1 !== contentSpec.visible)).forEach(((contentSpec, index) => {
            var _a, _b, _c, _d;
            const contentText = this._content[index];
            contentSpec.autoFit && "inscribed" === contentSpec.fitStrategy ? (contentText.setAttribute("fontSize", 12), 
            autoFitTexts.push({
                text: contentText,
                spec: contentSpec
            })) : otherHeight += null !== (_c = null === (_b = null === (_a = null == contentText ? void 0 : contentText.AABBBounds) || void 0 === _a ? void 0 : _a.height) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : 0;
            const contentSpace = null !== (_d = contentSpec.space) && void 0 !== _d ? _d : 0;
            otherHeight += contentSpace;
        })), autoFitTexts.length <= 0) return;
        const ra = 12 / autoFitTexts.reduce(((width, textItem) => Math.max(width, textItem.text.AABBBounds.width())), 0) * autoFitTexts.length, h = otherHeight / 2, a = ra ** 2 + 1, b = 2 * h * ra, c = h ** 2 - r ** 2, y = 2 * (ra * ((-b + Math.sqrt(b ** 2 - 4 * a * c)) / (2 * a)) + h), lineHeight = (y - otherHeight) / autoFitTexts.length;
        isValidNumber(y) && autoFitTexts.forEach((textItem => {
            var _a;
            const specLineHeight = null === (_a = textItem.spec.style) || void 0 === _a ? void 0 : _a.lineHeight;
            textItem.text.setAttribute("fontSize", lineHeight), textItem.text.setAttribute("lineHeight", isValid(specLineHeight) ? specLineHeight : lineHeight);
        }));
    }
    _setYPosition() {
        var _a, _b, _c, _d, _e, _f;
        let lastContentHeight = 0;
        const titleHeight = null !== (_d = null === (_c = null === (_b = null === (_a = this._title) || void 0 === _a ? void 0 : _a.AABBBounds) || void 0 === _b ? void 0 : _b.height) || void 0 === _c ? void 0 : _c.call(_b)) && void 0 !== _d ? _d : 0, titleSpace = null !== (_f = null === (_e = this.attribute.title) || void 0 === _e ? void 0 : _e.space) && void 0 !== _f ? _f : 0;
        array(this.attribute.content).filter((contentSpec => !1 !== contentSpec.visible)).forEach(((contentSpec, index) => {
            var _a;
            const contentText = this._content[index];
            contentText.setAttribute("y", titleHeight + titleSpace + lastContentHeight);
            const contentSpace = null !== (_a = contentSpec.space) && void 0 !== _a ? _a : 0;
            lastContentHeight += contentText.AABBBounds.height() + contentSpace;
        }));
    }
}
//# sourceMappingURL=indicator.js.map