import { graphicCreator, vglobal } from "@visactor/vrender-core";

import { cloneDeep, debounce, merge, polygonContainPoint, throttle } from "@visactor/vutils";

import { AbstractComponent } from "../core/base";

import { IOperateType } from "./type";

import { DEFAULT_BRUSH_ATTRIBUTES, DEFAULT_SIZE_THRESHOLD } from "./config";

import { loadBrushComponent } from "./register";

const delayMap = {
    debounce: debounce,
    throttle: throttle
};

loadBrushComponent();

export class Brush extends AbstractComponent {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Brush.defaultAttributes, attributes)), 
        this.name = "brush", this._activeDrawState = !1, this._cacheDrawPoints = [], this._isDrawedBeforeEnd = !1, 
        this._activeMoveState = !1, this._operatingMaskMoveDx = 0, this._operatingMaskMoveDy = 0, 
        this._operatingMaskMoveRangeX = [ -1 / 0, 1 / 0 ], this._operatingMaskMoveRangeY = [ -1 / 0, 1 / 0 ], 
        this._brushMaskAABBBoundsDict = {}, this._onBrushStart = e => {
            var _a;
            if (this._outOfInteractiveRange(e)) return;
            e.stopPropagation();
            const brushMoved = null === (_a = this.attribute.brushMoved) || void 0 === _a || _a;
            this._activeMoveState = brushMoved && this._isPosInBrushMask(e), this._activeDrawState = !this._activeMoveState, 
            this._activeDrawState && this._initDraw(e), this._activeMoveState && this._initMove(e);
        }, this._onBrushing = e => {
            this._outOfInteractiveRange(e) || ((this._activeDrawState || this._activeMoveState) && e.stopPropagation(), 
            this._activeDrawState && this._drawing(e), this._activeMoveState && this._moving(e));
        }, this._onBrushEnd = e => {
            e.preventDefault();
            const {removeOnClick: removeOnClick = !0} = this.attribute;
            this._activeDrawState && !this._isDrawedBeforeEnd && removeOnClick ? (this._container.incrementalClearChild(), 
            this._brushMaskAABBBoundsDict = {}, this._dispatchEvent(IOperateType.brushClear, {
                operateMask: this._operatingMask,
                operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
                event: e
            })) : (this._activeDrawState && this._dispatchEvent(IOperateType.drawEnd, {
                operateMask: this._operatingMask,
                operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
                event: e
            }), this._activeMoveState && this._dispatchEvent(IOperateType.moveEnd, {
                operateMask: this._operatingMask,
                operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
                event: e
            })), this._activeDrawState = !1, this._activeMoveState = !1, this._isDrawedBeforeEnd = !1, 
            this._operatingMask && this._operatingMask.setAttribute("pickable", !1);
        };
    }
    _bindBrushEvents() {
        if (this.attribute.disableTriggerEvent) return;
        const {delayType: delayType = "throttle", delayTime: delayTime = 0, trigger: trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger: updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger: endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger: resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger} = this.attribute;
        this.stage.addEventListener(trigger, this._onBrushStart), this.stage.addEventListener(updateTrigger, delayMap[delayType](this._onBrushing, delayTime)), 
        this.stage.addEventListener(endTrigger, this._onBrushEnd), this.stage.addEventListener(resetTrigger, this._onBrushEnd);
    }
    _isPosInBrushMask(e) {
        const pos = this.eventPosToStagePos(e), brushMasks = this._container.getChildren();
        for (let i = 0; i < brushMasks.length; i++) {
            const {points: points = [], dx: dx = 0, dy: dy = 0} = brushMasks[i].attribute, pointsConsiderOffset = points.map((point => ({
                x: point.x + dx,
                y: point.y + dy
            })));
            if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y)) return this._operatingMask = brushMasks[i], 
            !0;
        }
        return !1;
    }
    _initDraw(e) {
        const {brushMode: brushMode} = this.attribute, pos = this.eventPosToStagePos(e);
        this._cacheDrawPoints = [ pos ], this._isDrawedBeforeEnd = !1, "single" === brushMode && (this._brushMaskAABBBoundsDict = {}, 
        this._container.incrementalClearChild()), this._addBrushMask(), this._dispatchEvent(IOperateType.drawStart, {
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
            event: e
        });
    }
    _initMove(e) {
        var _a, _b;
        this._cacheMovePoint = this.eventPosToStagePos(e), this._operatingMaskMoveDx = null !== (_a = this._operatingMask.attribute.dx) && void 0 !== _a ? _a : 0, 
        this._operatingMaskMoveDy = null !== (_b = this._operatingMask.attribute.dy) && void 0 !== _b ? _b : 0;
        const {interactiveRange: interactiveRange} = this.attribute, {minY: minY = -1 / 0, maxY: maxY = 1 / 0, minX: minX = -1 / 0, maxX: maxX = 1 / 0} = interactiveRange, {x1: x1, x2: x2, y1: y1, y2: y2} = this._operatingMask.globalAABBBounds, minMoveStepX = minX - x1, maxMoveStepX = maxX - x2, minMoveStepY = minY - y1, maxMoveStepY = maxY - y2;
        this._operatingMaskMoveRangeX = [ minMoveStepX, maxMoveStepX ], this._operatingMaskMoveRangeY = [ minMoveStepY, maxMoveStepY ], 
        this._operatingMask.setAttribute("pickable", !0), this._dispatchEvent(IOperateType.moveStart, {
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
            event: e
        });
    }
    _drawing(e) {
        var _a, _b;
        const pos = this.eventPosToStagePos(e), {x1: x1 = 0, x2: x2 = 0, y1: y1 = 0, y2: y2 = 0} = null === (_a = this._operatingMask) || void 0 === _a ? void 0 : _a._AABBBounds, {sizeThreshold: sizeThreshold = DEFAULT_SIZE_THRESHOLD, brushType: brushType} = this.attribute, cacheLength = this._cacheDrawPoints.length;
        if (this._isDrawedBeforeEnd = !!(Math.abs(x2 - x1) > sizeThreshold || Math.abs(y1 - y2) > sizeThreshold), 
        cacheLength > 0) {
            const lastPos = null !== (_b = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) && void 0 !== _b ? _b : {};
            if (pos.x === lastPos.x && pos.y === lastPos.y) return;
        }
        "polygon" === brushType || cacheLength <= 1 ? this._cacheDrawPoints.push(pos) : this._cacheDrawPoints[cacheLength - 1] = pos;
        const maskPoints = this._computeMaskPoints();
        this._operatingMask.setAttribute("points", maskPoints), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, 
        this._dispatchEvent(IOperateType.drawing, {
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
            event: e
        });
    }
    _moving(e) {
        const startPos = this._cacheMovePoint, pos = this.eventPosToStagePos(e);
        if (pos.x === (null == startPos ? void 0 : startPos.x) && pos.y === (null == startPos ? void 0 : startPos.y)) return;
        const moveStepX = pos.x - startPos.x, moveStepY = pos.y - startPos.y, moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) + this._operatingMaskMoveDx, moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) + this._operatingMaskMoveDy;
        this._operatingMask.setAttributes({
            dx: moveX,
            dy: moveY
        }), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, 
        this._dispatchEvent(IOperateType.moving, {
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
            event: e
        });
    }
    _computeMaskPoints() {
        const {brushType: brushType, xRange: xRange = [ 0, 0 ], yRange: yRange = [ 0, 0 ]} = this.attribute;
        let maskPoints = [];
        const startPoint = this._cacheDrawPoints[0], endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
        return maskPoints = "rect" === brushType ? [ startPoint, {
            x: endPoint.x,
            y: startPoint.y
        }, endPoint, {
            x: startPoint.x,
            y: endPoint.y
        } ] : "x" === brushType ? [ {
            x: startPoint.x,
            y: yRange[0]
        }, {
            x: endPoint.x,
            y: yRange[0]
        }, {
            x: endPoint.x,
            y: yRange[1]
        }, {
            x: startPoint.x,
            y: yRange[1]
        } ] : "y" === brushType ? [ {
            x: xRange[0],
            y: startPoint.y
        }, {
            x: xRange[0],
            y: endPoint.y
        }, {
            x: xRange[1],
            y: endPoint.y
        }, {
            x: xRange[1],
            y: startPoint.y
        } ] : cloneDeep(this._cacheDrawPoints), maskPoints;
    }
    _addBrushMask() {
        var _a;
        const {brushStyle: brushStyle, hasMask: hasMask} = this.attribute, brushMask = graphicCreator.polygon(Object.assign(Object.assign({
            points: cloneDeep(this._cacheDrawPoints),
            cursor: "move",
            pickable: !1
        }, brushStyle), {
            opacity: hasMask ? null !== (_a = brushStyle.opacity) && void 0 !== _a ? _a : 1 : 0
        }));
        brushMask.name = `brush-${Date.now()}`, this._operatingMask = brushMask, this._container.add(brushMask), 
        this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
    }
    _outOfInteractiveRange(e) {
        const {interactiveRange: interactiveRange} = this.attribute, {minY: minY = -1 / 0, maxY: maxY = 1 / 0, minX: minX = -1 / 0, maxX: maxX = 1 / 0} = interactiveRange, pos = this.eventPosToStagePos(e);
        return pos.x > maxX || pos.x < minX || pos.y > maxY || pos.y < minY;
    }
    eventPosToStagePos(e) {
        var _a, _b;
        const {x: x, y: y} = vglobal.mapToCanvasPoint(e);
        return {
            x: x - ((null === (_a = this.stage) || void 0 === _a ? void 0 : _a.x) || 0),
            y: y - ((null === (_b = this.stage) || void 0 === _b ? void 0 : _b.y) || 0)
        };
    }
    render() {
        this._bindBrushEvents();
        const group = this.createOrUpdateChild("brush-container", {}, "group");
        this._container = group;
    }
    releaseBrushEvents() {
        const {delayType: delayType = "throttle", delayTime: delayTime = 0, trigger: trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger: updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger: endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger: resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger} = this.attribute;
        this.stage.removeEventListener(trigger, this._onBrushStart), this.stage.removeEventListener(updateTrigger, delayMap[delayType](this._onBrushing, delayTime)), 
        this.stage.removeEventListener(endTrigger, this._onBrushEnd), this.stage.removeEventListener(resetTrigger, this._onBrushEnd);
    }
}

Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;
//# sourceMappingURL=brush.js.map