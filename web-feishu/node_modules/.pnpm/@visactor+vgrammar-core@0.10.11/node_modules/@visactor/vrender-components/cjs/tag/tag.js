"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Tag = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("../core/base"), util_1 = require("../util"), constant_1 = require("../constant"), register_1 = require("./register");

(0, register_1.loadTagComponent)();

class Tag extends base_1.AbstractComponent {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, Tag.defaultAttributes, attributes)), 
        this.name = "tag";
    }
    render() {
        var _a, _b, _c, _d;
        const {text: text = "", textStyle: textStyle = {}, shape: shape = {}, panel: panel = {}, space: space = 4, minWidth: minWidth, maxWidth: maxWidth, padding: padding = 4, visible: visible, state: state, type: type, textAlwaysCenter: textAlwaysCenter} = this.attribute, parsedPadding = (0, 
        vutils_1.normalizePadding)(padding), group = this.createOrUpdateChild("tag-content", {
            x: 0,
            y: 0,
            zIndex: 1
        }, "group");
        let symbol, tagWidth = parsedPadding[1] + parsedPadding[3], tagHeight = parsedPadding[0] + parsedPadding[2], textX = 0, symbolPlaceWidth = 0;
        const {visible: shapeVisible} = shape, shapeStyle = __rest(shape, [ "visible" ]);
        if ((0, vutils_1.isBoolean)(shapeVisible)) {
            const size = (null == shapeStyle ? void 0 : shapeStyle.size) || 10, maxSize = (0, 
            vutils_1.isNumber)(size) ? size : Math.max(size[0], size[1]);
            symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
                symbolType: "circle",
                size: size,
                strokeBoundsBuffer: 0
            }, shapeStyle), {
                visible: shapeVisible,
                x: maxSize / 2,
                y: maxSize / 2
            }), "symbol"), (0, vutils_1.isEmpty)(null == state ? void 0 : state.shape) || (symbol.states = state.shape), 
            shapeVisible && (symbolPlaceWidth = maxSize + space);
        }
        let textShape;
        if (tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth, "rich" === type) {
            const richTextAttrs = Object.assign(Object.assign({
                textConfig: text,
                visible: (0, vutils_1.isValid)(text) && !1 !== visible
            }, textStyle), {
                x: textX,
                y: 0,
                width: null !== (_a = textStyle.width) && void 0 !== _a ? _a : 0,
                height: null !== (_b = textStyle.height) && void 0 !== _b ? _b : 0
            });
            textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext");
            const {visible: bgVisible} = panel, backgroundStyle = __rest(panel, [ "visible" ]);
            if (visible && (0, vutils_1.isBoolean)(bgVisible)) {
                const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
                    visible: bgVisible && !!text,
                    x: textShape.AABBBounds.x1,
                    y: textShape.AABBBounds.y1,
                    width: textShape.AABBBounds.width(),
                    height: textShape.AABBBounds.height()
                }), "rect");
                (0, vutils_1.isEmpty)(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
            }
        } else if ("html" === type) {
            const richTextAttrs = Object.assign(Object.assign({
                textConfig: [],
                visible: (0, vutils_1.isValid)(text) && !1 !== visible,
                html: Object.assign(Object.assign({
                    dom: text
                }, constant_1.DEFAULT_HTML_TEXT_SPEC), textStyle)
            }, textStyle), {
                x: textX,
                y: 0
            });
            textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext");
            const {visible: bgVisible} = panel, backgroundStyle = __rest(panel, [ "visible" ]);
            if (visible && (0, vutils_1.isBoolean)(bgVisible)) {
                const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
                    visible: bgVisible && !!text,
                    x: textShape.AABBBounds.x1,
                    y: textShape.AABBBounds.y1,
                    width: textShape.AABBBounds.width(),
                    height: textShape.AABBBounds.height()
                }), "rect");
                (0, vutils_1.isEmpty)(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
            }
        } else {
            const textAttrs = Object.assign(Object.assign({
                text: text,
                visible: (0, vutils_1.isValid)(text) && !1 !== visible,
                lineHeight: null == textStyle ? void 0 : textStyle.fontSize
            }, textStyle), {
                x: textX,
                y: 0
            });
            (0, vutils_1.isNil)(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), 
            textShape = group.createOrUpdateChild("tag-text", textAttrs, "text"), (0, vutils_1.isEmpty)(null == state ? void 0 : state.text) || (textShape.states = state.text);
            const textBounds = (0, util_1.measureTextSize)(textAttrs.text, textStyle, null === (_c = this.stage) || void 0 === _c ? void 0 : _c.getTheme().text.fontFamily), textWidth = textBounds.width, textHeight = textBounds.height;
            tagWidth += textWidth;
            const size = null !== (_d = shape.size) && void 0 !== _d ? _d : 10, maxSize = (0, 
            vutils_1.isNumber)(size) ? size : Math.max(size[0], size[1]);
            tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
            const {textAlign: textAlign, textBaseline: textBaseline} = textStyle;
            ((0, vutils_1.isValid)(minWidth) || (0, vutils_1.isValid)(maxWidth)) && ((0, vutils_1.isValid)(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), 
            (0, vutils_1.isValid)(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, 
            textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2])));
            let x = 0, y = 0;
            "center" === textAlign ? (x -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), 
            group.setAttribute("x", -symbolPlaceWidth / 2)) : "right" === textAlign || "end" === textAlign ? (x -= tagWidth, 
            symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : "left" !== textAlign && "start" !== textAlign || group.setAttribute("x", parsedPadding[3]), 
            !textAlwaysCenter || "left" !== textAlign && "start" !== textAlign || textShape.setAttributes({
                x: textX + tagWidth / 2,
                textAlign: "center"
            }), "middle" === textBaseline ? (y -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (y -= tagHeight, 
            symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), 
            symbol && symbol.setAttribute("y", textHeight / 2));
            const {visible: bgVisible} = panel, backgroundStyle = __rest(panel, [ "visible" ]);
            if (visible && (0, vutils_1.isBoolean)(bgVisible)) {
                const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
                    visible: bgVisible && !!text,
                    x: x,
                    y: y,
                    width: tagWidth,
                    height: tagHeight
                }), "rect");
                (0, vutils_1.isEmpty)(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
            }
        }
    }
}

exports.Tag = Tag, Tag.defaultAttributes = {
    visible: !0,
    textStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
    },
    space: 4,
    padding: 4,
    shape: {
        fill: "#000"
    }
};
//# sourceMappingURL=tag.js.map
