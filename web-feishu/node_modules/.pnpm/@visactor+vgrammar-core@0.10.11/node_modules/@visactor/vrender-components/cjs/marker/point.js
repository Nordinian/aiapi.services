"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MarkPoint = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), segment_1 = require("../segment"), tag_1 = require("../tag"), base_1 = require("./base"), config_1 = require("./config"), type_1 = require("./type"), register_1 = require("./register"), limit_shape_1 = require("../util/limit-shape");

(0, register_1.loadMarkPointComponent)();

class MarkPoint extends base_1.Marker {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, MarkPoint.defaultAttributes, attributes)), 
        this.name = "markPoint";
    }
    setLabelPos() {}
    setItemAttributes(item, itemContent, itemPosition, itemType) {
        var _a;
        if (!item) return;
        const {autoRotate: autoRotate = !0, refX: refX = 0, refY: refY = 0, refAngle: refAngle = 0, textStyle: textStyle = {}, richTextStyle: richTextStyle = {}, imageStyle: imageStyle = {}, position: position = type_1.IMarkPointItemPosition.middle} = itemContent, itemAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0, itemOffsetX = refX * Math.cos(itemAngle) + refY * Math.cos(itemAngle - Math.PI / 2), itemOffsetY = refX * Math.sin(itemAngle) + refY * Math.sin(itemAngle - Math.PI / 2);
        "text" === itemType ? item.setAttributes(Object.assign(Object.assign({}, textStyle), {
            textStyle: Object.assign(Object.assign({}, config_1.DEFAULT_MARK_POINT_TEXT_STYLE_MAP[(null == itemContent ? void 0 : itemContent.position) || "end"]), textStyle.textStyle)
        })) : "richText" === itemType ? item.setAttributes({
            dx: this.getItemDx(item, position, richTextStyle) + (richTextStyle.dx || 0),
            dy: this.getItemDy(item, position, richTextStyle) + (richTextStyle.dy || 0)
        }) : "image" === itemType && item.setAttributes({
            dx: this.getItemDx(item, position, imageStyle) + (imageStyle.dx || 0),
            dy: this.getItemDy(item, position, imageStyle) + (imageStyle.dy || 0)
        }), item.setAttributes({
            x: itemPosition.x + (itemOffsetX || 0),
            y: itemPosition.y + (itemOffsetY || 0),
            angle: autoRotate && itemAngle + refAngle
        });
    }
    getItemDx(item, position, style) {
        var _a, _b;
        const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style ? void 0 : style.width) || 0;
        return position.includes("inside") ? -width : 0;
    }
    getItemDy(item, position, style) {
        var _a, _b;
        const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style ? void 0 : style.height) || 0;
        return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
    }
    initItem(itemContent, itemPosition) {
        const {type: type = "text", symbolStyle: symbolStyle, richTextStyle: richTextStyle, imageStyle: imageStyle, renderCustomCallback: renderCustomCallback} = itemContent;
        let item;
        return "symbol" === type ? item = vrender_core_1.graphicCreator.symbol(Object.assign(Object.assign({}, itemPosition), symbolStyle)) : "text" === type ? item = new tag_1.Tag(Object.assign({}, itemPosition)) : "richText" === type ? item = vrender_core_1.graphicCreator.richtext(Object.assign(Object.assign({}, itemPosition), richTextStyle)) : "image" === type ? item = vrender_core_1.graphicCreator.image(Object.assign(Object.assign({}, itemPosition), imageStyle)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback()), 
        this.setItemAttributes(item, itemContent, itemPosition, type), item;
    }
    getItemLineAttr(itemLine, position, itemPosition) {
        let points = [];
        const {type: type = "type-s"} = itemLine;
        return points = "type-do" === type ? [ position, {
            x: (position.x + itemPosition.x) / 2,
            y: itemPosition.y
        }, itemPosition ] : "type-po" === type ? [ position, {
            x: itemPosition.x,
            y: position.y
        }, itemPosition ] : "type-op" === type ? [ position, {
            x: position.x,
            y: itemPosition.y
        }, itemPosition ] : [ position, itemPosition ], points;
    }
    setItemLineAttr(itemLine, position, itemPosition, visible) {
        if (this._line) {
            const {startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle} = itemLine, points = this.getItemLineAttr(itemLine, position, itemPosition);
            this._line.setAttributes({
                points: points,
                startSymbol: startSymbol,
                endSymbol: endSymbol,
                lineStyle: lineStyle,
                visible: visible
            });
        }
    }
    getDecorativeLineAttr(itemLine, itemPosition) {
        var _a;
        const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10, itemAngle = this._line.getEndAngle() || 0;
        return {
            startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
            startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
            endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
            endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
        };
    }
    setDecorativeLineAttr(itemLine, itemPosition, visible) {
        if (this._decorativeLine) {
            const {lineStyle: lineStyle} = itemLine, {startPointOffsetX: startPointOffsetX, startPointOffsetY: startPointOffsetY, endPointOffsetX: endPointOffsetX, endPointOffsetY: endPointOffsetY} = this.getDecorativeLineAttr(itemLine, itemPosition);
            this._decorativeLine.setAttributes(Object.assign(Object.assign({
                points: [ {
                    x: itemPosition.x + startPointOffsetX,
                    y: itemPosition.y + startPointOffsetY
                }, {
                    x: itemPosition.x + endPointOffsetX,
                    y: itemPosition.y + endPointOffsetY
                } ]
            }, lineStyle), {
                visible: visible
            }));
        }
    }
    setAllOfItemsAttr(itemPosition) {
        var _a;
        const {position: position, itemLine: itemLine = {}, itemContent: itemContent = {}, limitRect: limitRect} = this.attribute, {type: type = "text", confine: confine} = itemContent;
        if (limitRect && confine) {
            const {x: x, y: y, width: width, height: height} = limitRect, {dx: dx, dy: dy} = (0, 
            limit_shape_1.computeOffsetForlimit)(this._item, {
                x1: x,
                y1: y,
                x2: x + width,
                y2: y + height
            });
            itemPosition.x = itemPosition.x + dx, itemPosition.y = itemPosition.y + dy;
        }
        this.setItemAttributes(this._item, itemContent, itemPosition, type), this.setItemLineAttr(itemLine, position, itemPosition, itemLine.visible), 
        this.setDecorativeLineAttr(itemLine, itemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
    }
    initMarker(container) {
        const {position: position, itemContent: itemContent = {}} = this.attribute, itemPosition = {
            x: position.x + (itemContent.offsetX || 0),
            y: position.y + (itemContent.offsetY || 0)
        }, line = new segment_1.Segment({
            points: [],
            pickable: !1
        });
        line.name = "mark-point-line", this._line = line, container.add(line);
        const decorativeLine = vrender_core_1.graphicCreator.line({
            points: []
        });
        decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, 
        container.add(decorativeLine);
        const item = this.initItem(itemContent, itemPosition);
        this._item = item, this.setAllOfItemsAttr(itemPosition), container.add(item);
    }
    updateMarker() {
        const {position: position, itemContent: itemContent = {}} = this.attribute, {type: type = "text"} = itemContent, itemPosition = {
            x: position.x + (itemContent.offsetX || 0),
            y: position.y + (itemContent.offsetY || 0)
        };
        this.setItemAttributes(this._item, itemContent, itemPosition, type), this.setAllOfItemsAttr(itemPosition);
    }
    isValidPoints() {
        const {position: position} = this.attribute;
        return !(!(0, vutils_1.isValidNumber)(position.x) || !(0, vutils_1.isValidNumber)(position.y));
    }
}

exports.MarkPoint = MarkPoint, MarkPoint.defaultAttributes = config_1.DEFAULT_MARK_POINT_THEME;
//# sourceMappingURL=point.js.map
