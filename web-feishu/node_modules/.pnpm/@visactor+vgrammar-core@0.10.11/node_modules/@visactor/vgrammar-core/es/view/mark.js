var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { isNil, isString } from "@visactor/vutils";

import { BridgeElementKey, CollectionMarkType, DefaultKey, DefaultMarkData, Mark3DType } from "../graph/constants";

import { DiffState, GrammarMarkType, LayoutState, HOOK_EVENT, GrammarTypeEnum, BuiltInEncodeNames } from "../graph/enums";

import { Differ, groupData } from "../graph/mark/differ";

import { Animate } from "../graph/animation/animate";

import { createGraphicItem, removeGraphicItem } from "../graph/util/graphic";

import { GrammarBase } from "./grammar-base";

import { isFieldEncode, isScaleEncode, parseEncodeType } from "../parse/mark";

import { getGrammarOutput, parseField, isFunctionType } from "../parse/util";

import { parseTransformSpec } from "../parse/transform";

import { createElement } from "../graph/util/element";

import { invokeEncoder, invokeEncoderToItems, splitEncoderInLarge } from "../graph/mark/encode";

import { isPositionOrSizeChannel, transformsByType } from "../graph/attributes";

import getExtendedEvents from "../graph/util/events-extend";

import { EVENT_SOURCE_VIEW } from "./constants";

export class Mark extends GrammarBase {
    constructor(view, markType, group) {
        super(view), this.grammarType = "mark", this.elements = [], this.elementMap = new Map, 
        this.isUpdated = !0, this._isReentered = !1, this.animate = new Animate(this, {}), 
        this.differ = new Differ([]), this.evaluateSync = (data, parameters) => {
            var _a;
            return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || this.evaluateTransformSync(this._getTransformsAfterEncode(), this.elements, parameters), 
            this;
        }, this.markType = markType, this.spec.type = markType, this.spec.encode = {
            update: {}
        }, this.spec.group = group, group && (this.group = group, this.attach(group), group.appendChild(this));
    }
    parse(spec) {
        var _a, _b, _c;
        if (super.parse(spec), this.spec.group) {
            const groupMark = isString(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;
            this.detach(groupMark);
        }
        const groupMark = isString(spec.group) ? this.view.getMarkById(spec.group) : spec.group;
        return this.attach(groupMark), this.join(null === (_a = spec.from) || void 0 === _a ? void 0 : _a.data, spec.key, spec.sort, spec.groupBy, spec.groupSort), 
        this.coordinate(spec.coordinate), this.state(spec.state, this.spec.stateSort), Object.keys(null !== (_b = this.spec.encode) && void 0 !== _b ? _b : {}).forEach((state => {
            this.encodeState(state, {}, !0);
        })), Object.keys(null !== (_c = spec.encode) && void 0 !== _c ? _c : {}).forEach((state => {
            this.encodeState(state, spec.encode[state]);
        })), this.animation(spec.animation), this.animationState(spec.animationState), this.morph(spec.morph, spec.morphKey, spec.morphElementKey), 
        this.layout(spec.layout), this.configure(spec), this.transform(spec.transform), 
        this.parseAddition(spec), this.spec = spec, this.markType = spec.type, this.commit(), 
        this;
    }
    parameters() {
        var _a;
        return null !== (_a = this._finalParameters) && void 0 !== _a ? _a : super.parameters();
    }
    parseAddition(spec) {
        return this;
    }
    reuse(grammar) {
        if (grammar.grammarType !== this.grammarType) return this;
        const mark = grammar;
        return this.markType = mark.markType, this.coord = mark.coord, this.elementMap = mark.elementMap, 
        this.elements = mark.elements, this.elementMap.forEach((element => element.mark = this)), 
        this.differ = mark.differ, this.animate = mark.animate, this.animate.mark = this, 
        this._context = mark._context, this.graphicItem = mark.graphicItem, this.graphicIndex = mark.graphicIndex, 
        this.graphicParent = mark.graphicParent, this.needClear = mark.needClear, this.isUpdated = mark.isUpdated, 
        this;
    }
    needLayout() {
        return !isNil(this.spec.layout);
    }
    handleLayoutEnd() {}
    handleRenderEnd() {
        this.needClear && (this.cleanExitElements(), this.elementMap.forEach((element => {
            element.diffState === DiffState.exit ? element.clearGraphicAttributes() : element.clearChangedGraphicAttributes();
        })), this.differ.updateToCurrent(), this.needClear = !1);
    }
    evaluateMainTasks(data, parameters) {
        var _a;
        if (this.needSkipBeforeLayout() && this.view.getLayoutState() === LayoutState.before) return this;
        const stage = null === (_a = this.view.renderer) || void 0 === _a ? void 0 : _a.stage();
        this.init(stage, parameters);
        const transformData = this.evaluateTransformSync(this._getTransformsBeforeJoin(), null != data ? data : DefaultMarkData, parameters);
        let inputData = (null == transformData ? void 0 : transformData.progressive) ? data : transformData;
        return this.evaluateGroup(inputData), this.renderContext = this.parseRenderContext(inputData, parameters), 
        this.renderContext.progressive ? (this.differ.reset(), this.elementMap.clear(), 
        this.evaluateProgressive()) : ((null == transformData ? void 0 : transformData.progressive) && (this.renderContext.parameters = parameters, 
        this.renderContext.beforeTransformProgressive = transformData.progressive, inputData = transformData.progressive.output()), 
        this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(inputData), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 
        this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, parameters), 
        this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), 
        this.evaluateEncode(this.elements, this._getEncoders(), parameters), this.emit(HOOK_EVENT.AFTER_MARK_ENCODE)), 
        this.emit(HOOK_EVENT.BEFORE_MARK_UPDATE), this.update(this.spec), this.emit(HOOK_EVENT.AFTER_MARK_UPDATE), 
        this;
    }
    evaluateGroup(data) {
        if (this.markType === GrammarMarkType.group) return;
        const res = groupData(null != data ? data : DefaultMarkData, this.spec.groupBy, this.spec.groupSort), groupKeys = res.keys;
        this._groupKeys = groupKeys, this.differ.setCurrentData(res);
    }
    _getTransformsAfterEncodeItems() {
        return this.transforms && this.transforms.filter((entry => "afterEncodeItems" === entry.markPhase));
    }
    _getTransformsAfterEncode() {
        return this.transforms && this.transforms.filter((entry => isNil(entry.markPhase) || "afterEncode" === entry.markPhase));
    }
    _getTransformsBeforeJoin() {
        return this.transforms ? this.transforms.filter((entry => "beforeJoin" === entry.markPhase)) : [];
    }
    evaluate(data, parameters) {
        var _a;
        return __awaiter(this, void 0, void 0, (function*() {
            return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || (yield this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, parameters)), 
            this;
        }));
    }
    output() {
        return this;
    }
    join(data, key, sort, groupBy, groupSort) {
        return this.grammarSource && (this.detach(this.grammarSource), this.grammarSource = null), 
        this.spec.from = null, isNil(data) || (isString(data) ? this.grammarSource = this.view.getDataById(data) : this.grammarSource = data, 
        this.spec.from = {
            data: data
        }, this.attach(this.grammarSource)), this.spec.key = key, this.spec.sort = sort, 
        this.spec.groupBy = groupBy, this.spec.groupSort = groupSort, this.commit(), this;
    }
    coordinate(coordinate) {
        return isString(coordinate) ? this.coord = this.view.getCoordinateById(coordinate) : this.coord = coordinate, 
        this.attach(this.coord), this.commit(), this;
    }
    state(state, stateSort) {
        return this.spec.stateSort = stateSort, this.setFunctionSpec(state, "state");
    }
    encode(channel, value, clear) {
        return this.encodeState(DiffState.update, channel, value, clear);
    }
    encodeState(state, channel, value, clear) {
        if (state === DiffState.enter && (this._isReentered = !0), this.spec.encode[state]) {
            const lastEncoder = this.spec.encode[state];
            if (isFunctionType(lastEncoder)) this.detach(parseEncodeType(lastEncoder, this.view)); else {
                const isSingleChannel = isString(channel);
                isSingleChannel && clear || !isSingleChannel && value ? (Object.keys(lastEncoder).forEach((c => {
                    this.detach(parseEncodeType(lastEncoder[c], this.view));
                })), this.spec.encode[state] = {}) : isSingleChannel ? this.detach(parseEncodeType(lastEncoder[channel], this.view)) : Object.keys(channel).forEach((c => {
                    this.detach(parseEncodeType(lastEncoder[c], this.view));
                }));
            }
        }
        return channel && (this.spec.encode[state] || (this.spec.encode[state] = {}), isString(channel) ? (this.spec.encode[state][channel] = value, 
        this.attach(parseEncodeType(value, this.view))) : isFunctionType(channel) ? (this.spec.encode[state] = channel, 
        this.attach(parseEncodeType(channel, this.view))) : channel && (Object.assign(this.spec.encode[state], channel), 
        Object.values(channel).forEach((channelEncoder => {
            this.attach(parseEncodeType(channelEncoder, this.view));
        })))), this.commit(), this;
    }
    _getEncoders() {
        var _a;
        return null !== (_a = this.spec.encode) && void 0 !== _a ? _a : {};
    }
    animation(animationConfig) {
        return this.spec.animation = animationConfig, this;
    }
    animationState(animationState) {
        return this.setFunctionSpec(animationState, "animationState");
    }
    layout(layout) {
        return this.spec.layout = layout, this.commit(), this;
    }
    morph(enableMorph, morphKey, morphElementKey) {
        return this.spec.morph = enableMorph, this.spec.morphKey = morphKey, this.spec.morphElementKey = morphElementKey, 
        this;
    }
    transform(transforms) {
        const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
        prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []);
        const nextTransforms = parseTransformSpec(transforms, this.view);
        return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), 
        this.spec.transform = transforms, this.commit(), this;
    }
    configure(config) {
        const keys = [ "clip", "zIndex", "interactive", "context", "setCustomizedShape", "large", "largeThreshold", "progressiveStep", "progressiveThreshold", "support3d", "morph", "morphKey", "morphElementKey", "attributeTransforms", "skipTheme", "enableSegments" ];
        return null === config ? (keys.forEach((key => {
            isNil(this.spec[key]) || (this.spec[key] = void 0);
        })), this) : (keys.forEach((key => {
            isNil(config[key]) || (this.spec[key] = config[key]);
        })), this);
    }
    context(context) {
        return this.spec.context = context, this._context = context, this;
    }
    isCollectionMark() {
        return CollectionMarkType.includes(this.markType);
    }
    needAnimate() {
        var _a;
        return !(null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) && !isNil(this.spec.animation);
    }
    getAllElements() {
        const elements = this.elements.slice();
        return this.elementMap.forEach((element => {
            element.diffState !== DiffState.exit || elements.includes(element) || elements.push(element);
        })), this.spec.sort && elements.sort(((elementA, elementB) => this.spec.sort(elementA.getDatum(), elementB.getDatum()))), 
        elements;
    }
    getScales() {
        const scales = {};
        return this.references.forEach(((count, ref) => {
            ref.grammarType === GrammarTypeEnum.scale && (scales[ref.id()] = ref.output());
        })), scales;
    }
    getScalesByChannel() {
        const encoders = this.spec.encode;
        if (!encoders) return {};
        const res = {}, params = this.parameters();
        return Object.keys(encoders).forEach((state => {
            const useEncoders = encoders[state];
            useEncoders && !isFunctionType(useEncoders) && Object.keys(useEncoders).forEach((channel => {
                isScaleEncode(useEncoders[channel]) && (res[channel] = getGrammarOutput(useEncoders[channel].scale, params));
            }));
        })), res;
    }
    getFieldsByChannel() {
        const encoders = this.spec.encode;
        if (!encoders) return {};
        const res = {};
        return Object.keys(encoders).forEach((state => {
            const useEncoders = encoders[state];
            isFunctionType(useEncoders) || Object.keys(useEncoders).forEach((channel => {
                isFieldEncode(useEncoders[channel]) && (res[channel] = useEncoders[channel].field);
            }));
        })), res;
    }
    init(stage, parameters) {
        var _a, _b, _c, _d;
        if (this._delegateEvent || (this._delegateEvent = (event, type) => {
            var _a;
            const activeElement = null === (_a = event.target) || void 0 === _a ? void 0 : _a[BridgeElementKey];
            if ((null == activeElement ? void 0 : activeElement.mark) === this) {
                const extendedEvt = getExtendedEvents(this.view, event, activeElement, type, EVENT_SOURCE_VIEW);
                this.emitGrammarEvent(type, extendedEvt, activeElement);
            }
        }, this.initEvent()), this.animate || (this.animate = new Animate(this, this.spec.animation), 
        this.needAnimate() && this.animate.updateState(this.spec.animationState)), !this.group) {
            const group = getGrammarOutput(this.spec.group, parameters);
            this.group = group, group && group.appendChild(this);
        }
        const groupGraphicItem = this.group ? this.group.getGroupGraphicItem() : stage.defaultLayer, markIndex = null !== (_c = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.children) || void 0 === _b ? void 0 : _b.indexOf(this)) && void 0 !== _c ? _c : 0;
        if (this.markType !== GrammarMarkType.group) {
            if (!this.graphicItem) {
                const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
                    pickable: !1,
                    zIndex: null !== (_d = this.spec.zIndex) && void 0 !== _d ? _d : 0
                });
                (this.spec.support3d || Mark3DType.includes(this.markType)) && graphicItem.setMode("3d"), 
                graphicItem.name = `${this.id() || this.markType}`, this.graphicItem = graphicItem;
            }
            this.graphicParent = this.graphicItem, !groupGraphicItem || this.graphicIndex === markIndex && this.graphicItem.parent === groupGraphicItem || groupGraphicItem.insertIntoKeepIdx(this.graphicItem, markIndex);
        } else this.graphicParent = groupGraphicItem;
        this.graphicIndex = markIndex;
    }
    update(spec) {
        this._context = this.spec.context, this.isUpdated = !0, this.renderContext.progressive || (spec.animation && this.animate.updateConfig(spec.animation), 
        this.animate.updateState(spec.animationState)), this.markType !== GrammarMarkType.group ? (isNil(spec.zIndex) || this.graphicItem.setAttribute("zIndex", spec.zIndex), 
        isNil(spec.clip) || this.graphicItem.setAttribute("clip", spec.clip), this.elementMap.forEach((element => {
            element.updateGraphicItem({
                interactive: spec.interactive
            });
        }))) : this.elementMap.forEach((element => {
            element.updateGraphicItem({
                clip: spec.clip,
                zIndex: spec.zIndex,
                interactive: spec.interactive
            });
        }));
    }
    evaluateJoin(data) {
        var _a, _b, _c, _d;
        this.needClear = !0;
        const keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), groupKeyGetter = parseField(null !== (_d = this.spec.groupBy) && void 0 !== _d ? _d : () => DefaultKey), sort = this.spec.sort, isCollectionMark = this.isCollectionMark(), enterElements = new Set(this.elements.filter((element => element.diffState === DiffState.enter))), elements = [];
        this.differ.setCallback(((key, data, prevData) => {
            const elementKey = key;
            let element;
            if (isNil(data)) element = this.elementMap.get(elementKey), element && (element.diffState = DiffState.exit); else if (isNil(prevData)) {
                if (element = this.elementMap.has(elementKey) ? this.elementMap.get(elementKey) : createElement(this), 
                element.diffState === DiffState.exit) {
                    element.diffState = DiffState.enter;
                    this.animate.getElementAnimators(element, DiffState.exit).forEach((animator => animator.stop("start")));
                }
                element.diffState = DiffState.enter;
                const groupKey = isCollectionMark ? key : groupKeyGetter(data[0]);
                element.updateData(groupKey, data, keyGetter, this.view), this.elementMap.set(elementKey, element), 
                elements.push(element);
            } else if (element = this.elementMap.get(elementKey), element) {
                element.diffState = DiffState.update;
                const groupKey = isCollectionMark ? key : groupKeyGetter(data[0]);
                element.updateData(groupKey, data, keyGetter, this.view), elements.push(element);
            }
            enterElements.delete(element);
        }));
        const currentData = null != data ? data : DefaultMarkData;
        isCollectionMark || this.differ.setCurrentData(groupData(currentData, (datum => `${groupKeyGetter(datum)}-${keyGetter(datum)}`), void 0)), 
        this.differ.doDiff(), enterElements.forEach((element => {
            this.elementMap.delete(isCollectionMark ? element.groupKey : `${element.groupKey}-${element.key}`), 
            element.remove(), element.release();
        })), this.elements = elements, sort && this.elements.length >= 2 && this.elements.sort(((elementA, elementB) => sort(elementA.getDatum(), elementB.getDatum())));
    }
    evaluateState(elements, stateSpec, parameters) {
        stateSpec && elements.forEach((element => {
            element.state(stateSpec, parameters);
        }));
    }
    evaluateGroupEncode(elements, groupEncode, parameters) {
        var _a;
        if (this.markType === GrammarMarkType.group) {
            const el = this.elements[0], nextAttrs = {}, items = [ Object.assign({}, null === (_a = el.items) || void 0 === _a ? void 0 : _a[0], {
                nextAttrs: nextAttrs
            }) ];
            return invokeEncoderToItems(el, items, groupEncode, parameters), nextAttrs;
        }
        if (!this._groupKeys || !groupEncode) return;
        const res = {};
        return this._groupKeys.forEach((key => {
            const el = elements.find((el => el.groupKey === key));
            el && (res[key] = invokeEncoder(groupEncode, el.items && el.items[0] && el.items[0].datum, el, parameters));
        })), res;
    }
    evaluateEncode(elements, encoders, parameters) {
        if (encoders) {
            this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
                encoders: encoders,
                parameters: parameters
            }, this);
            const groupEncodeAttrs = this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
            elements.forEach((element => {
                this.markType === GrammarMarkType.group && groupEncodeAttrs ? element.items.forEach((item => {
                    item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs);
                })) : (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && !this.isCollectionMark() && element.items.forEach((item => {
                    item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs[element.groupKey]);
                })), element.encodeItems(element.items, encoders, this._isReentered, parameters);
            })), this._isReentered = !1, this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), elements, parameters), 
            elements.forEach((element => {
                element.encodeGraphic(this.isCollectionMark() ? null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey] : null);
            })), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
                encoders: encoders,
                parameters: parameters
            }, this);
        } else elements.forEach((element => {
            element.initGraphicItem();
        }));
    }
    addGraphicItem(attrs, groupKey, newGraphicItem) {
        var _a;
        const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
        if (graphicItem) {
            if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) {
                let group;
                if (this._groupKeys) {
                    const index = this._groupKeys.indexOf(groupKey);
                    index >= 0 && (group = this.graphicParent.getChildAt(index));
                } else group = this.graphicParent.at(0);
                this.isCollectionMark() ? (graphicItem.incremental = 1, group.appendChild(graphicItem)) : group.incrementalAppendChild(graphicItem);
            } else this.graphicParent.appendChild(graphicItem);
            return graphicItem;
        }
    }
    parseRenderContext(data, parameters) {
        const enableProgressive = this.markType !== GrammarMarkType.group && this.spec.progressiveStep > 0 && this.spec.progressiveThreshold > 0 && this.spec.progressiveStep < this.spec.progressiveThreshold, large = this.spec.large && this.spec.largeThreshold > 0 && data.length >= this.spec.largeThreshold;
        if (enableProgressive) {
            const groupedData = this.differ.getCurrentData();
            return groupedData && groupedData.keys && groupedData.keys.some((key => groupedData.data.get(key).length > this.spec.progressiveThreshold)) ? {
                large: large,
                parameters: parameters,
                progressive: {
                    data: data,
                    step: this.spec.progressiveStep,
                    currentIndex: 0,
                    totalStep: groupedData.keys.reduce(((total, key) => Math.max(Math.ceil(groupedData.data.get(key).length / this.spec.progressiveStep), total)), 1),
                    groupedData: groupedData.data
                }
            } : {
                large: large
            };
        }
        return {
            large: large
        };
    }
    isProgressive() {
        return this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive);
    }
    isDoingProgressive() {
        return this.renderContext && (this.renderContext.progressive && this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep || this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished());
    }
    clearProgressive() {
        this.renderContext && this.renderContext.progressive && (this.elements = [], this.graphicParent.children.forEach((group => {
            group.incrementalClearChild();
        })), this.graphicParent.removeAllChild()), this.renderContext && this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.release(), 
        this.renderContext = null;
    }
    restartProgressive() {
        this.renderContext && this.renderContext.progressive && (this.renderContext.progressive.currentIndex = 0);
    }
    evaluateJoinProgressive() {
        var _a, _b, _c;
        const currentIndex = this.renderContext.progressive.currentIndex, keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), elements = [];
        if (this.isCollectionMark()) return this._groupKeys.forEach(((key, index) => {
            const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);
            if (0 === currentIndex) {
                const element = createElement(this);
                element.diffState = DiffState.enter, element.updateData(key, dataSlice, keyGetter, this.view), 
                elements.push(element);
            } else {
                const element = this.elements[index];
                element.updateData(key, dataSlice, keyGetter, this.view), elements.push(element);
            }
        })), elements;
        const groupElements = {};
        return this._groupKeys.forEach((key => {
            const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep), group = [];
            dataSlice.forEach((entry => {
                const element = createElement(this);
                element.diffState = DiffState.enter, element.updateData(key, [ entry ], keyGetter, this.view), 
                group.push(element), elements.push(element);
            })), groupElements[key] = group;
        })), {
            groupElements: groupElements,
            elements: elements
        };
    }
    evaluateEncodeProgressive(elements, encoders, parameters) {
        if (!encoders) return void elements.forEach((element => {
            element.initGraphicItem();
        }));
        const positionEncoders = Object.keys(encoders).reduce(((res, state) => (!encoders[state] || state !== BuiltInEncodeNames.enter && state !== BuiltInEncodeNames.exit && state !== BuiltInEncodeNames.update || (res[state] = splitEncoderInLarge(this.markType, encoders[state], this.glyphType).positionEncoder), 
        res)), {}), progressiveIndex = this.renderContext.progressive.currentIndex, isCollection = this.isCollectionMark();
        this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
            encoders: encoders,
            parameters: parameters
        }, this);
        const groupEncodeAttrs = this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
        if (elements.forEach(((element, index) => {
            const onlyPos = progressiveIndex > 0 || !isCollection && index > 0;
            !onlyPos && (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && element.items.forEach((item => {
                item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs[element.groupKey]);
            })), element.encodeItems(element.items, onlyPos ? positionEncoders : encoders, this._isReentered, parameters);
        })), this._isReentered = !1, this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), elements, parameters), 
        elements.forEach((element => {
            element.encodeGraphic();
        })), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
            encoders: encoders,
            parameters: parameters
        }, this), 0 === progressiveIndex && !isCollection) {
            const firstChild = elements[0].getGraphicItem(), group = null == firstChild ? void 0 : firstChild.parent;
            if (group) {
                const attrs = firstChild.attribute, theme = {}, itemAttrs = {};
                Object.keys(attrs).forEach((key => {
                    [ "pickable", "zIndex" ].includes(key) || (isPositionOrSizeChannel(this.markType, key) ? itemAttrs[key] = attrs[key] : theme[key] = attrs[key]);
                })), group.setTheme({
                    common: theme
                }), firstChild.initAttributes(itemAttrs);
            }
        }
    }
    evaluateProgressive() {
        var _a, _b, _c;
        if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.beforeTransformProgressive) {
            this.renderContext.beforeTransformProgressive.progressiveRun();
            const output = this.renderContext.beforeTransformProgressive.output();
            return this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(output), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 
            this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters), 
            this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), 
            this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters), 
            void this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
        }
        if (!(null === (_b = this.renderContext) || void 0 === _b ? void 0 : _b.progressive)) return;
        const parameters = this.renderContext.parameters;
        this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);
        const result = this.evaluateJoinProgressive(), elements = Array.isArray(result) ? result : result.elements;
        if (this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 0 === this.renderContext.progressive.currentIndex ? (this.graphicParent.removeAllChild(), 
        this._groupKeys.forEach((key => {
            const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
                pickable: !1,
                zIndex: this.spec.zIndex
            });
            graphicItem.incremental = this.renderContext.progressive.step, this.graphicParent.appendChild(graphicItem);
        })), this.elements = elements) : this.elements = this.elements.concat(elements), 
        this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(elements, this.spec.state, parameters), 
        this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), 
        Array.isArray(result)) this.evaluateEncodeProgressive(elements, this._getEncoders(), parameters); else {
            const groupElements = result.groupElements;
            Object.keys(groupElements).forEach((key => {
                this.evaluateEncodeProgressive(groupElements[key], this._getEncoders(), parameters);
            }));
        }
        this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
        const progressiveTransforms = null === (_c = this._getTransformsAfterEncode()) || void 0 === _c ? void 0 : _c.filter((entry => !0 === entry.canProgressive));
        (null == progressiveTransforms ? void 0 : progressiveTransforms.length) && this.evaluateTransformSync(progressiveTransforms, this.elements, parameters), 
        this.renderContext.progressive.currentIndex += 1;
    }
    isLargeMode() {
        return this.renderContext && this.renderContext.large;
    }
    cleanExitElements() {
        this.elementMap.forEach(((element, key) => {
            element.diffState !== DiffState.exit || element.isReserved || (this.elementMap.delete(key), 
            element.remove(), element.release());
        }));
    }
    getGroupGraphicItem() {
        if (this.elements && this.elements[0] && this.elements[0].getGraphicItem) return this.elements[0].getGraphicItem();
    }
    getBounds() {
        var _a;
        return this.graphicItem ? this.graphicItem.AABBBounds : null === (_a = this.getGroupGraphicItem()) || void 0 === _a ? void 0 : _a.AABBBounds;
    }
    getMorphConfig() {
        var _a;
        return {
            morph: null !== (_a = this.spec.morph) && void 0 !== _a && _a,
            morphKey: this.spec.morphKey,
            morphElementKey: this.spec.morphElementKey
        };
    }
    getAttributeTransforms() {
        var _a;
        return null !== (_a = this.spec.attributeTransforms) && void 0 !== _a ? _a : transformsByType[this.markType];
    }
    getContext() {
        return this._context;
    }
    needSkipBeforeLayout() {
        var _a, _b;
        if (!0 === (null === (_a = this.spec.layout) || void 0 === _a ? void 0 : _a.skipBeforeLayouted)) return !0;
        let group = this.group;
        for (;group; ) {
            if (!0 === (null === (_b = group.getSpec().layout) || void 0 === _b ? void 0 : _b.skipBeforeLayouted)) return !0;
            group = group.group;
        }
        return !1;
    }
    initEvent() {
        if (this._delegateEvent) {
            this.view.renderer.stage().on("*", this._delegateEvent);
        }
    }
    releaseEvent() {
        if (this._delegateEvent) {
            const stage = this.view.renderer.stage();
            stage && stage.off("*", this._delegateEvent);
        }
    }
    clear() {
        var _a;
        super.clear(), this.transforms = null, this.elementMap = null, this.elements = null, 
        this.graphicItem = null, this.animate = null, null === (_a = this.group) || void 0 === _a || _a.removeChild(this), 
        this.group = null;
    }
    prepareRelease() {
        this.animate.stop(), this.elementMap.forEach((element => element.diffState = DiffState.exit)), 
        this._finalParameters = this.parameters();
    }
    release() {
        this.releaseEvent(), this.elements.forEach((element => element.release())), this.elementMap.clear(), 
        this._finalParameters = null, this.animate && this.animate.release(), this.graphicItem && removeGraphicItem(this.graphicItem), 
        this.detachAll(), super.release();
    }
}
//# sourceMappingURL=mark.js.map
