import type { ICustomPath2D } from './../interface/path';
import type { OBBBounds, Dict, IPointLike, IAABBBounds } from '@visactor/vutils';
import { AABBBounds, Matrix, Point } from '@visactor/vutils';
import type { GraphicType, IAnimateConfig, IGraphicAttribute, IGraphic, IGraphicAnimateParams, IGraphicJson, ISetAttributeContext, ITransform, GraphicReleaseStatus } from '../interface/graphic';
import { Node } from './node-tree';
import type { IAnimate, IAnimateTarget, IGlyphGraphicAttribute, ILayer, IPickerService, IShadowRoot, IStage, IStep, ISubAnimate } from '../interface';
import { Animate } from '../animate';
import { IContainPointMode } from '../common/enums';
export declare const PURE_STYLE_KEY: string[];
export declare const GRAPHIC_UPDATE_TAG_KEY: string[];
export declare const NOWORK_ANIMATE_ATTR: {
    strokeSeg: number;
    boundsPadding: number;
    pickMode: number;
    boundsMode: number;
    customPickShape: number;
    pickable: number;
    childrenPickable: number;
    visible: number;
    zIndex: number;
    layout: number;
    keepDirIn3d: number;
    outerBorder: number;
    innerBorder: number;
    lineDash: number;
    lineCap: number;
    lineJoin: number;
    miterLimit: number;
    strokeBoundsBuffer: number;
    scaleCenter: number;
    anchor: number;
    anchor3d: number;
    postMatrix: number;
    backgroundMode: number;
    background: number;
    texture: number;
    cursor: number;
    html: number;
};
export declare abstract class Graphic<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>> extends Node implements IGraphic<T>, IAnimateTarget {
    static mixin(source: Dict<any>): void;
    _events?: any;
    onBeforeAttributeUpdate?: (val: any, attributes: Partial<T>, key: null | string | string[], context?: ISetAttributeContext) => T | undefined;
    parent: any;
    resources?: Map<string, {
        state: 'init' | 'loading' | 'success' | 'fail';
        data?: HTMLImageElement | HTMLCanvasElement;
    }>;
    backgroundImg?: boolean;
    type: GraphicType;
    prefixed: string;
    numberType: number;
    isContainer?: boolean;
    valid: boolean;
    stage?: IStage;
    layer?: ILayer;
    incremental?: number;
    glyphHost?: IGraphic<IGlyphGraphicAttribute>;
    _onSetStage?: (g: IGraphic, stage: IStage, layer: ILayer) => void;
    in3dMode?: boolean;
    protected _AABBBounds: AABBBounds;
    get AABBBounds(): AABBBounds;
    protected _OBBBounds?: OBBBounds;
    get OBBBounds(): OBBBounds;
    protected _globalAABBBounds: AABBBounds;
    get globalAABBBounds(): AABBBounds;
    protected _transMatrix: Matrix;
    get transMatrix(): Matrix;
    protected _globalTransMatrix: Matrix;
    get globalTransMatrix(): Matrix;
    protected _updateTag: number;
    stamp?: number;
    attribute: T;
    shadowRoot?: IShadowRoot;
    releaseStatus?: GraphicReleaseStatus;
    states?: Record<string, Partial<T>>;
    currentStates?: string[];
    stateAnimateConfig?: IAnimateConfig;
    normalAttrs?: Partial<T>;
    stateProxy?: (stateName: string, targetStates?: string[]) => T;
    animates: Map<string | number, IAnimate>;
    nextAttrs?: T;
    prevAttrs?: T;
    finalAttrs?: T;
    pathProxy?: ICustomPath2D;
    constructor(params?: T);
    setMode(mode: '2d' | '3d'): void;
    set3dMode(): void;
    set2dMode(): void;
    getOffsetXY(attr?: ITransform, includeScroll?: boolean): Point;
    onAnimateBind(animate: IAnimate | ISubAnimate): void;
    protected tryUpdateAABBBounds(full?: boolean): AABBBounds;
    protected combindShadowAABBBounds(bounds: IAABBBounds): void;
    protected abstract doUpdateAABBBounds(full?: boolean): AABBBounds;
    protected abstract tryUpdateOBBBounds(): OBBBounds;
    protected tryUpdateGlobalAABBBounds(): AABBBounds;
    protected tryUpdateGlobalTransMatrix(clearTag?: boolean): Matrix;
    shouldUpdateGlobalMatrix(): boolean;
    protected tryUpdateLocalTransMatrix(clearTag?: boolean): Matrix;
    shouldUpdateAABBBounds(): boolean;
    shouldSelfChangeUpdateAABBBounds(): boolean;
    protected shouldUpdateLocalMatrix(): boolean;
    isValid(): boolean;
    protected _validNumber(num?: number): boolean;
    shouldUpdateShape(): boolean;
    clearUpdateShapeTag(): void;
    containsPoint(x: number, y: number, mode: IContainPointMode, picker?: IPickerService): boolean;
    setAttributes(params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    _setAttributes(params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    setAttribute(key: string, value: any, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    protected needUpdateTags(keys: string[], k?: string[]): boolean;
    protected needUpdateTag(key: string, k?: string[]): boolean;
    initAttributes(params: T): void;
    translate(x: number, y: number): this;
    translateTo(x: number, y: number): this;
    scale(scaleX: number, scaleY: number, scaleCenter?: IPointLike): this;
    scaleTo(scaleX: number, scaleY: number): this;
    rotate(angle: number, rotateCenter?: IPointLike): this;
    rotateTo(angle: number): this;
    skewTo(b: number, c: number): this;
    animate(params?: IGraphicAnimateParams): Animate;
    onAttributeUpdate(context?: ISetAttributeContext): void;
    update(d?: {
        bounds: boolean;
        trans: boolean;
    }): void;
    hasState(stateName?: string): boolean;
    getState(stateName: string): Partial<T>;
    applyStateAttrs(attrs: Partial<T>, stateNames: string[], hasAnimation?: boolean, isClear?: boolean): void;
    updateNormalAttrs(stateAttrs: Partial<T>): void;
    private getNormalAttribute;
    clearStates(hasAnimation?: boolean): void;
    removeState(stateName: string, hasAnimation?: boolean): void;
    toggleState(stateName: string, hasAnimation?: boolean): void;
    addState(stateName: string, keepCurrentStates?: boolean, hasAnimation?: boolean): void;
    useStates(states: string[], hasAnimation?: boolean): void;
    addUpdateBoundTag(): void;
    addUpdateShapeTag(): void;
    addUpdateShapeAndBoundsTag(): void;
    protected updateShapeAndBoundsTagSetted(): boolean;
    protected clearUpdateBoundTag(): void;
    addUpdatePositionTag(): void;
    addUpdateGlobalPositionTag(): void;
    protected clearUpdateLocalPositionTag(): void;
    protected clearUpdateGlobalPositionTag(): void;
    addUpdateLayoutTag(): void;
    protected clearUpdateLayoutTag(): void;
    protected needUpdateLayout(): boolean;
    protected getAnchor(anchor: [string | number, string | number], params: {
        b?: IAABBBounds;
    }): [number, number];
    protected doUpdateLocalMatrix(): void;
    protected doUpdateGlobalMatrix(): void;
    setStage(stage?: IStage, layer?: ILayer): void;
    setStageToShadowRoot(stage?: IStage, layer?: ILayer): void;
    onAddStep(step: IStep): void;
    onStop(props?: Partial<T>): void;
    onStep(subAnimate: ISubAnimate, animate: IAnimate, step: IStep, ratio: number, end: boolean): void;
    stepInterpolate(subAnimate: ISubAnimate, animate: IAnimate, nextAttributes: Record<string, any>, step: IStep, ratio: number, end: boolean, nextProps: Record<string, any>, lastProps?: Record<string, any>, nextParsedProps?: any, propKeys?: string[]): void;
    defaultInterpolate(nextStepVal: any, lastStepVal: any, key: string, nextAttributes: Record<string, any>, nextParsedProps: any, ratio: number): boolean;
    protected _interpolate(key: string, ratio: number, lastStepVal: any, nextStepVal: any, nextAttributes: any): void;
    getDefaultAttribute(name: string): any;
    getComputedAttribute(name: string): any;
    onSetStage(cb: (g: IGraphic, stage: IStage) => void, immediate?: boolean): void;
    attachShadow(shadowRoot?: IShadowRoot): IShadowRoot;
    detachShadow(): void;
    toJson(): IGraphicJson;
    createPathProxy(path?: string): ICustomPath2D;
    loadImage(image: any, background?: boolean): void;
    imageLoadSuccess(url: string, image: HTMLImageElement, cb?: () => void): void;
    imageLoadFail(url: string, cb?: () => void): void;
    private _stopAnimates;
    stopAnimates(stopChildren?: boolean): void;
    release(): void;
    protected _emitCustomEvent(type: string, context?: any): void;
    abstract getNoWorkAnimateAttr(): Record<string, number>;
    abstract clone(): Graphic<any>;
}
