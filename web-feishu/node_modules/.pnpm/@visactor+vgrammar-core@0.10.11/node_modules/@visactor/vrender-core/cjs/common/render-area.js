"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawAreaSegments = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), cubic_bezier_1 = require("./segment/curve/cubic-bezier"), line_1 = require("./segment/curve/line"), render_utils_1 = require("./render-utils");

function drawAreaSegments(path, segPath, percent, params) {
    var _a;
    const {drawConnect: drawConnect = !1, mode: mode = "none"} = params || {};
    if (drawConnect && "none" === mode) return;
    const {top: top, bottom: bottom} = segPath;
    if (top.curves.length !== bottom.curves.length) return;
    if (percent >= 1) {
        const topList = [], bottomList = [];
        let lastDefined = !0;
        if (drawConnect) {
            let lastCurve, lastBottomCurve, defined0 = !0;
            const n = top.curves.length;
            top.curves.forEach(((curve, i) => {
                const bototmCurve = bottom.curves[n - i - 1];
                let currentTopCurve = curve, currentBottomCurve = bototmCurve;
                if (curve.originP1 === curve.originP2) return lastCurve = curve, void (lastBottomCurve = bototmCurve);
                if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (currentTopCurve = lastCurve, 
                currentBottomCurve = lastBottomCurve), curve.defined) defined0 || (topList.push(currentTopCurve), 
                bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, topList, bottomList, params), 
                topList.length = 0, bottomList.length = 0, defined0 = !defined0); else {
                    const {originP1: originP1, originP2: originP2} = curve;
                    let validTopCurve, validBottomCurve;
                    originP1 && !1 !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && !1 !== originP2.defined && (validTopCurve = curve, 
                    validBottomCurve = bototmCurve), defined0 ? (defined0 = !defined0, topList.push(validTopCurve || curve), 
                    bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined0 = !defined0, 
                    topList.push(validTopCurve || curve), bottomList.push(validBottomCurve || bototmCurve), 
                    drawAreaConnectBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0);
                }
                lastCurve = curve;
            })), drawAreaConnectBlock(path, topList, bottomList, params);
        } else {
            for (let i = 0, n = top.curves.length; i < n; i++) {
                const topCurve = top.curves[i];
                lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), 
                topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), 
                lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));
            }
            drawAreaBlock(path, topList, bottomList, params);
        }
        return;
    }
    if (percent <= 0) return;
    let {direction: direction} = params || {};
    const {curves: topCurves} = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = (0, 
    vutils_1.abs)(endP.x - topCurves[0].p0.x), yTotalLength = (0, vutils_1.abs)(endP.y - topCurves[0].p0.y);
    direction = null != direction ? direction : xTotalLength > yTotalLength ? enums_1.Direction.ROW : enums_1.Direction.COLUMN, 
    Number.isFinite(xTotalLength) || (direction = enums_1.Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = enums_1.Direction.ROW);
    const totalDrawLength = percent * (direction === enums_1.Direction.ROW ? xTotalLength : yTotalLength);
    let drawedLengthUntilLast = 0, lastDefined = !0;
    const topList = [], bottomList = [];
    let lastTopCurve, lastBottomCurve, defined0 = !0;
    for (let i = 0, n = top.curves.length; i < n; i++) {
        const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction), percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (percent < 0) break;
        if (drawedLengthUntilLast += curCurveLength, drawConnect) {
            const bototmCurve = bottom.curves[n - i - 1];
            let currentTopCurve = topCurve, currentBottomCurve = bototmCurve;
            if (topCurve.originP1 === topCurve.originP2) {
                lastTopCurve = topCurve, lastBottomCurve = bototmCurve;
                continue;
            }
            if (lastTopCurve && lastTopCurve.originP1 === lastTopCurve.originP2 && (currentTopCurve = lastTopCurve, 
            currentBottomCurve = lastBottomCurve), topCurve.defined) defined0 || (topList.push(currentTopCurve), 
            bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, topList, bottomList, params), 
            topList.length = 0, bottomList.length = 0, defined0 = !defined0); else {
                const {originP1: originP1, originP2: originP2} = topCurve;
                let validTopCurve, validBottomCurve;
                originP1 && !1 !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && !1 !== originP2.defined && (validTopCurve = topCurve, 
                validBottomCurve = bototmCurve), defined0 ? (defined0 = !defined0, topList.push(validTopCurve || topCurve), 
                bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined0 = !defined0, 
                topList.push(validTopCurve || topCurve), bottomList.push(validBottomCurve || bototmCurve), 
                drawAreaConnectBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0);
            }
            lastTopCurve = topCurve;
        } else {
            let tc = null, bc = null;
            lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), 
            topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), 
            lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), 
            tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? (0, cubic_bezier_1.divideCubic)(tc, percent)[0] : (0, 
            line_1.divideLinear)(tc, percent)[0], bc = bc.p2 && bc.p3 ? (0, cubic_bezier_1.divideCubic)(bc, 1 - percent)[1] : (0, 
            line_1.divideLinear)(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, 
            topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
        }
    }
    drawConnect ? drawAreaConnectBlock(path, topList, bottomList, params) : drawAreaBlock(path, topList, bottomList, params);
}

function drawAreaConnectBlock(path, topList, bottomList, params) {
    if (topList.length < 2) return;
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0, mode: mode} = params || {};
    let curve = topList[0];
    path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = topList[topList.length - 1];
    let end = curve.p3 || curve.p1;
    path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), curve = bottomList[bottomList.length - 1], 
    path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = bottomList[0], 
    end = curve.p3 || curve.p1, path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), 
    path.closePath();
}

function drawAreaBlock(path, topList, bottomList, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};
    let needMoveTo = !0;
    topList.forEach((curve => {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        (0, render_utils_1.drawSegItem)(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    })), needMoveTo = !0;
    for (let i = bottomList.length - 1; i >= 0; i--) {
        const curve = bottomList[i];
        curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        (0, render_utils_1.drawSegItem)(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    }
    path.closePath();
}

//# sourceMappingURL=render-area.js.map
exports.drawAreaSegments = drawAreaSegments;