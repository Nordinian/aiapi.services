"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DiscreteLegend = void 0;

const vutils_1 = require("@visactor/vutils"), vrender_core_1 = require("@visactor/vrender-core"), base_1 = require("../base"), pager_1 = require("../../pager"), constant_1 = require("../constant"), register_1 = require("../register"), DEFAULT_STATES = {
    [constant_1.LegendStateValue.focus]: {},
    [constant_1.LegendStateValue.selected]: {},
    [constant_1.LegendStateValue.selectedHover]: {},
    [constant_1.LegendStateValue.unSelected]: {},
    [constant_1.LegendStateValue.unSelectedHover]: {}
};

(0, register_1.loadDiscreteLegendComponent)();

class DiscreteLegend extends base_1.LegendBase {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, DiscreteLegend.defaultAttributes, attributes)), 
        this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, 
        this._itemHeight = 0, this._itemMaxWidth = 0, this._onHover = e => {
            const target = e.target;
            if (target && target.name && target.name.startsWith(constant_1.LEGEND_ELEMENT_NAME.item)) {
                const legendItem = target.delegate;
                if (this._lastActiveItem) {
                    if (this._lastActiveItem.id === legendItem.id) return;
                    this._unHover(this._lastActiveItem, e);
                }
                this._hover(legendItem, e);
            } else this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
        }, this._onUnHover = e => {
            this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
        }, this._onClick = e => {
            var _a, _b, _c, _d;
            const target = e.target;
            if (target && target.name && target.name.startsWith(constant_1.LEGEND_ELEMENT_NAME.item)) {
                const legendItem = target.delegate;
                if (target.name === constant_1.LEGEND_ELEMENT_NAME.focus) {
                    const isFocusSelected = legendItem.hasState(constant_1.LegendStateValue.focus);
                    legendItem.toggleState(constant_1.LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item => {
                        this._removeLegendItemState(item, [ constant_1.LegendStateValue.unSelected, constant_1.LegendStateValue.unSelectedHover, constant_1.LegendStateValue.focus ], e), 
                        this._setLegendItemState(item, constant_1.LegendStateValue.selected, e);
                    })) : (this._setLegendItemState(legendItem, constant_1.LegendStateValue.selected, e), 
                    this._removeLegendItemState(legendItem, [ constant_1.LegendStateValue.unSelected, constant_1.LegendStateValue.unSelectedHover ], e), 
                    null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach((item => {
                        legendItem !== item && (this._removeLegendItemState(item, [ constant_1.LegendStateValue.selected, constant_1.LegendStateValue.selectedHover, constant_1.LegendStateValue.focus ], e), 
                        this._setLegendItemState(item, constant_1.LegendStateValue.unSelected, e));
                    })));
                } else {
                    null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach((item => {
                        item.removeState(constant_1.LegendStateValue.focus);
                    }));
                    const {selectMode: selectMode = "multiple", allowAllCanceled: allowAllCanceled = !0} = this.attribute, isSelected = legendItem.hasState(constant_1.LegendStateValue.selected), currentSelectedItems = this._getSelectedLegends();
                    if ("multiple" === selectMode) {
                        if (!1 === allowAllCanceled && isSelected && 1 === currentSelectedItems.length) return void this._dispatchLegendEvent(constant_1.LegendEvent.legendItemClick, legendItem, e);
                        isSelected ? (this._removeLegendItemState(legendItem, [ constant_1.LegendStateValue.selected, constant_1.LegendStateValue.selectedHover ], e), 
                        this._setLegendItemState(legendItem, constant_1.LegendStateValue.unSelected, e)) : (this._setLegendItemState(legendItem, constant_1.LegendStateValue.selected, e), 
                        this._removeLegendItemState(legendItem, [ constant_1.LegendStateValue.unSelected, constant_1.LegendStateValue.unSelectedHover ], e));
                    } else this._setLegendItemState(legendItem, constant_1.LegendStateValue.selected, e), 
                    this._removeLegendItemState(legendItem, [ constant_1.LegendStateValue.unSelected, constant_1.LegendStateValue.unSelectedHover ], e), 
                    null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach((item => {
                        legendItem !== item && (this._removeLegendItemState(item, [ constant_1.LegendStateValue.selected, constant_1.LegendStateValue.selectedHover ], e), 
                        this._setLegendItemState(item, constant_1.LegendStateValue.unSelected, e));
                    }));
                }
                this._dispatchLegendEvent(constant_1.LegendEvent.legendItemClick, legendItem, e);
            }
        };
    }
    setSelected(selectedData) {
        var _a;
        (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach((item => {
            const itemData = item.data;
            selectedData.includes(itemData.label) ? (this._setLegendItemState(item, constant_1.LegendStateValue.selected), 
            this._removeLegendItemState(item, [ constant_1.LegendStateValue.unSelected, constant_1.LegendStateValue.unSelectedHover ])) : (this._removeLegendItemState(item, [ constant_1.LegendStateValue.selected, constant_1.LegendStateValue.selectedHover ]), 
            this._setLegendItemState(item, constant_1.LegendStateValue.unSelected));
        }));
    }
    _renderContent() {
        const {item: item = {}, items: items, reversed: reversed, maxCol: maxCol = 1, maxRow: maxRow = 2} = this.attribute;
        if (!1 === item.visible || (0, vutils_1.isEmpty)(items)) return;
        let legendItems = items;
        reversed && (legendItems = null == items ? void 0 : items.reverse());
        const itemsContainer = vrender_core_1.graphicCreator.group({
            x: 0,
            y: 0
        });
        this._itemsContainer = itemsContainer;
        const {layout: layout, maxWidth: maxWidth, maxHeight: maxHeight, defaultSelected: defaultSelected = [], autoPage: autoPage} = this.attribute, isHorizontal = "horizontal" === layout, {spaceCol: spaceCol = constant_1.DEFAULT_ITEM_SPACE_COL, spaceRow: spaceRow = constant_1.DEFAULT_ITEM_SPACE_ROW, maxWidth: maxItemWidth, width: itemWidth, height: itemHeight} = item;
        (0, vutils_1.isValid)(maxItemWidth) ? (0, vutils_1.isValid)(itemWidth) ? this._itemWidthByUser = Math.min(maxItemWidth, itemWidth) : this._itemWidthByUser = maxItemWidth : (0, 
        vutils_1.isValid)(itemWidth) && (this._itemWidthByUser = itemWidth), (0, vutils_1.isValid)(itemHeight) && (this._itemHeightByUser = itemHeight);
        let doWrap = !1, maxWidthInCol = 0, startX = 0, startY = 0, maxPages = 1, pages = 1;
        legendItems.forEach(((item, index) => {
            item.id || (item.id = item.label), item.index = index;
            const itemGroup = this._renderEachItem(item, !!(0, vutils_1.isEmpty)(defaultSelected) || (null == defaultSelected ? void 0 : defaultSelected.includes(item.label)), index, legendItems), itemWidth = itemGroup.attribute.width, itemHeight = itemGroup.attribute.height;
            this._itemHeight = Math.max(this._itemHeight, itemHeight), maxWidthInCol = Math.max(itemWidth, maxWidthInCol), 
            this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth), isHorizontal ? (maxPages = maxRow, 
            (0, vutils_1.isValid)(maxWidth) && (itemWidth >= maxWidth ? (doWrap = !0, index > 0 && (startX = 0, 
            startY += itemHeight + spaceRow, pages += 1)) : maxWidth < startX + itemWidth && (doWrap = !0, 
            startX = 0, startY += itemHeight + spaceRow, pages += 1)), index > 0 && itemGroup.setAttributes({
                x: startX,
                y: startY
            }), startX += spaceCol + itemWidth) : (maxPages = maxCol, (0, vutils_1.isValid)(maxHeight) && maxHeight < startY + itemHeight && (doWrap = !0, 
            startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0, pages += 1), 
            index > 0 && itemGroup.setAttributes({
                x: startX,
                y: startY
            }), startY += spaceRow + itemHeight), itemsContainer.add(itemGroup);
        }));
        let pagerRendered = !1;
        doWrap && autoPage && pages > maxPages && (pagerRendered = this._renderPager(isHorizontal)), 
        pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + (0, 
        vutils_1.get)(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) return;
        if (!this._itemsContainer) return;
        const {hover: hover = !0, select: select = !0} = this.attribute;
        hover && (this._itemsContainer.addEventListener("pointermove", this._onHover), this._itemsContainer.addEventListener("pointerleave", this._onUnHover)), 
        select && this._itemsContainer.addEventListener("pointerdown", this._onClick);
    }
    _renderEachItem(item, isSelected, index, items) {
        var _a, _b;
        const {id: id, label: label, value: value, shape: shape} = item, {padding: padding = 0, focus: focus, focusIconStyle: focusIconStyle} = this.attribute.item, {shape: shapeAttr, label: labelAttr, value: valueAttr, background: background} = this.attribute.item, shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items), labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items), valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items), backgroundStyle = this._handleStyle(background, item, isSelected, index, items), parsedPadding = (0, 
        vutils_1.normalizePadding)(padding);
        let itemGroup;
        !1 === background.visible ? (itemGroup = vrender_core_1.graphicCreator.group({
            x: 0,
            y: 0,
            cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
        }), this._appendDataToShape(itemGroup, constant_1.LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = vrender_core_1.graphicCreator.group(Object.assign({
            x: 0,
            y: 0
        }, backgroundStyle.style)), this._appendDataToShape(itemGroup, constant_1.LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), 
        itemGroup.id = `${null != id ? id : label}-${index}`, itemGroup.addState(isSelected ? constant_1.LegendStateValue.selected : constant_1.LegendStateValue.unSelected);
        const innerGroup = vrender_core_1.graphicCreator.group({
            x: 0,
            y: 0,
            pickable: !1
        });
        itemGroup.add(innerGroup);
        let focusShape, focusStartX = 0, shapeSize = 0, shapeSpace = 0;
        if (shapeAttr && !1 !== shapeAttr.visible) {
            const s = (0, vutils_1.get)(shapeStyle, "style.size", constant_1.DEFAULT_SHAPE_SIZE);
            shapeSize = (0, vutils_1.isArray)(s) ? s[0] || 0 : s, shapeSpace = (0, vutils_1.get)(shapeAttr, "space", constant_1.DEFAULT_SHAPE_SPACE);
            const itemShape = vrender_core_1.graphicCreator.symbol(Object.assign(Object.assign({
                x: 0,
                y: 0,
                symbolType: "circle",
                strokeBoundsBuffer: 0
            }, shape), shapeStyle.style));
            Object.keys(shapeStyle.state || {}).forEach((key => {
                const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
                shape.fill && (0, vutils_1.isNil)(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), 
                shape.stroke && (0, vutils_1.isNil)(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
            })), this._appendDataToShape(itemShape, constant_1.LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), 
            itemShape.addState(isSelected ? constant_1.LegendStateValue.selected : constant_1.LegendStateValue.unSelected), 
            innerGroup.add(itemShape);
        }
        let focusSpace = 0;
        if (focus) {
            const focusSize = (0, vutils_1.get)(focusIconStyle, "size", constant_1.DEFAULT_SHAPE_SIZE);
            focusShape = vrender_core_1.graphicCreator.symbol(Object.assign(Object.assign({
                x: 0,
                y: -focusSize / 2 - 1,
                strokeBoundsBuffer: 0
            }, focusIconStyle), {
                visible: !0,
                pickMode: "imprecise",
                boundsPadding: parsedPadding
            })), this._appendDataToShape(focusShape, constant_1.LEGEND_ELEMENT_NAME.focus, item, itemGroup), 
            focusSpace = focusSize;
        }
        const labelShape = vrender_core_1.graphicCreator.text(Object.assign(Object.assign({
            x: shapeSize / 2 + shapeSpace,
            y: 0,
            textAlign: "start",
            textBaseline: "middle",
            lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
        }, labelStyle.style), {
            text: labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label
        }));
        this._appendDataToShape(labelShape, constant_1.LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), 
        labelShape.addState(isSelected ? constant_1.LegendStateValue.selected : constant_1.LegendStateValue.unSelected), 
        innerGroup.add(labelShape);
        const labelSpace = (0, vutils_1.get)(labelAttr, "space", constant_1.DEFAULT_LABEL_SPACE);
        if ((0, vutils_1.isValid)(value)) {
            const valueSpace = (0, vutils_1.get)(valueAttr, "space", focus ? constant_1.DEFAULT_VALUE_SPACE : 0), valueShape = vrender_core_1.graphicCreator.text(Object.assign(Object.assign({
                x: 0,
                y: 0,
                textAlign: "start",
                textBaseline: "middle",
                lineHeight: valueStyle.style.fontSize
            }, valueStyle.style), {
                text: valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value
            }));
            if (this._appendDataToShape(valueShape, constant_1.LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), 
            valueShape.addState(isSelected ? constant_1.LegendStateValue.selected : constant_1.LegendStateValue.unSelected), 
            this._itemWidthByUser) {
                const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace, valueBounds = valueShape.AABBBounds, labelBounds = labelShape.AABBBounds, valueWidth = valueBounds.width(), labelWidth = labelBounds.width();
                labelWidth > layoutWidth ? (layoutWidth - valueWidth) / labelWidth > .4 ? labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : (valueShape.setAttribute("maxLineWidth", .5 * layoutWidth), 
                labelShape.setAttribute("maxLineWidth", .5 * layoutWidth)) : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth), 
                valueAttr.alignRight ? valueShape.setAttributes({
                    textAlign: "right",
                    x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
                }) : valueShape.setAttribute("x", labelShape.AABBBounds.x2 + valueSpace);
            } else valueShape.setAttribute("x", labelShape.AABBBounds.x2 + valueSpace);
            focusStartX = valueShape.AABBBounds.x2 + valueSpace, innerGroup.add(valueShape);
        } else this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), 
        focusStartX = labelShape.AABBBounds.x2 + labelSpace) : focusStartX = labelShape.AABBBounds.x2 + labelSpace;
        focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
        const innerGroupBounds = innerGroup.AABBBounds, innerGroupWidth = innerGroupBounds.width(), innerGroupHeight = innerGroupBounds.height(), itemGroupWidth = (0, 
        vutils_1.isValid)(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3], itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
        return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, 
        focusShape && focusShape.setAttribute("visible", !1), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), 
        itemGroup;
    }
    _renderPager(isHorizontal) {
        const renderStartY = this._title ? this._title.AABBBounds.height() + (0, vutils_1.get)(this.attribute, "title.space", 8) : 0, {maxWidth: maxWidth, maxHeight: maxHeight, maxCol: maxCol = 1, maxRow: maxRow = 2, item: item = {}, pager: pager = {}, disableTriggerEvent: disableTriggerEvent} = this.attribute, {spaceCol: spaceCol = constant_1.DEFAULT_ITEM_SPACE_COL, spaceRow: spaceRow = constant_1.DEFAULT_ITEM_SPACE_ROW} = item, itemsContainer = this._itemsContainer, {animation: animation = !0, animationDuration: animationDuration = 450, animationEasing: animationEasing = "quadIn", space: pagerSpace = constant_1.DEFAULT_PAGER_SPACE, position: position = "middle"} = pager, pageStyle = __rest(pager, [ "animation", "animationDuration", "animationEasing", "space", "position" ]);
        let pagerComp, pageHeight = 0, pageWidth = 0, startX = 0, startY = 0, pages = 1;
        if (isHorizontal) {
            if (pagerComp = new pager_1.Pager(Object.assign(Object.assign({
                layout: 1 === maxRow ? "horizontal" : "vertical",
                total: 99
            }, (0, vutils_1.merge)({
                handler: {
                    preShape: "triangleUp",
                    nextShape: "triangleDown"
                }
            }, pageStyle)), {
                disableTriggerEvent: disableTriggerEvent
            })), this._pager = pagerComp, this._innerView.add(pagerComp), pageHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, 
            pageWidth = maxWidth - pagerComp.AABBBounds.width() - pagerSpace, pageWidth <= 0) return this._innerView.removeChild(pagerComp), 
            !1;
            let y;
            itemsContainer.getChildren().forEach(((item, index) => {
                const {width: width, height: height} = item.attribute;
                pageWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), 
                index > 0 && item.setAttributes({
                    x: startX,
                    y: startY
                }), startX += spaceCol + width;
            })), pagerComp.setAttribute("total", Math.ceil(pages / maxRow)), y = "start" === position ? renderStartY : "end" === position ? renderStartY + pageHeight - pagerComp.AABBBounds.height() / 2 : renderStartY + pageHeight / 2 - pagerComp.AABBBounds.height() / 2, 
            pagerComp.setAttributes({
                x: pageWidth,
                y: y
            });
        } else {
            if (pagerComp = new pager_1.Pager(Object.assign({
                layout: "horizontal",
                total: 99,
                disableTriggerEvent: disableTriggerEvent
            }, pageStyle)), this._pager = pagerComp, this._innerView.add(pagerComp), pageWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, 
            pageHeight = maxHeight - pagerComp.AABBBounds.height() - pagerSpace - renderStartY, 
            pageHeight <= 0) return this._innerView.removeChild(pagerComp), !1;
            let x;
            itemsContainer.getChildren().forEach(((item, index) => {
                const {height: height} = item.attribute;
                pageHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, 
                pages += 1), index > 0 && item.setAttributes({
                    x: startX,
                    y: startY
                }), startY += spaceRow + height;
            })), pagerComp.setAttribute("total", Math.ceil(pages / maxCol)), x = "start" === position ? 0 : "end" === position ? pageWidth - pagerComp.AABBBounds.width() : (pageWidth - pagerComp.AABBBounds.width()) / 2, 
            pagerComp.setAttributes({
                x: x,
                y: maxHeight - pagerComp.AABBBounds.height()
            });
        }
        pager.defaultCurrent > 1 && (isHorizontal ? itemsContainer.setAttribute("y", -(pager.defaultCurrent - 1) * (pageHeight + spaceRow)) : itemsContainer.setAttribute("x", -(pager.defaultCurrent - 1) * (pageWidth + spaceCol)));
        const clipGroup = vrender_core_1.graphicCreator.group({
            x: 0,
            y: renderStartY,
            width: pageWidth,
            height: pageHeight,
            clip: !0,
            pickable: !1
        });
        clipGroup.add(itemsContainer), this._innerView.add(clipGroup);
        const onPaging = e => {
            const {current: current} = e.detail;
            animation ? itemsContainer.animate().to(isHorizontal ? {
                y: -(current - 1) * (pageHeight + spaceRow)
            } : {
                x: -(current - 1) * (pageWidth + spaceCol)
            }, animationDuration, animationEasing) : isHorizontal ? itemsContainer.setAttribute("y", -(current - 1) * (pageHeight + spaceRow)) : itemsContainer.setAttribute("x", -(current - 1) * (pageWidth + spaceCol));
        };
        return this._pager.addEventListener("toPrev", onPaging), this._pager.addEventListener("toNext", onPaging), 
        !0;
    }
    _hover(legendItem, e) {
        this._lastActiveItem = legendItem;
        legendItem.hasState(constant_1.LegendStateValue.selected) ? this._setLegendItemState(legendItem, constant_1.LegendStateValue.selectedHover, e) : this._setLegendItemState(legendItem, constant_1.LegendStateValue.unSelectedHover, e);
        const focusButton = legendItem.getChildren()[0].find((node => node.name === constant_1.LEGEND_ELEMENT_NAME.focus), !1);
        focusButton && focusButton.setAttribute("visible", !0), this._dispatchLegendEvent(constant_1.LegendEvent.legendItemHover, legendItem, e);
    }
    _unHover(legendItem, e) {
        let attributeUpdate = !1;
        (legendItem.hasState(constant_1.LegendStateValue.unSelectedHover) || legendItem.hasState(constant_1.LegendStateValue.selectedHover)) && (attributeUpdate = !0), 
        legendItem.removeState(constant_1.LegendStateValue.unSelectedHover), legendItem.removeState(constant_1.LegendStateValue.selectedHover), 
        legendItem.getChildren()[0].getChildren().forEach((child => {
            attributeUpdate || !child.hasState(constant_1.LegendStateValue.unSelectedHover) && !child.hasState(constant_1.LegendStateValue.selectedHover) || (attributeUpdate = !0), 
            child.removeState(constant_1.LegendStateValue.unSelectedHover), child.removeState(constant_1.LegendStateValue.selectedHover);
        }));
        const focusButton = legendItem.getChildren()[0].find((node => node.name === constant_1.LEGEND_ELEMENT_NAME.focus), !1);
        focusButton && focusButton.setAttribute("visible", !1), attributeUpdate && this._dispatchLegendEvent(constant_1.LegendEvent.legendItemAttributeUpdate, legendItem, e), 
        this._dispatchLegendEvent(constant_1.LegendEvent.legendItemUnHover, legendItem, e);
    }
    _setLegendItemState(legendItem, stateName, e) {
        let attributeUpdate = !1;
        legendItem.hasState(stateName) || (attributeUpdate = !0), legendItem.addState(stateName, true), 
        legendItem.getChildren()[0].getChildren().forEach((child => {
            child.name !== constant_1.LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = !0), 
            child.addState(stateName, true));
        })), attributeUpdate && this._dispatchLegendEvent(constant_1.LegendEvent.legendItemAttributeUpdate, legendItem, e);
    }
    _removeLegendItemState(legendItem, stateNames, e) {
        let attributeUpdate = !1;
        stateNames.forEach((name => {
            !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = !0), legendItem.removeState(name);
        })), legendItem.getChildren()[0].getChildren().forEach((child => {
            child.name !== constant_1.LEGEND_ELEMENT_NAME.focus && stateNames.forEach((name => {
                !attributeUpdate && child.hasState(name) && (attributeUpdate = !0), child.removeState(name);
            }));
        })), attributeUpdate && this._dispatchLegendEvent(constant_1.LegendEvent.legendItemAttributeUpdate, legendItem, e);
    }
    _getSelectedLegends() {
        var _a;
        const selectedData = [];
        return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item => {
            item.hasState(constant_1.LegendStateValue.selected) && selectedData.push(item.data);
        })), selectedData;
    }
    _appendDataToShape(shape, name, data, delegateShape, states = {}) {
        shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = (0, 
        vutils_1.merge)({}, DEFAULT_STATES, states);
    }
    _dispatchLegendEvent(eventName, legendItem, event) {
        const currentSelectedItems = this._getSelectedLegends();
        currentSelectedItems.sort(((pre, next) => pre.index - next.index));
        const currentSelected = currentSelectedItems.map((obj => obj.label));
        this._dispatchEvent(eventName, {
            item: legendItem,
            data: legendItem.data,
            selected: legendItem.hasState(constant_1.LegendStateValue.selected),
            currentSelectedItems: currentSelectedItems,
            currentSelected: currentSelected,
            event: event
        });
    }
    _handleStyle(config, item, isSelected, index, items) {
        const newConfig = {};
        return config.style && ((0, vutils_1.isFunction)(config.style) ? newConfig.style = config.style(item, isSelected, index, items) : newConfig.style = config.style), 
        config.state && (newConfig.state = {}, Object.keys(config.state).forEach((key => {
            config.state[key] && ((0, vutils_1.isFunction)(config.state[key]) ? newConfig.state[key] = config.state[key](item, isSelected, index, items) : newConfig.state[key] = config.state[key]);
        }))), newConfig;
    }
}

exports.DiscreteLegend = DiscreteLegend, DiscreteLegend.defaultAttributes = {
    layout: "horizontal",
    title: {
        align: "start",
        space: constant_1.DEFAULT_TITLE_SPACE,
        textStyle: {
            fontSize: 12,
            fontWeight: "bold",
            fill: "#2C3542"
        }
    },
    item: {
        spaceCol: constant_1.DEFAULT_ITEM_SPACE_COL,
        spaceRow: constant_1.DEFAULT_ITEM_SPACE_ROW,
        shape: {
            space: constant_1.DEFAULT_SHAPE_SPACE,
            style: {
                size: constant_1.DEFAULT_SHAPE_SIZE,
                cursor: "pointer"
            },
            state: {
                selectedHover: {
                    opacity: .85
                },
                unSelected: {
                    opacity: .5
                }
            }
        },
        label: {
            space: constant_1.DEFAULT_LABEL_SPACE,
            style: {
                fontSize: 12,
                fill: "#2C3542",
                cursor: "pointer"
            },
            state: {
                selectedHover: {
                    opacity: .85
                },
                unSelected: {
                    fill: "#D8D8D8"
                }
            }
        },
        value: {
            alignRight: !1,
            style: {
                fontSize: 12,
                fill: "#ccc",
                cursor: "pointer"
            },
            state: {
                selectedHover: {
                    opacity: .85
                },
                unSelected: {
                    fill: "#D8D8D8"
                }
            }
        },
        background: {
            style: {
                cursor: "pointer"
            }
        },
        focus: !1,
        focusIconStyle: {
            size: constant_1.DEFAULT_SHAPE_SIZE,
            symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
            fill: "#333",
            cursor: "pointer"
        }
    },
    autoPage: !0,
    pager: {
        space: constant_1.DEFAULT_PAGER_SPACE,
        handler: {
            style: {
                size: 10
            },
            space: 4
        }
    },
    hover: !0,
    select: !0,
    selectMode: "multiple",
    allowAllCanceled: !0
};
//# sourceMappingURL=discrete.js.map
