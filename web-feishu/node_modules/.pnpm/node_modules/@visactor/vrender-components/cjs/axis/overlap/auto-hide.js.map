{"version":3,"sources":["../src/axis/overlap/auto-hide.ts"],"names":[],"mappings":"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","file":"auto-hide.js","sourcesContent":["/**\n * @description 自动隐藏\n */\n\nimport type { IText } from '@visactor/vrender-core';\nimport type { IBounds } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport { isEmpty, isFunction, isRectIntersect, isRotateAABBIntersect, last } from '@visactor/vutils';\nimport type { CustomMethod } from '../type';\nimport { genRotateBounds } from './util';\n\nfunction itemIntersect(item1: IText, item2: IText) {\n  return (\n    isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) &&\n    (item1.rotatedBounds && item2.rotatedBounds\n      ? isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true)\n      : true)\n  );\n}\n\nconst methods = {\n  parity: function (items: IText[]) {\n    return items.filter((item, i) => (i % 2 ? item.setAttribute('opacity', 0) : 1));\n  },\n  greedy: function (items: IText[], sep: number) {\n    let a: IText;\n    return items.filter((b, i) => {\n      if (!i || !intersect(a, b, sep)) {\n        a = b;\n        return 1;\n      }\n      return b.setAttribute('opacity', 0);\n    });\n  }\n};\n\nfunction intersect(textA: IText, textB: IText, sep: number) {\n  const a = textA.AABBBounds;\n  const b = textB.AABBBounds;\n  return (\n    sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2) &&\n    (textA.rotatedBounds && textB.rotatedBounds\n      ? sep >\n        Math.max(\n          textB.rotatedBounds.x1 - textA.rotatedBounds.x2,\n          textA.rotatedBounds.x1 - textB.rotatedBounds.x2,\n          textB.rotatedBounds.y1 - textA.rotatedBounds.y2,\n          textA.rotatedBounds.y1 - textB.rotatedBounds.y2\n        )\n      : true)\n  );\n}\n\nfunction hasOverlap(items: IText[], pad: number) {\n  for (let i = 1, n = items.length, a = items[0], b; i < n; a = b, ++i) {\n    if (intersect(a, (b = items[i]), pad)) {\n      return true;\n    }\n  }\n}\n\nfunction hasBounds(item: IText) {\n  const b = item.AABBBounds;\n  return b.width() > 1 && b.height() > 1;\n}\n\n// reset all items to be fully opaque\nfunction reset(items: IText[]) {\n  items.forEach(item => item.setAttribute('opacity', 1));\n  return items;\n}\n\ntype HideConfig = {\n  /**\n   * 轴的方向\n   */\n  orient: string;\n  /**\n   * 防重叠策略。\n   * - 'parity': 奇偶校验，使用删除所有其他标签的策略（这对于标准线性轴非常有效）。\n   * - 'greedy': 将执行标签的线性扫描，并删除与最后一个可见标签重叠的所有标签。\n   * - 也可以传入函数用于自定义策略\n   */\n  method?: 'parity' | 'greedy' | CustomMethod;\n  /**\n   * 设置文本之间的间隔距离，单位 px\n   */\n  separation?: number;\n  /**\n   * 保证最后的label展示\n   */\n  lastVisible?: boolean;\n};\n\nexport function autoHide(labels: IText[], config: HideConfig) {\n  if (isEmpty(labels)) {\n    return;\n  }\n\n  const source = labels.filter(hasBounds);\n  if (isEmpty(source)) {\n    return;\n  }\n\n  let items;\n\n  items = reset(source);\n\n  // 计算旋转包围盒\n  genRotateBounds(items);\n\n  const { method = 'parity', separation: sep = 0 } = config;\n\n  const reduce = isFunction(method) ? method : methods[method] || methods.parity;\n\n  if (items.length >= 3 && hasOverlap(items, sep)) {\n    do {\n      items = reduce(items, sep);\n    } while (items.length >= 3 && hasOverlap(items, sep));\n    /**\n     * 0.17.10 之前，当最后label个数小于3 的时候，才做最后的label强制显示的策略\n     */\n    const checkLast = items.length < 3 || config.lastVisible;\n\n    if (checkLast) {\n      const lastSourceItem = last(source);\n\n      if (!lastSourceItem.attribute.opacity) {\n        const remainLength = items.length;\n        if (remainLength > 1) {\n          lastSourceItem.setAttribute('opacity', 1);\n\n          for (let i = remainLength - 1; i >= 0; i--) {\n            if (intersect(items[i], lastSourceItem, sep)) {\n              items[i].setAttribute('opacity', 0);\n            } else {\n              // 当遇到第一个不相交的label的时候，就可以停止了\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  source.forEach(item => {\n    item.setAttribute('visible', !!item.attribute.opacity);\n  });\n}\n"]}