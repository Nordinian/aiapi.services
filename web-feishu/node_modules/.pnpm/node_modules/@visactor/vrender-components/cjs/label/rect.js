"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RectLabel = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("./base");

class RectLabel extends base_1.LabelBase {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, RectLabel.defaultAttributes, attributes));
    }
    labeling(textBounds, graphicBounds, position = "top", offset = 0) {
        if (!textBounds || !graphicBounds) return;
        const {x1: x1, y1: y1, x2: x2, y2: y2} = textBounds, width = Math.abs(x2 - x1), height = Math.abs(y2 - y1), rectWidth = Math.abs(graphicBounds.x2 - graphicBounds.x1), rectHeight = Math.abs(graphicBounds.y2 - graphicBounds.y1);
        let anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2, anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2, sx = 0, sy = 0;
        switch (position) {
          case "top":
          case "inside-top":
            sy = -.5;
            break;

          case "bottom":
          case "inside-bottom":
            sy = .5;
            break;

          case "left":
          case "inside-left":
            sx = -.5;
            break;

          case "right":
          case "inside-right":
            sx = .5;
            break;

          case "top-right":
            sx = .5, sy = -.5;
            break;

          case "top-left":
            sx = -.5, sy = -.5;
            break;

          case "bottom-right":
            sx = .5, sy = .5;
            break;

          case "bottom-left":
            sx = -.5, sy = .5;
        }
        anchorX += sx * rectWidth, anchorY += sy * rectHeight;
        let vx = 0, vy = 0;
        const isInside = position.includes("inside");
        switch (position.includes("top") ? vy = isInside ? 1 : -1 : position.includes("bottom") ? vy = isInside ? -1 : 1 : position.includes("left") ? vx = isInside ? 1 : -1 : position.includes("right") && (vx = isInside ? -1 : 1), 
        position) {
          case "top-right":
          case "bottom-right":
            vx = -1;
            break;

          case "top-left":
          case "bottom-left":
            vx = 1;
        }
        return {
            x: anchorX + vx * offset + vx * width / 2,
            y: anchorY + vy * offset + vy * height / 2
        };
    }
}

exports.RectLabel = RectLabel, RectLabel.tag = "rect-label", RectLabel.defaultAttributes = {
    textStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "center",
        textBaseline: "middle",
        boundsPadding: [ -1, 0, -1, 0 ]
    },
    position: "top",
    offset: 5,
    pickable: !1
};
//# sourceMappingURL=rect.js.map