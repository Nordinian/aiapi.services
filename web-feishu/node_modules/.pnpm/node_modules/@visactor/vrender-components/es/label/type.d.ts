import type { EasingType, IGraphic, IGroupGraphicAttribute, ITextGraphicAttribute, IRichTextGraphicAttribute, IText, TextAlignType, TextBaselineType, ILineGraphicAttribute, IRichTextCharacter, IRichText, ILine } from '@visactor/vrender-core';
import type { IPointLike } from '@visactor/vutils';
export type LabelItemStateStyle<T> = {
    hover?: T;
    hover_reverse?: T;
    selected?: T;
    selected_reverse?: T;
    [key: string]: T;
};
export type LabelItem = {
    id?: string;
    data?: any;
    [key: string]: any;
    textType?: string;
    text?: string | string[] | number | number[] | IRichTextCharacter[];
    textAlign?: 'left' | 'right' | 'center' | 'start' | 'end';
    textBaseline?: 'top' | 'middle' | 'bottom' | 'alphabetic';
} & Omit<Partial<ITextGraphicAttribute>, 'textAlign' | 'textBaseline'> & Omit<Partial<IRichTextGraphicAttribute>, 'textAlign' | 'textBaseline'>;
export interface BaseLabelAttrs extends IGroupGraphicAttribute {
    type: string;
    baseMarkGroupName: string;
    getBaseMarks?: () => IGraphic[];
    select?: boolean;
    hover?: boolean;
    data: LabelItem[];
    textStyle?: Partial<ITextGraphicAttribute>;
    state?: LabelItemStateStyle<ITextGraphicAttribute>;
    line?: ILabelLineSpec;
    labelLineState?: LabelItemStateStyle<ILineGraphicAttribute>;
    syncState?: boolean;
    position?: Functional<string>;
    offset?: number;
    overlap?: OverlapAttrs | boolean;
    smartInvert?: SmartInvertAttrs | boolean;
    animation?: ILabelAnimation | boolean;
    animationEnter?: ILabelUpdateAnimation;
    animationUpdate?: ILabelUpdateAnimation | ILabelUpdateChannelAnimation[];
    animationExit?: ILabelExitAnimation;
    dataFilter?: (data: LabelItem[]) => LabelItem[];
    customLayoutFunc?: (data: LabelItem[], getRelatedGraphic: (data: LabelItem) => IGraphic, getRelatedPoint?: (data: LabelItem) => IPointLike) => (IText | IRichText)[];
    customOverlapFunc?: (label: (IText | IRichText)[], getRelatedGraphic: (data: LabelItem) => IGraphic, getRelatedPoint?: (data: LabelItem) => IPointLike) => (IText | IRichText)[];
    disableTriggerEvent?: boolean;
    id?: string;
}
export interface OverlapAttrs {
    size?: {
        width: number;
        height: number;
    };
    hideOnHit?: boolean;
    clampForce?: boolean;
    avoidBaseMark?: boolean;
    avoidMarks?: string[] | IGraphic[];
    strategy?: Strategy[];
    overlapPadding?: number;
}
export interface SmartInvertAttrs {
    mode?: string;
    textType?: string;
    contrastRatiosThreshold?: number;
    alternativeColors?: string | string[];
    fillStrategy?: 'base' | 'invertBase' | 'similarBase' | 'null';
    strokeStrategy?: 'base' | 'invertBase' | 'similarBase' | 'null';
    brightColor?: string;
    darkColor?: string;
    outsideEnable?: boolean;
}
export type PositionStrategy = {
    type: 'position';
    position?: Functional<LabelPosition[]>;
};
export type BoundStrategy = {
    type: 'bound';
    position?: Functional<LabelPosition[]>;
};
export type MoveYStrategy = {
    type: 'moveY';
    offset: Functional<number[]>;
};
export type MoveXStrategy = {
    type: 'moveX';
    offset: Functional<number[]>;
};
export type Strategy = PositionStrategy | BoundStrategy | MoveYStrategy | MoveXStrategy;
export type LabelPosition = SymbolLabelAttrs['position'] | RectLabelAttrs['position'];
export interface SymbolLabelAttrs extends BaseLabelAttrs {
    type: 'symbol';
    position?: Functional<'top' | 'bottom' | 'left' | 'right' | 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'center'>;
}
export interface RectLabelAttrs extends BaseLabelAttrs {
    type: 'rect';
    position?: Functional<'top' | 'bottom' | 'left' | 'right' | 'inside' | 'inside-top' | 'inside-bottom' | 'inside-right' | 'inside-left' | 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'>;
}
export interface LineLabelAttrs extends BaseLabelAttrs {
    type: 'line';
    position?: Functional<'start' | 'end'>;
}
export interface AreaLabelAttrs extends BaseLabelAttrs {
    type: 'area';
    position?: Functional<'start' | 'end'>;
}
export interface LineDataLabelAttrs extends BaseLabelAttrs {
    type: 'line-data';
    position?: Functional<'top' | 'bottom' | 'left' | 'right' | 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'center'>;
}
export interface PolygonLabelAttrs extends BaseLabelAttrs {
    type: 'polygon';
    position?: Functional<'center'>;
}
export interface ArcLabelAttrs extends BaseLabelAttrs {
    type: 'arc';
    baseMarkGroupName: string;
    position?: Functional<'inside' | 'outside' | 'inside-inner' | 'inside-outer'>;
    width?: number;
    height?: number;
    coverEnable?: boolean;
    rotate?: boolean;
    spaceWidth?: number;
    angle?: number;
    offsetAngle?: number;
    offsetRadius?: number;
    textAlign?: TextAlignType;
    textBaseline?: TextBaselineType;
    layoutArcGap?: number;
    line?: IArcLabelLineSpec;
    layout?: IArcLabelLayoutSpec;
    points?: IPoint[];
    centerOffset?: number;
}
export interface ILabelLineSpec {
    visible?: boolean;
    style?: Partial<ILineGraphicAttribute>;
}
export interface IArcLabelLineSpec extends ILabelLineSpec {
    line1MinLength?: number;
    line2MinLength?: number;
    smooth?: boolean;
}
export type ArcLabelAlignType = 'arc' | 'labelLine' | 'edge';
export type ArcLabelStrategyType = 'priority' | 'vertical' | 'none';
export interface IArcLabelLayoutSpec {
    textAlign?: ArcLabelAlignType;
    align?: ArcLabelAlignType;
    strategy?: ArcLabelStrategyType;
    tangentConstraint?: boolean;
}
export interface DataLabelAttrs extends IGroupGraphicAttribute {
    dataLabels: (RectLabelAttrs | SymbolLabelAttrs | ArcLabelAttrs | LineDataLabelAttrs)[];
    size: {
        width: number;
        height: number;
    };
}
export type Functional<T> = T | ((data: any) => T);
export interface ILabelExitAnimation {
    duration?: number;
    delay?: number;
    easing?: EasingType;
}
export interface ILabelEnterAnimation extends ILabelExitAnimation {
    mode?: 'same-time' | 'after' | 'after-all';
}
export interface ILabelUpdateAnimation extends ILabelExitAnimation {
    increaseEffect?: boolean;
}
export interface ILabelUpdateChannelAnimation extends ILabelUpdateAnimation {
    channel?: string[];
    options?: {
        excludeChannels?: string[];
    };
}
export interface ILabelAnimation extends ILabelEnterAnimation, ILabelExitAnimation, ILabelUpdateAnimation {
}
export interface IPoint {
    x: number;
    y: number;
}
export interface IPolarPoint {
    radius: number;
    angle: number;
}
export type Quadrant = 1 | 2 | 3 | 4;
export type TextAlign = 'left' | 'right' | 'center';
export type LabelContent = {
    text: IText | IRichText;
    labelLine?: ILine;
};
