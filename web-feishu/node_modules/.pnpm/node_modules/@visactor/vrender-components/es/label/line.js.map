{"version":3,"sources":["../src/label/line.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAIzC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,kBAAkB,EAAE,MAAM,QAAQ,CAAC;AAG5C,MAAM,OAAO,SAAU,SAAQ,SAAyB;IAgBtD,YAAY,UAA0B,EAAE,OAA0B;QAChE,KAAK,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,EAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,EAAE,SAAS,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC,CAAC;QAhBhG,SAAI,GAAG,YAAY,CAAC;IAiBpB,CAAC;IAES,gBAAgB,CAAC,OAAc,EAAE,QAAmC,EAAE,EAAE,QAAQ,GAAG,KAAK;QAChG,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM,EAAE;YACvC,OAAO,KAAK,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SAC/C;QACD,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC;QACnD,MAAM,KAAK,GAAG,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAC3D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;YAClB,OAAO;SACR;QACD,OAAO;YACL,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAW;YAC7B,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAW;YAC7B,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAW;YAC7B,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAW;SAC9B,CAAC;IACJ,CAAC;IAES,QAAQ,CAAC,UAAuB,EAAE,aAA0B,EAAE,WAAmB,KAAK,EAAE,MAAM,GAAG,CAAC;QAC1G,OAAO,kBAAkB,CAAC,UAAU,EAAE,aAAa,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;IACzE,CAAC;;AApCM,2BAAiB,GAA4B;IAClD,SAAS,EAAE;QACT,QAAQ,EAAE,EAAE;QACZ,IAAI,EAAE,MAAM;QACZ,SAAS,EAAE,QAAQ;QACnB,YAAY,EAAE,QAAQ;QACtB,aAAa,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;KAC9B;IACD,QAAQ,EAAE,KAAK;IACf,MAAM,EAAE,CAAC;IACT,QAAQ,EAAE,KAAK;CAChB,CAAC","file":"line.js","sourcesContent":["import type { IBoundsLike } from '@visactor/vutils';\nimport { merge } from '@visactor/vutils';\nimport type { ILine } from '@visactor/vrender-core';\nimport type { PointLocationCfg } from '../core/type';\nimport type { LineLabelAttrs } from './type';\nimport { LabelBase } from './base';\nimport { labelingLineOrArea } from './util';\nimport type { ComponentOptions } from '../interface';\n\nexport class LineLabel extends LabelBase<LineLabelAttrs> {\n  name = 'line-label';\n\n  static defaultAttributes: Partial<LineLabelAttrs> = {\n    textStyle: {\n      fontSize: 12,\n      fill: '#000',\n      textAlign: 'center',\n      textBaseline: 'middle',\n      boundsPadding: [-1, 0, -1, 0] // to ignore the textBound buf\n    },\n    position: 'end',\n    offset: 6,\n    pickable: false\n  };\n\n  constructor(attributes: LineLabelAttrs, options?: ComponentOptions) {\n    super(options?.skipDefault ? attributes : merge({}, LineLabel.defaultAttributes, attributes));\n  }\n\n  protected getGraphicBounds(graphic: ILine, point: Partial<PointLocationCfg> = {}, position = 'end') {\n    if (!graphic || graphic.type !== 'line') {\n      return super.getGraphicBounds(graphic, point);\n    }\n    const points = graphic.attribute.points || [point];\n    const index = position === 'start' ? 0 : points.length - 1;\n    if (!points[index]) {\n      return;\n    }\n    return {\n      x1: points[index].x as number,\n      x2: points[index].x as number,\n      y1: points[index].y as number,\n      y2: points[index].y as number\n    };\n  }\n\n  protected labeling(textBounds: IBoundsLike, graphicBounds: IBoundsLike, position: string = 'end', offset = 0) {\n    return labelingLineOrArea(textBounds, graphicBounds, position, offset);\n  }\n}\n"]}