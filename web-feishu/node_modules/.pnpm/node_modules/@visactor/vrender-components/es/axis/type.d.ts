import type { IGraphicAttribute, ILineGraphicAttribute, SymbolType, ITextGraphicAttribute, ISymbolGraphicAttribute, IRectGraphicAttribute, IGroupGraphicAttribute, IText, IGroup } from '@visactor/vrender-core';
import type { Dict } from '@visactor/vutils';
import type { Point, TextContent } from '../core/type';
import type { SegmentAttributes } from '../segment';
import type { TagAttributes } from '../tag';
export type AxisItemStateStyle<T> = {
    hover?: T;
    hover_reverse?: T;
    selected?: T;
    selected_reverse?: T;
};
export type callbackFunc<T> = (datum: Dict<any>, index: number, data?: Dict<any>[], layer?: number) => T;
export type TickLineItem = {
    start: Point;
    end: Point;
    value: number;
    anchor?: [number, number];
    alpha?: number;
    beta?: number;
    [key: string]: any;
};
export type TransformedAxisItem = AxisItem & {
    point: Point;
};
export type AxisItem = {
    id?: string | number;
    label: string | number;
    value: number;
    rawValue: any;
    [key: string]: any;
};
export interface AxisBaseAttributes extends IGroupGraphicAttribute {
    select?: boolean;
    hover?: boolean;
    verticalFactor?: number;
    orient?: string;
    items: AxisItem[][];
    title?: TitleAttributes;
    label?: LabelAttributes;
    tick?: TickAttributes;
    subTick?: SubTickAttributes;
    line?: LineAttributes;
    disableTriggerEvent?: boolean;
}
export interface ILine3dType {
    alpha: number;
    anchor3d?: [number, number];
}
export interface LineAxisAttributes extends Omit<AxisBaseAttributes, 'label'> {
    start: Point;
    end: Point;
    verticalLimitSize?: number;
    verticalMinSize?: number;
    label?: LabelAttributes & {
        containerAlign?: 'left' | 'right' | 'center' | 'top' | 'bottom' | 'middle';
        flush?: boolean;
        lastVisible?: boolean;
    };
    panel?: {
        visible?: boolean;
        style?: Partial<IRectGraphicAttribute>;
        state?: AxisItemStateStyle<Partial<IRectGraphicAttribute>>;
    };
}
export interface CircleAxisAttributes extends AxisBaseAttributes {
    inside?: boolean;
    center: Point;
    startAngle?: number;
    endAngle?: number;
    radius: number;
    innerRadius?: number;
}
export type TitleAttributes = Omit<TagAttributes, 'shape' | 'space' | 'panel' | 'state'> & {
    visible?: boolean;
    position?: 'start' | 'middle' | 'end';
    space?: number;
    autoRotate?: boolean;
    shape?: {
        visible?: boolean;
        space?: number;
        style?: Omit<Partial<ISymbolGraphicAttribute>, 'visible'>;
    };
    background?: {
        visible?: boolean;
        style?: Omit<Partial<IRectGraphicAttribute>, 'visible' | 'width' | 'height'>;
    };
    state?: {
        text?: AxisItemStateStyle<Partial<ITextGraphicAttribute>>;
        shape?: AxisItemStateStyle<Partial<ISymbolGraphicAttribute>>;
        background?: AxisItemStateStyle<Partial<IRectGraphicAttribute>>;
    };
};
export interface LineAttributes extends Pick<SegmentAttributes, 'startSymbol' | 'endSymbol'> {
    visible?: boolean;
    breakRange?: [number, number];
    breakShape?: SymbolType | [SymbolType, SymbolType];
    breakShapeStyle?: Partial<IGraphicAttribute>;
    style?: Partial<ILineGraphicAttribute>;
    state?: AxisItemStateStyle<Partial<ILineGraphicAttribute>>;
}
export interface TickAttributes {
    visible: boolean;
    inside?: boolean;
    alignWithLabel?: boolean;
    length?: number;
    style?: Partial<ILineGraphicAttribute> | callbackFunc<Partial<ILineGraphicAttribute> | undefined>;
    state?: AxisItemStateStyle<Partial<ILineGraphicAttribute> | callbackFunc<Partial<ILineGraphicAttribute> | undefined>>;
    dataFilter?: (data: AxisItem[]) => AxisItem[];
}
export interface SubTickAttributes {
    visible: boolean;
    count?: number;
    inside?: boolean;
    length?: number;
    style?: Partial<ILineGraphicAttribute> | callbackFunc<Partial<ILineGraphicAttribute> | undefined>;
    state?: AxisItemStateStyle<Partial<ILineGraphicAttribute> | callbackFunc<Partial<ILineGraphicAttribute> | undefined>>;
}
export type CustomMethod = (items: IText[], separation: number) => IText[];
export interface AxisLabelOverlap {
    autoRotate?: boolean;
    autoRotateAngle?: number[];
    autoHide?: boolean;
    autoHideMethod?: 'parity' | 'greedy' | CustomMethod;
    autoHideSeparation?: number;
    autoLimit?: boolean;
    limitEllipsis?: string;
    layoutFunc?: (labels: IText[], labelData: AxisItem[], layer: number, axis: IGroup) => void;
}
export type LabelAttributes = Omit<AxisLabelOverlap, 'text'> & TextContent & {
    visible: boolean;
    inside?: boolean;
    space?: number;
    formatMethod?: (value: string, datum: Dict<any>, index: number, data?: Dict<any>[], layer?: number) => string;
    style?: Partial<ITextGraphicAttribute> | callbackFunc<Partial<ITextGraphicAttribute> | undefined>;
    state?: AxisItemStateStyle<Partial<ITextGraphicAttribute> | callbackFunc<Partial<ITextGraphicAttribute> | undefined>>;
    dataFilter?: (data: AxisItem[], layer: number) => AxisItem[];
};
