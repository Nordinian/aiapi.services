import { PointService, merge, polarToCartesian, mixin } from "@visactor/vutils";

import { BaseGrid } from "./base";

import { POLAR_START_ANGLE, POLAR_END_ANGLE } from "../../constant";

import { LineAxisMixin } from "../mixin/line";

import { loadLineAxisGridComponent } from "../register";

function getCirclePoints(center, count, radius, startAngle, endAngle) {
    const points = [], range = endAngle - startAngle;
    for (let i = 0; i < count; i++) {
        const angle = startAngle + i * range / count;
        points.push(polarToCartesian(center, radius, angle));
    }
    return points;
}

loadLineAxisGridComponent();

export class LineAxisGrid extends BaseGrid {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
    }
    _getGridPoint(gridType, point) {
        let gridPoints;
        if ("line" === gridType) {
            const {length: length} = this.attribute;
            gridPoints = [ point, this.getVerticalCoord(point, length, !0) ];
        } else if ("circle" === gridType || "polygon" === gridType) {
            const {center: center, sides: sides = 6, startAngle: startAngle = POLAR_START_ANGLE, endAngle: endAngle = POLAR_END_ANGLE} = this.attribute;
            gridPoints = getCirclePoints(center, sides, PointService.distancePP(center, point), startAngle, endAngle);
        }
        return gridPoints;
    }
    getGridAttribute(isSubGrid) {
        const {type: gridType, alignWithLabel: alignWithLabel = !0} = this.attribute;
        let tickSegment = 1;
        let gridAttribute;
        this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value);
        let items = [];
        if (isSubGrid) {
            gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
            const subGridItems = [], {count: subCount = 4} = this.attribute.subGrid || {};
            if (this.data.length >= 2) {
                const points = [];
                this.data.forEach((item => {
                    let tickValue = item.value;
                    if (!alignWithLabel) {
                        const value = item.value - tickSegment / 2;
                        if (this.isInValidValue(value)) return;
                        tickValue = value;
                    }
                    points.push({
                        value: tickValue
                    });
                }));
                for (let i = 0; i < points.length - 1; i++) {
                    const pre = points[i], next = points[i + 1];
                    subGridItems.push({
                        id: `sub-${i}-0`,
                        points: this._getGridPoint(gridType, this.getTickCoord(pre.value)),
                        datum: {}
                    });
                    for (let j = 0; j < subCount; j++) {
                        const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point = this.getTickCoord(value);
                        subGridItems.push({
                            id: `sub-${i}-${j + 1}`,
                            points: this._getGridPoint(gridType, point),
                            datum: {}
                        });
                    }
                    i === points.length - 2 && subGridItems.push({
                        id: `sub-${i}-${subCount + 1}`,
                        points: this._getGridPoint(gridType, this.getTickCoord(next.value)),
                        datum: {}
                    });
                }
                items = subGridItems;
            }
        } else {
            gridAttribute = this.attribute;
            const gridItems = [];
            this.data.forEach((item => {
                let {point: point} = item;
                if (!alignWithLabel) {
                    const value = item.value - tickSegment / 2;
                    if (this.isInValidValue(value)) return;
                    point = this.getTickCoord(value);
                }
                gridItems.push({
                    id: item.label,
                    datum: item,
                    points: this._getGridPoint(gridType, point)
                });
            })), items = gridItems;
        }
        return Object.assign(Object.assign({}, gridAttribute), {
            items: items
        });
    }
}

mixin(LineAxisGrid, LineAxisMixin);
//# sourceMappingURL=line.js.map
