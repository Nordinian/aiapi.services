var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { AABBBounds, Bounds, getRectIntersect, isArray, isBoolean, isEmpty, isValid, max, merge, normalizePadding, pi, rectInsideAnotherRect } from "@visactor/vutils";

import { AbstractComponent } from "../core/base";

import { loadPoptipComponent } from "./register";

const _tBounds = new AABBBounds;

loadPoptipComponent();

export class PopTip extends AbstractComponent {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, PopTip.defaultAttributes, attributes)), 
        this.name = "poptip", this.positionList = [ "top", "tl", "tr", "bottom", "bl", "br", "left", "lt", "lb", "right", "rt", "rb" ];
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const {titleStyle: titleStyle = {}, position: position, contentStyle: contentStyle = {}, panel: panel = {}, space: space = 4, minWidth: minWidth = 0, maxWidth: maxWidth = 1 / 0, padding: padding = 4, maxWidthPercent: maxWidthPercent, visible: visible, state: state, dx: dx = 0, dy: dy = 0} = this.attribute;
        let {title: title = "", content: content = ""} = this.attribute;
        title = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title) : title, 
        content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
        const parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("poptip-content", {
            x: 0,
            y: 0,
            zIndex: 1
        }, "group"), maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3], titleVisible = isValid(title) && !1 !== visible, titleAttrs = Object.assign(Object.assign({
            text: isArray(title) ? title : [ title ],
            visible: titleVisible
        }, titleStyle), {
            x: parsedPadding[3],
            y: parsedPadding[0],
            maxLineWidth: maxLineWidth,
            textAlign: "left",
            textBaseline: "top"
        }), titleShape = group.createOrUpdateChild("poptip-title", titleAttrs, "wrapText");
        isEmpty(null == state ? void 0 : state.title) || (titleShape.states = state.title);
        const titleBounds = titleShape.AABBBounds, titleHeight = titleBounds.height(), titleWidth = titleBounds.width();
        let height = titleHeight + space;
        titleVisible || (height = 0);
        const contentVisible = isValid(content) && !1 !== visible, contentAttrs = Object.assign(Object.assign({
            text: isArray(content) ? content : [ content ],
            visible: contentVisible
        }, contentStyle), {
            x: parsedPadding[3],
            y: parsedPadding[0] + height,
            maxLineWidth: maxLineWidth,
            textAlign: "left",
            textBaseline: "top"
        }), contentShape = group.createOrUpdateChild("poptip-content", contentAttrs, "wrapText");
        isEmpty(null == state ? void 0 : state.content) || (contentShape.states = state.content);
        const contentBounds = contentShape.AABBBounds, contentHeight = contentBounds.height(), contentWidth = contentBounds.width();
        contentVisible && (height += contentHeight);
        let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
        popTipWidth > maxWidth ? popTipWidth = maxWidth : popTipWidth < minWidth && (popTipWidth = minWidth);
        let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
        const {visible: bgVisible} = panel, backgroundStyle = __rest(panel, [ "visible" ]), symbolSize = null !== (_a = backgroundStyle.size) && void 0 !== _a ? _a : 12, spaceSize = isArray(symbolSize) ? [ symbolSize[0] + (null !== (_b = backgroundStyle.space) && void 0 !== _b ? _b : 0), symbolSize[1] + (null !== (_c = backgroundStyle.space) && void 0 !== _c ? _c : 0) ] : symbolSize + (null !== (_d = backgroundStyle.space) && void 0 !== _d ? _d : 0), lineWidth = null !== (_e = backgroundStyle.lineWidth) && void 0 !== _e ? _e : 1, range = this.stage ? [ null !== (_f = this.stage.viewWidth) && void 0 !== _f ? _f : this.stage.width, null !== (_g = this.stage.viewHeight) && void 0 !== _g ? _g : this.stage.height ] : void 0;
        if (range) {
            const b = this.AABBBounds, leftWidth = null !== (_h = this.attribute.x) && void 0 !== _h ? _h : b.x1, rightWidth = range[0] - b.x1;
            let maxSpace = Math.max(leftWidth, rightWidth);
            const buf = (isArray(symbolSize) ? symbolSize[0] : 12) + 3;
            if (maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent), maxSpace < popTipWidth) {
                popTipWidth = maxSpace;
                const buf = parsedPadding[1] + parsedPadding[3];
                titleShape.setAttribute("maxLineWidth", maxSpace - buf), contentShape.setAttribute("maxLineWidth", maxSpace - buf), 
                poptipHeight = parsedPadding[0] + parsedPadding[2], titleVisible && (poptipHeight += titleShape.AABBBounds.height() + space), 
                poptipHeight += contentShape.AABBBounds.height();
            }
        }
        const layout = "auto" === position;
        let maxBBoxI, maxBBoxSize = -1 / 0;
        for (let i = 0; i < this.positionList.length + 1; i++) {
            const p = layout ? this.positionList[i === this.positionList.length ? maxBBoxI : i] : position, {angle: angle, offset: offset, rectOffset: rectOffset} = this.getAngleAndOffset(p, popTipWidth, poptipHeight, isArray(spaceSize) ? spaceSize : [ spaceSize, spaceSize - lineWidth ]);
            if (isBoolean(bgVisible)) {
                const offsetX = (isArray(symbolSize) ? symbolSize[0] : symbolSize) / 4, bgSymbol = group.createOrUpdateChild("poptip-symbol-panel", Object.assign(Object.assign({}, backgroundStyle), {
                    visible: bgVisible && (contentVisible || titleVisible),
                    x: offsetX,
                    y: 0,
                    strokeBoundsBuffer: -1,
                    boundsPadding: -2,
                    anchor: [ 0, 0 ],
                    symbolType: "arrow2Left",
                    angle: angle,
                    dx: offset[0],
                    dy: offset[1],
                    size: symbolSize,
                    zIndex: -9
                }), "symbol");
                isEmpty(null == state ? void 0 : state.panel) || (bgSymbol.states = state.panel);
                const bgRect = group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
                    visible: bgVisible && (contentVisible || titleVisible),
                    x: 0,
                    y: 0,
                    width: popTipWidth,
                    height: poptipHeight,
                    zIndex: -8
                }), "rect");
                isEmpty(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
            }
            if (group.setAttributes({
                x: -offset[0] + dx,
                y: -offset[1] + dy
            }), !layout || !range) break;
            {
                _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
                const b = _tBounds, stageBounds = (new Bounds).setValue(0, 0, range[0], range[1]);
                if (rectInsideAnotherRect(b, stageBounds, !1)) break;
                {
                    const bbox = getRectIntersect(b, stageBounds, !1), size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
                    size > maxBBoxSize && (maxBBoxSize = size, maxBBoxI = i);
                }
            }
        }
    }
    getAngleAndOffset(position, width, height, size) {
        const sizeH = size[1] / 2;
        switch (position) {
          case "tl":
            return {
                angle: pi / 2 * 3,
                offset: [ width / 4, height + sizeH ],
                rectOffset: [ -width / 4, -height - size[1] ]
            };

          case "top":
            return {
                angle: pi / 2 * 3,
                offset: [ width / 2, height + sizeH ],
                rectOffset: [ 0, -height - size[1] ]
            };

          case "tr":
            return {
                angle: pi / 2 * 3,
                offset: [ width / 4 * 3, height + sizeH ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };

          case "rt":
            return {
                angle: 0,
                offset: [ -sizeH, height / 5 ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };

          case "right":
            return {
                angle: 0,
                offset: [ -sizeH, height / 2 ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };

          case "rb":
            return {
                angle: 0,
                offset: [ -sizeH, height / 5 * 4 ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };

          case "bl":
            return {
                angle: pi / 2,
                offset: [ width / 4, -sizeH ],
                rectOffset: [ -width / 4, -height - size[1] ]
            };

          case "bottom":
            return {
                angle: pi / 2,
                offset: [ width / 2, -sizeH ],
                rectOffset: [ 0, -height - size[1] ]
            };

          case "br":
            return {
                angle: pi / 2,
                offset: [ width / 4 * 3, -sizeH ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };

          case "lt":
            return {
                angle: pi,
                offset: [ width + sizeH, height / 5 ],
                rectOffset: [ -width / 4, -height - size[1] ]
            };

          case "left":
            return {
                angle: pi,
                offset: [ width + sizeH, height / 2 ],
                rectOffset: [ 0, -height - size[1] ]
            };

          case "lb":
            return {
                angle: pi,
                offset: [ width + sizeH, height / 5 * 4 ],
                rectOffset: [ width / 4 * 3, -height - size[1] ]
            };
        }
    }
}

PopTip.defaultAttributes = {
    position: "rt",
    visible: !0,
    title: null,
    content: null,
    titleStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
    },
    contentStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
    },
    maxWidthPercent: .8,
    space: 8,
    padding: 10
};
//# sourceMappingURL=poptip.js.map
