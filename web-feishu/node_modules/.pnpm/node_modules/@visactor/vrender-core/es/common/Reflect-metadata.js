export default (function(Reflect) {
    var target, previous;
    return function(exporter) {
        const hasOwn = Object.prototype.hasOwnProperty, supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", supportsCreate = "function" == typeof Object.create, supportsProto = {
            __proto__: []
        } instanceof Array, downLevel = !supportsCreate && !supportsProto, HashMap = {
            create: supportsCreate ? function() {
                return MakeDictionary(Object.create(null));
            } : supportsProto ? function() {
                return MakeDictionary({
                    __proto__: null
                });
            } : function() {
                return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
                return hasOwn.call(map, key);
            } : function(map, key) {
                return key in map;
            },
            get: downLevel ? function(map, key) {
                return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
                return map[key];
            }
        }, functionPrototype = Object.getPrototypeOf(Function), usePolyfill = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, _Map = usePolyfill || "function" != typeof Map || "function" != typeof Map.prototype.entries ? CreateMapPolyfill() : Map, Metadata = (usePolyfill || "function" != typeof Set || "function" != typeof Set.prototype.entries ? CreateSetPolyfill() : Set, 
        new (usePolyfill || "function" != typeof WeakMap ? CreateWeakMapPolyfill() : WeakMap));
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError;
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError;
            return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError;
            return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError;
            return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            let targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create) return;
                targetMetadata = new _Map, Metadata.set(O, targetMetadata);
            }
            let metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create) return;
                metadataMap = new _Map, targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
            const parent = OrdinaryGetPrototypeOf(O);
            return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, !1);
            return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            const parent = OrdinaryGetPrototypeOf(O);
            return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, !1);
            if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
        }
        function Type(x) {
            if (null === x) return 1;
            switch (typeof x) {
              case "undefined":
                return 0;

              case "boolean":
                return 2;

              case "string":
                return 3;

              case "symbol":
                return 4;

              case "number":
                return 5;

              case "object":
                return null === x ? 1 : 6;

              default:
                return 6;
            }
        }
        function IsUndefined(x) {
            return void 0 === x;
        }
        function IsNull(x) {
            return null === x;
        }
        function IsSymbol(x) {
            return "symbol" == typeof x;
        }
        function IsObject(x) {
            return "object" == typeof x ? null !== x : "function" == typeof x;
        }
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                return input;
            }
            const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (void 0 !== exoticToPrim) {
                const result = exoticToPrim.call(input, hint);
                if (IsObject(result)) throw new TypeError;
                return result;
            }
            return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
            if ("string" === hint) {
                const toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    const result = toString_1.call(O);
                    if (!IsObject(result)) return result;
                }
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                }
            } else {
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                }
                const toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    const result = toString_2.call(O);
                    if (!IsObject(result)) return result;
                }
            }
            throw new TypeError;
        }
        function ToBoolean(argument) {
            return !!argument;
        }
        function ToString(argument) {
            return "" + argument;
        }
        function ToPropertyKey(argument) {
            const key = ToPrimitive(argument, 3);
            return IsSymbol(key) ? key : ToString(key);
        }
        function IsCallable(argument) {
            return "function" == typeof argument;
        }
        function GetMethod(V, P) {
            const func = V[P];
            if (null != func) {
                if (!IsCallable(func)) throw new TypeError;
                return func;
            }
        }
        function OrdinaryGetPrototypeOf(O) {
            const proto = Object.getPrototypeOf(O);
            if ("function" != typeof O || O === functionPrototype) return proto;
            if (proto !== functionPrototype) return proto;
            const prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
            const constructor = prototypeProto.constructor;
            return "function" != typeof constructor || constructor === O ? proto : constructor;
        }
        function CreateMapPolyfill() {
            const cacheSentinel = {}, arraySentinel = [], MapIterator = function() {
                function MapIterator(keys, values, selector) {
                    this._index = 0, this._keys = keys, this._values = values, this._selector = selector;
                }
                return MapIterator.prototype["@@iterator"] = function() {
                    return this;
                }, MapIterator.prototype[iteratorSymbol] = function() {
                    return this;
                }, MapIterator.prototype.next = function() {
                    const index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        const result = this._selector(this._keys[index], this._values[index]);
                        return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, 
                        this._values = arraySentinel) : this._index++, {
                            value: result,
                            done: !1
                        };
                    }
                    return {
                        value: void 0,
                        done: !0
                    };
                }, MapIterator.prototype.throw = function(error) {
                    throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
                    error;
                }, MapIterator.prototype.return = function(value) {
                    return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
                    {
                        value: value,
                        done: !0
                    };
                }, MapIterator;
            }();
            return function() {
                function Map() {
                    this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
                }
                return Object.defineProperty(Map.prototype, "size", {
                    get: function() {
                        return this._keys.length;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Map.prototype.has = function(key) {
                    return this._find(key, !1) >= 0;
                }, Map.prototype.get = function(key) {
                    const index = this._find(key, !1);
                    return index >= 0 ? this._values[index] : void 0;
                }, Map.prototype.set = function(key, value) {
                    const index = this._find(key, !0);
                    return this._values[index] = value, this;
                }, Map.prototype.delete = function(key) {
                    const index = this._find(key, !1);
                    if (index >= 0) {
                        const size = this._keys.length;
                        for (let i = index + 1; i < size; i++) this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i];
                        return this._keys.length--, this._values.length--, key === this._cacheKey && (this._cacheKey = cacheSentinel, 
                        this._cacheIndex = -2), !0;
                    }
                    return !1;
                }, Map.prototype.clear = function() {
                    this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, 
                    this._cacheIndex = -2;
                }, Map.prototype.keys = function() {
                    return new MapIterator(this._keys, this._values, getKey);
                }, Map.prototype.values = function() {
                    return new MapIterator(this._keys, this._values, getValue);
                }, Map.prototype.entries = function() {
                    return new MapIterator(this._keys, this._values, getEntry);
                }, Map.prototype["@@iterator"] = function() {
                    return this.entries();
                }, Map.prototype[iteratorSymbol] = function() {
                    return this.entries();
                }, Map.prototype._find = function(key, insert) {
                    return this._cacheKey !== key && (this._cacheIndex = this._keys.indexOf(this._cacheKey = key)), 
                    this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, this._keys.push(key), 
                    this._values.push(void 0)), this._cacheIndex;
                }, Map;
            }();
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [ key, value ];
            }
        }
        function CreateSetPolyfill() {
            return function() {
                function Set() {
                    this._map = new _Map;
                }
                return Object.defineProperty(Set.prototype, "size", {
                    get: function() {
                        return this._map.size;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Set.prototype.has = function(value) {
                    return this._map.has(value);
                }, Set.prototype.add = function(value) {
                    return this._map.set(value, value), this;
                }, Set.prototype.delete = function(value) {
                    return this._map.delete(value);
                }, Set.prototype.clear = function() {
                    this._map.clear();
                }, Set.prototype.keys = function() {
                    return this._map.keys();
                }, Set.prototype.values = function() {
                    return this._map.values();
                }, Set.prototype.entries = function() {
                    return this._map.entries();
                }, Set.prototype["@@iterator"] = function() {
                    return this.keys();
                }, Set.prototype[iteratorSymbol] = function() {
                    return this.keys();
                }, Set;
            }();
        }
        function CreateWeakMapPolyfill() {
            const UUID_SIZE = 16, keys = HashMap.create(), rootKey = CreateUniqueKey();
            return function() {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                return WeakMap.prototype.has = function(target) {
                    const table = GetOrCreateWeakMapTable(target, !1);
                    return void 0 !== table && HashMap.has(table, this._key);
                }, WeakMap.prototype.get = function(target) {
                    const table = GetOrCreateWeakMapTable(target, !1);
                    return void 0 !== table ? HashMap.get(table, this._key) : void 0;
                }, WeakMap.prototype.set = function(target, value) {
                    return GetOrCreateWeakMapTable(target, !0)[this._key] = value, this;
                }, WeakMap.prototype.delete = function(target) {
                    const table = GetOrCreateWeakMapTable(target, !1);
                    return void 0 !== table && delete table[this._key];
                }, WeakMap.prototype.clear = function() {
                    this._key = CreateUniqueKey();
                }, WeakMap;
            }();
            function CreateUniqueKey() {
                let key;
                do {
                    key = "@@WeakMap@@" + CreateUUID();
                } while (HashMap.has(keys, key));
                return keys[key] = !0, key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create) return;
                    Object.defineProperty(target, rootKey, {
                        value: HashMap.create()
                    });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (let i = 0; i < size; ++i) buffer[i] = 255 * Math.random() | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(size)) : FillRandomBytes(new Uint8Array(size), size) : FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                const data = GenRandomBytes(UUID_SIZE);
                data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
                let result = "";
                for (let offset = 0; offset < UUID_SIZE; ++offset) {
                    const byte = data[offset];
                    4 !== offset && 6 !== offset && 8 !== offset || (result += "-"), byte < 16 && (result += "0"), 
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        function MakeDictionary(obj) {
            return obj.__ = void 0, delete obj.__, obj;
        }
        exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), 
        exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
    }((target = Reflect, function(key, value) {
        "function" != typeof target[key] && Object.defineProperty(target, key, {
            configurable: !0,
            writable: !0,
            value: value
        }), previous && previous(key, value);
    })), Reflect;
}({}));