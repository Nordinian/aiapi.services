{"version":3,"sources":["../src/render/contributions/render/contributions/symbol-contribution-render.ts"],"names":[],"mappings":"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","file":"symbol-contribution-render.js","sourcesContent":["import type {\n  IGraphicAttribute,\n  IContext2d,\n  IMarkAttribute,\n  ISymbol,\n  ISymbolGraphicAttribute,\n  IThemeAttribute,\n  ISymbolRenderContribution,\n  IDrawContext\n} from '../../../../interface';\nimport { getScaledStroke } from '../../../../common/canvas-utils';\nimport { defaultBaseBackgroundRenderContribution } from './base-contribution-render';\nimport { BaseRenderContributionTime } from '../../../../common/enums';\nimport { defaultBaseTextureRenderContribution } from './base-texture-contribution-render';\n\nexport class DefaultSymbolRenderContribution implements ISymbolRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    symbol: ISymbol,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    symbolAttribute: Required<ISymbolGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const parsedPath = symbol.getParsedPath();\n    // todo: 考虑使用path\n    if (!parsedPath) {\n      return;\n    }\n\n    const { outerBorder, innerBorder } = symbol.attribute;\n    const doOuterBorder = outerBorder && outerBorder.visible !== false;\n    const doInnerBorder = innerBorder && innerBorder.visible !== false;\n    if (!(doOuterBorder || doInnerBorder)) {\n      return;\n    }\n\n    const {\n      size = symbolAttribute.size,\n      opacity = symbolAttribute.opacity,\n      x: originX = symbolAttribute.x,\n      y: originY = symbolAttribute.y,\n      scaleX = symbolAttribute.scaleX,\n      scaleY = symbolAttribute.scaleY\n    } = symbol.attribute;\n\n    const doStrokeOuter = !!(outerBorder && outerBorder.stroke);\n    const doStrokeInner = !!(innerBorder && innerBorder.stroke);\n\n    if (doOuterBorder) {\n      const { distance = symbolAttribute.outerBorder.distance } = outerBorder;\n      const d = getScaledStroke(context, distance as number, context.dpr);\n\n      context.beginPath();\n      if (parsedPath.drawOffset(context, size, x, y, d) === false) {\n        context.closePath();\n      }\n\n      // shadow\n      context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute);\n\n      if (strokeCb) {\n        strokeCb(context, outerBorder, symbolAttribute.outerBorder);\n      } else if (doStrokeOuter) {\n        // 存在stroke\n        const lastOpacity = (symbolAttribute.outerBorder as any).opacity;\n        (symbolAttribute.outerBorder as any).opacity = opacity;\n        context.setStrokeStyle(\n          symbol,\n          outerBorder,\n          (originX - x) / scaleX,\n          (originY - y) / scaleY,\n          symbolAttribute.outerBorder as any\n        );\n        (symbolAttribute.outerBorder as any).opacity = lastOpacity;\n        context.stroke();\n      }\n    }\n\n    if (doInnerBorder) {\n      const { distance = symbolAttribute.innerBorder.distance } = innerBorder;\n      const d = getScaledStroke(context, distance as number, context.dpr);\n\n      context.beginPath();\n      if (parsedPath.drawOffset(context, size, x, y, -d) === false) {\n        context.closePath();\n      }\n\n      // shadow\n      context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute);\n\n      if (strokeCb) {\n        strokeCb(context, innerBorder, symbolAttribute.innerBorder);\n      } else if (doStrokeInner) {\n        // 存在stroke\n        const lastOpacity = (symbolAttribute.innerBorder as any).opacity;\n        (symbolAttribute.innerBorder as any).opacity = opacity;\n        context.setStrokeStyle(\n          symbol,\n          innerBorder,\n          (originX - x) / scaleX,\n          (originY - y) / scaleY,\n          symbolAttribute.innerBorder as any\n        );\n        (symbolAttribute.innerBorder as any).opacity = lastOpacity;\n        context.stroke();\n      }\n    }\n  }\n}\n\nexport const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();\nexport const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;\nexport const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;\n"]}