var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

import { injectable } from "../../../common/inversify-lite";

import { AABBBounds, pi2 } from "@visactor/vutils";

import { graphicCreator, mat3Tomat4, multiplyMat4Mat4 } from "../../../graphic";

import { mat4Allocate } from "../../../allocator/matrix-allocate";

import { ARC3D_NUMBER_TYPE } from "../../../graphic/constants";

export const DrawItemInterceptor = Symbol.for("DrawItemInterceptor");

const tempDirtyBounds = new AABBBounds;

export class ShadowRootDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), 
        !1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return graphic.attribute.shadowRootIdx < 0 && this.drawItem(graphic, renderService, drawContext, drawContribution, params), 
        !1;
    }
    drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.shadowRoot) return !1;
        const {context: context} = drawContext;
        if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), 
        drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
            tempDirtyBounds.copy(drawContribution.dirtyBounds);
            const m = graphic.globalTransMatrix.getInverse();
            drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);
        }
        return drawContribution.renderGroup(graphic.shadowRoot, drawContext, graphic.parent.globalTransMatrix), 
        context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), 
        !0;
    }
}

export class DebugDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params), 
        !1;
    }
    drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.attribute._debug_bounds) return !1;
        const {context: context} = drawContext;
        context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), 
        graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, !0);
        const b = graphic.AABBBounds;
        return !0 !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), 
        context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), 
        !0;
    }
}

let CommonDrawItemInterceptorContribution = class {
    constructor() {
        this.order = 1, this.interceptors = [ new ShadowRootDrawItemInterceptorContribution, new Canvas3DDrawItemInterceptor, new InteractiveDrawItemInterceptorContribution, new DebugDrawItemInterceptorContribution ];
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
        for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
    }
};

CommonDrawItemInterceptorContribution = __decorate([ injectable(), __metadata("design:paramtypes", []) ], CommonDrawItemInterceptorContribution);

export { CommonDrawItemInterceptorContribution };

export class InteractiveDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params));
    }
    beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
        let interactiveGraphic = graphic.interactiveGraphic;
        if (graphic.attribute.globalZIndex) {
            interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, 
            interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
                globalZIndex: 0,
                zIndex: graphic.attribute.globalZIndex
            }, !1, {
                skipUpdateCallback: !0
            }), drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
            if (interactiveLayer) {
                this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
            }
            return !0;
        }
        if (interactiveGraphic) {
            drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
            if (interactiveLayer) {
                this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
            }
            graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
        }
        return !1;
    }
    beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
        const baseGraphic = graphic.baseGraphic;
        if (baseGraphic) {
            this.processing = !0;
            const {context: context} = drawContext;
            return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, !0), 
            baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), 
            context.highPerformanceRestore(), this.processing = !1, !0;
        }
        return !1;
    }
    getShadowRoot(interactiveLayer) {
        var _a;
        let group = interactiveLayer.getElementById("_interactive_group");
        return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", 
        interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
    }
}

export class Canvas3DDrawItemInterceptor {
    constructor() {
        this.order = 1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
        drawContext.in3dInterceptor = !0;
        const {context: context, stage: stage} = renderService.drawParams;
        context.canvas;
        context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
        const m = context.currentMatrix;
        m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, 
        m.e /= context.dpr, m.f /= context.dpr;
        const matrix = mat4Allocate.allocate();
        mat3Tomat4(matrix, m);
        const lastModelMatrix = context.modelMatrix;
        if (lastModelMatrix) {
            if (matrix) {
                const m = mat4Allocate.allocate();
                context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
            }
        } else context.modelMatrix = matrix;
        if (context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer) {
            let isPie = !1, is3d = !1;
            if (graphic.forEachChildren((c => (isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie))), 
            graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {
                const children = graphic.getChildren(), sortedChildren = [ ...children ];
                sortedChildren.sort(((a, b) => {
                    var _a, _b, _c, _d;
                    let angle1 = ((null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2, angle2 = ((null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;
                    for (;angle1 < 0; ) angle1 += pi2;
                    for (;angle2 < 0; ) angle2 += pi2;
                    return angle2 - angle1;
                })), sortedChildren.forEach((c => {
                    c._next = null, c._prev = null;
                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {
                    graphic.appendChild(c);
                }));
                const m = graphic.parent.globalTransMatrix;
                drawContext.hack_pieFace = "outside", drawContribution.renderGroup(graphic, drawContext, m), 
                drawContext.hack_pieFace = "inside", drawContribution.renderGroup(graphic, drawContext, m), 
                drawContext.hack_pieFace = "top", drawContribution.renderGroup(graphic, drawContext, m), 
                graphic.removeAllChild(), children.forEach((c => {
                    c._next = null, c._prev = null;
                })), children.forEach((c => {
                    graphic.appendChild(c);
                }));
            } else if (is3d) {
                const children = graphic.getChildren(), zChildren = children.map((g => ({
                    ave_z: g.findFace().vertices.map((v => {
                        var _a;
                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                    })).reduce(((a, b) => a + b), 0),
                    g: g
                })));
                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {
                    i.g._next = null, i.g._prev = null;
                })), graphic.update(), zChildren.forEach((i => {
                    graphic.add(i.g);
                })), drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !0), 
                graphic.removeAllChild(), children.forEach((g => {
                    g._next = null, g._prev = null;
                })), graphic.update(), children.forEach((g => {
                    graphic.add(g);
                }));
            } else drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix);
        } else drawContribution.renderItem(graphic, drawContext);
        return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
}
//# sourceMappingURL=draw-interceptor.js.map
