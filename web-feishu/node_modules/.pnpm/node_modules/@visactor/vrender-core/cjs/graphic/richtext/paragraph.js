"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.seperateParagraph = void 0;

const utils_1 = require("../../common/utils"), utils_2 = require("./utils");

class Paragraph {
    constructor(text, newLine, character) {
        this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic";
        const lineHeight = (0, utils_1.calculateLineHeight)(character.lineHeight, this.fontSize);
        this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), 
        this.height = this.lineHeight;
        const {ascent: ascent, height: height, descent: descent, width: width} = (0, utils_2.measureTextCanvas)(text, character);
        let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
        this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), 
        deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, 
        this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, 
        this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, 
        this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), 
        this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, 
        this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", 
        this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, 
        this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, 
        this.height = this.widthOrigin, this.lineHeight = this.height);
    }
    updateWidth() {
        const {width: width} = (0, utils_2.measureTextCanvas)(this.text, this.character);
        this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, 
        this.width = this.heightOrigin, this.height = this.widthOrigin);
    }
    draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
        let text = this.text, left = this.left + deltaLeft;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) text = "...", direction = "vertical", baseline -= this.ellipsisWidth / 2; else {
            if ("hide" === this.ellipsis) return;
            if ("add" === this.ellipsis) text += "...", "right" === textAlign && (left -= this.ellipsisWidth); else if ("replace" === this.ellipsis) {
                const index = (0, utils_2.getStrByWithCanvas)(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
                if (text = text.slice(0, index), text += "...", "right" === textAlign) {
                    const {width: width} = (0, utils_2.measureTextCanvas)(this.text.slice(index), this.character);
                    "vertical" === direction || (left -= this.ellipsisWidth - width);
                }
            }
        }
        switch (this.character.script) {
          case "super":
            baseline -= this.ascent * (1 / 3);
            break;

          case "sub":
            baseline += this.descent / 2;
        }
        "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), 
        ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), 
        left = 0, baseline = 0), this.character.stroke && ((0, utils_2.applyStrokeStyle)(ctx, this.character), 
        ctx.strokeText(text, left, baseline)), (0, utils_2.applyFillStyle)(ctx, this.character), 
        this.character.fill && ctx.fillText(text, left, baseline), this.character.fill && ("boolean" == typeof this.character.lineThrough || "boolean" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), 
        this.character.lineThrough && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : "underline" === this.character.textDecoration ? ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : "line-through" === this.character.textDecoration && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), 
        "vertical" === direction && ctx.restore();
    }
    getWidthWithEllips(direction) {
        let text = this.text;
        const width = "vertical" === direction ? this.height : this.width;
        if ("hide" === this.ellipsis) return width;
        if ("add" === this.ellipsis) return width + this.ellipsisWidth;
        if ("replace" === this.ellipsis) {
            const index = (0, utils_2.getStrByWithCanvas)(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            text = text.slice(0, index), text += "...";
            const {width: measureWidth} = (0, utils_2.measureTextCanvas)(this.text.slice(index), this.character);
            return width + this.ellipsisWidth - measureWidth;
        }
        return width;
    }
}

function seperateParagraph(paragraph, index) {
    const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
    return [ new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, !0, paragraph.character) ];
}

exports.default = Paragraph, exports.seperateParagraph = seperateParagraph;
//# sourceMappingURL=paragraph.js.map
