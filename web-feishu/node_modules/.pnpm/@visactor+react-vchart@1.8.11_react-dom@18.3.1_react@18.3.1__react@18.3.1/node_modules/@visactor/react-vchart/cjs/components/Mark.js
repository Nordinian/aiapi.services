"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
}, __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
}, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Mark = void 0;

const react_1 = __importStar(require("react")), vutils_1 = require("@visactor/vutils"), view_1 = __importDefault(require("../context/view")), util_1 = require("../util"), Mark = props => {
    const context = (0, react_1.useContext)(view_1.default), id = react_1.default.useRef((0, 
    vutils_1.isNil)(props.id) ? (0, util_1.uid)("mark") : props.id), updateId = react_1.default.useRef(props.updateId);
    return props.updateId !== updateId.current && (updateId.current = props.updateId, 
    context && addOrUpdateMark(context, id.current, props)), (0, react_1.useEffect)((() => () => {
        context && removeMark(context, id.current);
    }), []), null;
};

exports.Mark = Mark;

const addOrUpdateMark = (view, id, props) => {
    var _a;
    if (!view.renderer) return;
    let mark = view.getMarkById(id);
    const {group: group, glyphType: glyphType, updateId: updateId} = props, others = __rest(props, [ "group", "glyphType", "updateId" ]);
    mark || (mark = view.mark(props.type, null !== (_a = props.group) && void 0 !== _a ? _a : view.rootMark, props.glyphType ? {
        glyphType: props.glyphType
    } : null).name(id)), mark.parse(others), view.runAsync();
}, removeMark = (view, id) => {
    if (view.renderer) {
        view.getMarkById(id);
        view.removeGrammar(id);
    }
};
//# sourceMappingURL=Mark.js.map