import { Bubble } from "./bubble";

import { isValid, debounce, throttle, get, isFunction } from "@visactor/vutils";

import { BASE_EVENTS, ChartEvent, Event_Bubble_Level, Event_Source_Type, VGRAMMAR_HOOK_EVENT } from "../constant/event";

const componentTypeMap = {
    cartesianAxis: "axis",
    "cartesianAxis-band": "axis",
    "cartesianAxis-linear": "axis",
    "cartesianAxis-time": "axis",
    polarAxis: "axis",
    "polarAxis-band": "axis",
    "polarAxis-linear": "axis",
    discreteLegend: "legend",
    continuousLegend: "legend",
    colorLegend: "legend",
    sizeLegend: "legend",
    label: "label"
};

export class EventDispatcher {
    constructor(vchart, compiler) {
        this._viewBubbles = new Map, this._windowBubbles = new Map, this._canvasBubbles = new Map, 
        this._viewListeners = new Map, this._windowListeners = new Map, this._canvasListeners = new Map, 
        this.globalInstance = vchart, this._compiler = compiler;
    }
    register(eType, handler) {
        var _a, _b, _c, _d;
        this._parseQuery(handler);
        const bubbles = this.getEventBubble((null === (_a = handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
        bubbles.get(eType) || bubbles.set(eType, new Bubble);
        if (bubbles.get(eType).addHandler(handler, null === (_c = handler.filter) || void 0 === _c ? void 0 : _c.level), 
        this._isValidEvent(eType) && !listeners.has(eType)) {
            const callback = this._onDelegate.bind(this);
            this._compiler.addEventListener(null === (_d = handler.filter) || void 0 === _d ? void 0 : _d.source, eType, callback), 
            listeners.set(eType, callback);
        }
        return this;
    }
    unregister(eType, handler) {
        var _a, _b, _c, _d;
        let clean = !1;
        const bubbles = this.getEventBubble((null === (_a = null == handler ? void 0 : handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = null == handler ? void 0 : handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
        if (handler) {
            const bubble = bubbles.get(eType);
            null == bubble || bubble.removeHandler(handler), 0 === (null == bubble ? void 0 : bubble.getCount()) && (null == bubble || bubble.release(), 
            bubbles.delete(eType), clean = !0), (null === (_c = null == handler ? void 0 : handler.wrappedCallback) || void 0 === _c ? void 0 : _c.cancel) && handler.wrappedCallback.cancel();
        } else {
            const bubble = bubbles.get(eType);
            null == bubble || bubble.release(), bubbles.delete(eType), clean = !0;
        }
        if (clean && this._isValidEvent(eType)) {
            const callback = listeners.get(eType);
            this._compiler.removeEventListener((null === (_d = null == handler ? void 0 : handler.filter) || void 0 === _d ? void 0 : _d.source) || Event_Source_Type.chart, eType, callback), 
            listeners.delete(eType);
        }
        return this;
    }
    dispatch(eType, params, level) {
        const bubble = this.getEventBubble(params.source || Event_Source_Type.chart).get(eType);
        if (!bubble) return this;
        let stopBubble = !1;
        if (level) {
            const handlers = bubble.getHandlers(level);
            stopBubble = this._invoke(handlers, eType, params);
        } else {
            const handlers = bubble.getHandlers(Event_Bubble_Level.mark);
            if (stopBubble = this._invoke(handlers, eType, params), !stopBubble) {
                const handlers = bubble.getHandlers(Event_Bubble_Level.model);
                stopBubble = this._invoke(handlers, eType, params);
            }
            if (!stopBubble) {
                const handlers = bubble.getHandlers(Event_Bubble_Level.chart);
                stopBubble = this._invoke(handlers, eType, params);
            }
            if (!stopBubble) {
                const handlers = bubble.getHandlers(Event_Bubble_Level.vchart);
                stopBubble = this._invoke(handlers, eType, params);
            }
        }
        return this;
    }
    release() {
        for (const entry of this._viewListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.chart, entry[0], entry[1]);
        this._viewListeners.clear();
        for (const entry of this._windowListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.window, entry[0], entry[1]);
        this._windowListeners.clear();
        for (const entry of this._canvasListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.canvas, entry[0], entry[1]);
        this._canvasListeners.clear();
        for (const bubble of this._viewBubbles.values()) bubble.release();
        this._viewBubbles.clear();
        for (const bubble of this._windowBubbles.values()) bubble.release();
        this._windowBubbles.clear();
        for (const bubble of this._canvasBubbles.values()) bubble.release();
        this._canvasBubbles.clear();
    }
    _filter(filter, evt, params) {
        var _a, _b, _c;
        if (isFunction(filter.filter) && !filter.filter(params)) return !1;
        if (filter.nodeName && get(params, "node.name") !== filter.nodeName) return !1;
        if (filter.markName && (null === (_a = null == params ? void 0 : params.mark) || void 0 === _a ? void 0 : _a.name) !== filter.markName) return !1;
        let modelType = null === (_b = params.model) || void 0 === _b ? void 0 : _b.type;
        return componentTypeMap[modelType] && (modelType = componentTypeMap[modelType]), 
        (!filter.type || modelType === filter.type) && (!("mark" === filter.level && !filter.type && !(null == params ? void 0 : params.mark)) && (!("model" === filter.level && !filter.type && !(null == params ? void 0 : params.model)) && (!isValid(filter.userId) || (null === (_c = params.model) || void 0 === _c ? void 0 : _c.userId) === filter.userId)));
    }
    _prepareParams(filter, params) {
        if (filter.markName && params.mark && params.itemMap) {
            const markId = params.mark.getProductId(), item = params.itemMap.get(markId), datum = null == item ? void 0 : item.getDatum();
            return Object.assign(Object.assign({}, params), {
                item: item,
                datum: datum
            });
        }
        return Object.assign({}, params);
    }
    _onDelegate(listenerParams) {
        var _a;
        const chart = this.globalInstance.getChart(), model = isValid(listenerParams.modelId) && (null == chart ? void 0 : chart.getModelById(listenerParams.modelId)) || void 0, mark = isValid(listenerParams.markId) && (null == chart ? void 0 : chart.getMarkById(listenerParams.markId)) || null, itemMap = new Map;
        let targetMark = null === (_a = listenerParams.item) || void 0 === _a ? void 0 : _a.mark;
        for (targetMark && isValid(targetMark.id()) && itemMap.set(targetMark.id(), listenerParams.item); null == targetMark ? void 0 : targetMark.elements; ) {
            const id = targetMark.id();
            isValid(id) && !itemMap.has(id) && itemMap.set(id, targetMark.elements[0]), targetMark = targetMark.group;
        }
        const params = {
            event: listenerParams.event,
            item: listenerParams.item,
            datum: listenerParams.datum,
            source: listenerParams.source,
            itemMap: itemMap,
            chart: chart,
            model: model,
            mark: null != mark ? mark : void 0,
            node: get(listenerParams.event, "target")
        };
        this.dispatch(listenerParams.type, params);
    }
    _invoke(handlers, type, params) {
        return handlers.map((handler => {
            var _a, _b, _c;
            const filter = handler.filter;
            if (!handler.query || this._filter(filter, type, params)) {
                const stopBubble = (handler.wrappedCallback || handler.callback).call(null, this._prepareParams(filter, params)), doStopBubble = null != stopBubble ? stopBubble : null === (_a = handler.query) || void 0 === _a ? void 0 : _a.consume;
                return doStopBubble && (null === (_b = params.event) || void 0 === _b || _b.stopPropagation(), 
                null === (_c = params.event) || void 0 === _c || _c.preventDefault()), !!doStopBubble;
            }
        })).some((r => !0 === r));
    }
    _getQueryLevel(query) {
        return query ? query.level ? query.level : isValid(query.id) ? Event_Bubble_Level.model : Event_Bubble_Level.vchart : Event_Bubble_Level.vchart;
    }
    _parseQuery(handler) {
        var _a;
        const query = handler.query;
        (null == query ? void 0 : query.throttle) ? handler.wrappedCallback = throttle(handler.callback, query.throttle) : (null == query ? void 0 : query.debounce) && (handler.wrappedCallback = debounce(handler.callback, query.debounce));
        let level = this._getQueryLevel(query), type = null, source = Event_Source_Type.chart, nodeName = null, markName = null, userId = null;
        return (null == query ? void 0 : query.nodeName) && (nodeName = query.nodeName), 
        (null == query ? void 0 : query.markName) && (markName = query.markName), !(null == query ? void 0 : query.type) || level !== Event_Bubble_Level.model && level !== Event_Bubble_Level.mark || (type = query.type), 
        (null == query ? void 0 : query.source) && (source = query.source), isValid(null == query ? void 0 : query.id) && (userId = null == query ? void 0 : query.id, 
        level = Event_Bubble_Level.model), handler.filter = {
            level: level,
            markName: markName,
            type: type,
            source: source,
            nodeName: nodeName,
            userId: userId,
            filter: null !== (_a = null == query ? void 0 : query.filter) && void 0 !== _a ? _a : null
        }, handler;
    }
    getEventBubble(source) {
        switch (source) {
          case Event_Source_Type.chart:
            return this._viewBubbles;

          case Event_Source_Type.window:
            return this._windowBubbles;

          case Event_Source_Type.canvas:
            return this._canvasBubbles;

          default:
            return this._viewBubbles;
        }
    }
    getEventListeners(source) {
        switch (source) {
          case Event_Source_Type.chart:
            return this._viewListeners;

          case Event_Source_Type.window:
            return this._windowListeners;

          case Event_Source_Type.canvas:
            return this._canvasListeners;

          default:
            return this._viewListeners;
        }
    }
    _isValidEvent(eType) {
        return BASE_EVENTS.includes(eType) || Object.values(VGRAMMAR_HOOK_EVENT).includes(eType) || Object.values(ChartEvent).includes(eType);
    }
}