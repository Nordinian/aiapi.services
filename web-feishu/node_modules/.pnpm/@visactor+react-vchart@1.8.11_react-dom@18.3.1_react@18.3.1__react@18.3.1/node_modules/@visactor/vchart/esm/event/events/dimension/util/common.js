import { isNil, array, isValid, isValidNumber } from "@visactor/vutils";

import { isDiscrete } from "@visactor/vscale";

const isInBound = (pos, min, max) => pos.x >= min.x && pos.x <= max.x && pos.y >= min.y && pos.y <= max.y;

export const isInRegionBound = (chart, axis, pos) => {
    const regionList = chart.getRegionsInIds(array(axis.layout.layoutBindRegionID));
    return null == regionList ? void 0 : regionList.some((region => {
        const rect = region.getLayoutRect(), startPoint = region.getLayoutStartPoint();
        return isInBound(pos, {
            x: startPoint.x,
            y: startPoint.y
        }, {
            x: rect.width + startPoint.x,
            y: rect.height + startPoint.y
        });
    }));
};

export const isSameDimensionInfo = (a, b) => {
    var _a, _b;
    return a === b || !isNil(a) && !isNil(b) && (a.value === b.value && (null === (_a = a.axis) || void 0 === _a ? void 0 : _a.id) === (null === (_b = b.axis) || void 0 === _b ? void 0 : _b.id));
};

export const getDimensionData = (value, axis, coordinate, getDimensionField) => {
    var _a;
    const scale = axis.getScale(), isDiscreteAxis = isDiscrete(scale.type), data = [], regions = axis.getRegions();
    for (const region of regions) {
        const seriesList = region.getSeries();
        for (const series of seriesList) if (series.coordinate === coordinate) {
            const dimensionField = array(getDimensionField(series)), viewData = null === (_a = series.getViewData()) || void 0 === _a ? void 0 : _a.latestData;
            if (dimensionField && viewData) if (isDiscreteAxis) data.push({
                series: series,
                datum: viewData.filter((datum => {
                    var _a;
                    return (null === (_a = datum[dimensionField[0]]) || void 0 === _a ? void 0 : _a.toString()) === (null == value ? void 0 : value.toString());
                }))
            }); else if (isValid(dimensionField[1])) data.push({
                series: series,
                datum: viewData.filter((datum => {
                    var _a;
                    return (null === (_a = datum[dimensionField[0]]) || void 0 === _a ? void 0 : _a.toString()) === (null == value ? void 0 : value.toString()) || isValid(datum[dimensionField[0]]) && isValid(datum[dimensionField[1]]) && value >= datum[dimensionField[0]] && value < datum[dimensionField[1]];
                }))
            }); else {
                const range = axis.getSpec().tooltipFilterRange, rangeArr = isValidNumber(range) ? [ -range, range ] : range;
                let datums = [];
                if (rangeArr) viewData.forEach((datum => {
                    if (isValid(datum[dimensionField[0]])) {
                        const delta = datum[dimensionField[0]] - value;
                        delta >= rangeArr[0] && delta <= rangeArr[1] && datums.push(datum);
                    }
                })); else {
                    let minDelta = 1 / 0, deltaSign = 0;
                    viewData.forEach((datum => {
                        if (isValid(datum[dimensionField[0]])) {
                            const delta = Math.abs(datum[dimensionField[0]] - value), sign = Math.sign(datum[dimensionField[0]] - value);
                            delta < minDelta ? (minDelta = delta, datums = [ datum ], deltaSign = sign) : delta === minDelta && sign === deltaSign && datums.push(datum);
                        }
                    }));
                }
                data.push({
                    series: series,
                    datum: datums
                });
            }
        }
    }
    return data;
};

export const getAxis = (chart, filter, pos) => {
    const axesComponents = chart.getAllComponents().filter((c => "axes" === c.specKey && filter(c) && isInRegionBound(chart, c, pos)));
    return axesComponents.length ? axesComponents : null;
};
//# sourceMappingURL=common.js.map
