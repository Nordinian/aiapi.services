import { array } from "@visactor/vutils";

import { DataView } from "@visactor/vdataset";

import { dataToDataView, updateDataViewInData } from "../../data/initialize";

export class ChartData {
    get dataList() {
        return this._dataArr;
    }
    constructor(dataSet, onError) {
        this._dataArr = [], this._onError = onError, this._dataSet = dataSet;
    }
    parseData(dataSpec) {
        this._dataArr = [];
        const list = array(dataSpec);
        for (let i = 0; i < list.length; i++) this._dataArr.push(dataToDataView(list[i], this._dataSet, this._dataArr, {
            onError: this._onError
        }));
    }
    updateData(dataSpec, fullUp = !1, forceMerge = !0) {
        const list = array(dataSpec);
        return (!fullUp || list.length === this._dataArr.length) && (this._dataValueForEach(list, ((_data, dv) => {
            dv.markRunning();
        })), this._dataValueForEach(list, ((data, dv) => {
            updateDataViewInData(dv, data, forceMerge);
        })), !0);
    }
    _dataValueForEach(list, callBack) {
        list.forEach(((data, i) => {
            if (data instanceof DataView) return;
            const dv = this.getSeriesData(data.id, i);
            dv && callBack(data, dv, i);
        }));
    }
    getSeriesData(id, index) {
        var _a, _b;
        if (!this._dataArr.length) return null;
        if ("string" == typeof id) {
            const metchData = this._dataArr.filter((data => data.name === id));
            return metchData[0] ? metchData[0] : (null === (_a = this._onError) || void 0 === _a || _a.call(this, `no data matches dataId ${id}!`), 
            null);
        }
        return "number" == typeof index ? this._dataArr[index] ? this._dataArr[index] : (null === (_b = this._onError) || void 0 === _b || _b.call(this, `no data matches dataIndex ${index}!`), 
        null) : this._dataArr[0];
    }
}
//# sourceMappingURL=data.js.map
