import { array, isFunction, isValid } from "@visactor/vutils";

import { BaseTooltipHelper } from "../../model/tooltip-helper";

import { getTooltipActualActiveType } from "../../component/tooltip/utils/common";

export class BaseSeriesTooltipHelper extends BaseTooltipHelper {
    constructor(series) {
        super(), this._getSeriesCacheInfo = () => {
            var _a, _b, _c;
            const {series: series} = this, _seriesField = series.getSeriesField();
            return {
                seriesFields: isValid(_seriesField) ? array(_seriesField) : null !== (_a = series.getSeriesKeys()) && void 0 !== _a ? _a : [],
                dimensionFields: null !== (_b = series.getDimensionField()) && void 0 !== _b ? _b : [],
                measureFields: null !== (_c = series.getMeasureField()) && void 0 !== _c ? _c : [],
                type: series.type
            };
        }, this._getDimensionData = datum => {
            const {dimensionFields: dimensionFields} = this._seriesCacheInfo;
            return dimensionFields[0] && (null == datum ? void 0 : datum[dimensionFields[0]]);
        }, this._getMeasureData = datum => {
            const {measureFields: measureFields} = this._seriesCacheInfo;
            return measureFields[0] && (null == datum ? void 0 : datum[measureFields[0]]);
        }, this._getSeriesStyle = (datum, styleKey, defaultValue) => {
            var _a;
            for (const key of array(styleKey)) {
                const value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
                if (isValid(value)) return value;
            }
            return defaultValue;
        }, this.contentKeyCallback = (datum, params) => {
            const {dimensionFields: dimensionFields, seriesFields: seriesFields} = this._seriesCacheInfo, subDimensionField = dimensionFields[dimensionFields.length - 1];
            return isValid(seriesFields[0]) && (null == datum ? void 0 : datum[seriesFields[0]]) ? null == datum ? void 0 : datum[seriesFields[0]] : (dimensionFields.length > 1 && (0 === seriesFields.length || this.series.getSeriesKeys().length), 
            null == datum ? void 0 : datum[subDimensionField]);
        }, this.contentValueCallback = (datum, params) => this._getMeasureData(datum), this.contentShapeTypeCallback = (datum, params) => {
            var _a;
            return null !== (_a = this._getSeriesStyle(datum, "shape", null)) && void 0 !== _a ? _a : this._getSeriesStyle(datum, "symbolType", this.series.getDefaultShapeType());
        }, this.contentShapeColorCallback = (datum, params) => this._getSeriesStyle(datum, [ "fill", "stroke" ]), 
        this.titleValueCallback = (datum, params) => this._getDimensionData(datum), this.series = series, 
        this.updateTooltipSpec();
    }
    updateTooltipSpec() {
        var _a, _b, _c, _d;
        const seriesTooltipSpec = null !== (_b = null === (_a = this.series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) && void 0 !== _b ? _b : {}, chartTooltipSpec = null !== (_d = null === (_c = this.series.getChart().getSpec()) || void 0 === _c ? void 0 : _c.tooltip) && void 0 !== _d ? _d : {}, spec = Object.assign(Object.assign({}, chartTooltipSpec), seriesTooltipSpec);
        [ "mark", "dimension" ].forEach((activeType => {
            const pattern = spec[activeType];
            isValid(pattern) && (spec[activeType] = Object.assign(Object.assign({}, pattern), {
                title: isValid(pattern.title) ? isFunction(pattern.title) ? pattern.title : Object.assign(Object.assign({}, pattern.title), {
                    seriesId: this.series.id
                }) : void 0,
                content: isValid(pattern.content) ? isFunction(pattern.content) ? pattern.content : array(pattern.content).map((line => isFunction(line) ? line : Object.assign(Object.assign({}, line), {
                    seriesId: this.series.id
                }))) : void 0
            }));
        })), this.spec = spec, this.activeType = getTooltipActualActiveType(spec), this._seriesCacheInfo = this._getSeriesCacheInfo();
    }
    getDefaultTooltipPattern(activeType, dimensionInfo) {
        if ("mark" === activeType) return {
            visible: !0,
            activeType: activeType,
            title: {
                key: void 0,
                value: this.titleValueCallback,
                hasShape: !1
            },
            content: [ {
                seriesId: this.series.id,
                key: this.contentKeyCallback,
                value: this.contentValueCallback,
                hasShape: !0,
                shapeType: this.contentShapeTypeCallback,
                shapeColor: this.contentShapeColorCallback,
                shapeStroke: this.contentShapeColorCallback,
                shapeHollow: !1
            } ]
        };
        if ("dimension" === activeType && dimensionInfo) {
            const title = {
                key: void 0,
                value: this._getDimensionData,
                hasShape: !1
            }, content = [];
            return dimensionInfo.forEach((({data: data}) => data.forEach((({series: series}) => {
                content.push({
                    seriesId: series.id,
                    key: this.contentKeyCallback,
                    value: this.contentValueCallback,
                    hasShape: !0,
                    shapeType: this.contentShapeTypeCallback,
                    shapeColor: this.contentShapeColorCallback,
                    shapeStroke: this.contentShapeColorCallback,
                    shapeHollow: !1
                });
            })))), {
                visible: !0,
                activeType: activeType,
                title: title,
                content: content
            };
        }
        return null;
    }
}
//# sourceMappingURL=tooltip-helper.js.map
