import { isArray, isValid, isValidNumber, isNil } from "@visactor/vutils";

import { ComponentTypeEnum } from "../interface/type";

import { isDiscrete, isContinuous } from "@visactor/vscale";

import { LineCrosshair, RectCrosshair, Tag } from "@visactor/vrender-components";

import { BaseCrossHair } from "./base";

import { getDatumByValue, limitTagInBounds } from "./util";

import { getAxisLabelOffset } from "../axis/util";

import { isXAxis } from "../axis/cartesian/util/common";

import { Factory } from "../../core/factory";

export class CartesianCrossHair extends BaseCrossHair {
    static getSpecInfo(chartSpec) {
        const crosshairSpec = chartSpec[this.specKey];
        if (isNil(crosshairSpec)) return;
        if (!isArray(crosshairSpec)) return crosshairSpec.xField || crosshairSpec.yField ? [ {
            spec: crosshairSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.cartesianCrosshair
        } ] : void 0;
        const specInfos = [];
        return crosshairSpec.forEach(((s, i) => {
            (s.xField || s.yField) && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.cartesianCrosshair
            });
        })), specInfos;
    }
    constructor(spec, options) {
        super(spec, options), this.type = ComponentTypeEnum.cartesianCrosshair, this.name = ComponentTypeEnum.cartesianCrosshair, 
        this._currValueX = new Map, this._currValueY = new Map;
    }
    _showDefaultCrosshairBySpec() {
        const {xField: xField, yField: yField} = this._spec;
        if ((null == xField ? void 0 : xField.visible) && xField.defaultSelect) {
            const {axisIndex: axisIndex, datum: datum} = xField.defaultSelect;
            this._defaultCrosshair(axisIndex, datum, 1);
        }
        if ((null == yField ? void 0 : yField.visible) && yField.defaultSelect) {
            const {axisIndex: axisIndex, datum: datum} = yField.defaultSelect;
            this._defaultCrosshair(axisIndex, datum, 2);
        }
    }
    _defaultCrosshair(axisIndex, datum, tag) {
        const axis = this._option.getComponentsByKey("axes").find((c => c.getSpecIndex() === axisIndex));
        axis && (1 === tag ? (this._currValueX.clear(), this._currValueX.set(axisIndex, {
            axis: axis,
            v: datum
        })) : (this._currValueY.clear(), this._currValueY.set(axisIndex, {
            axis: axis,
            v: datum
        })), this.layoutByValue(tag));
    }
    _findAllAxisContains(relativeX, relativeY) {
        const xAxisMap = this._getAxisInfoByField("x"), yAxisMap = this._getAxisInfoByField("y");
        return {
            xAxisMap: this._filterAxisByPoint(xAxisMap, relativeX, relativeY),
            yAxisMap: this._filterAxisByPoint(yAxisMap, relativeX, relativeY)
        };
    }
    _getValueAt(axis, p) {
        let value = axis.getScale().invert(p);
        return isContinuous(axis.getScale().type) && isValidNumber(+value) && (value = (+value).toFixed(2)), 
        value;
    }
    clearAxisValue() {
        this._currValueX.clear(), this._currValueY.clear();
    }
    setAxisValue(v, axis) {
        isXAxis(axis.getOrient()) ? this._currValueX.set(axis.getSpecIndex(), {
            v: v,
            axis: axis
        }) : this._currValueY.set(axis.getSpecIndex(), {
            v: v,
            axis: axis
        });
    }
    _getAllAxisValues(axisMap, p, currValue, vertical) {
        let discrete = !1;
        return axisMap.forEach((item => {
            isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = !1 : discrete = !0);
        })), !!this.enable && (axisMap.forEach(((item, id) => {
            const axis = item.axis;
            currValue.set(id, {
                v: this._getValueAt(axis, p - (vertical ? axis.getLayoutStartPoint().x - this.getLayoutStartPoint().x : axis.getLayoutStartPoint().y - this.getLayoutStartPoint().y)),
                axis: axis
            });
        })), !0);
    }
    _layoutCrosshair(relativeX, relativeY) {
        const {xAxisMap: xAxisMap, yAxisMap: yAxisMap} = this._findAllAxisContains(relativeX, relativeY);
        if (xAxisMap && 0 === xAxisMap.size || yAxisMap && 0 === yAxisMap.size) {
            if (this.enableRemain) return;
            this.hide();
        } else this._currValueX.clear(), this._currValueY.clear(), xAxisMap && xAxisMap.size && this._getAllAxisValues(xAxisMap, relativeX, this._currValueX, !0), 
        yAxisMap && yAxisMap.size && this._getAllAxisValues(yAxisMap, relativeY, this._currValueY, !1), 
        this.layoutByValue(3);
    }
    hide() {
        this._xCrosshair && this._xCrosshair.hideAll(), this._xTopLabel && this._xTopLabel.hideAll(), 
        this._xBottomLabel && this._xBottomLabel.hideAll(), this._yCrosshair && this._yCrosshair.hideAll(), 
        this._yLeftLabel && this._yLeftLabel.hideAll(), this._yRightLabel && this._yRightLabel.hideAll();
    }
    layoutByValue(tag = 3) {
        var _a, _b, _c, _d;
        if (!this.enable) return;
        const series = this._firstSeries();
        if (!series) return;
        let xCrossHairInfo = {
            height: 0,
            leftPos: 0,
            rightPos: 0,
            topPos: 0,
            x: 0,
            bottom: {
                visible: !1,
                text: "",
                dx: 0,
                dy: 0
            },
            top: {
                visible: !1,
                text: "",
                dx: 0,
                dy: 0
            },
            visible: !1,
            axis: null
        }, yCrossHairInfo = {
            width: 0,
            leftPos: 0,
            topPos: 0,
            bottomPos: 0,
            y: 0,
            left: {
                visible: !1,
                text: "",
                dx: 0,
                dy: 0
            },
            right: {
                visible: !1,
                text: "",
                dx: 0,
                dy: 0
            },
            visible: !1,
            axis: null
        };
        const getRegionArea = (outRegion, currentValue) => {
            currentValue.forEach((({axis: axis}) => {
                axis.getRegions().forEach((r => {
                    outRegion.x1 = Math.min(outRegion.x1, r.getLayoutStartPoint().x), outRegion.y1 = Math.min(outRegion.y1, r.getLayoutStartPoint().y), 
                    outRegion.x2 = Math.max(outRegion.x2, r.getLayoutStartPoint().x + r.getLayoutRect().width), 
                    outRegion.y2 = Math.max(outRegion.y2, r.getLayoutStartPoint().y + r.getLayoutRect().height);
                }));
            }));
        };
        let x = 0, y = 0;
        if (this._currValueX.size) {
            const item = Array.from(this._currValueX.values())[0];
            x = item.axis.getScale().scale(item.v) + item.axis.getLayoutStartPoint().x - this.getLayoutStartPoint().x, 
            xCrossHairInfo.axis = item.axis;
        }
        if (this._currValueY.size) {
            const item = Array.from(this._currValueY.values())[0];
            y = item.axis.getScale().scale(item.v) + item.axis.getLayoutStartPoint().y - this.getLayoutStartPoint().y, 
            yCrossHairInfo.axis = item.axis;
        }
        xCrossHairInfo.visible = !!this._currValueX.size && Number.isFinite(x), yCrossHairInfo.visible = !!this._currValueY.size && Number.isFinite(y);
        const xRegion = {
            x1: 1 / 0,
            y1: 1 / 0,
            x2: -1 / 0,
            y2: -1 / 0
        }, yRegion = {
            x1: 1 / 0,
            y1: 1 / 0,
            x2: -1 / 0,
            y2: -1 / 0
        };
        let indexWidth;
        getRegionArea(xRegion, this._currValueX), getRegionArea(yRegion, this._currValueY);
        let valueHeight, offsetWidth = 0, offsetHeight = 0;
        if (this._xHair && this._currValueX.forEach((({axis: axis, v: v}) => {
            var _a;
            v = null != v ? v : "";
            const xScale = axis.getScale();
            if (isDiscrete(xScale.type)) indexWidth = xScale.bandwidth(), 0 === indexWidth && xScale.step && (offsetWidth = xScale.step()); else if (isContinuous(xScale.type)) {
                const fieldX = series.fieldX[0], fieldX2 = series.fieldX2, datum = getDatumByValue(series.getViewData().latestData, +v, fieldX, fieldX2);
                if (datum) {
                    const startX = series.dataToPositionX(datum);
                    fieldX2 ? (indexWidth = Math.abs(startX - series.dataToPositionX1(datum)), v = `${datum[fieldX]} ~ ${datum[fieldX2]}`) : indexWidth = 1, 
                    x = startX;
                }
            }
            if (null === (_a = this._xHair.label) || void 0 === _a ? void 0 : _a.visible) {
                const labelOffset = getAxisLabelOffset(axis.getSpec());
                "bottom" === axis.getOrient() ? (xCrossHairInfo.bottom.visible = !0, xCrossHairInfo.bottom.text = v, 
                xCrossHairInfo.bottom.dx = 0, xCrossHairInfo.bottom.dy = labelOffset) : "top" === axis.getOrient() && (xCrossHairInfo.top.visible = !0, 
                xCrossHairInfo.top.text = v, xCrossHairInfo.top.dx = 0, xCrossHairInfo.top.dy = -labelOffset);
            }
        })), this._yHair && this._currValueY.forEach((({axis: axis, v: v}) => {
            var _a;
            v = null != v ? v : "";
            const yScale = axis.getScale();
            if (isDiscrete(yScale.type)) valueHeight = yScale.bandwidth(), 0 === valueHeight && yScale.step && (offsetHeight = yScale.step()); else if (isContinuous(yScale.type)) {
                const fieldY = series.fieldY[0], fieldY2 = series.fieldY2, datum = getDatumByValue(series.getViewData().latestData, +v, fieldY, fieldY2);
                if (datum) {
                    const startY = series.dataToPositionY(datum);
                    fieldY2 ? (valueHeight = Math.abs(startY - series.dataToPositionY1(datum)), v = `${datum[fieldY]} ~ ${datum[fieldY2]}`) : valueHeight = 1, 
                    y = startY;
                }
            }
            if (null === (_a = this._yHair.label) || void 0 === _a ? void 0 : _a.visible) {
                const labelOffset = getAxisLabelOffset(axis.getSpec());
                "left" === axis.getOrient() ? (yCrossHairInfo.left.visible = !0, yCrossHairInfo.left.text = v, 
                yCrossHairInfo.left.dx = -labelOffset, yCrossHairInfo.left.dy = 0) : "right" === axis.getOrient() && (yCrossHairInfo.right.visible = !0, 
                yCrossHairInfo.right.text = v, yCrossHairInfo.right.dx = labelOffset, yCrossHairInfo.right.dy = 0);
            }
        })), this.enableRemain && !xCrossHairInfo.visible && isValid(this._cacheXCrossHairInfo)) xCrossHairInfo = this._cacheXCrossHairInfo; else if (xCrossHairInfo.leftPos = xRegion.x1, 
        xCrossHairInfo.rightPos = xRegion.x2, xCrossHairInfo.topPos = xRegion.y1, xCrossHairInfo.height = xRegion.y2 - xRegion.y1, 
        xCrossHairInfo.x = x + this.getLayoutStartPoint().x, null === (_b = null === (_a = this._xHair) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.formatMethod) {
            const {top: top, bottom: bottom} = xCrossHairInfo;
            bottom.visible && (bottom.text = this._xHair.label.formatMethod(bottom.text, "bottom")), 
            top.visible && (top.text = this._xHair.label.formatMethod(top.text, "top"));
        }
        if (this.enableRemain && !yCrossHairInfo.visible && isValid(this._cacheYCrossHairInfo)) yCrossHairInfo = this._cacheYCrossHairInfo; else if (yCrossHairInfo.leftPos = yRegion.x1, 
        yCrossHairInfo.topPos = yRegion.y1, yCrossHairInfo.bottomPos = yRegion.y2, yCrossHairInfo.width = yRegion.x2 - yRegion.x1, 
        yCrossHairInfo.y = y + this.getLayoutStartPoint().y, null === (_d = null === (_c = this._yHair) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.formatMethod) {
            const {left: left, right: right} = yCrossHairInfo;
            left.visible && (left.text = this._yHair.label.formatMethod(left.text, "left")), 
            right.visible && (right.text = this._yHair.label.formatMethod(right.text, "right"));
        }
        tag && (this._layoutHorizontal(yCrossHairInfo, null != valueHeight ? valueHeight : 0, offsetHeight), 
        this._layoutVertical(xCrossHairInfo, null != indexWidth ? indexWidth : 0, offsetWidth)), 
        this.enableRemain && (this._cacheXCrossHairInfo = Object.assign(Object.assign({}, xCrossHairInfo), {
            _isCache: !0
        }), this._cacheYCrossHairInfo = Object.assign(Object.assign({}, yCrossHairInfo), {
            _isCache: !0
        }));
    }
    _layoutVertical(crosshairInfo, bandWidth, offsetWidth) {
        var _a, _b;
        if (crosshairInfo._isCache && this.enableRemain || !this._xHair) return;
        const {x: x, topPos: topPos, height: height, top: top, bottom: bottom, visible: visible} = crosshairInfo;
        if (visible) {
            const type = this._xHair.type;
            let positionAttribute;
            if ("line" === type) positionAttribute = {
                start: {
                    x: x + bandWidth / 2,
                    y: topPos
                },
                end: {
                    x: x + bandWidth / 2,
                    y: topPos + height
                }
            }; else if ("rect" === type) {
                const extend = this._getRectSize(this._xHair, bandWidth, crosshairInfo.axis), {leftPos: leftPos, rightPos: rightPos} = crosshairInfo;
                positionAttribute = {
                    start: {
                        x: Math.max(x - extend / 2 - offsetWidth / 2, leftPos),
                        y: topPos
                    },
                    end: {
                        x: Math.min(x + bandWidth + extend / 2 + offsetWidth / 2, rightPos),
                        y: topPos + height
                    }
                };
            }
            if (this._updateCrosshair("x", type, positionAttribute), top.visible) {
                const updateAttrs = Object.assign(Object.assign(Object.assign({
                    x: x + bandWidth / 2,
                    y: topPos
                }, top), this._xHair.label), {
                    textStyle: Object.assign(Object.assign({}, null === (_a = this._xHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
                        textAlign: "center",
                        textBaseline: "bottom"
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._xTopLabel, updateAttrs, (label => {
                    label.name = "crosshair-x-top-label", this._xTopLabel = label;
                }));
            } else this._xTopLabel && this._xTopLabel.hideAll();
            if (bottom.visible) {
                const updateAttrs = Object.assign(Object.assign(Object.assign({
                    x: x + bandWidth / 2,
                    y: topPos + height
                }, bottom), this._xHair.label), {
                    textStyle: Object.assign(Object.assign({}, null === (_b = this._xHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
                        textAlign: "center",
                        textBaseline: "top"
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._xBottomLabel, updateAttrs, (label => {
                    label.name = "crosshair-x-bottom-label", this._xBottomLabel = label;
                }));
            } else this._xBottomLabel && this._xBottomLabel.hideAll();
        }
    }
    _layoutHorizontal(crosshairInfo, bandHeight, offsetHeight) {
        var _a, _b;
        if (crosshairInfo._isCache && this.enableRemain || !this._yHair) return;
        const {leftPos: leftPos, width: width, y: y, left: left, right: right, visible: visible} = crosshairInfo;
        if (visible) {
            const type = this._yHair.type;
            let positionAttribute;
            if ("line" === type) positionAttribute = {
                start: {
                    x: leftPos,
                    y: y + bandHeight / 2
                },
                end: {
                    x: leftPos + width,
                    y: y + bandHeight / 2
                }
            }; else if ("rect" === type) {
                const extend = this._getRectSize(this._yHair, bandHeight, crosshairInfo.axis), {topPos: topPos, bottomPos: bottomPos} = crosshairInfo;
                positionAttribute = {
                    start: {
                        x: leftPos,
                        y: Math.max(y - extend / 2 - offsetHeight / 2, topPos)
                    },
                    end: {
                        x: leftPos + width,
                        y: Math.min(y + bandHeight + extend / 2 + offsetHeight / 2, bottomPos)
                    }
                };
            }
            if (this._updateCrosshair("y", type, positionAttribute), left.visible) {
                const updateAttrs = Object.assign(Object.assign(Object.assign({
                    x: leftPos,
                    y: y + bandHeight / 2
                }, left), this._yHair.label), {
                    textStyle: Object.assign(Object.assign({}, null === (_a = this._yHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
                        textAlign: "right",
                        textBaseline: "middle"
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._yLeftLabel, updateAttrs, (label => {
                    label.name = "crosshair-y-left-label", this._yLeftLabel = label;
                }));
            } else this._yLeftLabel && this._yLeftLabel.hideAll();
            if (right.visible) {
                const updateAttrs = Object.assign(Object.assign(Object.assign({
                    x: leftPos + width,
                    y: y + bandHeight
                }, right), this._yHair.label), {
                    textStyle: Object.assign(Object.assign({}, null === (_b = this._yHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
                        textAlign: "left",
                        textBaseline: "middle"
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._yRightLabel, updateAttrs, (label => {
                    label.name = "crosshair-y-right-label", this._yRightLabel = label;
                }));
            } else this._yRightLabel && this._yRightLabel.hideAll();
        }
    }
    _getRectSize(hair, bandSize, axis) {
        var _a, _b, _c;
        let extend = 0;
        if (null === (_a = hair.style) || void 0 === _a ? void 0 : _a.sizePercent) extend = (hair.style.sizePercent - 1) * bandSize; else if ("number" == typeof (null === (_b = hair.style) || void 0 === _b ? void 0 : _b.size)) extend = hair.style.size - bandSize; else if ("function" == typeof (null === (_c = hair.style) || void 0 === _c ? void 0 : _c.size)) {
            const axisRect = axis.getLayoutRect();
            extend = hair.style.size(axisRect, axis) - bandSize;
        }
        return extend;
    }
    _parseFieldInfo() {
        const {xField: xField, yField: yField} = this._spec;
        xField && xField.visible && (this._xHair = this._parseField(xField, "xField")), 
        yField && yField.visible && (this._yHair = this._parseField(yField, "yField"));
    }
    _updateCrosshair(dim, type, attributes) {
        const container = this.getContainer();
        let crosshair, style;
        "x" === dim ? (crosshair = this._xCrosshair, style = this._xHair.style) : (crosshair = this._yCrosshair, 
        style = this._yHair.style), crosshair ? crosshair.setAttributes(attributes) : ("line" === type ? crosshair = new LineCrosshair(Object.assign(Object.assign({}, attributes), {
            lineStyle: style,
            zIndex: this.gridZIndex + 1,
            disableTriggerEvent: this._option.disableTriggerEvent
        })) : "rect" === type && (crosshair = new RectCrosshair(Object.assign(Object.assign({}, attributes), {
            rectStyle: style,
            zIndex: this.gridZIndex,
            disableTriggerEvent: this._option.disableTriggerEvent
        }))), null == container || container.add(crosshair), "x" === dim ? this._xCrosshair = crosshair : this._yCrosshair = crosshair);
    }
    _updateCrosshairLabel(label, attributes, callback) {
        const container = this.getContainer();
        label ? label.setAttributes(attributes) : (callback(label = new Tag(attributes)), 
        null == container || container.add(label)), limitTagInBounds(label, this._getLimitBounds());
    }
    _getNeedClearVRenderComponents() {
        return [ this._xCrosshair, this._xTopLabel, this._xBottomLabel, this._yCrosshair, this._yLeftLabel, this._yRightLabel ];
    }
}

CartesianCrossHair.specKey = "crosshair", CartesianCrossHair.type = ComponentTypeEnum.cartesianCrosshair;

export const registerCartesianCrossHair = () => {
    Factory.registerComponent(CartesianCrossHair.type, CartesianCrossHair);
};
//# sourceMappingURL=cartesian.js.map
