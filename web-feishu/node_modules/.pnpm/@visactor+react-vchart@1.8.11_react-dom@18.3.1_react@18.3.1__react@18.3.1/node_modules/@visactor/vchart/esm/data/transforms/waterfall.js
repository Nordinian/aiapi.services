import { isNil, precisionAdd } from "@visactor/vutils";

import { WaterfallDefaultSeriesField } from "../../constant/waterfall";

export const waterfall = (lastData, op) => {
    if (!lastData || 0 === lastData.length) return lastData;
    const {indexField: indexField, valueField: valueField, startAs: startAs, endAs: endAs, total: totalSpec, seriesField: seriesField, seriesFieldName: seriesFieldName, groupData: groupData} = op, totalData = [], {dimensionValues: dimensionValues, dimensionData: dimensionData} = groupData().latestData, indexValues = Array.from(dimensionValues[indexField]);
    let temp = {
        start: 0,
        end: 0,
        lastIndex: null
    };
    return indexValues.forEach(((key, index) => {
        const total = {
            start: temp.end,
            end: temp.end,
            lastIndex: temp.lastIndex,
            lastEnd: temp.end,
            index: key,
            isTotal: !1
        };
        dimensionData[key].forEach((d => {
            let isTotalTag = !1;
            if (totalSpec && "end" !== totalSpec.type) {
                if ("field" === totalSpec.type || "custom" === totalSpec.type) {
                    if (d[totalSpec.tagField]) if (isTotalTag = !0, "custom" === totalSpec.type) {
                        const {start: start, end: end} = totalSpec.product(d, temp);
                        d[startAs] = start, d[endAs] = end, total.end = end, total.start = start;
                    } else {
                        let start = 0, end = total.end;
                        if (totalSpec.collectCountField && !isNil(d[totalSpec.collectCountField])) {
                            const startIndex = totalData.length - +d[totalSpec.collectCountField], endIndex = totalData.length - 1;
                            startIndex < 0 ? console.warn("total.collectCountField error") : start = totalData[startIndex].start, 
                            endIndex < 0 ? console.warn("total.collectCountField error") : end = totalData[endIndex].end;
                        } else totalSpec.startField && !isNil(d[totalSpec.startField]) && (start = +d[totalSpec.startField]), 
                        totalSpec.valueField && !isNil(d[totalSpec.valueField]) && (end = precisionAdd(start, +d[totalSpec.valueField]));
                        d[startAs] = start, d[endAs] = end, d[valueField] = end - start, total.start = start, 
                        total.end = end;
                    }
                }
            } else index === indexValues.length - 1 && (total.start = 0, d[startAs] = total.start, 
            d[endAs] = total.end, isTotalTag = !0);
            isTotalTag || (d[startAs] = +total.end, d[endAs] = precisionAdd(d[startAs], +d[valueField]), 
            total.end = d[endAs]), total.isTotal = isTotalTag, (isNil(seriesField) || seriesField === WaterfallDefaultSeriesField) && (d[WaterfallDefaultSeriesField] = isTotalTag ? seriesFieldName.total : +d[valueField] >= 0 ? seriesFieldName.increase : seriesFieldName.decrease);
        })), temp = Object.assign(Object.assign({}, total), {
            lastIndex: key
        }), totalData.push(total);
    })), totalData;
};

export const waterfallFillTotal = (data, op) => {
    if (!data) return data;
    const {indexField: indexField, valueField: valueField, total: total, seriesField: seriesField} = op, totalData = {
        [indexField]: (null == total ? void 0 : total.text) || "total",
        [valueField]: data.reduce(((pre, cur) => precisionAdd(pre, +cur[valueField])), 0)
    };
    return seriesField && (totalData[seriesField] = "total"), data.push(totalData), 
    data;
};
//# sourceMappingURL=waterfall.js.map
