{"version":3,"sources":["../src/util/data.ts"],"names":[],"mappings":"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","file":"data.js","sourcesContent":["import type { DataView } from '@visactor/vdataset';\nimport type { StatisticOperations } from '../data/transforms/dimension-statistics';\nimport {\n  STACK_FIELD_END,\n  STACK_FIELD_START_PERCENT,\n  STACK_FIELD_END_PERCENT,\n  STACK_FIELD_END_OffsetSilhouette,\n  STACK_FIELD_START_OffsetSilhouette,\n  STACK_FIELD_TOTAL,\n  STACK_FIELD_TOTAL_PERCENT,\n  STACK_FIELD_TOTAL_TOP,\n  STACK_FIELD_START\n} from '../constant';\nimport { toValidNumber } from './type';\nimport { max, sum } from './math';\nimport type { ISeries, ISeriesStackDataMeta } from '../series/interface';\n\nexport function mergeFields(\n  targetFields: {\n    key: string;\n    operations: StatisticOperations;\n  }[],\n  mergeFields: {\n    key: string;\n    operations: StatisticOperations;\n  }[]\n): {\n  key: string;\n  operations: StatisticOperations;\n}[] {\n  for (let i = 0; i < mergeFields.length; i++) {\n    const element = mergeFields[i];\n    const _target = findFields(targetFields, element.key);\n    if (!_target) {\n      targetFields.push(element);\n    } else {\n      _target.operations = [...new Set(_target.operations.concat(element.operations))];\n    }\n  }\n  return targetFields;\n}\n\nfunction findFields(\n  list: {\n    key: string;\n    operations: StatisticOperations;\n  }[],\n  fieldKey: string\n) {\n  return list.find(i => i.key === fieldKey);\n}\n\n// 如果不存在别名就返回 field\nexport function getFieldAlias(dataView: DataView, field: string) {\n  if (!dataView) {\n    return field ?? null;\n  }\n  const fields = dataView.getFields();\n  if (!fields) {\n    return field ?? null;\n  }\n  if (!fields[field]) {\n    return field ?? null;\n  }\n  return fields[field].alias ?? field;\n}\n\nexport interface IStackCacheNode {\n  values: any[];\n  series: {\n    s: ISeries;\n    values: any[];\n  }[];\n  nodes: {\n    [key: string]: IStackCacheNode;\n  };\n}\nexport interface IStackCacheRoot {\n  nodes: {\n    [key: string]: IStackCacheNode;\n  };\n}\n\nexport function getRegionStackGroup(\n  region: { getSeries: () => any[] },\n  setInitialValue: boolean,\n  filter?: (s: any) => boolean\n) {\n  const stackValueGroup: { [key: string]: IStackCacheRoot } = {};\n  // 分组\n  region.getSeries().forEach(s => {\n    const stackData = s.getStackData();\n    const stackValue = s.getStackValue();\n    const stackValueField = s.getStackValueField();\n    const filterEnable = filter ? filter(s) : true;\n    if (stackData && stackValueField && filterEnable) {\n      stackValueGroup[stackValue] = stackValueGroup[stackValue] ?? {\n        nodes: {}\n      };\n      stackGroup(s, stackData, stackValueGroup[stackValue] as IStackCacheNode, stackValueField, setInitialValue);\n    }\n  });\n  return stackValueGroup;\n}\n\nexport function stackTotal(stackData: IStackCacheNode, valueField: string) {\n  if ('values' in stackData && stackData.values.length) {\n    const total = sum(stackData.values, valueField);\n    const percent = max(stackData.values, STACK_FIELD_END_PERCENT);\n    stackData.values.forEach(v => {\n      v[STACK_FIELD_TOTAL] = total;\n      v[STACK_FIELD_TOTAL_PERCENT] = percent;\n      delete v[STACK_FIELD_TOTAL_TOP];\n    });\n    const maxNode = stackData.values.reduce((max, current) => {\n      return current[STACK_FIELD_END] > max[STACK_FIELD_END] ? current : max;\n    });\n    maxNode[STACK_FIELD_TOTAL_TOP] = true;\n    return;\n  }\n  for (const key in stackData.nodes) {\n    stackTotal(stackData.nodes[key], valueField);\n  }\n}\n\nexport function stackOffsetSilhouette(stackCache: IStackCacheNode) {\n  if (!stackCache.values.length) {\n    return;\n  }\n  const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;\n  for (let j = 0; j < stackCache.values.length; j++) {\n    stackCache.values[j][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_START] - centerValue;\n    stackCache.values[j][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_END] - centerValue;\n  }\n}\n\nexport function stack(stackCache: IStackCacheNode, stackInverse: boolean, hasPercent?: boolean) {\n  if (stackCache.values.length > 0) {\n    // 设置一个小数以保证 log 计算不会报错\n    let positiveStart = 0;\n    let negativeStart = 0;\n    // temp\n    let sign = 1;\n    let value = 0;\n\n    // stack\n    const maxLength = stackCache.values.length;\n    for (let index = 0; index < maxLength; index++) {\n      const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];\n      value = v[STACK_FIELD_END];\n      if (value >= 0) {\n        v[STACK_FIELD_START] = positiveStart;\n        positiveStart += v[STACK_FIELD_END];\n        v[STACK_FIELD_END] = positiveStart;\n      } else {\n        v[STACK_FIELD_START] = negativeStart;\n        negativeStart += v[STACK_FIELD_END];\n        v[STACK_FIELD_END] = negativeStart;\n      }\n    }\n    if (hasPercent) {\n      // normalize\n      for (let index = 0; index < maxLength; index++) {\n        const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];\n        value = v[STACK_FIELD_END];\n        const denominator = value >= 0 ? positiveStart : negativeStart;\n        sign = value >= 0 ? 1 : -1;\n        v[STACK_FIELD_START_PERCENT] = denominator === 0 ? 0 : Math.min(1, v[STACK_FIELD_START] / denominator) * sign;\n        v[STACK_FIELD_END_PERCENT] = denominator === 0 ? 0 : Math.min(1, v[STACK_FIELD_END] / denominator) * sign;\n      }\n    }\n  }\n\n  for (const key in stackCache.nodes) {\n    stack(stackCache.nodes[key], stackInverse, hasPercent);\n  }\n}\n\nexport function stackGroup(\n  s: ISeries,\n  stackData: ISeriesStackDataMeta,\n  stackCache: IStackCacheNode,\n  valueField: string,\n  setInitialValue: boolean\n) {\n  if ('values' in stackData) {\n    // 初值\n    setInitialValue && stackData.values.forEach(v => (v[STACK_FIELD_END] = toValidNumber(v[valueField])));\n    stackCache.values.push(...stackData.values);\n    stackCache.series.push({ s: s, values: stackData.values });\n    return;\n  }\n  for (const key in stackData.nodes) {\n    !stackCache.nodes[key] &&\n      (stackCache.nodes[key] = {\n        values: [],\n        series: [],\n        nodes: {}\n      });\n    stackGroup(s, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue);\n  }\n}\n"]}