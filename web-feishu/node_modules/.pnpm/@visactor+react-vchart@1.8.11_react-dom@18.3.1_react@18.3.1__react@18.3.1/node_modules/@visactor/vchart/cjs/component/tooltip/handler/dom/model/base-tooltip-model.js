"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTooltipModel = void 0;

const env_1 = require("../../../../../util/env");

class BaseTooltipModel {
    static isInstance(obj) {
        return !!obj && obj.type === BaseTooltipModel.type;
    }
    setOption(option) {
        this._option = option, Object.values(this.children).forEach((c => c.setOption(option)));
    }
    getParentEl() {
        return BaseTooltipModel.isInstance(this.parent) ? this.parent.product : this.parent;
    }
    constructor(parent, option, childIndex) {
        this.type = BaseTooltipModel.type, this._renderContentCache = null, this.children = {}, 
        this.parent = parent, this._option = option, this.childIndex = null != childIndex ? childIndex : 0;
    }
    init(classList, id) {}
    initAll() {
        this.init(), Object.values(this.children).forEach((c => c.initAll()));
    }
    setStyle(style) {
        this.product && style && Object.keys(style).forEach((key => {
            this.product.style[key] !== style[key] && (this.product.style[key] = style[key]);
        }));
    }
    setContent(content) {}
    setVisibility(visibility) {
        if (!this.product) return;
        const {style: style} = this.product;
        style.visibility = visibility ? "visible" : "hidden", Object.values(this.children).forEach((c => c.setVisibility(visibility)));
    }
    getVisibility() {
        var _a, _b;
        return !!(null === (_b = null === (_a = this.product) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.visibility) && "hidden" !== this.product.style.visibility;
    }
    release() {
        var _a;
        if (Object.values(this.children).forEach((c => c.release())), this.children = {}, 
        this.product) {
            try {
                null === (_a = this.getParentEl()) || void 0 === _a || _a.removeChild(this.product);
            } catch (_b) {}
            this.product = null;
        }
    }
    createElement(tag, classList, style, id) {
        const element = null === env_1.domDocument || void 0 === env_1.domDocument ? void 0 : env_1.domDocument.createElement(tag), parentEl = this.getParentEl();
        if (!element || !parentEl) return;
        classList && element.classList.add(...classList), style && Object.keys(style).forEach((key => {
            element.style[key] = style[key];
        })), id && (element.id = id);
        let ptr = this.childIndex;
        if (BaseTooltipModel.isInstance(this.parent)) {
            let nextChildIndex = Number.MAX_VALUE;
            for (let i = 0; i < parentEl.children.length; i++) {
                const childModel = Object.values(this.parent.children).find((c => c.product === parentEl.children[i]));
                childModel.childIndex > this.childIndex && childModel.childIndex < nextChildIndex && (nextChildIndex = childModel.childIndex, 
                ptr = i);
            }
        }
        return ptr >= parentEl.children.length ? parentEl.appendChild(element) : parentEl.insertBefore(element, parentEl.children[ptr]), 
        element;
    }
}

exports.BaseTooltipModel = BaseTooltipModel, BaseTooltipModel.type = "tooltipModel";
//# sourceMappingURL=base-tooltip-model.js.map
