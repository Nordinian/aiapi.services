"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerAxis = exports.AxisComponent = void 0;

const vutils_extension_1 = require("@visactor/vutils-extension"), base_component_1 = require("../base/base-component"), vutils_1 = require("@visactor/vutils"), model_1 = require("../../util/model"), merge_spec_1 = require("../../util/spec/merge-spec"), constant_1 = require("../../constant"), utils_1 = require("../../animation/utils"), vutils_2 = require("@visactor/vutils"), util_1 = require("./util"), style_1 = require("../../util/style"), vdataset_1 = require("@visactor/vdataset"), vgrammar_core_1 = require("@visactor/vgrammar-core"), component_1 = require("../../mark/component"), factory_1 = require("../../core/factory"), vrender_components_1 = require("@visactor/vrender-components"), vrender_core_1 = require("@visactor/vrender-core"), scale_1 = require("../../data/parser/scale"), register_1 = require("../../data/register");

class AxisComponent extends base_component_1.BaseComponent {
    getOrient() {
        return this._orient;
    }
    getScale() {
        return this._scale;
    }
    getScales() {
        return this._scales;
    }
    getTickData() {
        return this._tickData;
    }
    get visible() {
        return this._visible;
    }
    getInverse() {
        return this._inverse;
    }
    constructor(spec, options) {
        var _a;
        super(spec, options), this.specKey = "axes", this._scales = [], this._visible = !0, 
        this._tick = void 0, this._visible = null === (_a = spec.visible) || void 0 === _a || _a;
    }
    _getNeedClearVRenderComponents() {
        return [];
    }
    getVRenderComponents() {
        var _a, _b;
        return (0, vutils_1.array)(null === (_b = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem());
    }
    created() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        if (super.created(), this.setSeriesAndRegionsFromSpec(), this.initEvent(), this.initScales(), 
        this.updateSeriesScale(), this.getVisible() && this._initData(), this._visible) {
            const axisMark = this._createMark({
                type: "component",
                name: `axis-${this.getOrient()}`
            }, {
                componentType: "angle" === this.getOrient() ? "circleAxis" : "axis",
                mode: this._spec.mode,
                noSeparateStyle: !0,
                skipTheme: !0
            });
            if (this._axisMark = axisMark, axisMark.setZIndex(this.layoutZIndex), (0, vutils_1.isValid)(this._spec.id) && axisMark.setUserId(this._spec.id), 
            this._marks.addMark(axisMark), null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) {
                const gridMark = this._createMark({
                    type: "component",
                    name: `axis-${this.getOrient()}-grid`
                }, {
                    componentType: "angle" === this.getOrient() ? vgrammar_core_1.GridEnum.circleAxisGrid : vgrammar_core_1.GridEnum.lineAxisGrid,
                    mode: this._spec.mode,
                    noSeparateStyle: !0,
                    skipTheme: !0
                });
                gridMark.setZIndex(null !== (_f = null !== (_d = null === (_c = null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.zIndex) && void 0 !== _d ? _d : null === (_e = this._spec.grid) || void 0 === _e ? void 0 : _e.zIndex) && void 0 !== _f ? _f : constant_1.LayoutZIndex.Axis_Grid), 
                this._marks.addMark(gridMark), this._gridMark = gridMark;
            }
            if ((0, vutils_1.isBoolean)(this._spec.interactive) && this._marks.forEach((m => m.setInteractive(this._spec.interactive))), 
            !1 !== this._option.animation && !1 !== (0, vutils_1.get)(this._option.getChart().getSpec(), "animation") && !0 === this._spec.animation) {
                const axisAnimateConfig = (0, utils_1.animationConfig)(null === (_g = factory_1.Factory.getAnimationInKey("axis")) || void 0 === _g ? void 0 : _g(), {
                    appear: null !== (_j = null !== (_h = this._spec.animationAppear) && void 0 !== _h ? _h : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationAppear.axis")) && void 0 !== _j ? _j : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationAppear"),
                    disappear: null !== (_l = null !== (_k = this._spec.animationDisappear) && void 0 !== _k ? _k : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationDisappear.axis")) && void 0 !== _l ? _l : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationDisappear"),
                    enter: null !== (_o = null !== (_m = this._spec.animationEnter) && void 0 !== _m ? _m : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationEnter.axis")) && void 0 !== _o ? _o : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationEnter"),
                    exit: null !== (_q = null !== (_p = this._spec.animationExit) && void 0 !== _p ? _p : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationExit.axis")) && void 0 !== _q ? _q : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationExit"),
                    update: null !== (_s = null !== (_r = this._spec.animationUpdate) && void 0 !== _r ? _r : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationUpdate.axis")) && void 0 !== _s ? _s : (0, 
                    vutils_1.get)(this._option.getChart().getSpec(), "animationUpdate")
                });
                axisAnimateConfig.enter && (axisAnimateConfig.update[0].customParameters = {
                    enter: axisAnimateConfig.enter[0]
                }), this._marks.forEach((m => m.setAnimationConfig(axisAnimateConfig)));
            }
        }
    }
    isSeriesDataEnable() {
        let enable = !0;
        return (0, model_1.eachSeries)(this._regions, (s => {
            var _a;
            (0, vutils_1.isArray)(null === (_a = s.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) && (enable = !1);
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), enable;
    }
    setSeriesAndRegionsFromSpec() {
        const {seriesId: seriesId, seriesIndex: seriesIndex, regionId: regionId, regionIndex: regionIndex} = this._spec;
        (0, vutils_1.isValid)(seriesId) && (this._seriesUserId = (0, vutils_1.array)(seriesId)), 
        (0, vutils_1.isValid)(regionId) && (this._regionUserId = (0, vutils_1.array)(regionId)), 
        (0, vutils_1.isValid)(seriesIndex) && (this._seriesIndex = (0, vutils_1.array)(seriesIndex)), 
        (0, vutils_1.isValid)(regionIndex) && (this._regionIndex = (0, vutils_1.array)(regionIndex)), 
        this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex), 
        this.layout.layoutBindRegionID = this._regions.map((x => x.id));
    }
    getBindSeriesFilter() {
        return {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        };
    }
    initEvent() {
        this.event.on(constant_1.ChartEvent.scaleUpdate, {
            filter: ({model: model}) => (null == model ? void 0 : model.id) === this.id
        }, this.effect.scaleUpdate.bind(this));
        const viewStatistics = (0, model_1.getSeries)(this._regions, {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }).map((s => s.getViewDataStatistics())).filter((v => !!v));
        viewStatistics.length > 1 ? this._option.dataSet.multipleDataViewAddListener(viewStatistics, "change", (() => {
            this.updateScaleDomain();
        })) : 1 === viewStatistics.length && viewStatistics[0].target.addListener("change", (() => {
            this.updateScaleDomain();
        })), (0, model_1.eachSeries)(this._regions, (s => {
            s.event.on(constant_1.ChartEvent.rawDataUpdate, {
                filter: ({model: model}) => (null == model ? void 0 : model.id) === s.id
            }, (() => {
                this._clearRawDomain();
            }));
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
    }
    updateScaleDomain() {}
    _clearRawDomain() {}
    computeData(updateType) {
        !this._tickData || "force" !== updateType && (0, vutils_2.isEqual)(this._scale.range(), [ 0, 1 ]) || (this._tickData.getDataView().reRunAllTransform(), 
        this._tickData.updateData());
    }
    initScales() {
        this._scales = [ this._scale ];
        const groups = [];
        if ((0, model_1.eachSeries)(this._regions, (s => {
            const g = s.getGroups();
            g && groups.push(g);
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), 0 !== groups.length) {
            const depth = (0, vutils_1.maxInArray)(groups.map((g => g.fields.length)));
            for (let i = 1; i < depth; i++) {
                const scale = this._scale.clone();
                this._scales.push(scale);
            }
        }
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reRender = !0, (null == prevSpec ? void 0 : prevSpec.type) !== (null == spec ? void 0 : spec.type) ? (result.reMake = !0, 
        result) : result;
    }
    getLabelFormatMethod() {
        return this._spec.label.formatMethod ? (value, datum, index) => this._spec.label.formatMethod(datum.rawValue, datum) : null;
    }
    getLabelItems(length) {
        return (0, vutils_1.isArray)(this._tickData.getLatestData()) ? [ this._tickData.getLatestData().map((obj => ({
            id: obj.value,
            label: obj.value,
            value: 0 === length ? 0 : this.dataToPosition([ obj.value ]) / length,
            rawValue: obj.value
        }))).filter((entry => entry.value >= 0 && entry.value <= 1)) ] : [];
    }
    _delegateAxisContainerEvent(component) {
        component.addEventListener("*", ((event, type) => this._delegateEvent(component, event, type)));
    }
    _getAxisAttributes() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const spec = this._spec;
        let titleTextStyle, titleAngle = spec.title.angle;
        "left" !== spec.orient && "right" !== spec.orient || (null === (_a = spec.title) || void 0 === _a ? void 0 : _a.autoRotate) && (0, 
        vutils_1.isNil)(spec.title.angle) && (titleAngle = "left" === spec.orient ? -90 : 90, 
        titleTextStyle = util_1.DEFAULT_TITLE_STYLE[spec.orient]);
        const labelSpec = (0, vutils_2.pickWithout)(spec.label, [ "style", "formatMethod", "state" ]), backgroundSpec = null !== (_b = spec.background) && void 0 !== _b ? _b : {}, titleBackgroundSpec = null !== (_c = spec.title.background) && void 0 !== _c ? _c : {};
        return {
            orient: this.getOrient(),
            select: !0 !== this._option.disableTriggerEvent && spec.select,
            hover: !0 !== this._option.disableTriggerEvent && spec.hover,
            line: (0, util_1.transformAxisLineStyle)(spec.domainLine),
            label: Object.assign({
                style: (0, vutils_1.isFunction)(spec.label.style) ? (datum, index, data, layer) => {
                    var _a;
                    const style = spec.label.style(datum.rawValue, index, datum, data, layer);
                    return (0, style_1.transformToGraphic)((0, merge_spec_1.mergeSpec)({}, null === (_a = this._theme.label) || void 0 === _a ? void 0 : _a.style, style));
                } : (0, style_1.transformToGraphic)(spec.label.style),
                formatMethod: spec.label.formatMethod ? (value, datum, index) => spec.label.formatMethod(datum.rawValue, datum) : null,
                state: (0, style_1.transformAxisLabelStateStyle)(spec.label.state)
            }, labelSpec),
            tick: !1 === spec.tick.visible ? {
                visible: !1
            } : {
                visible: spec.tick.visible,
                length: spec.tick.tickSize,
                inside: spec.tick.inside,
                alignWithLabel: spec.tick.alignWithLabel,
                style: (0, vutils_1.isFunction)(spec.tick.style) ? (value, index, datum, data) => {
                    var _a;
                    const style = spec.tick.style(value, index, datum, data);
                    return (0, style_1.transformToGraphic)((0, merge_spec_1.mergeSpec)({}, null === (_a = this._theme.tick) || void 0 === _a ? void 0 : _a.style, style));
                } : (0, style_1.transformToGraphic)(spec.tick.style),
                state: (0, style_1.transformStateStyle)(spec.tick.state),
                dataFilter: spec.tick.dataFilter
            },
            subTick: !1 === spec.subTick.visible ? {
                visible: !1
            } : {
                visible: spec.subTick.visible,
                length: spec.subTick.tickSize,
                inside: spec.subTick.inside,
                count: spec.subTick.tickCount,
                style: (0, vutils_1.isFunction)(spec.subTick.style) ? (value, index, datum, data) => {
                    var _a;
                    const style = spec.subTick.style(value, index, datum, data);
                    return (0, style_1.transformToGraphic)((0, merge_spec_1.mergeSpec)({}, null === (_a = this._theme.subTick) || void 0 === _a ? void 0 : _a.style, style));
                } : (0, style_1.transformToGraphic)(spec.subTick.style),
                state: (0, style_1.transformStateStyle)(spec.subTick.state)
            },
            title: !1 === spec.title.visible ? {
                visible: !1
            } : Object.assign({
                visible: spec.title.visible,
                position: spec.title.position,
                space: spec.title.space,
                autoRotate: !1,
                angle: titleAngle ? (0, vutils_2.degreeToRadian)(titleAngle) : null,
                textStyle: (0, merge_spec_1.mergeSpec)({}, titleTextStyle, (0, style_1.transformToGraphic)(spec.title.style)),
                padding: spec.title.padding,
                shape: !1 === (null === (_d = spec.title.shape) || void 0 === _d ? void 0 : _d.visible) ? {
                    visible: !1
                } : {
                    visible: null === (_e = spec.title.shape) || void 0 === _e ? void 0 : _e.visible,
                    space: null === (_f = spec.title.shape) || void 0 === _f ? void 0 : _f.space,
                    style: (0, style_1.transformToGraphic)(null === (_g = spec.title.shape) || void 0 === _g ? void 0 : _g.style)
                },
                background: !1 === titleBackgroundSpec.visible ? {
                    visible: !1
                } : {
                    visible: titleBackgroundSpec.visible,
                    style: (0, style_1.transformToGraphic)(titleBackgroundSpec.style)
                },
                state: {
                    text: (0, style_1.transformStateStyle)(spec.title.state),
                    shape: (0, style_1.transformStateStyle)(null === (_h = spec.title.shape) || void 0 === _h ? void 0 : _h.state),
                    background: (0, style_1.transformStateStyle)(null === (_j = spec.title.background) || void 0 === _j ? void 0 : _j.state)
                },
                pickable: !1 !== (null === (_k = spec.title.style) || void 0 === _k ? void 0 : _k.pickable),
                childrenPickable: !1 !== (null === (_l = spec.title.style) || void 0 === _l ? void 0 : _l.pickable)
            }, spec.title),
            panel: !1 === backgroundSpec.visible ? {
                visible: !1
            } : {
                visible: backgroundSpec.visible,
                style: (0, style_1.transformToGraphic)(backgroundSpec.style),
                state: (0, style_1.transformStateStyle)(backgroundSpec.state)
            }
        };
    }
    _getGridAttributes() {
        const spec = this._spec;
        return {
            alternateColor: spec.grid.alternateColor,
            alignWithLabel: spec.grid.alignWithLabel,
            style: (0, vutils_1.isFunction)(spec.grid.style) ? () => (datum, index) => {
                var _a, _b;
                const style = spec.grid.style(null === (_a = datum.datum) || void 0 === _a ? void 0 : _a.rawValue, index, datum.datum);
                return (0, style_1.transformToGraphic)((0, merge_spec_1.mergeSpec)({}, null === (_b = this._theme.grid) || void 0 === _b ? void 0 : _b.style, style));
            } : (0, style_1.transformToGraphic)(spec.grid.style),
            subGrid: !1 === spec.subGrid.visible ? {
                visible: !1
            } : {
                type: "line",
                visible: spec.subGrid.visible,
                alternateColor: spec.subGrid.alternateColor,
                style: (0, style_1.transformToGraphic)(spec.subGrid.style)
            }
        };
    }
    _initTickDataSet(options) {
        (0, register_1.registerDataSetInstanceParser)(this._option.dataSet, "scale", scale_1.scaleParser), 
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "ticks", vutils_extension_1.ticks);
        return new vdataset_1.DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_ticks`
        }).parse(this._scale, {
            type: "scale"
        }).transform({
            type: "ticks",
            options: options
        }, !1);
    }
    _tickTransformOption(coordinateType) {
        const tick = this._tick || {}, label = this._spec.label || {}, {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, tickMode: tickMode} = tick, {style: labelStyle, formatMethod: labelFormatter, minGap: labelGap} = label;
        return {
            sampling: !1 !== this._spec.sampling,
            tickCount: tickCount,
            forceTickCount: forceTickCount,
            tickStep: tickStep,
            tickMode: tickMode,
            axisOrientType: this._orient,
            coordinateType: coordinateType,
            labelStyle: labelStyle,
            labelFormatter: labelFormatter,
            labelGap: labelGap
        };
    }
    addTransformToTickData(options, execute) {
        var _a, _b;
        null === (_b = null === (_a = this._tickData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.transform(options, execute);
    }
    dataToPosition(values) {
        return this._scale.scale(values);
    }
}

exports.AxisComponent = AxisComponent, AxisComponent.specKey = "axes";

const registerAxis = () => {
    (0, vgrammar_core_1.registerAxis)(), (0, vgrammar_core_1.registerGrid)(), (0, component_1.registerComponentMark)(), 
    factory_1.Factory.registerAnimation("axis", (() => ({
        appear: {
            custom: vrender_components_1.GroupFadeIn
        },
        update: {
            custom: vrender_components_1.GroupTransition
        },
        exit: {
            custom: vrender_core_1.GroupFadeOut
        }
    })));
};

exports.registerAxis = registerAxis;
//# sourceMappingURL=base-axis.js.map
