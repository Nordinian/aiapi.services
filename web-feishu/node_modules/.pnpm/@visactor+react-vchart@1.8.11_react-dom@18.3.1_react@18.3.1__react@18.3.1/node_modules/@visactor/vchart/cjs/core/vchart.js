"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
}, __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerVChartCore = exports.VChart = void 0;

const array_1 = require("../data/parser/array"), common_1 = require("../typings/spec/common"), type_1 = require("../component/interface/type"), vdataset_1 = require("@visactor/vdataset"), util_1 = require("../util"), id_1 = require("../util/id"), space_1 = require("../util/space"), env_1 = require("../util/env"), debug_1 = require("../util/debug"), merge_spec_1 = require("../util/spec/merge-spec"), transform_1 = require("../util/spec/transform"), common_2 = require("../util/spec/common"), factory_1 = require("./factory"), event_1 = require("../event/event"), event_dispatcher_1 = require("../event/event-dispatcher"), geo_source_1 = require("../series/map/geo-source"), register_1 = require("../data/register"), initialize_1 = require("../data/initialize"), stack_split_1 = require("../data/transforms/stack-split"), copy_data_view_1 = require("../data/transforms/copy-data-view"), interface_1 = require("../animation/interface"), theme_manager_1 = require("../theme/theme-manager"), compiler_1 = require("../compile/compiler"), image_1 = require("../util/image"), constant_1 = require("../constant"), vutils_1 = require("@visactor/vutils"), instance_manager_1 = require("./instance-manager"), vrender_components_1 = require("@visactor/vrender-components"), util_2 = require("../chart/util"), region_1 = require("../region/region"), base_layout_1 = require("../layout/base-layout"), group_1 = require("../mark/group"), config_1 = require("../animation/config"), vgrammar_core_1 = require("@visactor/vgrammar-core"), util_3 = require("./util"), expression_function_1 = require("./expression-function"), env_2 = require("../env"), spec_1 = require("../util/spec"), builtin_1 = require("../theme/builtin"), plugin_service_1 = require("../plugin/chart/plugin-service");

class VChart {
    static useRegisters(comps) {
        comps.forEach((fn => {
            "function" == typeof fn ? fn() : console.error("Invalid function:", fn);
        }));
    }
    static useChart(charts) {
        charts.forEach((c => factory_1.Factory.registerChart(c.type, c)));
    }
    static useSeries(series) {
        series.forEach((s => factory_1.Factory.registerSeries(s.type, s)));
    }
    static useComponent(components) {
        components.forEach((c => factory_1.Factory.registerComponent(c.type, c)));
    }
    static useMark(marks) {
        marks.forEach((m => {
            var _a;
            return factory_1.Factory.registerMark(null !== (_a = m.constructorType) && void 0 !== _a ? _a : m.type, m);
        }));
    }
    static useLayout(layouts) {
        layouts.forEach((l => factory_1.Factory.registerLayout(l.type, l)));
    }
    static registerDataSetTransform(name, transform) {
        factory_1.Factory.registerTransform(name, transform);
    }
    static registerFunction(key, fun) {
        key && fun && expression_function_1.ExpressionFunction.instance().registerFunction(key, fun);
    }
    static unregisterFunction(key) {
        key && expression_function_1.ExpressionFunction.instance().unregisterFunction(key);
    }
    static getFunction(key) {
        return key ? expression_function_1.ExpressionFunction.instance().getFunction(key) : null;
    }
    static getFunctionList() {
        return expression_function_1.ExpressionFunction.instance().getFunctionNameList();
    }
    static registerMap(key, source, option) {
        const impl = factory_1.Factory.getImplementInKey("registerMap");
        impl && impl(key, source, option);
    }
    static unregisterMap(key) {
        const impl = factory_1.Factory.getImplementInKey("unregisterMap");
        impl && impl(key);
    }
    static getMap(key) {
        return (0, geo_source_1.getMapSource)(key);
    }
    static hideTooltip(excludeId = []) {
        instance_manager_1.InstanceManager.forEach((instance => {
            var _a;
            return null === (_a = null == instance ? void 0 : instance.hideTooltip) || void 0 === _a ? void 0 : _a.call(instance);
        }), excludeId);
    }
    static getLogger() {
        return vutils_1.Logger.getInstance();
    }
    getSpec() {
        return this._spec;
    }
    getSpecInfo() {
        return this._specInfo;
    }
    getDataSet() {
        return this._dataSet;
    }
    constructor(spec, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.id = (0, id_1.createID)(), this._userEvents = [], this._autoSize = !0, this._option = {
            mode: common_1.RenderModeEnum["desktop-browser"],
            onError: msg => {
                throw new Error(msg);
            },
            optimize: {
                disableCheckGraphicWidthOutRange: !0
            }
        }, this._observer = null, this._context = {}, this._onResize = (0, util_1.debounce)(((...args) => {
            this._doResize();
        }), 100), this._option = (0, vutils_1.merge)(this._option, {
            animation: !1 !== spec.animation
        }, options), this._onError = null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError;
        const _h = this._option, {dom: dom, renderCanvas: renderCanvas, mode: mode, stage: stage, poptip: poptip} = _h, restOptions = __rest(_h, [ "dom", "renderCanvas", "mode", "stage", "poptip" ]), isTrueBrowseEnv = (0, 
        env_1.isTrueBrowser)(mode);
        isTrueBrowseEnv && dom && (this._container = (0, util_1.isString)(dom) ? null === document || void 0 === document ? void 0 : document.getElementById(dom) : dom), 
        renderCanvas && (this._canvas = renderCanvas), stage && (this._stage = stage), "node" === mode || this._container || this._canvas || this._stage ? (isTrueBrowseEnv ? (0, 
        env_2.registerBrowserEnv)() : "node" === mode && (0, env_2.registerNodeEnv)(), this._viewBox = this._option.viewBox, 
        this._currentThemeName = theme_manager_1.ThemeManager.getCurrentThemeName(), this._setNewSpec(spec), 
        this._updateCurrentTheme(), this._currentSize = this.getCurrentSize(), this._compiler = new compiler_1.Compiler({
            dom: null !== (_c = this._container) && void 0 !== _c ? _c : "none",
            canvas: renderCanvas
        }, Object.assign(Object.assign({
            mode: this._option.mode,
            stage: stage,
            pluginList: !1 !== poptip ? [ "poptipForText" ] : []
        }, restOptions), {
            background: this._getBackground(),
            onError: this._onError
        })), this._compiler.setSize(this._currentSize.width, this._currentSize.height), 
        this._eventDispatcher = new event_dispatcher_1.EventDispatcher(this, this._compiler), 
        this._event = new event_1.Event(this._eventDispatcher, mode), this._compiler.initView(), 
        null === (_d = this.getStage()) || void 0 === _d || _d.setTheme({
            text: {
                fontFamily: null === (_e = this._currentTheme) || void 0 === _e ? void 0 : _e.fontFamily
            }
        }), this._initDataSet(this._option.dataSet), this._autoSize = !!isTrueBrowseEnv && (null === (_g = null !== (_f = spec.autoFit) && void 0 !== _f ? _f : this._option.autoFit) || void 0 === _g || _g), 
        this._bindResizeEvent(), this._bindVGrammarViewEvent(), this._initChartPlugin(), 
        instance_manager_1.InstanceManager.registerInstance(this)) : null === (_b = this._option) || void 0 === _b || _b.onError("please specify container or renderCanvas!");
    }
    _setNewSpec(spec, forceMerge) {
        return !!spec && ((0, util_1.isString)(spec) && (spec = JSON.parse(spec)), forceMerge && this._originalSpec && (spec = (0, 
        merge_spec_1.mergeSpec)({}, this._originalSpec, spec)), this._originalSpec = spec, 
        this._spec = this._getSpecFromOriginalSpec(), !0);
    }
    _getSpecFromOriginalSpec() {
        var _a;
        const spec = (0, transform_1.specTransform)(this._originalSpec);
        return spec.data = null !== (_a = spec.data) && void 0 !== _a ? _a : [], spec;
    }
    _initChartSpec(spec, actionSource) {
        var _a;
        VChart.getFunctionList() && VChart.getFunctionList().length && (spec = (0, util_1.functionTransform)(spec, VChart)), 
        this._spec = spec, this._chartSpecTransformer || (this._chartSpecTransformer = factory_1.Factory.createChartSpecTransformer(this._spec.type, {
            type: this._spec.type,
            getTheme: () => {
                var _a;
                return null !== (_a = this._currentTheme) && void 0 !== _a ? _a : {};
            },
            animation: this._option.animation
        })), this._chartSpecTransformer.transformSpec(this._spec), this._chartPluginApply("onAfterChartSpecTransform", this._spec, actionSource), 
        this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.transformModelSpec(this._spec), 
        this._chartPluginApply("onAfterModelSpecTransform", this._spec, this._specInfo, actionSource);
    }
    _updateSpecInfo() {
        var _a;
        this._chartSpecTransformer || (this._chartSpecTransformer = factory_1.Factory.createChartSpecTransformer(this._spec.type, {
            type: this._spec.type,
            getTheme: () => {
                var _a;
                return null !== (_a = this._currentTheme) && void 0 !== _a ? _a : {};
            }
        })), this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.createSpecInfo(this._spec);
    }
    _initChart(spec) {
        var _a, _b;
        if (!this._compiler) return void (null === (_a = this._option) || void 0 === _a || _a.onError("compiler is not initialized"));
        const chart = factory_1.Factory.createChart(spec.type, spec, {
            type: spec.type,
            globalInstance: this,
            eventDispatcher: this._eventDispatcher,
            dataSet: this._dataSet,
            container: this._container,
            canvas: this._canvas,
            map: new Map,
            mode: this._option.mode || common_1.RenderModeEnum["desktop-browser"],
            modeParams: this._option.modeParams,
            getCompiler: () => this._compiler,
            performanceHook: this._option.performanceHook,
            viewBox: this._viewBox,
            animation: this._option.animation,
            getTheme: () => {
                var _a;
                return null !== (_a = this._currentTheme) && void 0 !== _a ? _a : {};
            },
            getSpecInfo: () => {
                var _a;
                return null !== (_a = this._specInfo) && void 0 !== _a ? _a : {};
            },
            layout: this._option.layout,
            onError: this._onError,
            disableTriggerEvent: !0 === this._option.disableTriggerEvent
        });
        chart ? (this._chart = chart, this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height), 
        this._chart.created(), this._chart.init(), this._event.emit(constant_1.ChartEvent.initialized, {})) : null === (_b = this._option) || void 0 === _b || _b.onError("init chart fail");
    }
    _releaseData() {
        this._dataSet && (this._dataSet.dataViewMap = {}, this._dataSet = null);
    }
    _bindVGrammarViewEvent() {
        this._compiler && !this._compiler.isReleased && (this._compiler.getVGrammarView().addEventListener(constant_1.VGRAMMAR_HOOK_EVENT.ALL_ANIMATION_END, (() => {
            this._event.emit(constant_1.ChartEvent.animationFinished, {});
        })), this._compiler.getVGrammarView().addEventListener(constant_1.VGRAMMAR_HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER, (() => {
            this._event.emit(constant_1.ChartEvent.renderFinished, {});
        })));
    }
    _bindResizeEvent() {
        var _a;
        if (this._autoSize) {
            if (this._container) {
                const ResizeObserverWindow = window.ResizeObserver;
                this._observer = new ResizeObserverWindow(this._onResize), null === (_a = this._observer) || void 0 === _a || _a.observe(this._container);
            }
            window.addEventListener("resize", this._onResize);
        }
    }
    _unBindResizeEvent() {
        this._autoSize && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), 
        this._observer = null));
    }
    getCurrentSize() {
        var _a, _b, _c, _d;
        return (0, util_2.calculateChartSize)(this._spec, {
            container: this._container,
            canvas: this._canvas,
            mode: this._option.mode || common_1.RenderModeEnum["desktop-browser"],
            modeParams: this._option.modeParams
        }, {
            width: null !== (_b = null === (_a = this._currentSize) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : constant_1.DEFAULT_CHART_WIDTH,
            height: null !== (_d = null === (_c = this._currentSize) || void 0 === _c ? void 0 : _c.height) && void 0 !== _d ? _d : constant_1.DEFAULT_CHART_HEIGHT
        });
    }
    _doResize() {
        const {width: width, height: height} = this.getCurrentSize();
        this._currentSize.width === width && this._currentSize.height === height || (this._currentSize = {
            width: width,
            height: height
        }, this.resize(width, height));
    }
    _initDataSet(dataSet) {
        dataSet instanceof vdataset_1.DataSet ? this._dataSet = dataSet : this._dataSet = new vdataset_1.DataSet, 
        (0, register_1.registerDataSetInstanceParser)(this._dataSet, "dataview", vdataset_1.dataViewParser), 
        (0, register_1.registerDataSetInstanceParser)(this._dataSet, "array", array_1.arrayParser), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "stackSplit", stack_split_1.stackSplit), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "copyDataView", copy_data_view_1.copyDataView);
        for (const key in factory_1.Factory.transforms) (0, register_1.registerDataSetInstanceTransform)(this._dataSet, key, factory_1.Factory.transforms[key]);
        for (const key in factory_1.Factory.dataParser) (0, register_1.registerDataSetInstanceParser)(this._dataSet, key, factory_1.Factory.dataParser[key]);
    }
    updateCustomConfigAndRerender(updateSpecResult, sync, option = {}) {
        if (!this._isReleased && updateSpecResult) return (0, vutils_1.isFunction)(updateSpecResult) && (updateSpecResult = updateSpecResult()), 
        this._reCompile(updateSpecResult), sync ? this._renderSync(option) : this._renderAsync(option);
    }
    _updateCustomConfigAndRecompile(updateSpecResult, option = {}) {
        return !!updateSpecResult && (this._reCompile(updateSpecResult), this._beforeRender(option));
    }
    _reCompile(updateResult, morphConfig) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (updateResult.reMake) this._releaseData(), this._initDataSet(), this._chartSpecTransformer = null, 
        this._chart.release(), this._chart = null, null === (_a = this._compiler) || void 0 === _a || _a.releaseGrammar(!1 === (null === (_b = this._option) || void 0 === _b ? void 0 : _b.animation) || !1 === (null === (_c = this._spec) || void 0 === _c ? void 0 : _c.animation)), 
        this._userEvents.forEach((e => {
            var _a;
            return null === (_a = this._event) || void 0 === _a ? void 0 : _a.on(e.eType, e.query, e.handler);
        })), updateResult.reSize && this._doResize(); else if (updateResult.reCompile && (null === (_d = this._compiler) || void 0 === _d || _d.clear({
            chart: this._chart,
            vChart: this
        }, !this._option.animation || !this._spec.animation), null === (_e = this._compiler) || void 0 === _e || _e.compile({
            chart: this._chart,
            vChart: this
        }, {})), updateResult.reSize) {
            const {width: width, height: height} = this.getCurrentSize();
            this._chart.onResize(width, height, !1), null === (_g = (_f = this._compiler).resize) || void 0 === _g || _g.call(_f, width, height, !1);
        }
    }
    _beforeRender(option = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this._isReleased) return !1;
        if (this._chart) return !0;
        const {transformSpec: transformSpec, actionSource: actionSource} = option;
        return transformSpec && this._initChartSpec(this._spec, "render"), this._chartPluginApply("onBeforeInitChart", this._spec, actionSource), 
        null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeInitializeChart) || void 0 === _b || _b.call(_a), 
        this._initChart(this._spec), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterInitializeChart) || void 0 === _d || _d.call(_c), 
        !(!this._chart || !this._compiler) && (null === (_f = null === (_e = this._option.performanceHook) || void 0 === _e ? void 0 : _e.beforeCompileToVGrammar) || void 0 === _f || _f.call(_e), 
        this._compiler.compile({
            chart: this._chart,
            vChart: this
        }, {
            performanceHook: this._option.performanceHook
        }), null === (_h = null === (_g = this._option.performanceHook) || void 0 === _g ? void 0 : _g.afterCompileToVGrammar) || void 0 === _h || _h.call(_g), 
        !0);
    }
    _afterRender() {
        return !this._isReleased && (this._updateAnimateState(), this._event.emit(constant_1.ChartEvent.rendered, {}), 
        !0);
    }
    renderSync(morphConfig) {
        return this._renderSync({
            morphConfig: morphConfig,
            transformSpec: !0,
            actionSource: "render"
        });
    }
    renderAsync(morphConfig) {
        return __awaiter(this, void 0, void 0, (function*() {
            return this._renderAsync({
                morphConfig: morphConfig,
                transformSpec: !0,
                actionSource: "render"
            });
        }));
    }
    _renderSync(option = {}) {
        var _a;
        const self = this;
        return this._beforeRender(option) ? (null === (_a = this._compiler) || void 0 === _a || _a.renderSync(option.morphConfig), 
        this._afterRender(), self) : self;
    }
    _renderAsync(option = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, (function*() {
            const self = this;
            return this._beforeRender(option) ? (yield null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.renderAsync(option.morphConfig), 
            this._afterRender(), self) : self;
        }));
    }
    _updateAnimateState() {
        var _a, _b;
        this._option.animation && (null === (_a = this._chart) || void 0 === _a || _a.getAllRegions().forEach((region => {
            var _a;
            null === (_a = region.animate) || void 0 === _a || _a.updateAnimateState(interface_1.AnimationStateEnum.update, !0);
        })), null === (_b = this._chart) || void 0 === _b || _b.getAllComponents().forEach((component => {
            var _a;
            null === (_a = component.animate) || void 0 === _a || _a.updateAnimateState(interface_1.AnimationStateEnum.update, !0);
        })));
    }
    release() {
        var _a, _b, _c, _d;
        (null === (_a = this._onResize) || void 0 === _a ? void 0 : _a.cancel) && this._onResize.cancel(), 
        this._chartPluginApply("disposeAll"), this._chartSpecTransformer = null, null === (_b = this._chart) || void 0 === _b || _b.release(), 
        null === (_c = this._compiler) || void 0 === _c || _c.release(), null === (_d = this._eventDispatcher) || void 0 === _d || _d.release(), 
        this._unBindResizeEvent(), this._releaseData(), this._chart = null, this._compiler = null, 
        this._spec = null, this._originalSpec = null, this._userEvents = null, this._event = null, 
        this._eventDispatcher = null, this._isReleased = !0, instance_manager_1.InstanceManager.unregisterInstance(this);
    }
    updateData(id, data, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            if ((0, util_1.isNil)(this._dataSet)) return this;
            if (this._chart) return this._chart.updateData(id, data, !0, options), yield this._compiler.renderAsync(), 
            this;
            this._spec.data = (0, util_1.array)(this._spec.data);
            const preDV = this._spec.data.find((dv => dv.name === id || dv.id === id));
            return preDV ? preDV.id === id ? preDV.values = data : preDV.name === id && preDV.parse(data, options) : (0, 
            vutils_1.isArray)(data) ? this._spec.data.push({
                id: id,
                values: data
            }) : this._spec.data.push(data), this;
        }));
    }
    updateDataInBatches(list) {
        return __awaiter(this, void 0, void 0, (function*() {
            return this._chart ? (this._chart.updateFullData(list.map((({id: id, data: data, options: options}) => ({
                id: id,
                values: data,
                parser: options
            })))), this._chart.updateGlobalScaleDomain(), yield this._compiler.renderAsync(), 
            this) : (list.forEach((({id: id, data: data, options: options}) => {
                const preDV = this._spec.data.find((dv => dv.name === id));
                if (preDV) preDV.parse(data, options); else {
                    const dataView = new vdataset_1.DataView(this._dataSet, {
                        name: id
                    });
                    dataView.parse(data, options), this._spec.data.push(dataView);
                }
            })), this);
        }));
    }
    updateDataSync(id, data, options) {
        if ((0, util_1.isNil)(this._dataSet)) return this;
        if (this._chart) return this._chart.updateData(id, data, !0, options), this._compiler.renderSync(), 
        this;
        const preDV = this._spec.data.find((dv => dv.name === id));
        if (preDV) preDV.parse(data, options); else {
            const dataView = new vdataset_1.DataView(this._dataSet, {
                name: id
            });
            dataView.parse(data, options), this._spec.data.push(dataView);
        }
        return this;
    }
    updateFullDataSync(data, reRender = !0) {
        if (this._chart) return this._chart.updateFullData(data), reRender && this._compiler.renderSync(), 
        this;
        return (0, util_1.array)(data).forEach((d => {
            var _a;
            const {id: id, values: values, parser: parser, fields: fields} = d, preDV = this._spec.data.find((dv => dv.name === id));
            if (preDV) preDV.setFields((0, vutils_1.cloneDeep)(fields)), preDV.parse(values, (0, 
            vutils_1.cloneDeep)(parser)); else {
                const dataView = (0, initialize_1.dataToDataView)(d, this._dataSet, this._spec.data, {
                    onError: null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError
                });
                this._spec.data.push(dataView);
            }
        })), this;
    }
    updateFullData(data, reRender = !0) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (this._chart) return this._chart.updateFullData(data), reRender && (yield this._compiler.renderAsync()), 
            this;
            return (0, util_1.array)(data).forEach((d => {
                var _a;
                const {id: id, values: values, parser: parser, fields: fields} = d, preDV = this._spec.data.find((dv => dv.name === id));
                if (preDV) preDV.setFields((0, vutils_1.cloneDeep)(fields)), preDV.parse(values, (0, 
                vutils_1.cloneDeep)(parser)); else {
                    const dataView = (0, initialize_1.dataToDataView)(d, this._dataSet, this._spec.data, {
                        onError: null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError
                    });
                    this._spec.data.push(dataView);
                }
            })), this;
        }));
    }
    updateSpec(spec, forceMerge = !1, morphConfig) {
        return __awaiter(this, void 0, void 0, (function*() {
            const result = this._updateSpec(spec, forceMerge);
            return yield this.updateCustomConfigAndRerender(result, !1, {
                morphConfig: morphConfig,
                transformSpec: !0,
                actionSource: "updateSpec"
            }), this;
        }));
    }
    updateSpecSync(spec, forceMerge = !1, morphConfig) {
        const result = this._updateSpec(spec, forceMerge);
        return this.updateCustomConfigAndRerender(result, !0, {
            morphConfig: morphConfig,
            transformSpec: !0,
            actionSource: "updateSpec"
        }), this;
    }
    updateSpecAndRecompile(spec, forceMerge = !1, option = {}) {
        const result = this._updateSpec(spec, forceMerge);
        return this._updateCustomConfigAndRecompile(result, Object.assign({
            actionSource: "updateSpecAndRecompile"
        }, option));
    }
    _updateSpec(spec, forceMerge = !1) {
        var _a, _b;
        const lastSpec = this._spec;
        if (!this._setNewSpec(spec, forceMerge)) return;
        (0, vutils_1.isEqual)(lastSpec.theme, this._spec.theme) || this._setCurrentTheme();
        const reSize = this._shouldChartResize(lastSpec);
        return null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b || _b.updateLayoutTag(), 
        (0, util_2.mergeUpdateResult)(this._chart.updateSpec(this._spec), {
            change: reSize,
            reMake: !1,
            reCompile: !1,
            reSize: reSize
        });
    }
    updateModelSpec(filter, spec, forceMerge = !1, morphConfig) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (!spec || !this._spec) return this;
            if ((0, util_1.isString)(spec) && (spec = JSON.parse(spec)), (0, vutils_1.isFunction)(filter) || (0, 
            merge_spec_1.mergeSpecWithFilter)(this._spec, filter, spec, forceMerge), this._chart) {
                const model = this._chart.getModelInFilter(filter);
                if (model) return this._updateModelSpec(model, spec, !1, forceMerge, morphConfig);
            }
            return this;
        }));
    }
    updateModelSpecSync(filter, spec, forceMerge = !1, morphConfig) {
        if (!spec || !this._spec) return this;
        if ((0, util_1.isString)(spec) && (spec = JSON.parse(spec)), (0, vutils_1.isFunction)(filter) || (0, 
        merge_spec_1.mergeSpecWithFilter)(this._spec, filter, spec, forceMerge), this._chart) {
            const model = this._chart.getModelInFilter(filter);
            if (model) return this._updateModelSpec(model, spec, !0, forceMerge, morphConfig);
        }
        return this;
    }
    _updateModelSpec(model, spec, sync = !1, forceMerge = !1, morphConfig) {
        forceMerge && (spec = (0, merge_spec_1.mergeSpec)({}, model.getSpec(), spec));
        const result = model.updateSpec(spec);
        return model.reInit(spec), (result.change || result.reCompile || result.reMake || result.reSize || result.reRender) && this._chart.reDataFlow(), 
        this.updateCustomConfigAndRerender(result, sync, {
            morphConfig: morphConfig,
            transformSpec: !1,
            actionSource: "updateModelSpec"
        });
    }
    resize(width, height) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, (function*() {
            if (!this._chart || !this._compiler) return this;
            const chartCanvasRect = this._chart.getCanvasRect();
            return chartCanvasRect && chartCanvasRect.width === width && chartCanvasRect.height === height ? this : (this._chartPluginApply("onBeforeResize", width, height), 
            null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeResizeWithUpdate) || void 0 === _b || _b.call(_a), 
            this._chart.onResize(width, height, !1), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterResizeWithUpdate) || void 0 === _d || _d.call(_c), 
            yield null === (_f = (_e = this._compiler).resize) || void 0 === _f ? void 0 : _f.call(_e, width, height), 
            this._isReleased || this._event.emit(constant_1.ChartEvent.afterResize, {
                chart: this._chart
            }), this);
        }));
    }
    updateViewBox(viewBox, reRender = !0, reLayout = !0) {
        return this._chart && this._compiler ? (this._viewBox = viewBox, this._chart.updateViewBox(viewBox, reLayout), 
        reLayout && (this._compiler.renderSync(), this._chart.onEvaluateEnd()), this._compiler.updateViewBox(viewBox, reRender), 
        this) : this;
    }
    on(eType, query, handler) {
        var _a;
        this._userEvents && (this._userEvents.push({
            eType: eType,
            query: "function" == typeof query ? null : query,
            handler: "function" == typeof query ? query : handler
        }), null === (_a = this._event) || void 0 === _a || _a.on(eType, query, handler));
    }
    off(eType, handler) {
        var _a;
        if (this._userEvents && 0 !== this._userEvents.length) if (handler) {
            const index = this._userEvents.findIndex((e => e.eType === eType && e.handler === handler));
            index >= 0 && (this._userEvents.splice(index, 1), null === (_a = this._event) || void 0 === _a || _a.off(eType, handler));
        } else this._userEvents.forEach((e => {
            var _a;
            e.eType === eType && (null === (_a = this._event) || void 0 === _a || _a.off(eType, e.handler));
        })), this._userEvents = this._userEvents.filter((e => e.eType !== eType));
    }
    updateState(state, filter) {
        this._chart && this._chart.updateState(state, filter);
    }
    setSelected(datum, filter, region) {
        this._chart && this._chart.setSelected(datum, filter, region);
    }
    setHovered(datum, filter, region) {
        this._chart && this._chart.setHovered(datum, filter, region);
    }
    _updateCurrentTheme(nextThemeName) {
        var _a, _b;
        const optionTheme = this._option.theme, specTheme = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.theme;
        if (nextThemeName && (this._currentThemeName = nextThemeName), (0, vutils_1.isEmpty)(optionTheme) && (0, 
        vutils_1.isEmpty)(specTheme)) this._currentTheme = (0, common_2.getThemeObject)(this._currentThemeName, !0); else if ((0, 
        util_1.isString)(optionTheme) && (!specTheme || (0, util_1.isString)(specTheme)) || (0, 
        util_1.isString)(specTheme) && (!optionTheme || (0, util_1.isString)(optionTheme))) {
            const finalTheme = (0, spec_1.mergeTheme)({}, (0, common_2.getThemeObject)(this._currentThemeName, !0), (0, 
            common_2.getThemeObject)(optionTheme, !0), (0, common_2.getThemeObject)(specTheme, !0));
            this._currentTheme = finalTheme;
        } else {
            const finalTheme = (0, spec_1.mergeTheme)({}, (0, common_2.getThemeObject)(this._currentThemeName), (0, 
            common_2.getThemeObject)(optionTheme), (0, common_2.getThemeObject)(specTheme));
            this._currentTheme = (0, spec_1.preprocessTheme)(finalTheme, finalTheme.colorScheme);
        }
        (0, vrender_components_1.setPoptipTheme)((0, vutils_1.get)(this._currentTheme, "component.poptip")), 
        null === (_b = this._compiler) || void 0 === _b || _b.setBackground(this._getBackground());
    }
    _shouldChartResize(oldSpec) {
        var _a, _b;
        let resize = !1;
        (0, util_1.isNil)(this._spec.width) ? this._spec.width = oldSpec.width : this._spec.width !== oldSpec.width && (resize = !0), 
        (0, util_1.isNil)(this._spec.height) ? this._spec.height = oldSpec.height : this._spec.height !== oldSpec.height && (resize = !0);
        const lasAutoSize = this._autoSize;
        return this._autoSize = !!(0, env_1.isTrueBrowser)(this._option.mode) && (null === (_b = null !== (_a = this._spec.autoFit) && void 0 !== _a ? _a : this._option.autoFit) || void 0 === _b || _b), 
        this._autoSize !== lasAutoSize && (resize = !0), resize;
    }
    _getBackground() {
        return ("string" == typeof this._spec.background ? this._spec.background : null) || this._currentTheme.background || this._option.background;
    }
    getCurrentTheme() {
        return (0, common_2.getThemeObject)(this._currentThemeName);
    }
    getCurrentThemeName() {
        return this._currentThemeName;
    }
    setCurrentTheme(name) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (!theme_manager_1.ThemeManager.themeExist(name)) return this;
            const result = this._setCurrentTheme(name);
            return yield this.updateCustomConfigAndRerender(result, !1, {
                transformSpec: !1,
                actionSource: "setCurrentTheme"
            }), this;
        }));
    }
    setCurrentThemeSync(name) {
        if (!theme_manager_1.ThemeManager.themeExist(name)) return this;
        const result = this._setCurrentTheme(name);
        return this.updateCustomConfigAndRerender(result, !0, {
            transformSpec: !1,
            actionSource: "setCurrentTheme"
        }), this;
    }
    _setCurrentTheme(name) {
        var _a;
        return this._updateCurrentTheme(name), this._initChartSpec(this._getSpecFromOriginalSpec(), "setCurrentTheme"), 
        null === (_a = this._chart) || void 0 === _a || _a.setCurrentTheme(), {
            change: !0,
            reMake: !1
        };
    }
    _getTooltipComponent() {
        var _a;
        return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().find((c => c.type === type_1.ComponentTypeEnum.tooltip));
    }
    setTooltipHandler(tooltipHandler) {
        var _a, _b;
        this._context.tooltipHandler = tooltipHandler;
        const tooltip = this._getTooltipComponent();
        tooltip && (null === (_b = null === (_a = tooltip.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), 
        tooltip.tooltipHandler = tooltipHandler);
    }
    getTooltipHandlerByUser() {
        var _a;
        return null === (_a = this._context) || void 0 === _a ? void 0 : _a.tooltipHandler;
    }
    getTooltipHandler() {
        const tooltip = this._getTooltipComponent();
        return tooltip ? tooltip.tooltipHandler : this._context.tooltipHandler;
    }
    showTooltip(datum, options) {
        var _a;
        const tooltip = this._getTooltipComponent();
        return null !== (_a = (0, util_1.isValid)(datum) && "none" !== (null == tooltip ? void 0 : tooltip.showTooltip(datum, options))) && void 0 !== _a && _a;
    }
    hideTooltip() {
        var _a;
        const tooltip = this._getTooltipComponent();
        return null !== (_a = null == tooltip ? void 0 : tooltip.hideTooltip()) && void 0 !== _a && _a;
    }
    getLegendDataById(id) {
        var _a;
        const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
        return legendComponent ? legendComponent.getLegendData() : [];
    }
    getLegendDataByIndex(index = 0) {
        var _a;
        const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c => c.type === type_1.ComponentTypeEnum.discreteLegend));
        return legends[index] ? legends[index].getLegendData() : [];
    }
    getLegendSelectedDataById(id) {
        var _a;
        const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
        return legendComponent ? legendComponent.getSelectedData() : [];
    }
    getLegendSelectedDataByIndex(index = 0) {
        var _a;
        const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c => c.type === type_1.ComponentTypeEnum.discreteLegend));
        return legends[index] ? legends[index].getSelectedData() : [];
    }
    setLegendSelectedDataById(id, selectedData) {
        var _a;
        const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id);
        legendComponent && legendComponent.setSelectedData(selectedData);
    }
    setLegendSelectedDataByIndex(index = 0, selectedData) {
        var _a;
        const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c => c.type === type_1.ComponentTypeEnum.discreteLegend));
        legends[index] && legends[index].setSelectedData(selectedData);
    }
    getDataURL() {
        var _a;
        return __awaiter(this, void 0, void 0, (function*() {
            const stage = this.getStage();
            if (this._chart && stage) {
                stage.render();
                const canvas = this._chart.getCanvas();
                return yield (0, image_1.getCanvasDataURL)(canvas, {
                    onError: this._onError
                });
            }
            return null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined")), 
            null;
        }));
    }
    exportImg(name) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, (function*() {
            if (!(0, env_1.isTrueBrowser)(this._option.mode)) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("non-browser environment can not export img")));
            const dataURL = yield this.getDataURL();
            dataURL ? (0, image_1.URLToImage)(name, dataURL) : null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined"));
        }));
    }
    exportCanvas() {
        var _a;
        const stage = this.getStage();
        if (this._chart && stage) return stage.toCanvas();
        null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined"));
    }
    getImageBuffer() {
        var _a, _b;
        if ("node" !== this._option.mode) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("getImageBuffer() now only support node environment.")));
        const stage = this.getStage();
        if (stage) {
            stage.render();
            return stage.window.getImageBuffer();
        }
        return null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined")), 
        null;
    }
    setLayout(layout) {
        var _a;
        this._option.layout = layout, null === (_a = this._chart) || void 0 === _a || _a.setLayout(layout);
    }
    reLayout() {
        var _a;
        null === (_a = this._chart) || void 0 === _a || _a.setLayoutTag(!0);
    }
    getCompiler() {
        return this._compiler;
    }
    getChart() {
        return this._chart;
    }
    getStage() {
        return this._compiler.getStage();
    }
    getCanvas() {
        var _a;
        return null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getCanvas();
    }
    getContainer() {
        var _a;
        if ((0, util_1.isValid)(this._container)) return this._container;
        let canvasNode;
        return canvasNode = (0, util_1.isString)(this._canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(this._canvas) : this._canvas, 
        (0, util_1.isValid)(canvasNode) ? canvasNode.parentElement : null === (_a = this.getCanvas()) || void 0 === _a ? void 0 : _a.parentElement;
    }
    getComponents() {
        return this._chart.getAllComponents();
    }
    setDimensionIndex(value, opt = {}) {
        var _a;
        return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.setDimensionIndex(value, opt);
    }
    stopAnimation() {
        var _a, _b, _c;
        null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.stop();
    }
    pauseAnimation() {
        var _a, _b, _c;
        null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.pause();
    }
    resumeAnimation() {
        var _a, _b, _c;
        null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.resume();
    }
    convertDatumToPosition(datum, dataLinkInfo = {}, isRelativeToCanvas = !1) {
        var _a;
        if (!this._chart) return null;
        if ((0, vutils_1.isEmpty)(datum)) return null;
        const {seriesId: seriesId, seriesIndex: seriesIndex = 0} = dataLinkInfo;
        let series;
        if ((0, util_1.isValid)(seriesId) ? series = this._chart.getSeriesInUserId(seriesId) : (0, 
        util_1.isValid)(seriesIndex) && (series = null === (_a = this._chart.getSeriesInIndex([ seriesIndex ])) || void 0 === _a ? void 0 : _a[0]), 
        series) {
            const keys = Object.keys(datum), handledDatum = series.getViewData().latestData.find((viewDatum => keys.every((k => viewDatum[k] == datum[k])))), seriesLayoutStartPoint = series.getRegion().getLayoutStartPoint();
            let point;
            return point = handledDatum ? series.dataToPosition(handledDatum) : series.dataToPosition(datum), 
            (0, space_1.convertPoint)(point, seriesLayoutStartPoint, isRelativeToCanvas);
        }
        return null;
    }
    convertValueToPosition(value, dataLinkInfo, isRelativeToCanvas = !1) {
        var _a, _b;
        if (!this._chart || (0, util_1.isNil)(value) || (0, vutils_1.isEmpty)(dataLinkInfo)) return null;
        if (!(0, vutils_1.isArray)(value)) {
            const {axisId: axisId, axisIndex: axisIndex} = dataLinkInfo;
            let axis;
            if ((0, util_1.isValid)(axisId) ? axis = this._chart.getComponentsByKey("axes").find((s => s.userId === axisId)) : (0, 
            util_1.isValid)(axisIndex) && (axis = null === (_a = this._chart.getComponentsByKey("axes")) || void 0 === _a ? void 0 : _a[axisIndex]), 
            !axis) return (0, debug_1.warn)("Please check whether the `axisId` or `axisIndex` is set!"), 
            null;
            const pointValue = null == axis ? void 0 : axis.valueToPosition(value);
            if (isRelativeToCanvas) {
                const axisLayoutStartPoint = axis.getLayoutStartPoint(), axisOrient = axis.getOrient();
                return pointValue + ("bottom" === axisOrient || "top" === axisOrient ? axisLayoutStartPoint.x : axisLayoutStartPoint.y);
            }
            return pointValue;
        }
        const {seriesId: seriesId, seriesIndex: seriesIndex} = dataLinkInfo;
        let series;
        return (0, util_1.isValid)(seriesId) ? series = this._chart.getSeriesInUserId(seriesId) : (0, 
        util_1.isValid)(seriesIndex) && (series = null === (_b = this._chart.getSeriesInIndex([ seriesIndex ])) || void 0 === _b ? void 0 : _b[0]), 
        series ? (0, space_1.convertPoint)(series.valueToPosition(value[0], value[1]), series.getRegion().getLayoutStartPoint(), isRelativeToCanvas) : ((0, 
        debug_1.warn)("Please check whether the `seriesId` or `seriesIndex` is set!"), null);
    }
    getFunction(key) {
        return expression_function_1.ExpressionFunction.instance().getFunction(key);
    }
    registerFunction(key, fun) {
        key && fun && expression_function_1.ExpressionFunction.instance().registerFunction(key, fun);
    }
    unregisterFunction(key) {
        key && expression_function_1.ExpressionFunction.instance().unregisterFunction(key);
    }
    getFunctionList() {
        return expression_function_1.ExpressionFunction.instance().getFunctionNameList();
    }
    setRuntimeSpec(spec) {
        this._spec = spec, this._updateSpecInfo();
    }
    _initChartPlugin() {
        const pluginList = factory_1.Factory.getChartPlugins();
        pluginList.length > 0 && (this._chartPlugin = new plugin_service_1.ChartPluginService(this), 
        this._chartPlugin.load(pluginList.map((p => new p))), this._chartPluginApply("onInit", this._spec));
    }
    _chartPluginApply(funcName, ...args) {
        this._chartPlugin && this._chartPlugin[funcName] && this._chartPlugin[funcName].apply(this._chartPlugin, args);
    }
}

exports.VChart = VChart, VChart.InstanceManager = instance_manager_1.InstanceManager, 
VChart.ThemeManager = theme_manager_1.ThemeManager, VChart.globalConfig = {
    uniqueTooltip: !0
}, VChart.Utils = util_3.VCHART_UTILS;

const registerVChartCore = () => {
    factory_1.Factory.registerRegion("region", region_1.Region), factory_1.Factory.registerLayout("base", base_layout_1.Layout), 
    (0, group_1.registerGroupMark)(), vgrammar_core_1.View.useRegisters([ vgrammar_core_1.registerFilterTransform, vgrammar_core_1.registerMapTransform ]), 
    (0, config_1.registerVGrammarCommonAnimation)(), (0, builtin_1.registerTheme)(builtin_1.darkTheme.name, builtin_1.darkTheme), 
    vutils_1.Logger.getInstance(vutils_1.LoggerLevel.Error);
};

exports.registerVChartCore = registerVChartCore, (0, exports.registerVChartCore)();
//# sourceMappingURL=vchart.js.map