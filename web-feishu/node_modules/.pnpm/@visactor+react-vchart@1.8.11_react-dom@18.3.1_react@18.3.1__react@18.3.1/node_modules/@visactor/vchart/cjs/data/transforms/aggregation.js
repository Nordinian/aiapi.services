"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.markerAggregation = exports.markerMedian = exports.markerStandardDeviation = exports.markerVariance = exports.markerAverage = exports.markerSum = exports.markerMax = exports.markerMin = void 0;

const vutils_1 = require("@visactor/vutils"), math_1 = require("../../util/math"), markerMin = (_data, opt) => {
    const data = _data[0].latestData;
    return (0, math_1.min)(data, opt.field);
};

exports.markerMin = markerMin;

const markerMax = (_data, opt) => {
    const data = _data[0].latestData;
    return (0, math_1.max)(data, opt.field);
};

function markerSum(_data, opt) {
    const data = _data[0].latestData;
    return (0, math_1.sum)(data, opt.field);
}

function markerAverage(_data, opt) {
    const data = _data[0].latestData;
    return (0, math_1.average)(data, opt.field);
}

function markerVariance(_data, opt) {
    const data = _data[0].latestData;
    return (0, math_1.variance)(data, opt.field);
}

function markerStandardDeviation(_data, opt) {
    const data = _data[0].latestData;
    return (0, math_1.standardDeviation)(data, opt.field);
}

function markerMedian(_data, opt) {
    const data = _data[0].latestData;
    return (0, math_1.median)(data, opt.field);
}

function markerAggregation(_data, options) {
    const results = [];
    return options.forEach((option => {
        const result = {
            x: null,
            y: null
        };
        if ((0, vutils_1.isValid)(option.x)) {
            const x = option.x;
            (0, vutils_1.isArray)(x) ? result.x = x.map((item => getFinalValue(item, _data, option))) : result.x = getFinalValue(x, _data, option);
        }
        if ((0, vutils_1.isValid)(option.y)) {
            const y = option.y;
            (0, vutils_1.isArray)(y) ? result.y = y.map((item => getFinalValue(item, _data, option))) : result.y = getFinalValue(y, _data, option);
        }
        option.getRefRelativeSeries && (result.getRefRelativeSeries = option.getRefRelativeSeries), 
        results.push(result);
    })), results;
}

exports.markerMax = markerMax, exports.markerSum = markerSum, exports.markerAverage = markerAverage, 
exports.markerVariance = markerVariance, exports.markerStandardDeviation = markerStandardDeviation, 
exports.markerMedian = markerMedian, exports.markerAggregation = markerAggregation;

const aggrMap = {
    min: exports.markerMin,
    max: exports.markerMax,
    sum: markerSum,
    average: markerAverage,
    variance: markerVariance,
    standardDeviation: markerStandardDeviation,
    median: markerMedian
};

function getFinalValue(source, _data, option) {
    const relativeSeries = option.getRelativeSeries(), startSeries = option.getStartRelativeSeries(), endSeries = option.getEndRelativeSeries(), relativeSeriesData = relativeSeries.getData().getLatestData(), startRelativeSeriesData = startSeries.getData().getLatestData(), endRelativeSeriesData = endSeries.getData().getLatestData();
    if ((0, vutils_1.isFunction)(source)) return source(relativeSeriesData, startRelativeSeriesData, endRelativeSeriesData, relativeSeries, startSeries, endSeries);
    if ((0, vutils_1.isPlainObject)(source)) {
        const {aggrType: aggrType, field: field} = source;
        return aggrMap[aggrType](_data, {
            field: field
        });
    }
    return source;
}
//# sourceMappingURL=aggregation.js.map
