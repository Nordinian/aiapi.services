"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getTooltipSpecForShow = void 0;

const merge_spec_1 = require("../../../../util/spec/merge-spec"), pattern_1 = require("./pattern"), common_1 = require("../../utils/common"), vutils_1 = require("@visactor/vutils"), getTooltipSpecForShow = (activeType, globalSpec, series, dimensionInfo) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const finalSpec = Object.assign(Object.assign({}, globalSpec), {
        activeType: activeType
    });
    if ("mark" === activeType && series) {
        const seriesSpec = null !== (_b = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        if ((0, vutils_1.isValid)(seriesSpec.visible) || (0, vutils_1.isValid)(seriesSpec.activeType) ? finalSpec.visible = (0, 
        common_1.getTooltipActualActiveType)(seriesSpec).includes("mark") : (0, vutils_1.isValid)(globalSpec.visible) || (0, 
        vutils_1.isValid)(globalSpec.activeType) ? finalSpec.visible = (0, common_1.getTooltipActualActiveType)(globalSpec).includes("mark") : finalSpec.visible = !0, 
        finalSpec.handler = null !== (_d = null !== (_c = seriesSpec.handler) && void 0 !== _c ? _c : globalSpec.handler) && void 0 !== _d ? _d : void 0, 
        null === (_e = finalSpec.handler) || void 0 === _e ? void 0 : _e.showTooltip) return finalSpec;
    } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        if (getSeriesListFromDimensionInfo(dimensionInfo).every((series => {
            var _a;
            return !(0, common_1.getTooltipActualActiveType)(null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec).includes("dimension");
        })) ? finalSpec.visible = !1 : (0, vutils_1.isValid)(globalSpec.visible) || (0, 
        vutils_1.isValid)(globalSpec.activeType) ? finalSpec.visible = (0, common_1.getTooltipActualActiveType)(globalSpec).includes("dimension") : finalSpec.visible = !0, 
        finalSpec.handler = null !== (_f = globalSpec.handler) && void 0 !== _f ? _f : void 0, 
        null === (_g = finalSpec.handler) || void 0 === _g ? void 0 : _g.showTooltip) return finalSpec;
    }
    const defaultPattern = getDefaultTooltipPattern(activeType, series, dimensionInfo), seriesPattern = getSeriesTooltipPattern(activeType, series, dimensionInfo), userPattern = (0, 
    merge_spec_1.mergeSpec)({}, (0, vutils_1.cloneDeep)(globalSpec[activeType]), seriesPattern), defaultPatternTitle = defaultPattern.title, titleShape = getShapePattern(void 0, userPattern, void 0, defaultPatternTitle);
    if ((0, vutils_1.isValid)(userPattern.title)) if ((0, vutils_1.isFunction)(userPattern.title)) {
        const userPatternTitle = userPattern.title;
        userPattern.title = (data, params) => {
            var _a;
            const userResult = null !== (_a = userPatternTitle(data, params)) && void 0 !== _a ? _a : {};
            return Object.assign(Object.assign({}, titleShape), userResult);
        };
    } else userPattern.title = Object.assign(Object.assign(Object.assign({}, defaultPattern.title), titleShape), userPattern.title); else userPattern.title = Object.assign(Object.assign({}, defaultPattern.title), titleShape);
    const defaultPatternContent = (0, vutils_1.array)(defaultPattern.content);
    if ((0, vutils_1.isValid)(userPattern.content)) {
        const shapePatternMap = getShapePatternMapOfEachSeries(defaultPatternContent);
        if ((0, vutils_1.isFunction)(userPattern.content)) {
            const userPatternContent = userPattern.content;
            userPattern.content = (data, params) => {
                var _a;
                const newPatternContent = [];
                return (0, vutils_1.array)(null !== (_a = userPatternContent(data, params)) && void 0 !== _a ? _a : []).forEach((userLine => {
                    newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
                })), newPatternContent;
            };
        } else {
            const newPatternContent = [];
            (0, vutils_1.array)(userPattern.content).forEach((userLine => {
                newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
            })), userPattern.content = newPatternContent;
        }
    } else userPattern.content = defaultPatternContent.map((line => Object.assign(Object.assign({}, line), getShapePattern(void 0, userPattern, void 0, line))));
    return finalSpec[activeType] = Object.assign(Object.assign(Object.assign({}, defaultPattern), userPattern), {
        activeType: activeType
    }), finalSpec;
};

exports.getTooltipSpecForShow = getTooltipSpecForShow;

const getDefaultTooltipPattern = (activeType, series, dimensionInfo) => {
    var _a;
    let defaultPattern = {};
    if ("mark" === activeType && series) defaultPattern = null !== (_a = (0, pattern_1.makeDefaultPattern)(series, "mark")) && void 0 !== _a ? _a : {}; else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        const patternList = [];
        dimensionInfo[0].data.forEach((data => {
            const {series: series} = data, mockDimensionInfo = [ Object.assign(Object.assign({}, dimensionInfo[0]), {
                data: [ data ]
            }) ], pattern = (0, pattern_1.makeDefaultPattern)(series, "dimension", mockDimensionInfo);
            pattern && patternList.push(pattern);
        }));
        const defaultPatternContent = [];
        patternList.forEach((({content: content}) => {
            (0, vutils_1.isFunction)(content) ? defaultPatternContent.push(content) : defaultPatternContent.push(...(0, 
            vutils_1.array)(content));
        })), defaultPattern = Object.assign(Object.assign({}, patternList[0]), {
            content: defaultPatternContent
        });
    }
    return defaultPattern;
}, getSeriesTooltipPattern = (activeType, series, dimensionInfo) => {
    var _a, _b;
    let seriesPattern = {};
    if ("mark" === activeType && series) {
        const seriesSpec = null !== (_b = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        seriesPattern = seriesSpec.mark ? (0, vutils_1.cloneDeep)(seriesSpec.mark) : {};
    } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        const seriesPatternList = getSeriesListFromDimensionInfo(dimensionInfo).filter((series => {
            var _a;
            const spec = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec;
            return (0, vutils_1.isValid)(null == spec ? void 0 : spec.dimension) && (0, common_1.getTooltipActualActiveType)(spec).includes("dimension");
        })).map((series => series.tooltipHelper.spec.dimension));
        if (seriesPatternList.length) {
            let seriesPatternContent = [];
            seriesPatternList.every((({content: content}) => (0, vutils_1.isNil)(content))) ? seriesPatternContent = void 0 : seriesPatternList.forEach((({content: content}) => {
                (0, vutils_1.isNil)(content) || ((0, vutils_1.isFunction)(content) ? null == seriesPatternContent || seriesPatternContent.push(content) : null == seriesPatternContent || seriesPatternContent.push(...(0, 
                vutils_1.array)(content)));
            })), seriesPattern = Object.assign(Object.assign({}, seriesPatternList[0]), {
                content: seriesPatternContent
            });
        }
    }
    return seriesPattern;
}, getSeriesListFromDimensionInfo = (0, vutils_1.memoize)((dimensionInfo => dimensionInfo.reduce(((list, cur) => list.concat(cur.data.map((data => data.series)).filter(vutils_1.isValid))), []))), getShapePatternMapOfEachSeries = content => {
    const shapePatternMap = {};
    return content.forEach((line => {
        var _a;
        const key = null !== (_a = line.seriesId) && void 0 !== _a ? _a : 0;
        shapePatternMap[key] || (shapePatternMap[key] = line);
    })), shapePatternMap;
}, getShapePattern = (userLinePattern, userPattern, shapePatternMap, defaultShapePattern) => {
    var _a, _b;
    const shapePatternFromMap = null !== (_b = null == shapePatternMap ? void 0 : shapePatternMap[null !== (_a = null == userLinePattern ? void 0 : userLinePattern.seriesId) && void 0 !== _a ? _a : 0]) && void 0 !== _b ? _b : null == shapePatternMap ? void 0 : shapePatternMap[0], shapeKeys = new Set([].concat(Object.keys(null != userLinePattern ? userLinePattern : {}), Object.keys(null != userPattern ? userPattern : {}), Object.keys(null != shapePatternFromMap ? shapePatternFromMap : {}), Object.keys(null != defaultShapePattern ? defaultShapePattern : {})).filter((key => key.toLowerCase().includes("shape")))), shapePattern = {};
    return shapeKeys.forEach((key => {
        var _a, _b, _c;
        const value = null !== (_c = null !== (_b = null !== (_a = null == userLinePattern ? void 0 : userLinePattern[key]) && void 0 !== _a ? _a : null == userPattern ? void 0 : userPattern[key]) && void 0 !== _b ? _b : null == shapePatternFromMap ? void 0 : shapePatternFromMap[key]) && void 0 !== _c ? _c : null == defaultShapePattern ? void 0 : defaultShapePattern[key];
        void 0 !== value && (shapePattern[key] = value);
    })), shapePattern;
};
//# sourceMappingURL=get-spec.js.map
