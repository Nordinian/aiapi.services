{"version":3,"sources":["../src/data/transforms/stack-split.ts"],"names":[],"mappings":";;;AACA,6CAAyC;AAQlC,MAAM,UAAU,GAAG,CAAC,IAAqB,EAAE,EAAgB,EAAE,EAAE;IACpE,MAAM,MAAM,GAAqB;QAC/B,KAAK,EAAE,EAAE;KACV,CAAC;IACF,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC;IACtB,IAAI,CAAC,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,CAAA,EAAE;QACnB,OAAO,MAAM,CAAC;KACf;IACD,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;IACzC,IAAI,IAAI,GAAyB,MAAM,CAAC;IACxC,IAAI,QAA8B,CAAC;IACnC,IAAI,IAA0B,CAAC;IAC/B,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;QAChB,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAQ,EAAE,EAAE;YACjC,IAAI,GAAG,MAAM,CAAC;YACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACtC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBACpB,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChB,IAAI,IAAA,cAAK,EAAC,EAAE,CAAC,EAAE;oBACb,MAAM;iBACP;gBACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;oBACnB,IAAI,CAAC,KAAK,cAAc,EAAE;wBACxB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;qBACjC;yBAAM;wBACL,QAAQ,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;wBACzB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC;qBAC3B;iBACF;gBACD,IAAI,CAAC,KAAK,cAAc,EAAE;oBACxB,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAyB,CAAC;oBAC9C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACrB;qBAAM;oBACL,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAyB,CAAC;iBAC/C;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAvCW,QAAA,UAAU,cAuCrB","file":"stack-split.js","sourcesContent":["import type { ISeriesStackData, ISeriesStackDataLeaf, ISeriesStackDataNode } from '../../series/interface';\nimport { isNil } from '@visactor/vutils';\nimport type { DataView } from '@visactor/vdataset';\nimport type { Datum } from '../../typings';\n\nexport interface IStackOption {\n  fields: string[];\n}\n\nexport const stackSplit = (data: Array<DataView>, op: IStackOption) => {\n  const result: ISeriesStackData = {\n    nodes: {}\n  };\n  const { fields } = op;\n  if (!fields?.length) {\n    return result;\n  }\n  const lastFieldIndex = fields.length - 1;\n  let temp: ISeriesStackDataNode = result;\n  let nextNode: ISeriesStackDataNode;\n  let leaf: ISeriesStackDataLeaf;\n  data.forEach(dv => {\n    dv.latestData.forEach((d: Datum) => {\n      temp = result;\n      for (let i = 0; i < fields.length; i++) {\n        const f = fields[i];\n        const fV = d[f];\n        if (isNil(fV)) {\n          break;\n        }\n        if (!temp.nodes[fV]) {\n          if (i === lastFieldIndex) {\n            temp.nodes[fV] = { values: [] };\n          } else {\n            nextNode = { nodes: {} };\n            temp.nodes[fV] = nextNode;\n          }\n        }\n        if (i === lastFieldIndex) {\n          leaf = temp.nodes[fV] as ISeriesStackDataLeaf;\n          leaf.values.push(d);\n        } else {\n          temp = temp.nodes[fV] as ISeriesStackDataNode;\n        }\n      }\n    });\n  });\n  return result;\n};\n"]}