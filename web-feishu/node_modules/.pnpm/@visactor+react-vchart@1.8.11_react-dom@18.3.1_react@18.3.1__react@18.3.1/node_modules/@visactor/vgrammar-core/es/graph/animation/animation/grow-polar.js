import { isNumber } from "@visactor/vutils";

const growAngleInIndividual = (element, options, animationParameters) => options && "anticlockwise" === options.orient ? {
    from: {
        startAngle: element.getGraphicAttribute("endAngle", !1)
    },
    to: {
        startAngle: element.getGraphicAttribute("startAngle", !1)
    }
} : {
    from: {
        endAngle: element.getGraphicAttribute("startAngle", !1)
    },
    to: {
        endAngle: element.getGraphicAttribute("endAngle", !1)
    }
}, growAngleInOverall = (element, options, animationParameters) => {
    if (options && "anticlockwise" === options.orient) {
        const overallValue = isNumber(options.overall) ? options.overall : 2 * Math.PI;
        return {
            from: {
                startAngle: overallValue,
                endAngle: overallValue
            },
            to: {
                startAngle: element.getGraphicAttribute("startAngle", !1),
                endAngle: element.getGraphicAttribute("endAngle", !1)
            }
        };
    }
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: overallValue,
            endAngle: overallValue
        },
        to: {
            startAngle: element.getGraphicAttribute("startAngle", !1),
            endAngle: element.getGraphicAttribute("endAngle", !1)
        }
    };
};

export const growAngleIn = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleInOverall(element, options) : growAngleInIndividual(element, options);
};

const growAngleOutIndividual = (element, options, animationParameters) => options && "anticlockwise" === options.orient ? {
    from: {
        startAngle: element.getGraphicAttribute("startAngle", !0)
    },
    to: {
        startAngle: element.getGraphicAttribute("endAngle", !1)
    }
} : {
    from: {
        endAngle: element.getGraphicAttribute("endAngle", !0)
    },
    to: {
        endAngle: element.getGraphicAttribute("startAngle", !1)
    }
}, growAngleOutOverall = (element, options, animationParameters) => {
    if (options && "anticlockwise" === options.orient) {
        const overallValue = isNumber(options.overall) ? options.overall : 2 * Math.PI;
        return {
            from: {
                startAngle: element.getGraphicAttribute("startAngle", !0),
                endAngle: element.getGraphicAttribute("endAngle", !0)
            },
            to: {
                startAngle: overallValue,
                endAngle: overallValue
            }
        };
    }
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: element.getGraphicAttribute("startAngle", !0),
            endAngle: element.getGraphicAttribute("endAngle", !0)
        },
        to: {
            startAngle: overallValue,
            endAngle: overallValue
        }
    };
};

export const growAngleOut = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(element, options) : growAngleOutIndividual(element, options);
};

const growRadiusInIndividual = (element, options, animationParameters) => options && "inside" === options.orient ? {
    from: {
        innerRadius: element.getGraphicAttribute("outerRadius", !1)
    },
    to: {
        innerRadius: element.getGraphicAttribute("innerRadius", !1)
    }
} : {
    from: {
        outerRadius: element.getGraphicAttribute("innerRadius", !1)
    },
    to: {
        outerRadius: element.getGraphicAttribute("outerRadius", !1)
    }
}, growRadiusInOverall = (element, options, animationParameters) => {
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            innerRadius: overallValue,
            outerRadius: overallValue
        },
        to: {
            innerRadius: element.getGraphicAttribute("innerRadius", !1),
            outerRadius: element.getGraphicAttribute("outerRadius", !1)
        }
    };
};

export const growRadiusIn = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusInOverall(element, options) : growRadiusInIndividual(element, options);
};

const growRadiusOutIndividual = (element, options, animationParameters) => options && "inside" === options.orient ? {
    from: {
        innerRadius: element.getGraphicAttribute("innerRadius", !0)
    },
    to: {
        innerRadius: element.getGraphicAttribute("outerRadius", !1)
    }
} : {
    from: {
        outerRadius: element.getGraphicAttribute("outerRadius", !0)
    },
    to: {
        outerRadius: element.getGraphicAttribute("innerRadius", !1)
    }
}, growRadiusOutOverall = (element, options, animationParameters) => {
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            innerRadius: element.getGraphicAttribute("innerRadius", !0),
            outerRadius: element.getGraphicAttribute("outerRadius", !0)
        },
        to: {
            innerRadius: overallValue,
            outerRadius: overallValue
        }
    };
};

export const growRadiusOut = (element, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusOutOverall(element, options) : growRadiusOutIndividual(element, options);
};
//# sourceMappingURL=grow-polar.js.map
