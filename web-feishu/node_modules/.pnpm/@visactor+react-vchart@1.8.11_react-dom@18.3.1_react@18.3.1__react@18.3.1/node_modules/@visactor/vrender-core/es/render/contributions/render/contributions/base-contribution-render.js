var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

import { inject, injectable, named } from "../../../../common/inversify-lite";

import { getTheme } from "../../../../graphic";

import { canvasAllocate } from "../../../../allocator/canvas-allocate";

import { BaseRenderContributionTime } from "../../../../common/enums";

import { ContributionProvider } from "../../../../common/contribution-provider";

import { InteractiveSubRenderContribution } from "./constants";

export class DefaultBaseBackgroundRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        const {background: background, backgroundMode: backgroundMode = graphicAttribute.backgroundMode, backgroundFit: backgroundFit = graphicAttribute.backgroundFit} = graphic.attribute;
        if (background) if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = getTheme(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
            }
            context.clip();
            const b = graphic.AABBBounds;
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), 
            context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = background, context.fill(), context.highPerformanceRestore();
    }
    doDrawImage(context, data, b, backgroundMode, backgroundFit) {
        if ("no-repeat" === backgroundMode) context.drawImage(data, b.x1, b.y1, b.width(), b.height()); else {
            const targetW = b.width(), targetH = b.height();
            let w = targetW, h = targetH;
            if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
                const resW = data.width, resH = data.height;
                if ("repeat-x" === backgroundMode) {
                    w = resW * (targetH / resH), h = targetH;
                } else if ("repeat-y" === backgroundMode) {
                    h = resH * (targetW / resW), w = targetW;
                }
                const dpr = context.dpr, canvas = canvasAllocate.allocate({
                    width: w,
                    height: h,
                    dpr: dpr
                }), ctx = canvas.getContext("2d");
                ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), 
                ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
            }
            const dpr = context.dpr, pattern = context.createPattern(data, backgroundMode);
            pattern.setTransform && pattern.setTransform(new DOMMatrix([ 1 / dpr, 0, 0, 1 / dpr, 0, 0 ])), 
            context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), 
            context.translate(-b.x1, -b.y1);
        }
    }
}

export const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution;

let DefaultBaseInteractiveRenderContribution = class {
    constructor(subRenderContribitions) {
        this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, 
        this.useStyle = !0, this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), 
        this._subRenderContribitions.forEach((c => {
            c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
        }));
    }
};

DefaultBaseInteractiveRenderContribution = __decorate([ injectable(), __param(0, inject(ContributionProvider)), __param(0, named(InteractiveSubRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultBaseInteractiveRenderContribution);

export { DefaultBaseInteractiveRenderContribution };
//# sourceMappingURL=base-contribution-render.js.map
