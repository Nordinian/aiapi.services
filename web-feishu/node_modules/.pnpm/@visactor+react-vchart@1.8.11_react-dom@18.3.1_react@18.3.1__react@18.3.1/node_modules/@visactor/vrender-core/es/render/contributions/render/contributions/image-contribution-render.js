import { getTheme } from "../../../../graphic";

import { DefaultBaseBackgroundRenderContribution } from "./base-contribution-render";

import { BaseRenderContributionTime } from "../../../../common/enums";

import { isNumber, isObject } from "@visactor/vutils";

import { parsePadding } from "../../../../common/utils";

import { createRectPath } from "../../../../common/shape/rect";

export class DefaultImageBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        const {background: background, backgroundMode: backgroundMode = graphicAttribute.backgroundMode, backgroundFit: backgroundFit = graphicAttribute.backgroundFit} = graphic.attribute;
        if (background) if (graphic.backgroundImg) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = getTheme(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
            }
            const b = graphic.AABBBounds;
            this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), 
            graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else if (isObject(background)) {
            const {stroke: stroke, fill: fill, lineWidth: lineWidth = 1, cornerRadius: cornerRadius = 0, expandX: expandX = 0, expandY: expandY = 0} = background;
            if (!stroke && !fill) return;
            context.beginPath();
            const {x: x, y: y, width: width, height: height} = getActualPosition(graphic);
            cornerRadius ? createRectPath(context, x - expandX, y - expandY, width + 2 * expandX, height + 2 * expandY, cornerRadius) : context.rect(x - expandX, y - expandY, width + 2 * expandX, height + 2 * expandY), 
            context.globalAlpha = 1, fill && (context.fillStyle = fill, context.fill()), stroke && lineWidth > 0 && (context.lineWidth = lineWidth, 
            context.strokeStyle = stroke, context.stroke());
        } else {
            context.beginPath();
            const b = graphic.AABBBounds;
            context.rect(x, y, b.width(), b.height()), context.fillStyle = background, context.globalAlpha = 1, 
            context.fill();
        }
    }
}

function getActualPosition(graphic) {
    const boundsPadding = parsePadding(graphic.attribute.boundsPadding), bounds = graphic.AABBBounds;
    let x = bounds.x1, y = bounds.y1, width = bounds.width(), height = bounds.height();
    return isNumber(boundsPadding) ? (x += boundsPadding, y += boundsPadding, width -= 2 * boundsPadding, 
    height -= 2 * boundsPadding) : (x += boundsPadding[3], y += boundsPadding[0], width -= boundsPadding[1] + boundsPadding[3], 
    height -= boundsPadding[0] + boundsPadding[2]), {
        x: x,
        y: y,
        width: width,
        height: height
    };
}

export const defaultImageBackgroundRenderContribution = new DefaultImageBackgroundRenderContribution;
//# sourceMappingURL=image-contribution-render.js.map
