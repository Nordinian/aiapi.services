"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createColor = exports.getScaledStroke = void 0;

const vutils_1 = require("@visactor/vutils"), color_utils_1 = require("./color-utils");

function getScaledStroke(context, width, dpr) {
    let strokeWidth = width;
    const {a: a, b: b, c: c, d: d} = context.currentMatrix, scaleX = Math.sign(a) * Math.sqrt(a * a + b * b), scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
    return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, 
    strokeWidth);
}

function createColor(context, c, params, offsetX, offsetY) {
    if (!c || !0 === c) return "black";
    let result, color;
    if ((0, vutils_1.isArray)(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++) ; else color = c;
    return color = color_utils_1.GradientParser.Parse(color), "string" == typeof color ? color : ("linear" === color.gradient ? result = createLinearGradient(context, color, params, offsetX, offsetY) : "conical" === color.gradient ? result = createConicGradient(context, color, params, offsetX, offsetY) : "radial" === color.gradient && (result = createRadialGradient(context, color, params, offsetX, offsetY)), 
    result || "orange");
}

function createLinearGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createRadialGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d, _e, _f;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        x /= scaleX, y /= scaleY, w /= scaleX, h /= scaleY;
    }
    const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createConicGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient.GetPattern(w + x, h + y, undefined);
}

//# sourceMappingURL=canvas-utils.js.map
exports.getScaledStroke = getScaledStroke, exports.createColor = createColor;