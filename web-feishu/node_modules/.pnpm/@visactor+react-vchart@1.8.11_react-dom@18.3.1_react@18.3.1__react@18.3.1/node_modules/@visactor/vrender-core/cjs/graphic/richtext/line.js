"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const icon_1 = require("./icon"), paragraph_1 = __importDefault(require("./paragraph")), utils_1 = require("./utils");

class Line {
    constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
        this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, 
        this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p => p)), 
        this.textAlign = (this.paragraphs[0] instanceof icon_1.RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", 
        this.direction = direction, this.directionKey = utils_1.DIRECTION_KEY[this.direction], 
        this.actualWidth = 0;
        let maxHeight = 0;
        this.paragraphs.forEach(((word, index) => {
            if (0 === index && word instanceof paragraph_1.default) {
                const result = utils_1.regFirstSpace.exec(word.text);
                0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), 
                word.updateWidth());
            }
            this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
        })), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, 
        this.calcOffset(width, isWidthMax);
    }
    calcOffset(width, isWidthMax) {
        const directionKey = this.directionKey, maxHeight = this.height;
        let x = this.left, spacing = 0;
        if (this.actualWidth < width && !isWidthMax) switch (this.textAlign) {
          case "right":
            x = width - this.actualWidth;
            break;

          case "center":
            x = (width - this.actualWidth) / 2;
            break;

          case "justify":
            this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);
        }
        this.paragraphs.map((function(paragraph) {
            paragraph instanceof icon_1.RichTextIcon ? (paragraph["_" + directionKey.x] = x, 
            x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, 
            x += paragraph[directionKey.width] + spacing);
        }));
    }
    draw(ctx, lastLine, x, y, drawIcon) {
        if (lastLine) {
            let otherParagraphWidth = 0;
            for (let i = this.paragraphs.length - 1; i >= 0; i--) {
                const paragraph = this.paragraphs[i];
                if (paragraph instanceof icon_1.RichTextIcon) break;
                if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
                    paragraph.verticalEllipsis = !0;
                    break;
                }
                const {width: width} = (0, utils_1.measureTextCanvas)("...", paragraph.character), ellipsisWidth = width || 0;
                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                    paragraph.ellipsis = "add";
                    break;
                }
                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                    paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                    break;
                }
                paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
            }
        }
        this.paragraphs.map(((paragraph, index) => {
            if (paragraph instanceof icon_1.RichTextIcon) return paragraph.setAttributes({
                x: x + paragraph._x,
                y: y + paragraph._y
            }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
            paragraph.draw(ctx, y + this.ascent, x, 0 === index, this.textAlign);
        }));
    }
    getWidthWithEllips() {
        let otherParagraphWidth = 0;
        for (let i = this.paragraphs.length - 1; i >= 0; i--) {
            const paragraph = this.paragraphs[i];
            if (paragraph instanceof icon_1.RichTextIcon) break;
            const {width: width} = (0, utils_1.measureTextCanvas)("...", paragraph.character), ellipsisWidth = width || 0;
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
                break;
            }
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                break;
            }
            paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
        }
        let width = 0;
        return this.paragraphs.map(((paragraph, index) => {
            paragraph instanceof icon_1.RichTextIcon ? width += paragraph.width : width += paragraph.getWidthWithEllips(this.direction);
        })), width;
    }
}

exports.default = Line;
//# sourceMappingURL=line.js.map
