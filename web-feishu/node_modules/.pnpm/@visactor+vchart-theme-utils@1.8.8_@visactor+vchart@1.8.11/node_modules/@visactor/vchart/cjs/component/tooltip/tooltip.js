"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerTooltip = exports.Tooltip = void 0;

const type_1 = require("../interface/type"), base_component_1 = require("../base/base-component"), dom_1 = require("./handler/dom"), canvas_1 = require("./handler/canvas"), env_1 = require("../../util/env"), common_1 = require("./interface/common"), constants_1 = require("./handler/constants"), show_tooltip_1 = require("./utils/show-tooltip"), common_2 = require("./utils/common"), common_3 = require("../../event/events/dimension/util/common"), constant_1 = require("../../constant"), dimension_tooltip_1 = require("./processor/dimension-tooltip"), util_1 = require("./processor/util"), mark_tooltip_1 = require("./processor/mark-tooltip"), vutils_1 = require("@visactor/vutils"), vchart_1 = require("../../core/vchart"), factory_1 = require("../../core/factory"), tooltip_transformer_1 = require("./tooltip-transformer");

class Tooltip extends base_component_1.BaseComponent {
    constructor() {
        super(...arguments), this.layoutZIndex = 1, this.type = type_1.ComponentTypeEnum.tooltip, 
        this.name = type_1.ComponentTypeEnum.tooltip, this.transformerConstructor = tooltip_transformer_1.TooltipSpecTransformer, 
        this.specKey = "tooltip", this.layoutType = "none", this._alwaysShow = !1, this._eventList = [], 
        this._isTooltipShown = !1, this._mountEvent = (eType, query, callback) => {
            this.event.on(eType, query, callback), this._eventList.push({
                eventType: eType,
                handler: callback
            });
        }, this._getMouseOutHandler = needPointerDetection => params => {
            var _a, _b;
            if (this._alwaysShow) return;
            if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return;
            const browserEnv = (0, env_1.isTrueBrowser)(this._option.mode), {clientX: clientX, clientY: clientY} = params.event;
            browserEnv && this._isPointerOnTooltip(params) || browserEnv && needPointerDetection && this._isPointerInChart({
                x: clientX,
                y: clientY
            }) || this._handleChartMouseOut(params);
        }, this._handleChartMouseOut = params => {
            this._alwaysShow || "none" !== this._spec.triggerOff && (this._hideTooltipByHandler(Object.assign({}, params)), 
            this._cacheInfo = void 0);
        }, this._handleMouseMove = params => {
            if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), 
            this._alwaysShow) return;
            if (this._isPointerOnTooltip(params)) return;
            const mouseEventData = this._getMouseEventData(params), {tooltipInfo: {dimension: dimensionInfo}, ignore: {mark: ignoreMark, dimension: ignoreDimension}} = mouseEventData;
            let markTooltipSuccess = !1, dimensionTooltipSuccess = !1;
            markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params), 
            markTooltipSuccess || (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params)), 
            markTooltipSuccess || dimensionTooltipSuccess || (0, common_2.isEmptyPos)(params) || (ignoreMark && (0, 
            util_1.isMarkInfo)(this._cacheInfo) ? markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params, !0) : ignoreDimension && (0, 
            util_1.isDimensionInfo)(this._cacheInfo) ? dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params, !0) : (0, 
            vutils_1.isValid)(dimensionInfo) && (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params))), 
            markTooltipSuccess || dimensionTooltipSuccess && !(0, vutils_1.isNil)(dimensionInfo) || this._handleChartMouseOut(params);
        }, this._showTooltipByMouseEvent = (activeType, mouseEventData, params, useCache) => {
            const processor = this._processor[activeType];
            if (!processor.shouldHandleTooltip(params, {
                tooltipInfo: mouseEventData.tooltipInfo[activeType],
                ignore: mouseEventData.ignore[activeType]
            })) return !1;
            let success;
            if (useCache) success = !processor.showTooltip(this._cacheInfo, params, !0); else {
                const tooltipInfo = mouseEventData.tooltipInfo[activeType], isSameAsCache = this._isSameAsCacheInfo(tooltipInfo);
                success = !processor.showTooltip(tooltipInfo, params, isSameAsCache), success && (this._cacheInfo = tooltipInfo);
            }
            success && (this._isTooltipShown = !0);
            const vchart = this._option.globalInstance;
            return success && vchart_1.VChart.globalConfig.uniqueTooltip && vchart_1.VChart.hideTooltip(vchart.id), 
            success;
        }, this._getMouseEventData = params => {
            const result = {
                tooltipInfo: {},
                ignore: {}
            };
            return Object.keys(this._processor).forEach((activeType => {
                const {tooltipInfo: tooltipInfo, ignore: ignore} = this._processor[activeType].getMouseEventData(params);
                result.tooltipInfo[activeType] = tooltipInfo, result.ignore[activeType] = ignore;
            })), result;
        }, this._hideTooltipByHandler = params => {
            var _a, _b, _c;
            if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return common_1.TooltipResult.success;
            if (this.event.emit(constant_1.ChartEvent.tooltipHide, Object.assign(Object.assign({}, params), {
                source: constant_1.Event_Source_Type.chart,
                tooltip: this
            })), null === (_c = this.tooltipHandler) || void 0 === _c ? void 0 : _c.hideTooltip) {
                const result = this.tooltipHandler.hideTooltip(params);
                return result || (this._isTooltipShown = !1), result;
            }
            return common_1.TooltipResult.failed;
        };
    }
    static getSpecInfo(chartSpec) {
        const tooltipSpec = chartSpec[this.specKey];
        if (!tooltipSpec) return null;
        if (!(0, vutils_1.isArray)(tooltipSpec)) return [ {
            spec: tooltipSpec,
            specPath: [ this.specKey ],
            type: type_1.ComponentTypeEnum.tooltip
        } ];
        const specInfos = [];
        return tooltipSpec.forEach(((s, i) => {
            specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: type_1.ComponentTypeEnum.tooltip
            });
        })), specInfos;
    }
    isTooltipShown() {
        return this._isTooltipShown;
    }
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return [];
    }
    _registerEvent() {}
    _releaseEvent() {}
    onLayout(ctx) {}
    onLayoutEnd(ctx) {}
    onRender(ctx) {}
    created() {
        super.created(), this._regions = this._option.getAllRegions(), this._initEvent();
    }
    release() {
        var _a, _b;
        super.release(), this._eventList.forEach((({eventType: eventType, handler: handler}) => {
            this.event.off(eventType, handler);
        })), this._eventList = [], null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), 
        this._isTooltipShown = !1;
    }
    beforeRelease() {
        this.event.emit(constant_1.ChartEvent.tooltipHide, {
            tooltip: this
        }), this.event.emit(constant_1.ChartEvent.tooltipRelease, {
            tooltip: this
        });
    }
    _initHandler() {
        var _a, _b, _c;
        const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", userTooltipHandler = this._option.globalInstance.getTooltipHandlerByUser();
        if (userTooltipHandler) this.tooltipHandler = userTooltipHandler; else {
            const Handler = "canvas" === renderMode ? canvas_1.CanvasTooltipHandler : dom_1.DomTooltipHandler, id = `${this._spec.className}-${null !== (_b = this._option.globalInstance.id) && void 0 !== _b ? _b : 0}-${null !== (_c = this._option.specIndex) && void 0 !== _c ? _c : 0}`;
            this.tooltipHandler = new Handler(id, this);
        }
    }
    _initProcessor() {
        this._processor = {
            mark: new mark_tooltip_1.MarkTooltipProcessor(this),
            dimension: new dimension_tooltip_1.DimensionTooltipProcessor(this)
        };
    }
    _initEvent() {
        var _a;
        if (this._option.disableTriggerEvent) return;
        const trigger = null !== (_a = this._spec.trigger) && void 0 !== _a ? _a : "hover", mode = this._option.mode;
        "hover" === trigger ? (this._mountEvent("pointermove", {
            level: constant_1.Event_Bubble_Level.chart
        }, this._handleMouseMove), ((0, env_1.isMobileLikeMode)(mode) || (0, env_1.isMiniAppLikeMode)(mode)) && (this._mountEvent("pointerdown", {
            level: constant_1.Event_Bubble_Level.chart
        }, this._handleMouseMove), this._mountEvent("pointerup", {
            source: "window"
        }, this._getMouseOutHandler(!0))), this._mountEvent("pointerout", {
            source: "canvas"
        }, this._getMouseOutHandler(!1))) : "click" === trigger && (this._mountEvent("pointertap", {
            level: constant_1.Event_Bubble_Level.chart
        }, this._handleMouseMove), this._mountEvent("pointerup", {
            source: "window"
        }, this._getMouseOutHandler(!0)));
    }
    reInit(spec) {
        var _a, _b;
        super.reInit(spec), this.tooltipHandler ? null === (_b = (_a = this.tooltipHandler).reInit) || void 0 === _b || _b.call(_a) : this._initHandler();
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec();
        const userSpec = this._spec;
        this._spec = Object.assign(Object.assign({}, userSpec), {
            visible: !(0, vutils_1.isValid)(userSpec.visible) || userSpec.visible,
            activeType: (0, common_2.getTooltipActualActiveType)(userSpec),
            renderMode: "html",
            trigger: (0, vutils_1.isValid)(userSpec.trigger) ? userSpec.trigger : "hover",
            className: (0, vutils_1.isValid)(userSpec.className) ? userSpec.className : constants_1.TOOLTIP_EL_CLASS_NAME,
            enterable: !!(0, vutils_1.isValid)(userSpec.enterable) && userSpec.enterable,
            transitionDuration: (0, vutils_1.isValid)(userSpec.transitionDuration) ? userSpec.transitionDuration : 150
        }), this._spec.triggerOff = (0, vutils_1.isValid)(userSpec.triggerOff) ? userSpec.triggerOff : this._spec.trigger, 
        (0, vutils_1.isValid)(userSpec.renderMode) ? this._spec.renderMode = userSpec.renderMode : (0, 
        env_1.isMiniAppLikeMode)(this._option.mode) && (this._spec.renderMode = "canvas"), 
        (0, vutils_1.isValid)(userSpec.mark) && (this._spec.mark = Object.assign(Object.assign({}, (0, 
        vutils_1.cloneDeep)(userSpec.mark)), {
            activeType: "mark"
        })), (0, vutils_1.isValid)(userSpec.dimension) && (this._spec.dimension = Object.assign(Object.assign({}, (0, 
        vutils_1.cloneDeep)(userSpec.dimension)), {
            activeType: "dimension"
        })), (0, vutils_1.isValid)(userSpec.parentElement) ? (0, vutils_1.isString)(userSpec.parentElement) ? this._spec.parentElement = null === (_a = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === _a ? void 0 : _a.getElementById(userSpec.parentElement) : this._spec.parentElement = userSpec.parentElement : (0, 
        env_1.isTrueBrowser)(this._option.mode) && (this._spec.parentElement = null === env_1.domDocument || void 0 === env_1.domDocument ? void 0 : env_1.domDocument.body), 
        (0, vutils_1.isValid)(userSpec.confine) ? this._spec.confine = userSpec.confine : this._spec.confine = "canvas" === this._spec.renderMode;
    }
    showTooltip(datum, options) {
        var _a;
        if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), 
        !(null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip)) return !1;
        const result = (0, show_tooltip_1.showTooltip)(datum, options, this.tooltipHandler, this._option);
        return "none" !== result && (this._alwaysShow = !!(null == options ? void 0 : options.alwaysShow)), 
        result;
    }
    hideTooltip() {
        const params = {
            changePositionOnly: !1,
            item: void 0,
            datum: void 0,
            source: constant_1.Event_Source_Type.chart
        };
        return this._alwaysShow = !1, !this._hideTooltipByHandler(params);
    }
    _isSameAsCacheInfo(nextInfo) {
        if (nextInfo === this._cacheInfo) return !0;
        if ((0, vutils_1.isNil)(this._cacheInfo) || (0, vutils_1.isNil)(nextInfo)) return !1;
        if ((0, util_1.isDimensionInfo)(nextInfo)) {
            if ((0, util_1.isMarkInfo)(this._cacheInfo)) return !1;
            const prevInfo = this._cacheInfo;
            return prevInfo.length === nextInfo.length && nextInfo.every(((info, i) => (0, common_3.isSameDimensionInfo)(info, prevInfo[i])));
        }
        if ((0, util_1.isDimensionInfo)(this._cacheInfo)) return !1;
        const prevInfo = this._cacheInfo;
        return (null == nextInfo ? void 0 : nextInfo.datum) === prevInfo.datum && (null == nextInfo ? void 0 : nextInfo.mark) === prevInfo.mark && (null == nextInfo ? void 0 : nextInfo.series) === prevInfo.series;
    }
    _isPointerInChart(point) {
        const globalInstance = this._option.globalInstance;
        if (!globalInstance.getChart()) return !1;
        const {x: x, y: y} = point, canvas = globalInstance.getCanvas(), {x: chartX, y: chartY, width: chartWidth, height: chartHeight} = canvas.getBoundingClientRect();
        return x >= chartX && x <= chartX + chartWidth && y >= chartY && y <= chartY + chartHeight;
    }
    _isPointerOnTooltip(params) {
        var _a, _b;
        if (this._spec.enterable && "html" === this._spec.renderMode) {
            const {event: event} = params;
            let newTarget;
            if ((0, vutils_1.isValid)(event.nativeEvent)) {
                const nativeEvent = event.nativeEvent;
                newTarget = nativeEvent.relatedTarget, nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (newTarget = nativeEvent.composedPath()[0]);
            } else newTarget = event.relatedTarget;
            const container = null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.getTooltipContainer) || void 0 === _b ? void 0 : _b.call(_a);
            if ((0, vutils_1.isValid)(container) && (0, vutils_1.isValid)(newTarget) && (0, 
            vutils_1.hasParentElement)(newTarget, container)) return !0;
        }
        return !1;
    }
    getVisible() {
        return !1 !== this._spec.visible;
    }
}

exports.Tooltip = Tooltip, Tooltip.type = type_1.ComponentTypeEnum.tooltip, Tooltip.transformerConstructor = tooltip_transformer_1.TooltipSpecTransformer, 
Tooltip.specKey = "tooltip";

const registerTooltip = () => {
    factory_1.Factory.registerComponent(Tooltip.type, Tooltip);
};

exports.registerTooltip = registerTooltip;
//# sourceMappingURL=tooltip.js.map
