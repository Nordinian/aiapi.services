"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerCartesianLinearAxis = exports.CartesianLinearAxis = void 0;

const vscale_1 = require("@visactor/vscale"), axis_1 = require("./axis"), vutils_1 = require("@visactor/vutils"), type_1 = require("../../interface/type"), linear_axis_mixin_1 = require("../mixin/linear-axis-mixin"), factory_1 = require("../../../core/factory"), base_axis_1 = require("../base-axis");

class CartesianLinearAxis extends axis_1.CartesianAxis {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.cartesianLinearAxis, this._zero = !0, 
        this._nice = !0, this._extend = {}, this._scale = new vscale_1.LinearScale;
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this.setExtraAttrFromSpec();
    }
    initScales() {
        var _a, _b;
        super.initScales();
        const range = [ 0, 1 ];
        (0, vutils_1.isValid)(null === (_a = this._domain) || void 0 === _a ? void 0 : _a.min) && (range[0] = this._domain.min), 
        (0, vutils_1.isValid)(null === (_b = this._domain) || void 0 === _b ? void 0 : _b.max) && (range[1] = this._domain.max), 
        this._scale.domain(range);
    }
    computeDomain(data) {
        return this.computeLinearDomain(data);
    }
    axisHelper() {
        const helper = super.axisHelper();
        return helper.setExtendDomain = this.setExtendDomain.bind(this), helper.valueToPosition = this.valueToPosition.bind(this), 
        helper;
    }
}

exports.CartesianLinearAxis = CartesianLinearAxis, CartesianLinearAxis.type = type_1.ComponentTypeEnum.cartesianLinearAxis, 
CartesianLinearAxis.specKey = "axes", (0, vutils_1.mixin)(CartesianLinearAxis, linear_axis_mixin_1.LinearAxisMixin);

const registerCartesianLinearAxis = () => {
    (0, base_axis_1.registerAxis)(), factory_1.Factory.registerComponent(CartesianLinearAxis.type, CartesianLinearAxis);
};

exports.registerCartesianLinearAxis = registerCartesianLinearAxis;
//# sourceMappingURL=linear-axis.js.map
