"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getOneLineData = exports.getShowContent = void 0;

const vutils_1 = require("@visactor/vutils"), common_1 = require("./common"), common_2 = require("../../utils/common"), constants_1 = require("../constants"), getShowContent = (pattern, data, params) => {
    var _a, _b, _c, _d, _e;
    if (!data || "mouseout" === (null === (_a = null == params ? void 0 : params.event) || void 0 === _a ? void 0 : _a.type)) return null;
    const patternTitle = (0, common_1.getTooltipPatternValue)(pattern.title, data, params), patternContent = (0, 
    vutils_1.array)((0, common_1.getTooltipPatternValue)(pattern.content, data, params)), tooltipContent = {
        title: {
            value: null === (_b = null == patternTitle ? void 0 : patternTitle.value) || void 0 === _b ? void 0 : _b.toString(),
            hasShape: !1,
            shapeType: void 0,
            shapeHollow: void 0
        },
        content: []
    }, {maxLineCount: maxLineCount = constants_1.TOOLTIP_MAX_LINE_COUNT} = pattern, patternTitleVisible = !1 !== (0, 
    common_1.getTooltipContentValue)(null == patternTitle ? void 0 : patternTitle.visible, data, params);
    if (patternTitle && patternTitleVisible) {
        const datum = (0, common_1.getFirstDatumFromTooltipData)(data);
        tooltipContent.title = {
            value: (0, common_1.getTooltipContentValue)(null == patternTitle ? void 0 : patternTitle.value, datum, params),
            valueStyle: (0, common_1.getTooltipContentValue)(null == patternTitle ? void 0 : patternTitle.valueStyle, datum, params),
            hasShape: patternTitle.hasShape
        };
    } else tooltipContent.title = {
        hasShape: !1,
        visible: !1
    };
    if ("mark" === pattern.activeType) for (const content of null != patternContent ? patternContent : []) {
        const oneLineData = (0, exports.getOneLineData)(null === (_c = data[0]) || void 0 === _c ? void 0 : _c.datum[0], content, params);
        if (!1 !== oneLineData.visible) {
            if (tooltipContent.content.length === maxLineCount - 1) {
                tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), constants_1.TOOLTIP_OTHERS_LINE));
                break;
            }
            if (!(tooltipContent.content.length < maxLineCount)) break;
            tooltipContent.content.push(oneLineData);
        }
    } else if ("dimension" === pattern.activeType) for (const {data: d} of data) {
        for (const {datum: datum, series: series} of d) {
            if (!(0, common_2.getTooltipActualActiveType)(null === (_d = series.tooltipHelper) || void 0 === _d ? void 0 : _d.spec).includes("dimension")) continue;
            const contentPatterns = null !== (_e = null == patternContent ? void 0 : patternContent.filter((c => (0, 
            vutils_1.isNil)(c.seriesId) || c.seriesId === series.id))) && void 0 !== _e ? _e : [];
            for (const datumItem of datum) {
                for (const linePattern of contentPatterns) {
                    const oneLineData = (0, exports.getOneLineData)(datumItem, linePattern, params);
                    if (!1 !== oneLineData.visible) {
                        if (tooltipContent.content.length === maxLineCount - 1) {
                            tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), constants_1.TOOLTIP_OTHERS_LINE));
                            break;
                        }
                        if (!(tooltipContent.content.length < maxLineCount)) break;
                        tooltipContent.content.push(oneLineData);
                    }
                }
                if (tooltipContent.content.length >= maxLineCount) break;
            }
            if (tooltipContent.content.length >= maxLineCount) break;
        }
        if (tooltipContent.content.length >= maxLineCount) break;
    }
    return tooltipContent.title && (tooltipContent.content.length > 0 && tooltipContent.content[0].shapeType ? ((0, 
    vutils_1.isNil)(tooltipContent.title.shapeType) && (tooltipContent.title.shapeType = tooltipContent.content[0].shapeType), 
    (0, vutils_1.isNil)(tooltipContent.title.shapeColor) && (tooltipContent.title.shapeColor = tooltipContent.content[0].shapeColor)) : tooltipContent.title.hasShape = !1), 
    tooltipContent;
};

exports.getShowContent = getShowContent;

const getOneLineData = (datum, config, params) => {
    const key = (0, common_1.getTooltipContentValue)(config.key, datum, params), value = (0, 
    common_1.getTooltipContentValue)(config.value, datum, params), visible = !1 !== (0, 
    common_1.getTooltipContentValue)(config.visible, datum, params) && ((0, vutils_1.isValid)(key) || (0, 
    vutils_1.isValid)(value)), isKeyAdaptive = (0, common_1.getTooltipContentValue)(config.isKeyAdaptive, datum, params), spaceRow = (0, 
    common_1.getTooltipContentValue)(config.spaceRow, datum, params), shapeType = (0, 
    common_1.getTooltipContentValue)(config.shapeType, datum, params), shapeColor = (0, 
    common_1.getTooltipContentValue)(config.shapeColor, datum, params), shapeFill = (0, 
    common_1.getTooltipContentValue)(config.shapeFill, datum, params), shapeStroke = (0, 
    common_1.getTooltipContentValue)(config.shapeStroke, datum, params), shapeLineWidth = (0, 
    common_1.getTooltipContentValue)(config.shapeLineWidth, datum, params), keyStyle = (0, 
    common_1.getTooltipContentValue)(config.keyStyle, datum, params), valueStyle = (0, 
    common_1.getTooltipContentValue)(config.valueStyle, datum, params);
    return {
        key: key,
        value: value,
        visible: visible,
        isKeyAdaptive: isKeyAdaptive,
        hasShape: config.hasShape,
        shapeType: shapeType,
        shapeFill: shapeFill,
        shapeStroke: shapeStroke,
        shapeLineWidth: shapeLineWidth,
        shapeHollow: config.shapeHollow,
        shapeColor: shapeColor,
        keyStyle: keyStyle,
        valueStyle: valueStyle,
        spaceRow: spaceRow,
        datum: datum
    };
};

exports.getOneLineData = getOneLineData;
//# sourceMappingURL=compose.js.map
