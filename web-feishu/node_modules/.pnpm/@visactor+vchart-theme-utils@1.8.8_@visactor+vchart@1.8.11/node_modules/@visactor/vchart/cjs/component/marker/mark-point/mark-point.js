"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerMarkPoint = exports.MarkPoint = void 0;

const vdataset_1 = require("@visactor/vdataset"), type_1 = require("../../interface/type"), aggregation_1 = require("../../../data/transforms/aggregation"), utils_1 = require("../utils"), register_1 = require("../../../data/register"), vrender_components_1 = require("@visactor/vrender-components"), vutils_1 = require("@visactor/vutils"), style_1 = require("../../../util/style"), base_marker_1 = require("../base-marker"), constant_1 = require("../../../constant"), factory_1 = require("../../../core/factory"), marker_filter_1 = require("../../../data/transforms/marker-filter");

class MarkPoint extends base_marker_1.BaseMarker {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.markPoint, this.name = type_1.ComponentTypeEnum.markPoint, 
        this.specKey = "markPoint", this.layoutZIndex = constant_1.LayoutZIndex.MarkPoint;
    }
    static getSpecInfo(chartSpec) {
        const markPointSpec = chartSpec[this.specKey];
        if ((0, vutils_1.isEmpty)(markPointSpec)) return;
        if (!(0, vutils_1.isArray)(markPointSpec) && !1 !== markPointSpec.visible) return [ {
            spec: markPointSpec,
            specPath: [ this.specKey ],
            type: type_1.ComponentTypeEnum.markPoint
        } ];
        const specInfos = [];
        return markPointSpec.forEach(((m, i) => {
            !1 !== m.visible && specInfos.push({
                spec: m,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: type_1.ComponentTypeEnum.markPoint
            });
        })), specInfos;
    }
    _createMarkerComponent() {
        var _a, _b;
        const {itemContent: itemContent = {}, itemLine: itemLine = {}} = this._spec, {text: label = {}, symbol: symbol, image: image, richText: richText} = itemContent, restItemContent = __rest(itemContent, [ "text", "symbol", "image", "richText" ]), markPointAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null !== (_a = this._spec.interactive) && void 0 !== _a && _a,
            position: {
                x: 0,
                y: 0
            },
            clipInRange: null !== (_b = this._spec.clip) && void 0 !== _b && _b,
            itemContent: Object.assign({
                symbolStyle: (0, style_1.transformToGraphic)(null == symbol ? void 0 : symbol.style),
                imageStyle: null == image ? void 0 : image.style,
                textStyle: (0, utils_1.transformLabelAttributes)(label),
                richTextStyle: null == richText ? void 0 : richText.style
            }, restItemContent)
        }, {visible: visible, line: line = {}} = itemLine, restItemLine = __rest(itemLine, [ "visible", "line" ]);
        markPointAttrs.itemLine = !1 !== visible ? Object.assign(Object.assign({}, restItemLine), {
            visible: !0,
            lineStyle: (0, style_1.transformToGraphic)(line.style)
        }) : {
            visible: !1
        };
        return new vrender_components_1.MarkPoint(markPointAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d, _e, _f;
        const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, isXYLayout = "x" in spec && "y" in spec, isCoordinateLayout = "coordinate" in spec, isPositionLayout = "position" in spec, autoRange = null !== (_a = null == spec ? void 0 : spec.autoRange) && void 0 !== _a && _a;
        let point;
        isXYLayout ? point = (0, utils_1.xyLayout)(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0] : isCoordinateLayout ? point = (0, 
        utils_1.coordinateLayout)(data, relativeSeries, autoRange, spec.coordinatesOffset)[0] : isPositionLayout && (point = (0, 
        utils_1.positionLayout)([ spec.position ], relativeSeries, spec.regionRelative)[0]);
        const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
        let limitRect;
        if (spec.clip || (null === (_b = spec.itemContent) || void 0 === _b ? void 0 : _b.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = (0, utils_1.computeClipRange)([ relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        if (this._markerComponent) {
            const attribute = null !== (_c = this._markerComponent.attribute) && void 0 !== _c ? _c : {}, textStyle = null !== (_e = null === (_d = attribute.itemContent) || void 0 === _d ? void 0 : _d.textStyle) && void 0 !== _e ? _e : {};
            this._markerComponent.setAttributes({
                position: point,
                itemContent: Object.assign(Object.assign({}, attribute.itemContent), {
                    textStyle: Object.assign(Object.assign({}, textStyle), {
                        text: (null === (_f = this._spec.itemContent.text) || void 0 === _f ? void 0 : _f.formatMethod) ? this._spec.itemContent.text.formatMethod(dataPoints, seriesData) : textStyle.text
                    })
                }),
                limitRect: limitRect,
                dx: this._layoutOffsetX,
                dy: this._layoutOffsetY
            });
        }
    }
    _initDataView() {
        const spec = this._spec, relativeSeries = this._relativeSeries, isXYProcess = (0, 
        vutils_1.isValid)(spec.x) && (0, vutils_1.isValid)(spec.y), isCoordinateProcess = (0, 
        vutils_1.isValid)(spec.coordinate);
        if (!isCoordinateProcess && !isXYProcess) return;
        let options;
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "markerAggregation", aggregation_1.markerAggregation), 
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "markerFilter", marker_filter_1.markerFilter), 
        isXYProcess ? options = [ this._processSpecXY(spec.x, spec.y) ] : isCoordinateProcess && (options = this._processSpecCoo(spec));
        const data = new vdataset_1.DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        data.parse([ relativeSeries.getViewData() ], {
            type: "dataview"
        }), data.transform({
            type: "markerAggregation",
            options: options
        }), options && data.transform({
            type: "markerFilter",
            options: this._getAllRelativeSeries()
        }), data.target.on("change", (() => {
            this._markerLayout();
        })), this._markerData = data;
    }
}

exports.MarkPoint = MarkPoint, MarkPoint.type = type_1.ComponentTypeEnum.markPoint, 
MarkPoint.specKey = "markPoint";

const registerMarkPoint = () => {
    factory_1.Factory.registerComponent(MarkPoint.type, MarkPoint);
};

exports.registerMarkPoint = registerMarkPoint;
//# sourceMappingURL=mark-point.js.map
