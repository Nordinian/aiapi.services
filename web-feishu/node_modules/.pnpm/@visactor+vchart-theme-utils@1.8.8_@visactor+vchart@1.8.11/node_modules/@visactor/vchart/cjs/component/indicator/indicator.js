"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerIndicator = exports.Indicator = void 0;

const vdataset_1 = require("@visactor/vdataset"), constant_1 = require("../../constant"), type_1 = require("../interface/type"), base_component_1 = require("../base/base-component"), merge_spec_1 = require("../../util/spec/merge-spec"), model_1 = require("../../util/model"), style_1 = require("../../util/style"), space_1 = require("../../util/space"), vutils_1 = require("@visactor/vutils"), util_1 = require("./util"), register_1 = require("../../data/register"), compilable_data_1 = require("../../compile/data/compilable-data"), vrender_components_1 = require("@visactor/vrender-components"), factory_1 = require("../../core/factory");

class Indicator extends base_component_1.BaseComponent {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.indicator, this.name = type_1.ComponentTypeEnum.indicator, 
        this.specKey = "indicator", this.layoutType = "none", this.layoutZIndex = constant_1.LayoutZIndex.Indicator, 
        this.layoutLevel = constant_1.LayoutLevel.Indicator, this._gap = 0, this._activeDatum = null;
    }
    static getSpecInfo(chartSpec) {
        if (this.type !== Indicator.type) return null;
        const indicatorSpec = chartSpec[this.specKey];
        if (!(0, vutils_1.isArray)(indicatorSpec)) return !1 === indicatorSpec.visible ? [] : [ {
            spec: indicatorSpec,
            specPath: [ this.specKey ],
            type: type_1.ComponentTypeEnum.indicator
        } ];
        const specInfos = [];
        return indicatorSpec.forEach(((s, i) => {
            s && !1 !== s.visible && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: type_1.ComponentTypeEnum.indicator
            });
        })), specInfos;
    }
    created() {
        super.created(), this.initData(), this.initEvent();
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._gap = this._spec.gap || 0, this._title = this._spec.title, 
        this._content = (0, vutils_1.array)(this._spec.content), this._regions = this._option.getRegionsInUserIdOrIndex((0, 
        vutils_1.array)(this._spec.regionId), (0, vutils_1.array)(this._spec.regionIndex));
    }
    onRender(ctx) {}
    changeRegions(regions) {}
    initEvent() {
        if (this._option.disableTriggerEvent) return;
        "none" !== this._spec.trigger && ("hover" === this._spec.trigger ? (this.event.on("hovered", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(params.value[0]);
        })), this.event.on("unhovered", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(null);
        }))) : (this.event.on("selected", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(params.value[0]);
        })), this.event.on("unselected", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(null);
        }))));
    }
    updateDatum(datum) {
        this._activeDatum = datum, this._displayData.updateData();
        const attrs = this._getIndicatorAttrs();
        this._createOrUpdateIndicatorComponent(attrs);
    }
    initData() {
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "indicatorFilter", util_1.indicatorMapper);
        const displayData = new vdataset_1.DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        displayData.transform({
            type: "indicatorFilter",
            options: {
                title: this._title,
                content: this._content,
                datum: () => this._activeDatum
            }
        }), displayData.target.addListener("change", this.updateDatum.bind(this)), this._displayData = new compilable_data_1.CompilableData(this._option, displayData);
    }
    updateLayoutAttribute() {
        const attrs = this._getIndicatorAttrs();
        this._createOrUpdateIndicatorComponent(attrs), super.updateLayoutAttribute();
    }
    _getIndicatorAttrs() {
        const region = this._regions[0], {width: width, height: height} = region.getLayoutRect(), {x: x, y: y} = region.getLayoutStartPoint(), contentComponentSpec = [];
        return (0, vutils_1.array)(this._spec.content).forEach((eachItem => {
            const contentSpec = (0, merge_spec_1.mergeSpec)({}, this._theme.content, eachItem);
            contentComponentSpec.push({
                visible: !1 !== contentSpec.visible && (!contentSpec.field || null !== this._activeDatum),
                space: contentSpec.space || this._gap,
                autoLimit: contentSpec.autoLimit,
                autoFit: contentSpec.autoFit,
                fitPercent: contentSpec.fitPercent,
                style: Object.assign(Object.assign({}, (0, style_1.transformToGraphic)(contentSpec.style)), {
                    text: this._createText(contentSpec.field, contentSpec.style.text)
                })
            });
        })), {
            visible: !1 !== this._spec.visible && (!1 !== this._spec.fixed || null !== this._activeDatum),
            size: {
                width: width,
                height: height
            },
            zIndex: this.layoutZIndex,
            x: x,
            y: y,
            dx: this._spec.offsetX ? (0, space_1.getActualNumValue)(this._spec.offsetX, this._computeLayoutRadius()) : 0,
            dy: this._spec.offsetY ? (0, space_1.getActualNumValue)(this._spec.offsetY, this._computeLayoutRadius()) : 0,
            limitRatio: this._spec.limitRatio || 1 / 0,
            title: {
                visible: !1 !== this._spec.title.visible && (!(0, vutils_1.isValid)(this._spec.title.field) || null !== this._activeDatum),
                space: this._spec.title.space || this._gap,
                autoLimit: this._spec.title.autoLimit,
                autoFit: this._spec.title.autoFit,
                fitPercent: this._spec.title.fitPercent,
                style: Object.assign(Object.assign({}, (0, style_1.transformToGraphic)(this._spec.title.style)), {
                    text: this._createText(this._spec.title.field, this._spec.title.style.text)
                })
            },
            content: contentComponentSpec
        };
    }
    _createOrUpdateIndicatorComponent(attrs) {
        if (this._indicatorComponent) (0, vutils_1.isEqual)(attrs, this._cacheAttrs) || this._indicatorComponent.setAttributes(attrs); else {
            const container = this.getContainer(), indicator = new vrender_components_1.Indicator(attrs);
            indicator.name = "indicator", container.add(indicator), this._indicatorComponent = indicator, 
            this._indicatorComponent.on("*", ((event, type) => this._delegateEvent(this._indicatorComponent, event, type)));
        }
        return this._cacheAttrs = attrs, this._indicatorComponent;
    }
    _createText(field, text) {
        var _a;
        return field ? this._activeDatum ? this._activeDatum[field] : "" : (0, vutils_1.isFunction)(text) ? null !== (_a = text(this._activeDatum, void 0)) && void 0 !== _a ? _a : "" : null != text ? text : "";
    }
    _computeLayoutRadius() {
        const region = this._regions[0], {width: width, height: height} = region.getLayoutRect();
        return Math.min(width / 2, height / 2);
    }
    isRelativeModel(model) {
        return (0, model_1.eachSeries)(this._regions, (s => model === s)) || this._regions.includes(model);
    }
    _getNeedClearVRenderComponents() {
        return [ this._indicatorComponent ];
    }
    clear() {
        this._cacheAttrs = null, super.clear();
    }
}

exports.Indicator = Indicator, Indicator.type = type_1.ComponentTypeEnum.indicator, 
Indicator.specKey = "indicator";

const registerIndicator = () => {
    factory_1.Factory.registerComponent(Indicator.type, Indicator);
};

exports.registerIndicator = registerIndicator;
//# sourceMappingURL=indicator.js.map
