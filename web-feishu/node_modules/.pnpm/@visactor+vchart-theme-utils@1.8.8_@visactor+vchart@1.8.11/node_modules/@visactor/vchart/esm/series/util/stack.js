import { valueInScaleRange } from "../../util/scale";

export function stackWithMinHeight(stackCache, stackInverse, context) {
    if (stackCache.values.length > 0) {
        let lastY, seriesInfo = stackCache.series;
        stackInverse && (seriesInfo = seriesInfo.slice().reverse()), seriesInfo.forEach((({s: s, values: values}, sIndex) => {
            var _a, _b;
            const barMinHeight = s.getSpec().barMinHeight, seriesScale = null === (_b = (_a = s[context.axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = s[context.axisHelper].isInverse();
            for (let index = 0; index < values.length; index++) {
                const obj = values[stackInverse ? values.length - 1 - index : index], y1 = valueInScaleRange(s[context.startMethod](obj), seriesScale);
                let y = valueInScaleRange(s[context.endMethod](obj), seriesScale);
                0 === index && 0 === sIndex && (lastY = y1);
                let height = Math.abs(y1 - y);
                height < barMinHeight && (height = barMinHeight);
                let flag = 1;
                y < y1 ? flag = -1 : y === y1 && (flag = context.isVertical ? inverse ? 1 : -1 : inverse ? -1 : 1), 
                y = lastY + flag * height, obj[context.start] = lastY, obj[context.end] = y, lastY = y;
            }
        }));
    }
    for (const key in stackCache.nodes) stackWithMinHeight(stackCache.nodes[key], stackInverse, context);
}
//# sourceMappingURL=stack.js.map
