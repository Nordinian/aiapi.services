import { BandScale, scaleWholeRangeSize } from "@visactor/vscale";

import { CartesianAxis } from "./axis";

import { ComponentTypeEnum } from "../../interface";

import { mixin } from "@visactor/vutils";

import { BandAxisMixin } from "../mixin/band-axis-mixin";

import { Factory } from "../../../core/factory";

import { registerAxis } from "../base-axis";

export class CartesianBandAxis extends CartesianAxis {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.cartesianBandAxis, this._scale = new BandScale;
    }
    computeDomain(data) {
        return this.computeBandDomain(data);
    }
    updateScaleRange() {
        const isChanged = super.updateScaleRange();
        return this.updateGroupScaleRange(), isChanged;
    }
    initScales() {
        super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
    }
    axisHelper() {
        const getScale = depth => this._scales[depth];
        return {
            isContinuous: !1,
            dataToPosition: this.dataToPosition.bind(this),
            getScale: getScale,
            getBandwidth: depth => getScale(depth).bandwidth(),
            getAxisType: () => this.type,
            getAxisId: () => this.id,
            isInverse: () => this._inverse
        };
    }
    transformScaleDomain() {
        this.updateFixedWholeLength();
    }
    updateFixedWholeLength() {
        var _a;
        if (this._scale && (this._spec.bandSize && this._scale.bandwidth(this._spec.bandSize), 
        this._spec.maxBandSize && this._scale.maxBandwidth(this._spec.maxBandSize), this._spec.minBandSize && this._scale.minBandwidth(this._spec.minBandSize), 
        this._scale.isBandwidthFixed() && this._spec.autoRegionSize && (this._spec.bandSize || this._spec.maxBandSize))) {
            const rangeSize = scaleWholeRangeSize(this._scale.domain().length, null !== (_a = this._spec.bandSize) && void 0 !== _a ? _a : this._spec.maxBandSize, this._scale.paddingInner(), this._scale.paddingOuter());
            [ "bottom", "top" ].includes(this._orient) ? this._regions.forEach((region => region.setMaxWidth(rangeSize))) : [ "left", "right" ].includes(this._orient) && this._regions.forEach((region => region.setMaxHeight(rangeSize)));
        }
    }
}

CartesianBandAxis.type = ComponentTypeEnum.cartesianBandAxis, CartesianBandAxis.specKey = "axes", 
mixin(CartesianBandAxis, BandAxisMixin);

export const registerCartesianBandAxis = () => {
    registerAxis(), Factory.registerComponent(CartesianBandAxis.type, CartesianBandAxis);
};
//# sourceMappingURL=band-axis.js.map
