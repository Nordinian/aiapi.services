import { isValid, isNil, array } from "@visactor/vutils";

import { getFirstDatumFromTooltipData, getTooltipContentValue, getTooltipPatternValue } from "./common";

import { getTooltipActualActiveType } from "../../utils/common";

import { TOOLTIP_MAX_LINE_COUNT, TOOLTIP_OTHERS_LINE } from "../constants";

export const getShowContent = (pattern, data, params) => {
    var _a, _b, _c, _d, _e;
    if (!data || "mouseout" === (null === (_a = null == params ? void 0 : params.event) || void 0 === _a ? void 0 : _a.type)) return null;
    const patternTitle = getTooltipPatternValue(pattern.title, data, params), patternContent = array(getTooltipPatternValue(pattern.content, data, params)), tooltipContent = {
        title: {
            value: null === (_b = null == patternTitle ? void 0 : patternTitle.value) || void 0 === _b ? void 0 : _b.toString(),
            hasShape: !1,
            shapeType: void 0,
            shapeHollow: void 0
        },
        content: []
    }, {maxLineCount: maxLineCount = TOOLTIP_MAX_LINE_COUNT} = pattern, patternTitleVisible = !1 !== getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.visible, data, params);
    if (patternTitle && patternTitleVisible) {
        const datum = getFirstDatumFromTooltipData(data);
        tooltipContent.title = {
            value: getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.value, datum, params),
            valueStyle: getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.valueStyle, datum, params),
            hasShape: patternTitle.hasShape
        };
    } else tooltipContent.title = {
        hasShape: !1,
        visible: !1
    };
    if ("mark" === pattern.activeType) for (const content of null != patternContent ? patternContent : []) {
        const oneLineData = getOneLineData(null === (_c = data[0]) || void 0 === _c ? void 0 : _c.datum[0], content, params);
        if (!1 !== oneLineData.visible) {
            if (tooltipContent.content.length === maxLineCount - 1) {
                tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), TOOLTIP_OTHERS_LINE));
                break;
            }
            if (!(tooltipContent.content.length < maxLineCount)) break;
            tooltipContent.content.push(oneLineData);
        }
    } else if ("dimension" === pattern.activeType) for (const {data: d} of data) {
        for (const {datum: datum, series: series} of d) {
            if (!getTooltipActualActiveType(null === (_d = series.tooltipHelper) || void 0 === _d ? void 0 : _d.spec).includes("dimension")) continue;
            const contentPatterns = null !== (_e = null == patternContent ? void 0 : patternContent.filter((c => isNil(c.seriesId) || c.seriesId === series.id))) && void 0 !== _e ? _e : [];
            for (const datumItem of datum) {
                for (const linePattern of contentPatterns) {
                    const oneLineData = getOneLineData(datumItem, linePattern, params);
                    if (!1 !== oneLineData.visible) {
                        if (tooltipContent.content.length === maxLineCount - 1) {
                            tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), TOOLTIP_OTHERS_LINE));
                            break;
                        }
                        if (!(tooltipContent.content.length < maxLineCount)) break;
                        tooltipContent.content.push(oneLineData);
                    }
                }
                if (tooltipContent.content.length >= maxLineCount) break;
            }
            if (tooltipContent.content.length >= maxLineCount) break;
        }
        if (tooltipContent.content.length >= maxLineCount) break;
    }
    return tooltipContent.title && (tooltipContent.content.length > 0 && tooltipContent.content[0].shapeType ? (isNil(tooltipContent.title.shapeType) && (tooltipContent.title.shapeType = tooltipContent.content[0].shapeType), 
    isNil(tooltipContent.title.shapeColor) && (tooltipContent.title.shapeColor = tooltipContent.content[0].shapeColor)) : tooltipContent.title.hasShape = !1), 
    tooltipContent;
};

export const getOneLineData = (datum, config, params) => {
    const key = getTooltipContentValue(config.key, datum, params), value = getTooltipContentValue(config.value, datum, params), visible = !1 !== getTooltipContentValue(config.visible, datum, params) && (isValid(key) || isValid(value)), isKeyAdaptive = getTooltipContentValue(config.isKeyAdaptive, datum, params), spaceRow = getTooltipContentValue(config.spaceRow, datum, params), shapeType = getTooltipContentValue(config.shapeType, datum, params), shapeColor = getTooltipContentValue(config.shapeColor, datum, params), shapeFill = getTooltipContentValue(config.shapeFill, datum, params), shapeStroke = getTooltipContentValue(config.shapeStroke, datum, params), shapeLineWidth = getTooltipContentValue(config.shapeLineWidth, datum, params), keyStyle = getTooltipContentValue(config.keyStyle, datum, params), valueStyle = getTooltipContentValue(config.valueStyle, datum, params);
    return {
        key: key,
        value: value,
        visible: visible,
        isKeyAdaptive: isKeyAdaptive,
        hasShape: config.hasShape,
        shapeType: shapeType,
        shapeFill: shapeFill,
        shapeStroke: shapeStroke,
        shapeLineWidth: shapeLineWidth,
        shapeHollow: config.shapeHollow,
        shapeColor: shapeColor,
        keyStyle: keyStyle,
        valueStyle: valueStyle,
        spaceRow: spaceRow,
        datum: datum
    };
};
//# sourceMappingURL=compose.js.map
