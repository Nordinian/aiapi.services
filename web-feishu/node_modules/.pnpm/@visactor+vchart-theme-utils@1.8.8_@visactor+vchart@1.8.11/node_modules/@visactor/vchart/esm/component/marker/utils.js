var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { isValid, isNumber, array, minInArray, maxInArray, isArray, normalizePadding } from "@visactor/vutils";

import { isPercent, transformToGraphic } from "../../util";

import { AGGR_TYPE } from "../../constant/marker";

function isNeedExtendDomain(domain, datum, autoRange) {
    if (!autoRange) return !1;
    const domainNum = domain.map((n => 1 * n)), min = minInArray(domainNum), max = maxInArray(domainNum);
    return datum < min || datum > max;
}

function getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    let x;
    return isNumber(datum.x) && isNeedExtendDomain(xDomain, datum.x, autoRange) && (null === (_b = null == relativeSeries ? void 0 : (_a = relativeSeries.getXAxisHelper()).setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", datum.x)), 
    x = isPercent(datum.x) ? convertPercentToValue(datum.x, regionWidth) + regionStartLayoutStartPoint.x : relativeSeries.getXAxisHelper().dataToPosition([ datum.x ]) + regionStartLayoutStartPoint.x, 
    x;
}

function getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    let y;
    return isNumber(datum.y) && isNeedExtendDomain(yDomain, datum.y, autoRange) && (null === (_b = null === (_a = relativeSeries.getYAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_yAxis_extend", datum.y)), 
    y = isPercent(datum.y) ? convertPercentToValue(datum.y, regionHeight) + regionStartLayoutStartPoint.y : relativeSeries.getYAxisHelper().dataToPosition([ datum.y ]) + regionStartLayoutStartPoint.y, 
    y;
}

function convertPercentToValue(percent, relativeLength) {
    return Number(percent.substring(0, percent.length - 1)) * relativeLength / 100;
}

export function isAggrSpec(spec) {
    return AGGR_TYPE.includes(spec);
}

export function xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
    const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint(), regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width)), regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height)), refSeries = {
        relativeSeries: relativeSeries,
        startRelativeSeries: startRelativeSeries,
        endRelativeSeries: endRelativeSeries
    }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, xDomain = relativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = relativeSeries.getYAxisHelper().getScale(0).domain();
    return dataPoints.forEach((datum => {
        const isValidX = isValid(datum.x), isValidY = isValid(datum.y);
        if (isValidX && isValidY) {
            const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint);
            lines.push([ {
                x: x,
                y: y
            } ]);
        } else if (isValid(datum.x)) {
            const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height), y1 = Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y);
            lines.push([ {
                x: x,
                y: y
            }, {
                x: x,
                y: y1
            } ]);
        } else if (isValid(datum.y)) {
            const x = Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint), x1 = Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width);
            lines.push([ {
                x: x,
                y: y
            }, {
                x: x1,
                y: y
            } ]);
        }
    })), lines;
}

export function coordinateLayout(data, relativeSeries, autoRange, coordinatesOffset) {
    const points = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, isArrayCoordinatesOffset = isArray(coordinatesOffset);
    return dataPoints.forEach(((datum, index) => {
        var _a, _b, _c, _d;
        const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, regionStart = refRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), {width: regionWidth, height: regionHeight} = regionStart.getLayoutRect();
        let offsetX = 0, offsetY = 0;
        if (coordinatesOffset) {
            const currentCoordinatesOffset = isArrayCoordinatesOffset ? coordinatesOffset[index] : coordinatesOffset, x = currentCoordinatesOffset.x, y = currentCoordinatesOffset.y;
            x && (offsetX = isPercent(x) ? Number(x.substring(0, x.length - 1)) * regionWidth / 100 : x), 
            y && (offsetY = isPercent(y) ? Number(y.substring(0, y.length - 1)) * regionHeight / 100 : y);
        }
        const xDomain = refRelativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = refRelativeSeries.getYAxisHelper().getScale(0).domain(), xValue = array(datum.x), yValue = array(datum.y);
        1 === xValue.length && isNumber(xValue[0]) && isNeedExtendDomain(xDomain, xValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.getXAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", xValue[0])), 
        1 === yValue.length && isNumber(yValue[0]) && isNeedExtendDomain(yDomain, yValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.getYAxisHelper()) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", yValue[0])), 
        points.push({
            x: refRelativeSeries.getXAxisHelper().dataToPosition(xValue) + regionStartLayoutStartPoint.x + offsetX,
            y: refRelativeSeries.getYAxisHelper().dataToPosition(yValue) + regionStartLayoutStartPoint.y + offsetY
        });
    })), points;
}

export function positionLayout(positions, series, regionRelative) {
    if (regionRelative) {
        const region = series.getRegion(), {x: regionStartX, y: regionStartY} = region.getLayoutStartPoint(), {width: regionWidth, height: regionHeight} = region.getLayoutRect();
        return positions.map((position => {
            let {x: x, y: y} = position;
            return isPercent(x) && (x = convertPercentToValue(x, regionWidth)), x += regionStartX, 
            isPercent(y) && (y = convertPercentToValue(y, regionHeight)), y += regionStartY, 
            {
                x: x,
                y: y
            };
        }));
    }
    const {width: canvasWidth, height: canvasHeight} = series.getOption().getChart().getCanvasRect();
    return positions.map((position => {
        let {x: x, y: y} = position;
        return isPercent(x) && (x = convertPercentToValue(x, canvasWidth)), isPercent(y) && (y = convertPercentToValue(y, canvasHeight)), 
        {
            x: x,
            y: y
        };
    }));
}

export function computeClipRange(regions) {
    let minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY = -1 / 0;
    return regions.forEach((region => {
        const regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect();
        regionPos.x < minX && (minX = regionPos.x), regionPos.x + regionRect.width > maxX && (maxX = regionPos.x + regionRect.width), 
        regionPos.y < minY && (minY = regionPos.y), regionPos.y + regionRect.height > maxY && (maxY = regionPos.y + regionRect.height);
    })), {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
    };
}

export function transformLabelAttributes(label) {
    const {labelBackground: labelBackground = {}, style: style, shape: shape} = label, restLabel = __rest(label, [ "labelBackground", "style", "shape" ]);
    if (!1 !== label.visible) {
        const labelAttrs = restLabel;
        return (null == shape ? void 0 : shape.visible) ? labelAttrs.shape = Object.assign({
            visible: !0
        }, transformToGraphic(shape.style)) : labelAttrs.shape = {
            visible: !1
        }, !1 !== labelBackground.visible ? (labelAttrs.panel = Object.assign({
            visible: !0
        }, transformToGraphic(labelBackground.style)), isValid(labelBackground.padding) && (labelAttrs.padding = normalizePadding(labelBackground.padding))) : (labelAttrs.panel = {
            visible: !1
        }, labelAttrs.padding = 0), style && (labelAttrs.textStyle = transformToGraphic(style)), 
        labelAttrs;
    }
    return {
        visible: !1
    };
}
//# sourceMappingURL=utils.js.map
