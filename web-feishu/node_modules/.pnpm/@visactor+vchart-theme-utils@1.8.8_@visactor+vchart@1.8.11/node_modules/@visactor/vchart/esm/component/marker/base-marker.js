import { array, isValid, isNil, isString } from "@visactor/vutils";

import { BaseComponent } from "../base/base-component";

import { calcLayoutNumber } from "../../util/space";

import { isAggrSpec } from "./utils";

import { getFirstSeries } from "../../util";

export class BaseMarker extends BaseComponent {
    constructor() {
        super(...arguments), this.layoutType = "none", this._layoutOffsetX = 0, this._layoutOffsetY = 0;
    }
    getRelativeSeries() {
        return this._relativeSeries;
    }
    created() {
        super.created(), this.initEvent(), this._bindSeries(), this._initDataView();
    }
    _getAllRelativeSeries() {
        return {
            getRelativeSeries: () => this._relativeSeries,
            getStartRelativeSeries: () => this._startRelativeSeries,
            getEndRelativeSeries: () => this._endRelativeSeries
        };
    }
    _getFieldInfoFromSpec(dim, spec, relativeSeries) {
        const field = "x" === dim ? relativeSeries.getSpec().xField : relativeSeries.getSpec().yField;
        return isString(spec) && isAggrSpec(spec) ? {
            field: field,
            aggrType: spec
        } : spec;
    }
    _processSpecX(specX) {
        const relativeSeries = this._relativeSeries;
        return Object.assign({
            x: this._getFieldInfoFromSpec("x", specX, relativeSeries)
        }, this._getAllRelativeSeries());
    }
    _processSpecY(specY) {
        const relativeSeries = this._relativeSeries;
        return Object.assign({
            y: this._getFieldInfoFromSpec("y", specY, relativeSeries)
        }, this._getAllRelativeSeries());
    }
    _processSpecXY(specX, specY) {
        const relativeSeries = this._relativeSeries;
        return Object.assign({
            x: this._getFieldInfoFromSpec("x", specX, relativeSeries),
            y: this._getFieldInfoFromSpec("y", specY, relativeSeries)
        }, this._getAllRelativeSeries());
    }
    _processSpecCoo(spec) {
        var _a;
        return (null !== (_a = spec.coordinates) && void 0 !== _a ? _a : array(spec.coordinate)).map((coordinate => {
            const refRelativeSeries = this._getSeriesByIdOrIndex(coordinate.refRelativeSeriesId, coordinate.refRelativeSeriesIndex), {xField: xField, yField: yField} = refRelativeSeries.getSpec(), {xFieldDim: xFieldDim, xFieldIndex: xFieldIndex, yFieldDim: yFieldDim, yFieldIndex: yFieldIndex} = coordinate;
            let bindXField = xField;
            isValid(xFieldIndex) && (bindXField = array(xField)[xFieldIndex]), xFieldDim && array(xField).includes(xFieldDim) && (bindXField = xFieldDim);
            let bindYField = yField;
            isValid(yFieldIndex) && (bindYField = array(yField)[yFieldIndex]), yFieldDim && array(yField).includes(yFieldDim) && (bindYField = yFieldDim);
            const option = Object.assign({
                x: void 0,
                y: void 0
            }, this._getAllRelativeSeries());
            return isString(coordinate[bindXField]) && isAggrSpec(coordinate[bindXField]) ? option.x = {
                field: bindXField,
                aggrType: coordinate[bindXField]
            } : option.x = array(bindXField).map((field => coordinate[field])), isString(coordinate[bindYField]) && isAggrSpec(coordinate[bindYField]) ? option.y = {
                field: bindYField,
                aggrType: coordinate[bindYField]
            } : option.y = array(bindYField).map((field => coordinate[field])), option.getRefRelativeSeries = () => refRelativeSeries, 
            option;
        }));
    }
    updateLayoutAttribute() {
        var _a, _b, _c;
        if (null === (_a = this._spec.visible) || void 0 === _a || _a) {
            if (!this._markerComponent) {
                const markerComponent = this._createMarkerComponent();
                markerComponent.name = null !== (_b = this._spec.name) && void 0 !== _b ? _b : this.type, 
                markerComponent.id = null !== (_c = this._spec.id) && void 0 !== _c ? _c : `${this.type}-${this.id}`, 
                this._markerComponent = markerComponent, this.getContainer().add(this._markerComponent), 
                this._markerComponent.on("*", ((event, type) => this._delegateEvent(this._markerComponent, event, type)));
            }
            this._markerLayout();
        }
        super.updateLayoutAttribute();
    }
    _getSeriesByIdOrIndex(seriesUserId, seriesIndex) {
        var _a, _b;
        let series;
        return series = null === (_a = this._option.getSeriesInUserIdOrIndex(isValid(seriesUserId) ? [ seriesUserId ] : [], [ seriesIndex ])) || void 0 === _a ? void 0 : _a[0], 
        series || (series = null !== (_b = this._relativeSeries) && void 0 !== _b ? _b : this._getFirstSeries()), 
        series;
    }
    _bindSeries() {
        const spec = this._spec;
        this._relativeSeries = this._getSeriesByIdOrIndex(spec.relativeSeriesId, spec.relativeSeriesIndex), 
        this._startRelativeSeries = this._getSeriesByIdOrIndex(spec.startRelativeSeriesId, spec.startRelativeSeriesIndex), 
        this._endRelativeSeries = this._getSeriesByIdOrIndex(spec.endRelativeSeriesId, spec.endRelativeSeriesIndex);
    }
    initEvent() {}
    onRender(ctx) {}
    changeRegions(regions) {}
    clear() {
        super.clear(), this._firstSeries = null;
    }
    _getFirstSeries() {
        var _a;
        if (this._firstSeries) return this._firstSeries;
        const firstSeries = getFirstSeries(this._regions);
        return firstSeries ? (this._firstSeries = firstSeries, firstSeries) : (null === (_a = this._option) || void 0 === _a || _a.onError("need at least one series"), 
        null);
    }
    _getNeedClearVRenderComponents() {
        return [ this._markerComponent ];
    }
    onLayoutStart(layoutRect, chartViewRect, ctx) {
        isNil(this._spec.offsetX) || (this._layoutOffsetX = calcLayoutNumber(this._spec.offsetX, chartViewRect.width, chartViewRect)), 
        isNil(this._spec.offsetY) || (this._layoutOffsetY = calcLayoutNumber(this._spec.offsetY, chartViewRect.height, chartViewRect)), 
        super.onLayoutStart(layoutRect, chartViewRect, ctx);
    }
}
//# sourceMappingURL=base-marker.js.map
