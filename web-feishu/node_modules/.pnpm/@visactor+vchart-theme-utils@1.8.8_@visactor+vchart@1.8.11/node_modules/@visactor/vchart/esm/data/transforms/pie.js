import { couldBeValidNumber } from "../../util/type";

import { computeQuadrant } from "../../util/math";

import { ARC_TRANSFORM_VALUE } from "../../constant/polar";

function transformInvalidValue(value) {
    return couldBeValidNumber(value) ? Number.parseFloat(value) : 0;
}

export const pie = (originData, op) => {
    const data = originData.map((datum => Object.assign({}, datum)));
    if (!data || 0 === data.length) return data;
    const {angleField: angleField, startAngle: startAngle, endAngle: endAngle, minAngle: minAngle, asStartAngle: asStartAngle, asEndAngle: asEndAngle, asMiddleAngle: asMiddleAngle, asRadian: asRadian, asRatio: asRatio, asQuadrant: asQuadrant, asK: asK} = op, appendArcInfo = (data, startAngle, angle) => {
        data[asStartAngle] = startAngle, data[asEndAngle] = startAngle + angle, data[asMiddleAngle] = startAngle + angle / 2, 
        data[asRadian] = angle, data[asQuadrant] = computeQuadrant(startAngle + angle / 2);
    };
    let total = 0, max = -1 / 0;
    for (let index = 0; index < data.length; index++) {
        const angleFieldValue = transformInvalidValue(data[index][angleField]);
        total += angleFieldValue, max = Math.max(angleFieldValue, max), data[index][ARC_TRANSFORM_VALUE] = angleFieldValue;
    }
    const angleRange = endAngle - startAngle;
    let lastAngle = startAngle, restAngle = angleRange, largeThanMinAngleTotal = 0;
    if (data.forEach((d => {
        const angleFieldValue = d[ARC_TRANSFORM_VALUE], ratio = total ? angleFieldValue / total : 0;
        let radian = ratio * angleRange;
        radian < minAngle ? (radian = minAngle, restAngle -= minAngle) : largeThanMinAngleTotal += angleFieldValue;
        const dStartAngle = lastAngle, dEndAngle = lastAngle + radian;
        d[asRatio] = ratio, d[asK] = max ? angleFieldValue / max : 0, appendArcInfo(d, dStartAngle, radian), 
        lastAngle = dEndAngle;
    })), restAngle < angleRange) if (restAngle <= .001) {
        const angle = angleRange / data.length;
        data.forEach(((d, index) => {
            appendArcInfo(d, startAngle + index * angle, angle);
        }));
    } else {
        const unitRadian = restAngle / largeThanMinAngleTotal;
        lastAngle = startAngle, data.forEach((d => {
            const angle = d[asRadian] === minAngle ? minAngle : d[ARC_TRANSFORM_VALUE] * unitRadian;
            appendArcInfo(d, lastAngle, angle), lastAngle += angle;
        }));
    }
    return 0 !== total && (data[data.length - 1][asEndAngle] = endAngle), data;
};
//# sourceMappingURL=pie.js.map
