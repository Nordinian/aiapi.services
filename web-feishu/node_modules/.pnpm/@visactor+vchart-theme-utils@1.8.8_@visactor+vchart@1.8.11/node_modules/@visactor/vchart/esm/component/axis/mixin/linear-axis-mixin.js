import { isValidNumber, isNil, isValid, isFunction } from "@visactor/vutils";

import { maxInArr, minInArr } from "../../../util/array";

import { getLinearAxisSpecDomain } from "../util";

import { ChartEvent } from "../../../constant";

import { isXAxis } from "../cartesian/util/common";

export const e10 = Math.sqrt(50);

export const e5 = Math.sqrt(10);

export const e2 = Math.sqrt(2);

const DEFAULT_TICK_COUNT = 5;

export class LinearAxisMixin {
    constructor() {
        this._extend = {};
    }
    setExtraAttrFromSpec() {
        isValid(this._spec.nice) && (this._nice = this._spec.nice), isValid(this._spec.zero) && (this._zero = this._spec.zero), 
        this._expand = this._spec.expand, this._domain = getLinearAxisSpecDomain(this._spec);
    }
    transformScaleDomain() {
        this.setScaleNice();
    }
    setLinearScaleNice() {
        var _a;
        let tickCount = 5;
        const tick = this._spec.tick || {};
        if (isValidNumber(tick.forceTickCount)) tickCount = tick.forceTickCount; else if (isFunction(tick.tickCount)) {
            const range = this._scale.range();
            let rangeSize = Math.abs(range[range.length - 1] - range[0]);
            if (1 === rangeSize && this._option) {
                rangeSize = isXAxis(this._orient) ? this._option.getChartViewRect().width : this._option.getChartViewRect().height;
            }
            tickCount = tick.tickCount({
                rangeSize: rangeSize,
                labelStyle: this._spec.label && this._spec.label.style
            });
        } else tickCount = isValidNumber(tick.tickCount) ? tick.tickCount : 5;
        "accurateFirst" === this._spec.niceType && (tickCount = Math.max(5, tickCount));
        const {min: min, max: max} = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
        isNil(min) && isNil(max) ? this._nice && this._scale.nice(tickCount) : isValid(min) && isNil(max) ? this._nice && this._scale.niceMax(tickCount) : isNil(min) && isValid(max) && this._nice && this._scale.niceMin(tickCount);
    }
    setLogScaleNice() {
        var _a;
        const {min: min, max: max} = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
        isNil(min) && isNil(max) ? this._nice && this._scale.nice() : isValid(min) && isNil(max) ? this._nice && this._scale.niceMax() : isNil(min) && isValid(max) && this._nice && this._scale.niceMin();
    }
    setScaleNice() {
        "log" === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
    }
    dataToPosition(values, cfg) {
        return this.valueToPosition(values[0]);
    }
    valueToPosition(value) {
        return "log" !== this._spec.type || isNil(value) || 0 !== value && 0 !== value[0] ? this._scale.scale(value) : this._scale.range()[0];
    }
    computeLinearDomain(data) {
        const domain = [];
        return data.length ? data.forEach((d => {
            const {min: min, max: max} = d;
            domain[0] = void 0 === domain[0] ? min : Math.min(domain[0], min), domain[1] = void 0 === domain[1] ? max : Math.max(domain[1], max);
        })) : (domain[0] = 0, domain[1] = 0), this.expandDomain(domain), this.includeZero(domain), 
        this.setDomainMinMax(domain), domain;
    }
    expandDomain(domain) {
        if (!this._expand) return;
        let domainMin = domain[0], domainMax = domain[domain.length - 1];
        domainMin === domainMax && (0 === domainMax ? domainMax = 1 : domainMax > 0 ? domainMin = 0 : domainMax < 0 && (domainMax = 0)), 
        isValid(this._expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this._expand.min), 
        isValid(this._expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this._expand.max);
    }
    niceDomain(domain) {
        const {min: userMin, max: userMax} = getLinearAxisSpecDomain(this._spec);
        if (isValid(userMin) || isValid(userMax) || "linear" !== this._spec.type) return domain;
        if (Math.abs(minInArr(domain) - maxInArr(domain)) <= 1e-12) {
            let num = domain[0];
            const flag = num >= 0 ? 1 : -1;
            if (num = Math.abs(num), num < 1) domain[0] = 0, domain[1] = 1; else {
                let step = num / 5;
                const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
                step = (err >= e10 ? 10 : err >= e5 ? 5 : err >= e2 ? 2 : 1) * Math.pow(10, power), 
                domain[0] = 0, domain[1] = 10 * step;
            }
            flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
        }
        return domain;
    }
    includeZero(domain) {
        this._zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
    }
    setExtendDomain(key, value) {
        if (void 0 === value) return void delete this._extend[key];
        this._extend[key] = value;
        const domain = this._scale.domain();
        this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), 
        this.niceDomain(domain), this._scale.domain(domain, this._nice), this.setScaleNice(), 
        this.event.emit(ChartEvent.scaleUpdate, {
            model: this,
            value: "domain"
        });
    }
    extendDomain(domain) {
        let temp;
        const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min = reverse ? domainLast : 0, max = reverse ? 0 : domainLast;
        for (const key in this._extend) temp = this._extend[key], temp > domain[max] && (domain[max] = temp), 
        temp < domain[min] && (domain[min] = temp);
    }
    getDomainSpec() {
        return this._domain;
    }
    setDomainMinMax(domain) {
        if (!this._domain) return;
        const {min: min, max: max} = this._domain;
        isValid(min) && (domain[0] = min), isValid(max) && (domain[1] = max);
    }
    setZero(zero) {
        this._zero !== zero && (this._zero = zero, this.updateScaleDomain());
    }
    updateScaleDomain() {
        if (!this.isSeriesDataEnable()) return;
        const data = this.collectData(), domain = this.computeDomain(data);
        this.updateScaleDomainByModel(domain);
    }
    updateScaleDomainByModel(domain) {
        domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), 
        this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), 
        this._scale.domain(domain, this._nice), this.setScaleNice(), this.event.emit(ChartEvent.scaleDomainUpdate, {
            model: this
        }), this.event.emit(ChartEvent.scaleUpdate, {
            model: this,
            value: "domain"
        });
    }
}
//# sourceMappingURL=linear-axis-mixin.js.map
