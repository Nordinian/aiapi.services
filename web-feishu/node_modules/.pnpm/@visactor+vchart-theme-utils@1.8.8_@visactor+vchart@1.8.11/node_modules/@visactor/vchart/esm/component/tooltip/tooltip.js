import { ComponentTypeEnum } from "../interface/type";

import { BaseComponent } from "../base/base-component";

import { DomTooltipHandler } from "./handler/dom";

import { CanvasTooltipHandler } from "./handler/canvas";

import { isMobileLikeMode, isTrueBrowser, isMiniAppLikeMode, domDocument } from "../../util/env";

import { TooltipResult } from "./interface/common";

import { TOOLTIP_EL_CLASS_NAME } from "./handler/constants";

import { showTooltip } from "./utils/show-tooltip";

import { getTooltipActualActiveType, isEmptyPos } from "./utils/common";

import { isSameDimensionInfo } from "../../event/events/dimension/util/common";

import { ChartEvent, Event_Bubble_Level, Event_Source_Type } from "../../constant";

import { DimensionTooltipProcessor } from "./processor/dimension-tooltip";

import { isDimensionInfo, isMarkInfo } from "./processor/util";

import { MarkTooltipProcessor } from "./processor/mark-tooltip";

import { hasParentElement, isString, cloneDeep, isArray, isValid, isNil } from "@visactor/vutils";

import { VChart } from "../../core/vchart";

import { Factory } from "../../core/factory";

import { TooltipSpecTransformer } from "./tooltip-transformer";

export class Tooltip extends BaseComponent {
    constructor() {
        super(...arguments), this.layoutZIndex = 1, this.type = ComponentTypeEnum.tooltip, 
        this.name = ComponentTypeEnum.tooltip, this.transformerConstructor = TooltipSpecTransformer, 
        this.specKey = "tooltip", this.layoutType = "none", this._alwaysShow = !1, this._eventList = [], 
        this._isTooltipShown = !1, this._mountEvent = (eType, query, callback) => {
            this.event.on(eType, query, callback), this._eventList.push({
                eventType: eType,
                handler: callback
            });
        }, this._getMouseOutHandler = needPointerDetection => params => {
            var _a, _b;
            if (this._alwaysShow) return;
            if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return;
            const browserEnv = isTrueBrowser(this._option.mode), {clientX: clientX, clientY: clientY} = params.event;
            browserEnv && this._isPointerOnTooltip(params) || browserEnv && needPointerDetection && this._isPointerInChart({
                x: clientX,
                y: clientY
            }) || this._handleChartMouseOut(params);
        }, this._handleChartMouseOut = params => {
            this._alwaysShow || "none" !== this._spec.triggerOff && (this._hideTooltipByHandler(Object.assign({}, params)), 
            this._cacheInfo = void 0);
        }, this._handleMouseMove = params => {
            if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), 
            this._alwaysShow) return;
            if (this._isPointerOnTooltip(params)) return;
            const mouseEventData = this._getMouseEventData(params), {tooltipInfo: {dimension: dimensionInfo}, ignore: {mark: ignoreMark, dimension: ignoreDimension}} = mouseEventData;
            let markTooltipSuccess = !1, dimensionTooltipSuccess = !1;
            markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params), 
            markTooltipSuccess || (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params)), 
            markTooltipSuccess || dimensionTooltipSuccess || isEmptyPos(params) || (ignoreMark && isMarkInfo(this._cacheInfo) ? markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params, !0) : ignoreDimension && isDimensionInfo(this._cacheInfo) ? dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params, !0) : isValid(dimensionInfo) && (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params))), 
            markTooltipSuccess || dimensionTooltipSuccess && !isNil(dimensionInfo) || this._handleChartMouseOut(params);
        }, this._showTooltipByMouseEvent = (activeType, mouseEventData, params, useCache) => {
            const processor = this._processor[activeType];
            if (!processor.shouldHandleTooltip(params, {
                tooltipInfo: mouseEventData.tooltipInfo[activeType],
                ignore: mouseEventData.ignore[activeType]
            })) return !1;
            let success;
            if (useCache) success = !processor.showTooltip(this._cacheInfo, params, !0); else {
                const tooltipInfo = mouseEventData.tooltipInfo[activeType], isSameAsCache = this._isSameAsCacheInfo(tooltipInfo);
                success = !processor.showTooltip(tooltipInfo, params, isSameAsCache), success && (this._cacheInfo = tooltipInfo);
            }
            success && (this._isTooltipShown = !0);
            const vchart = this._option.globalInstance;
            return success && VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), 
            success;
        }, this._getMouseEventData = params => {
            const result = {
                tooltipInfo: {},
                ignore: {}
            };
            return Object.keys(this._processor).forEach((activeType => {
                const {tooltipInfo: tooltipInfo, ignore: ignore} = this._processor[activeType].getMouseEventData(params);
                result.tooltipInfo[activeType] = tooltipInfo, result.ignore[activeType] = ignore;
            })), result;
        }, this._hideTooltipByHandler = params => {
            var _a, _b, _c;
            if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return TooltipResult.success;
            if (this.event.emit(ChartEvent.tooltipHide, Object.assign(Object.assign({}, params), {
                source: Event_Source_Type.chart,
                tooltip: this
            })), null === (_c = this.tooltipHandler) || void 0 === _c ? void 0 : _c.hideTooltip) {
                const result = this.tooltipHandler.hideTooltip(params);
                return result || (this._isTooltipShown = !1), result;
            }
            return TooltipResult.failed;
        };
    }
    static getSpecInfo(chartSpec) {
        const tooltipSpec = chartSpec[this.specKey];
        if (!tooltipSpec) return null;
        if (!isArray(tooltipSpec)) return [ {
            spec: tooltipSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.tooltip
        } ];
        const specInfos = [];
        return tooltipSpec.forEach(((s, i) => {
            specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.tooltip
            });
        })), specInfos;
    }
    isTooltipShown() {
        return this._isTooltipShown;
    }
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return [];
    }
    _registerEvent() {}
    _releaseEvent() {}
    onLayout(ctx) {}
    onLayoutEnd(ctx) {}
    onRender(ctx) {}
    created() {
        super.created(), this._regions = this._option.getAllRegions(), this._initEvent();
    }
    release() {
        var _a, _b;
        super.release(), this._eventList.forEach((({eventType: eventType, handler: handler}) => {
            this.event.off(eventType, handler);
        })), this._eventList = [], null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), 
        this._isTooltipShown = !1;
    }
    beforeRelease() {
        this.event.emit(ChartEvent.tooltipHide, {
            tooltip: this
        }), this.event.emit(ChartEvent.tooltipRelease, {
            tooltip: this
        });
    }
    _initHandler() {
        var _a, _b, _c;
        const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", userTooltipHandler = this._option.globalInstance.getTooltipHandlerByUser();
        if (userTooltipHandler) this.tooltipHandler = userTooltipHandler; else {
            const Handler = "canvas" === renderMode ? CanvasTooltipHandler : DomTooltipHandler, id = `${this._spec.className}-${null !== (_b = this._option.globalInstance.id) && void 0 !== _b ? _b : 0}-${null !== (_c = this._option.specIndex) && void 0 !== _c ? _c : 0}`;
            this.tooltipHandler = new Handler(id, this);
        }
    }
    _initProcessor() {
        this._processor = {
            mark: new MarkTooltipProcessor(this),
            dimension: new DimensionTooltipProcessor(this)
        };
    }
    _initEvent() {
        var _a;
        if (this._option.disableTriggerEvent) return;
        const trigger = null !== (_a = this._spec.trigger) && void 0 !== _a ? _a : "hover", mode = this._option.mode;
        "hover" === trigger ? (this._mountEvent("pointermove", {
            level: Event_Bubble_Level.chart
        }, this._handleMouseMove), (isMobileLikeMode(mode) || isMiniAppLikeMode(mode)) && (this._mountEvent("pointerdown", {
            level: Event_Bubble_Level.chart
        }, this._handleMouseMove), this._mountEvent("pointerup", {
            source: "window"
        }, this._getMouseOutHandler(!0))), this._mountEvent("pointerout", {
            source: "canvas"
        }, this._getMouseOutHandler(!1))) : "click" === trigger && (this._mountEvent("pointertap", {
            level: Event_Bubble_Level.chart
        }, this._handleMouseMove), this._mountEvent("pointerup", {
            source: "window"
        }, this._getMouseOutHandler(!0)));
    }
    reInit(spec) {
        var _a, _b;
        super.reInit(spec), this.tooltipHandler ? null === (_b = (_a = this.tooltipHandler).reInit) || void 0 === _b || _b.call(_a) : this._initHandler();
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec();
        const userSpec = this._spec;
        this._spec = Object.assign(Object.assign({}, userSpec), {
            visible: !isValid(userSpec.visible) || userSpec.visible,
            activeType: getTooltipActualActiveType(userSpec),
            renderMode: "html",
            trigger: isValid(userSpec.trigger) ? userSpec.trigger : "hover",
            className: isValid(userSpec.className) ? userSpec.className : TOOLTIP_EL_CLASS_NAME,
            enterable: !!isValid(userSpec.enterable) && userSpec.enterable,
            transitionDuration: isValid(userSpec.transitionDuration) ? userSpec.transitionDuration : 150
        }), this._spec.triggerOff = isValid(userSpec.triggerOff) ? userSpec.triggerOff : this._spec.trigger, 
        isValid(userSpec.renderMode) ? this._spec.renderMode = userSpec.renderMode : isMiniAppLikeMode(this._option.mode) && (this._spec.renderMode = "canvas"), 
        isValid(userSpec.mark) && (this._spec.mark = Object.assign(Object.assign({}, cloneDeep(userSpec.mark)), {
            activeType: "mark"
        })), isValid(userSpec.dimension) && (this._spec.dimension = Object.assign(Object.assign({}, cloneDeep(userSpec.dimension)), {
            activeType: "dimension"
        })), isValid(userSpec.parentElement) ? isString(userSpec.parentElement) ? this._spec.parentElement = null === (_a = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === _a ? void 0 : _a.getElementById(userSpec.parentElement) : this._spec.parentElement = userSpec.parentElement : isTrueBrowser(this._option.mode) && (this._spec.parentElement = null == domDocument ? void 0 : domDocument.body), 
        isValid(userSpec.confine) ? this._spec.confine = userSpec.confine : this._spec.confine = "canvas" === this._spec.renderMode;
    }
    showTooltip(datum, options) {
        var _a;
        if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), 
        !(null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip)) return !1;
        const result = showTooltip(datum, options, this.tooltipHandler, this._option);
        return "none" !== result && (this._alwaysShow = !!(null == options ? void 0 : options.alwaysShow)), 
        result;
    }
    hideTooltip() {
        const params = {
            changePositionOnly: !1,
            item: void 0,
            datum: void 0,
            source: Event_Source_Type.chart
        };
        return this._alwaysShow = !1, !this._hideTooltipByHandler(params);
    }
    _isSameAsCacheInfo(nextInfo) {
        if (nextInfo === this._cacheInfo) return !0;
        if (isNil(this._cacheInfo) || isNil(nextInfo)) return !1;
        if (isDimensionInfo(nextInfo)) {
            if (isMarkInfo(this._cacheInfo)) return !1;
            const prevInfo = this._cacheInfo;
            return prevInfo.length === nextInfo.length && nextInfo.every(((info, i) => isSameDimensionInfo(info, prevInfo[i])));
        }
        if (isDimensionInfo(this._cacheInfo)) return !1;
        const prevInfo = this._cacheInfo;
        return (null == nextInfo ? void 0 : nextInfo.datum) === prevInfo.datum && (null == nextInfo ? void 0 : nextInfo.mark) === prevInfo.mark && (null == nextInfo ? void 0 : nextInfo.series) === prevInfo.series;
    }
    _isPointerInChart(point) {
        const globalInstance = this._option.globalInstance;
        if (!globalInstance.getChart()) return !1;
        const {x: x, y: y} = point, canvas = globalInstance.getCanvas(), {x: chartX, y: chartY, width: chartWidth, height: chartHeight} = canvas.getBoundingClientRect();
        return x >= chartX && x <= chartX + chartWidth && y >= chartY && y <= chartY + chartHeight;
    }
    _isPointerOnTooltip(params) {
        var _a, _b;
        if (this._spec.enterable && "html" === this._spec.renderMode) {
            const {event: event} = params;
            let newTarget;
            if (isValid(event.nativeEvent)) {
                const nativeEvent = event.nativeEvent;
                newTarget = nativeEvent.relatedTarget, nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (newTarget = nativeEvent.composedPath()[0]);
            } else newTarget = event.relatedTarget;
            const container = null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.getTooltipContainer) || void 0 === _b ? void 0 : _b.call(_a);
            if (isValid(container) && isValid(newTarget) && hasParentElement(newTarget, container)) return !0;
        }
        return !1;
    }
    getVisible() {
        return !1 !== this._spec.visible;
    }
}

Tooltip.type = ComponentTypeEnum.tooltip, Tooltip.transformerConstructor = TooltipSpecTransformer, 
Tooltip.specKey = "tooltip";

export const registerTooltip = () => {
    Factory.registerComponent(Tooltip.type, Tooltip);
};
//# sourceMappingURL=tooltip.js.map
