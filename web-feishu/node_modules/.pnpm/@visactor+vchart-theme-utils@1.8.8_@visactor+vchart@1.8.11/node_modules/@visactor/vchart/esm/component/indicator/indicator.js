import { DataView } from "@visactor/vdataset";

import { LayoutLevel, LayoutZIndex } from "../../constant";

import { ComponentTypeEnum } from "../interface/type";

import { BaseComponent } from "../base/base-component";

import { mergeSpec } from "../../util/spec/merge-spec";

import { eachSeries } from "../../util/model";

import { transformToGraphic } from "../../util/style";

import { getActualNumValue } from "../../util/space";

import { isEqual, isValid, isFunction, array, isArray } from "@visactor/vutils";

import { indicatorMapper } from "./util";

import { registerDataSetInstanceTransform } from "../../data/register";

import { CompilableData } from "../../compile/data/compilable-data";

import { Indicator as IndicatorComponents } from "@visactor/vrender-components";

import { Factory } from "../../core/factory";

export class Indicator extends BaseComponent {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.indicator, this.name = ComponentTypeEnum.indicator, 
        this.specKey = "indicator", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Indicator, 
        this.layoutLevel = LayoutLevel.Indicator, this._gap = 0, this._activeDatum = null;
    }
    static getSpecInfo(chartSpec) {
        if (this.type !== Indicator.type) return null;
        const indicatorSpec = chartSpec[this.specKey];
        if (!isArray(indicatorSpec)) return !1 === indicatorSpec.visible ? [] : [ {
            spec: indicatorSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.indicator
        } ];
        const specInfos = [];
        return indicatorSpec.forEach(((s, i) => {
            s && !1 !== s.visible && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.indicator
            });
        })), specInfos;
    }
    created() {
        super.created(), this.initData(), this.initEvent();
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._gap = this._spec.gap || 0, this._title = this._spec.title, 
        this._content = array(this._spec.content), this._regions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
    }
    onRender(ctx) {}
    changeRegions(regions) {}
    initEvent() {
        if (this._option.disableTriggerEvent) return;
        "none" !== this._spec.trigger && ("hover" === this._spec.trigger ? (this.event.on("hovered", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(params.value[0]);
        })), this.event.on("unhovered", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(null);
        }))) : (this.event.on("selected", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(params.value[0]);
        })), this.event.on("unselected", (params => {
            params.model && !this.isRelativeModel(params.model) || this.updateDatum(null);
        }))));
    }
    updateDatum(datum) {
        this._activeDatum = datum, this._displayData.updateData();
        const attrs = this._getIndicatorAttrs();
        this._createOrUpdateIndicatorComponent(attrs);
    }
    initData() {
        registerDataSetInstanceTransform(this._option.dataSet, "indicatorFilter", indicatorMapper);
        const displayData = new DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        displayData.transform({
            type: "indicatorFilter",
            options: {
                title: this._title,
                content: this._content,
                datum: () => this._activeDatum
            }
        }), displayData.target.addListener("change", this.updateDatum.bind(this)), this._displayData = new CompilableData(this._option, displayData);
    }
    updateLayoutAttribute() {
        const attrs = this._getIndicatorAttrs();
        this._createOrUpdateIndicatorComponent(attrs), super.updateLayoutAttribute();
    }
    _getIndicatorAttrs() {
        const region = this._regions[0], {width: width, height: height} = region.getLayoutRect(), {x: x, y: y} = region.getLayoutStartPoint(), contentComponentSpec = [];
        return array(this._spec.content).forEach((eachItem => {
            const contentSpec = mergeSpec({}, this._theme.content, eachItem);
            contentComponentSpec.push({
                visible: !1 !== contentSpec.visible && (!contentSpec.field || null !== this._activeDatum),
                space: contentSpec.space || this._gap,
                autoLimit: contentSpec.autoLimit,
                autoFit: contentSpec.autoFit,
                fitPercent: contentSpec.fitPercent,
                style: Object.assign(Object.assign({}, transformToGraphic(contentSpec.style)), {
                    text: this._createText(contentSpec.field, contentSpec.style.text)
                })
            });
        })), {
            visible: !1 !== this._spec.visible && (!1 !== this._spec.fixed || null !== this._activeDatum),
            size: {
                width: width,
                height: height
            },
            zIndex: this.layoutZIndex,
            x: x,
            y: y,
            dx: this._spec.offsetX ? getActualNumValue(this._spec.offsetX, this._computeLayoutRadius()) : 0,
            dy: this._spec.offsetY ? getActualNumValue(this._spec.offsetY, this._computeLayoutRadius()) : 0,
            limitRatio: this._spec.limitRatio || 1 / 0,
            title: {
                visible: !1 !== this._spec.title.visible && (!isValid(this._spec.title.field) || null !== this._activeDatum),
                space: this._spec.title.space || this._gap,
                autoLimit: this._spec.title.autoLimit,
                autoFit: this._spec.title.autoFit,
                fitPercent: this._spec.title.fitPercent,
                style: Object.assign(Object.assign({}, transformToGraphic(this._spec.title.style)), {
                    text: this._createText(this._spec.title.field, this._spec.title.style.text)
                })
            },
            content: contentComponentSpec
        };
    }
    _createOrUpdateIndicatorComponent(attrs) {
        if (this._indicatorComponent) isEqual(attrs, this._cacheAttrs) || this._indicatorComponent.setAttributes(attrs); else {
            const container = this.getContainer(), indicator = new IndicatorComponents(attrs);
            indicator.name = "indicator", container.add(indicator), this._indicatorComponent = indicator, 
            this._indicatorComponent.on("*", ((event, type) => this._delegateEvent(this._indicatorComponent, event, type)));
        }
        return this._cacheAttrs = attrs, this._indicatorComponent;
    }
    _createText(field, text) {
        var _a;
        return field ? this._activeDatum ? this._activeDatum[field] : "" : isFunction(text) ? null !== (_a = text(this._activeDatum, void 0)) && void 0 !== _a ? _a : "" : null != text ? text : "";
    }
    _computeLayoutRadius() {
        const region = this._regions[0], {width: width, height: height} = region.getLayoutRect();
        return Math.min(width / 2, height / 2);
    }
    isRelativeModel(model) {
        return eachSeries(this._regions, (s => model === s)) || this._regions.includes(model);
    }
    _getNeedClearVRenderComponents() {
        return [ this._indicatorComponent ];
    }
    clear() {
        this._cacheAttrs = null, super.clear();
    }
}

Indicator.type = ComponentTypeEnum.indicator, Indicator.specKey = "indicator";

export const registerIndicator = () => {
    Factory.registerComponent(Indicator.type, Indicator);
};
//# sourceMappingURL=indicator.js.map
