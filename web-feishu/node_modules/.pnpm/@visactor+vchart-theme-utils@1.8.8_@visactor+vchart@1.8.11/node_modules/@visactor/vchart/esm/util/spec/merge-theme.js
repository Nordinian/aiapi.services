import { array } from "@visactor/vutils";

import { transformColorSchemeToStandardStruct } from "../../theme/color-scheme/util";

import { seriesMarkInfoMap } from "../../series/interface/theme";

import { mergeSpec } from "./merge-spec";

export function mergeTheme(target, ...sources) {
    return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}

function transformThemeToMerge(theme) {
    if (!theme) return theme;
    const colorScheme = transformColorSchemeToMerge(theme.colorScheme), {series: series} = theme, {mark: markByType, markByName: markByName} = theme;
    let newSeriesTheme;
    return (markByType || markByName) && (newSeriesTheme = Object.keys(seriesMarkInfoMap).reduce(((newSeriesTheme, key) => {
        var _a;
        const value = null !== (_a = null == series ? void 0 : series[key]) && void 0 !== _a ? _a : {};
        return newSeriesTheme[key] = transformSeriesThemeToMerge(value, key, markByType, markByName), 
        newSeriesTheme;
    }), {})), Object.assign({}, theme, {
        colorScheme: colorScheme,
        series: Object.assign({}, theme.series, newSeriesTheme)
    });
}

export function transformColorSchemeToMerge(colorScheme) {
    return colorScheme && (colorScheme = Object.keys(colorScheme).reduce(((scheme, key) => {
        const value = colorScheme[key];
        return scheme[key] = transformColorSchemeToStandardStruct(value), scheme;
    }), {})), colorScheme;
}

export function transformSeriesThemeToMerge(seriesTheme, seriesType, markByType, markByName) {
    if (!seriesMarkInfoMap[seriesType]) return seriesTheme;
    const newTheme = {};
    return Object.values(seriesMarkInfoMap[seriesType]).forEach((({type: type, name: name}) => {
        newTheme[name] = mergeSpec({}, null == markByType ? void 0 : markByType[array(type)[0]], null == markByName ? void 0 : markByName[name], null == seriesTheme ? void 0 : seriesTheme[name]);
    })), Object.assign(Object.assign({}, seriesTheme), newTheme);
}
//# sourceMappingURL=merge-theme.js.map
