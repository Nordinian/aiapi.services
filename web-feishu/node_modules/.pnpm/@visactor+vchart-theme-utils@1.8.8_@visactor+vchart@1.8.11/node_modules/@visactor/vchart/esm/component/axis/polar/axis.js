var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { POLAR_DEFAULT_RADIUS, POLAR_END_ANGLE, POLAR_END_RADIAN } from "../../../constant/polar";

import { isContinuous } from "@visactor/vscale";

import { ChartEvent, LayoutZIndex, POLAR_START_ANGLE, POLAR_START_RADIAN } from "../../../constant";

import { ComponentTypeEnum } from "../../interface/type";

import { Factory } from "../../../core/factory";

import { mergeSpec } from "../../../util/spec/merge-spec";

import { eachSeries } from "../../../util/model";

import { polarToCartesian } from "../../../util/math";

import { isPolarAxisSeries } from "../../../series/util/utils";

import { getAxisLabelOffset, isValidPolarAxis } from "../util";

import { PointService, degreeToRadian, isValid, isArray, isValidNumber } from "@visactor/vutils";

import { CompilableData } from "../../../compile/data/compilable-data";

import { AxisComponent } from "../base-axis";

import { HOOK_EVENT } from "@visactor/vgrammar-core";

import { getPolarAxisInfo } from "./util";

export class PolarAxis extends AxisComponent {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.polarAxis, this.name = ComponentTypeEnum.polarAxis, 
        this._defaultBandPosition = 0, this._defaultBandInnerPadding = 0, this._defaultBandOuterPadding = 0, 
        this.layoutType = "absolute", this.layoutZIndex = LayoutZIndex.Axis, this._tick = void 0, 
        this._center = null, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, 
        this._orient = "radius", this._groupScales = [], this.effect = {
            scaleUpdate: param => {
                this.computeData(null == param ? void 0 : param.value), eachSeries(this._regions, (s => {
                    "radius" === this.getOrient() ? s.radiusAxisHelper = this.axisHelper() : s.angleAxisHelper = this.axisHelper();
                }), {
                    userId: this._seriesUserId,
                    specIndex: this._seriesIndex
                });
            }
        }, this._transformLayoutPosition = pos => {
            var _a;
            const region = null === (_a = this.getRegions()) || void 0 === _a ? void 0 : _a[0];
            return region ? region.getLayoutStartPoint() : pos;
        };
    }
    get center() {
        return this._center;
    }
    get startAngle() {
        return this._startAngle;
    }
    get endAngle() {
        return this._endAngle;
    }
    getOrient() {
        return this._orient;
    }
    getGroupScales() {
        return this._groupScales;
    }
    static getSpecInfo(chartSpec) {
        var _a, _b;
        const axesSpec = chartSpec[this.specKey];
        if (!axesSpec) return null;
        if (!isArray(axesSpec)) {
            if (!isValidPolarAxis(axesSpec)) return null;
            const {axisType: axisType, componentName: componentName} = getPolarAxisInfo(axesSpec);
            return axesSpec.center = chartSpec.center, axesSpec.startAngle = null !== (_a = chartSpec.startAngle) && void 0 !== _a ? _a : POLAR_START_ANGLE, 
            axesSpec.endAngle = null !== (_b = chartSpec.endAngle) && void 0 !== _b ? _b : isValid(chartSpec.startAngle) ? chartSpec.startAngle + 360 : POLAR_END_ANGLE, 
            axesSpec.type = axisType, [ {
                spec: axesSpec,
                specPath: [ this.specKey ],
                type: componentName
            } ];
        }
        const specInfos = [];
        let angleAxisIndex;
        const radiusAxisSpecInfos = [];
        return axesSpec.forEach(((s, i) => {
            var _a, _b, _c, _d, _e;
            if (!isValidPolarAxis(s)) return;
            const {axisType: axisType, componentName: componentName} = getPolarAxisInfo(s);
            s.center = chartSpec.center, s.startAngle = null !== (_a = chartSpec.startAngle) && void 0 !== _a ? _a : POLAR_START_ANGLE, 
            s.endAngle = null !== (_b = chartSpec.endAngle) && void 0 !== _b ? _b : isValid(chartSpec.startAngle) ? chartSpec.startAngle + 360 : POLAR_END_ANGLE, 
            s.outerRadius = null !== (_e = null !== (_d = null !== (_c = s.radius) && void 0 !== _c ? _c : chartSpec.outerRadius) && void 0 !== _d ? _d : chartSpec.radius) && void 0 !== _e ? _e : POLAR_DEFAULT_RADIUS, 
            s.type = axisType;
            const info = {
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: componentName
            };
            specInfos.push(info), "radius" === s.orient ? radiusAxisSpecInfos.push(info) : angleAxisIndex = i;
        })), radiusAxisSpecInfos.forEach((info => {
            info.angleAxisIndex = angleAxisIndex;
        })), specInfos;
    }
    static createComponent(specInfo, options) {
        const {spec: spec} = specInfo, others = __rest(specInfo, [ "spec" ]), C = Factory.getComponentInKey(others.type);
        return C ? new C(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), 
        null);
    }
    setAttrFromSpec() {
        var _a, _b;
        super.setAttrFromSpec(), this.visible && (this._axisStyle = this._getAxisAttributes(), 
        this._gridStyle = this._getGridAttributes()), this._tick = this._spec.tick, this._orient = "angle" === this._spec.orient ? "angle" : "radius", 
        this._center = this._spec.center;
        const chartSpec = this.getChart().getSpec(), startAngle = null !== (_a = this._spec.startAngle) && void 0 !== _a ? _a : chartSpec.startAngle, endAngle = null !== (_b = this._spec.endAngle) && void 0 !== _b ? _b : chartSpec.endAngle;
        this._startAngle = degreeToRadian(null != startAngle ? startAngle : POLAR_START_ANGLE), 
        this._endAngle = degreeToRadian(null != endAngle ? endAngle : isValid(startAngle) ? startAngle + 360 : POLAR_END_ANGLE), 
        this._inverse = this._spec.inverse;
    }
    onLayoutEnd(ctx) {
        this.updateScaleRange() && (this.updateSeriesScale(), this.event.emit(ChartEvent.scaleUpdate, {
            model: this,
            value: "range"
        })), super.onLayoutEnd(ctx);
    }
    onRender(ctx) {}
    changeRegions() {}
    _initData() {
        const tickData = this._initTickDataSet(this._tickTransformOption("polar"));
        tickData.target.addListener("change", this._forceLayout.bind(this)), this._tickData = new CompilableData(this._option, tickData);
    }
    _tickTransformOption(coordinateType) {
        return Object.assign(Object.assign({}, super._tickTransformOption(coordinateType)), {
            noDecimal: this._tick.noDecimals,
            startAngle: this.startAngle,
            labelOffset: getAxisLabelOffset(this._spec),
            getRadius: () => this.getOuterRadius()
        });
    }
    afterCompile() {
        var _a;
        const product = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
        product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, (() => {
            !1 === this._isLayout && this._delegateAxisContainerEvent(product.getGroupGraphicItem());
        }));
    }
    updateScaleRange() {
        const prevRange = this._scale.range();
        let newRange;
        return newRange = "radius" === this.getOrient() ? this._inverse ? [ this.computeLayoutOuterRadius(), this.computeLayoutInnerRadius() ] : [ this.computeLayoutInnerRadius(), this.computeLayoutOuterRadius() ] : this._inverse ? [ this._endAngle, this._startAngle ] : [ this._startAngle, this._endAngle ], 
        (!prevRange || !newRange || prevRange[0] !== newRange[0] || prevRange[1] !== newRange[1]) && (this._scale.range(newRange), 
        !0);
    }
    collectData(depth, rawData) {
        const data = [];
        return eachSeries(this._regions, (s => {
            var _a, _b, _c;
            let field;
            if (field = depth > 0 ? null === (_b = null === (_a = s.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : "radius" === this.getOrient() ? s.getRadiusField() : s.getAngleField(), 
            field = isArray(field) ? isContinuous(this._scale.type) ? field : [ field[0] ] : [ field ], 
            depth || (this._dataFieldText = s.getFieldAlias(field[0])), field) {
                const viewData = s.getViewData();
                if (rawData) field.forEach((f => {
                    data.push(s.getRawDataStatisticsByField(f, !1));
                })); else if (viewData && viewData.latestData && viewData.latestData.length) {
                    const seriesData = null === (_c = s.getViewDataStatistics) || void 0 === _c ? void 0 : _c.call(s);
                    field.forEach((f => {
                        var _a;
                        (null === (_a = null == seriesData ? void 0 : seriesData.latestData) || void 0 === _a ? void 0 : _a[f]) && data.push(seriesData.latestData[f]);
                    }));
                }
            }
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), data;
    }
    updateSeriesScale() {
        eachSeries(this._regions, (s => {
            "radius" === this.getOrient() ? (s.setRadiusScale(this._scale), s.radiusAxisHelper = this.axisHelper()) : (s.setAngleScale(this._scale), 
            s.angleAxisHelper = this.axisHelper());
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
    }
    getSeriesStatisticsField(s) {
        const f = "radius" === this.getOrient() ? s.getRadiusField() : s.getAngleField();
        return isContinuous(this._scale.type) ? f : [ f[0] ];
    }
    initGroupScales() {}
    axisHelper() {
        return {
            isContinuous: isContinuous(this._scale.type),
            dataToPosition: this.dataToPosition.bind(this),
            coordToPoint: this.coordToPoint.bind(this),
            pointToCoord: this.pointToCoord.bind(this),
            center: this.getCenter.bind(this),
            getScale: depth => this._scales[depth],
            getAxisId: () => this.id
        };
    }
    positionToData(position) {
        const coord = this.pointToCoord(position);
        return "radius" === this.getOrient() ? this.invert(coord.radius) : this.invert(coord.angle);
    }
    coordToPoint(point) {
        const angle = point.angle, {x: centerX, y: centerY} = this.getCenter(), p = polarToCartesian({
            angle: angle,
            radius: point.radius
        });
        return {
            x: p.x + centerX,
            y: p.y + centerY
        };
    }
    pointToCoord(point) {
        const {x: centerX, y: centerY} = this.getCenter();
        let dx = point.x - centerX, dy = point.y - centerY;
        const startAngle = this._startAngle, endAngle = this._endAngle, radius = Math.sqrt(dx * dx + dy * dy);
        dx /= radius, dy /= radius;
        let radian = Math.atan2(dy, dx);
        if (radian < startAngle) for (;radian <= startAngle; ) radian += 2 * Math.PI;
        if (radian > endAngle) for (;radian >= endAngle; ) radian -= 2 * Math.PI;
        return {
            radius: radius,
            angle: radian
        };
    }
    getCenter() {
        var _a, _b;
        return {
            x: (null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) || this.getRefLayoutRect().width / 2,
            y: (null === (_b = this._center) || void 0 === _b ? void 0 : _b.y) || this.getRefLayoutRect().height / 2
        };
    }
    getOuterRadius() {
        return this.computeLayoutOuterRadius();
    }
    getInnerRadius() {
        return this.computeLayoutInnerRadius();
    }
    tickValues() {
        if (this._tickData) {
            const latestData = this._tickData.getLatestData();
            if (!latestData || isArray(latestData)) return latestData || [];
            this.computeData("force");
        }
        return this._scale.ticks();
    }
    updateLayoutAttribute() {
        this._visible && ("radius" === this.getOrient() ? this._layoutRadiusAxis() : this._layoutAngleAxis()), 
        super.updateLayoutAttribute();
    }
    _layoutAngleAxis() {
        const center = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), angleRange = this._endAngle - this._startAngle, items = isArray(this._tickData.getLatestData()) ? this._tickData.getLatestData().map((obj => {
            const angle = this.dataToPosition([ obj.value ]);
            return {
                id: obj.value,
                label: obj.value,
                value: (angle - this._startAngle) / angleRange,
                rawValue: obj.value
            };
        })) : [], commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
            inside: this._spec.inside,
            center: center,
            radius: radius,
            innerRadius: innerRadius,
            startAngle: this._startAngle,
            endAngle: this._endAngle
        }), attrs = Object.assign(Object.assign({}, commonAttrs), {
            title: {
                text: this._spec.title.text || this._dataFieldText
            },
            items: items.length ? [ items ] : [],
            orient: "angle"
        });
        this._spec.grid.visible && (attrs.grid = Object.assign({
            type: "line",
            smoothLink: !0,
            items: items
        }, commonAttrs)), this._update(attrs);
    }
    _layoutRadiusAxis() {
        var _a, _b, _c;
        const center = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), endPoint = this.coordToPoint({
            angle: this._startAngle,
            radius: radius
        }), startPoint = this.coordToPoint({
            angle: this._startAngle,
            radius: innerRadius
        }), distance = PointService.distancePP(startPoint, endPoint), items = isArray(this._tickData.getLatestData()) ? this._tickData.getLatestData().map((obj => {
            const value = this.dataToPosition([ obj.value ]);
            return {
                id: obj.value,
                label: obj.value,
                value: (value - innerRadius) / distance,
                rawValue: obj.value
            };
        })) : [], commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
            start: startPoint,
            end: endPoint,
            verticalFactor: -1
        }), attrs = Object.assign(Object.assign({}, commonAttrs), {
            title: {
                text: this._spec.title.text || this._dataFieldText
            },
            items: items.length ? [ items ] : [],
            orient: "radius"
        });
        (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) && (attrs.grid = Object.assign({
            items: items,
            type: (null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.smooth) ? "circle" : "polygon",
            center: center,
            closed: !0,
            sides: null === (_c = this._getRelatedAngleAxis()) || void 0 === _c ? void 0 : _c.tickValues().length,
            startAngle: this._startAngle,
            endAngle: this._endAngle
        }, commonAttrs)), this._update(attrs);
    }
    _getRelatedAngleAxis() {
        const index = this._option.angleAxisIndex;
        if (isValid(index)) return this._option.getComponentByIndex(this.specKey, index);
    }
    computeLayoutOuterRadius() {
        var _a;
        const radius = null !== (_a = this._spec.outerRadius) && void 0 !== _a ? _a : this._spec.radius, outerRadius = null != radius ? radius : this.getRefSeriesRadius().outerRadius, {width: width, height: height} = this.getRefLayoutRect();
        return Math.min(width, height) / 2 * outerRadius;
    }
    computeLayoutInnerRadius() {
        var _a;
        const innerRadius = null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : this.getRefSeriesRadius().innerRadius, {width: width, height: height} = this.getRefLayoutRect();
        return Math.min(width, height) / 2 * innerRadius;
    }
    getRefLayoutRect() {
        return this.getRegions()[0].getLayoutRect();
    }
    getRefSeriesRadius() {
        let outerRadius = POLAR_DEFAULT_RADIUS, innerRadius = 0;
        const chartSpec = this.getChart().getSpec();
        return eachSeries(this.getRegions(), (s => {
            const series = s;
            if (isPolarAxisSeries(series.type)) {
                const {outerRadius: seriesRadius = chartSpec.outerRadius, innerRadius: seriesInnerRadius = chartSpec.innerRadius} = series;
                isValidNumber(seriesRadius) && (outerRadius = seriesRadius), isValidNumber(seriesInnerRadius) && (innerRadius = seriesInnerRadius);
            }
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), {
            outerRadius: outerRadius,
            innerRadius: innerRadius
        };
    }
    _update(attrs) {
        const {grid: gridAttrs} = attrs, axisAttrs = __rest(attrs, [ "grid" ]);
        if (this._axisMark.getProduct().encode(mergeSpec({}, this._axisStyle, axisAttrs)), 
        this._gridMark) {
            this._gridMark.getProduct().encode(mergeSpec({}, this._gridStyle, gridAttrs));
        }
    }
    invert(value) {
        var _a;
        if ("angle" === this.getOrient() && "band" === this._scale.type) {
            const range = this._scale.range(), rangeValue = range[range.length - 1] - range[0], offset = .5 === (null !== (_a = this.getSpec().bandPosition) && void 0 !== _a ? _a : this._defaultBandPosition) ? 0 : this._scale.bandwidth() / 2;
            if (range[0] < 0) {
                const transformedAngle = (value + offset + Math.abs(range[0])) % rangeValue - Math.abs(range[0]);
                return this._scale.invert(transformedAngle);
            }
            return this._scale.invert((value + offset) % rangeValue);
        }
        return this._scale.invert(value);
    }
}

PolarAxis.type = ComponentTypeEnum.polarAxis, PolarAxis.specKey = "axes";
//# sourceMappingURL=axis.js.map
