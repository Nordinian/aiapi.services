import { ticks } from "@visactor/vutils-extension";

import { BaseComponent } from "../base/base-component";

import { array, get, isArray, isBoolean, isFunction, isNil, isValid, maxInArray } from "@visactor/vutils";

import { eachSeries, getSeries } from "../../util/model";

import { mergeSpec } from "../../util/spec/merge-spec";

import { ChartEvent, LayoutZIndex } from "../../constant";

import { animationConfig } from "../../animation/utils";

import { degreeToRadian, pickWithout, isEqual } from "@visactor/vutils";

import { DEFAULT_TITLE_STYLE, transformAxisLineStyle } from "./util";

import { transformAxisLabelStateStyle, transformStateStyle, transformToGraphic } from "../../util/style";

import { DataView } from "@visactor/vdataset";

import { GridEnum, registerAxis as registerVGrammarAxis, registerGrid as registerVGrammarGrid } from "@visactor/vgrammar-core";

import { registerComponentMark } from "../../mark/component";

import { Factory } from "../../core/factory";

import { GroupFadeIn, GroupTransition } from "@visactor/vrender-components";

import { GroupFadeOut } from "@visactor/vrender-core";

import { scaleParser } from "../../data/parser/scale";

import { registerDataSetInstanceParser, registerDataSetInstanceTransform } from "../../data/register";

export class AxisComponent extends BaseComponent {
    getOrient() {
        return this._orient;
    }
    getScale() {
        return this._scale;
    }
    getScales() {
        return this._scales;
    }
    getTickData() {
        return this._tickData;
    }
    get visible() {
        return this._visible;
    }
    getInverse() {
        return this._inverse;
    }
    constructor(spec, options) {
        var _a;
        super(spec, options), this.specKey = "axes", this._scales = [], this._visible = !0, 
        this._tick = void 0, this._visible = null === (_a = spec.visible) || void 0 === _a || _a;
    }
    _getNeedClearVRenderComponents() {
        return [];
    }
    getVRenderComponents() {
        var _a, _b;
        return array(null === (_b = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem());
    }
    created() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        if (super.created(), this.setSeriesAndRegionsFromSpec(), this.initEvent(), this.initScales(), 
        this.updateSeriesScale(), this.getVisible() && this._initData(), this._visible) {
            const axisMark = this._createMark({
                type: "component",
                name: `axis-${this.getOrient()}`
            }, {
                componentType: "angle" === this.getOrient() ? "circleAxis" : "axis",
                mode: this._spec.mode,
                noSeparateStyle: !0,
                skipTheme: !0
            });
            if (this._axisMark = axisMark, axisMark.setZIndex(this.layoutZIndex), isValid(this._spec.id) && axisMark.setUserId(this._spec.id), 
            this._marks.addMark(axisMark), null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) {
                const gridMark = this._createMark({
                    type: "component",
                    name: `axis-${this.getOrient()}-grid`
                }, {
                    componentType: "angle" === this.getOrient() ? GridEnum.circleAxisGrid : GridEnum.lineAxisGrid,
                    mode: this._spec.mode,
                    noSeparateStyle: !0,
                    skipTheme: !0
                });
                gridMark.setZIndex(null !== (_f = null !== (_d = null === (_c = null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.zIndex) && void 0 !== _d ? _d : null === (_e = this._spec.grid) || void 0 === _e ? void 0 : _e.zIndex) && void 0 !== _f ? _f : LayoutZIndex.Axis_Grid), 
                this._marks.addMark(gridMark), this._gridMark = gridMark;
            }
            if (isBoolean(this._spec.interactive) && this._marks.forEach((m => m.setInteractive(this._spec.interactive))), 
            !1 !== this._option.animation && !1 !== get(this._option.getChart().getSpec(), "animation") && !0 === this._spec.animation) {
                const axisAnimateConfig = animationConfig(null === (_g = Factory.getAnimationInKey("axis")) || void 0 === _g ? void 0 : _g(), {
                    appear: null !== (_j = null !== (_h = this._spec.animationAppear) && void 0 !== _h ? _h : get(this._option.getChart().getSpec(), "animationAppear.axis")) && void 0 !== _j ? _j : get(this._option.getChart().getSpec(), "animationAppear"),
                    disappear: null !== (_l = null !== (_k = this._spec.animationDisappear) && void 0 !== _k ? _k : get(this._option.getChart().getSpec(), "animationDisappear.axis")) && void 0 !== _l ? _l : get(this._option.getChart().getSpec(), "animationDisappear"),
                    enter: null !== (_o = null !== (_m = this._spec.animationEnter) && void 0 !== _m ? _m : get(this._option.getChart().getSpec(), "animationEnter.axis")) && void 0 !== _o ? _o : get(this._option.getChart().getSpec(), "animationEnter"),
                    exit: null !== (_q = null !== (_p = this._spec.animationExit) && void 0 !== _p ? _p : get(this._option.getChart().getSpec(), "animationExit.axis")) && void 0 !== _q ? _q : get(this._option.getChart().getSpec(), "animationExit"),
                    update: null !== (_s = null !== (_r = this._spec.animationUpdate) && void 0 !== _r ? _r : get(this._option.getChart().getSpec(), "animationUpdate.axis")) && void 0 !== _s ? _s : get(this._option.getChart().getSpec(), "animationUpdate")
                });
                axisAnimateConfig.enter && (axisAnimateConfig.update[0].customParameters = {
                    enter: axisAnimateConfig.enter[0]
                }), this._marks.forEach((m => m.setAnimationConfig(axisAnimateConfig)));
            }
        }
    }
    isSeriesDataEnable() {
        let enable = !0;
        return eachSeries(this._regions, (s => {
            var _a;
            isArray(null === (_a = s.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) && (enable = !1);
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), enable;
    }
    setSeriesAndRegionsFromSpec() {
        const {seriesId: seriesId, seriesIndex: seriesIndex, regionId: regionId, regionIndex: regionIndex} = this._spec;
        isValid(seriesId) && (this._seriesUserId = array(seriesId)), isValid(regionId) && (this._regionUserId = array(regionId)), 
        isValid(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid(regionIndex) && (this._regionIndex = array(regionIndex)), 
        this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex), 
        this.layout.layoutBindRegionID = this._regions.map((x => x.id));
    }
    getBindSeriesFilter() {
        return {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        };
    }
    initEvent() {
        this.event.on(ChartEvent.scaleUpdate, {
            filter: ({model: model}) => (null == model ? void 0 : model.id) === this.id
        }, this.effect.scaleUpdate.bind(this));
        const viewStatistics = getSeries(this._regions, {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }).map((s => s.getViewDataStatistics())).filter((v => !!v));
        viewStatistics.length > 1 ? this._option.dataSet.multipleDataViewAddListener(viewStatistics, "change", (() => {
            this.updateScaleDomain();
        })) : 1 === viewStatistics.length && viewStatistics[0].target.addListener("change", (() => {
            this.updateScaleDomain();
        })), eachSeries(this._regions, (s => {
            s.event.on(ChartEvent.rawDataUpdate, {
                filter: ({model: model}) => (null == model ? void 0 : model.id) === s.id
            }, (() => {
                this._clearRawDomain();
            }));
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
    }
    updateScaleDomain() {}
    _clearRawDomain() {}
    computeData(updateType) {
        !this._tickData || "force" !== updateType && isEqual(this._scale.range(), [ 0, 1 ]) || (this._tickData.getDataView().reRunAllTransform(), 
        this._tickData.updateData());
    }
    initScales() {
        this._scales = [ this._scale ];
        const groups = [];
        if (eachSeries(this._regions, (s => {
            const g = s.getGroups();
            g && groups.push(g);
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }), 0 !== groups.length) {
            const depth = maxInArray(groups.map((g => g.fields.length)));
            for (let i = 1; i < depth; i++) {
                const scale = this._scale.clone();
                this._scales.push(scale);
            }
        }
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reRender = !0, (null == prevSpec ? void 0 : prevSpec.type) !== (null == spec ? void 0 : spec.type) ? (result.reMake = !0, 
        result) : result;
    }
    getLabelFormatMethod() {
        return this._spec.label.formatMethod ? (value, datum, index) => this._spec.label.formatMethod(datum.rawValue, datum) : null;
    }
    getLabelItems(length) {
        return isArray(this._tickData.getLatestData()) ? [ this._tickData.getLatestData().map((obj => ({
            id: obj.value,
            label: obj.value,
            value: 0 === length ? 0 : this.dataToPosition([ obj.value ]) / length,
            rawValue: obj.value
        }))).filter((entry => entry.value >= 0 && entry.value <= 1)) ] : [];
    }
    _delegateAxisContainerEvent(component) {
        component.addEventListener("*", ((event, type) => this._delegateEvent(component, event, type)));
    }
    _getAxisAttributes() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const spec = this._spec;
        let titleTextStyle, titleAngle = spec.title.angle;
        "left" !== spec.orient && "right" !== spec.orient || (null === (_a = spec.title) || void 0 === _a ? void 0 : _a.autoRotate) && isNil(spec.title.angle) && (titleAngle = "left" === spec.orient ? -90 : 90, 
        titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient]);
        const labelSpec = pickWithout(spec.label, [ "style", "formatMethod", "state" ]), backgroundSpec = null !== (_b = spec.background) && void 0 !== _b ? _b : {}, titleBackgroundSpec = null !== (_c = spec.title.background) && void 0 !== _c ? _c : {};
        return {
            orient: this.getOrient(),
            select: !0 !== this._option.disableTriggerEvent && spec.select,
            hover: !0 !== this._option.disableTriggerEvent && spec.hover,
            line: transformAxisLineStyle(spec.domainLine),
            label: Object.assign({
                style: isFunction(spec.label.style) ? (datum, index, data, layer) => {
                    var _a;
                    const style = spec.label.style(datum.rawValue, index, datum, data, layer);
                    return transformToGraphic(mergeSpec({}, null === (_a = this._theme.label) || void 0 === _a ? void 0 : _a.style, style));
                } : transformToGraphic(spec.label.style),
                formatMethod: spec.label.formatMethod ? (value, datum, index) => spec.label.formatMethod(datum.rawValue, datum) : null,
                state: transformAxisLabelStateStyle(spec.label.state)
            }, labelSpec),
            tick: !1 === spec.tick.visible ? {
                visible: !1
            } : {
                visible: spec.tick.visible,
                length: spec.tick.tickSize,
                inside: spec.tick.inside,
                alignWithLabel: spec.tick.alignWithLabel,
                style: isFunction(spec.tick.style) ? (value, index, datum, data) => {
                    var _a;
                    const style = spec.tick.style(value, index, datum, data);
                    return transformToGraphic(mergeSpec({}, null === (_a = this._theme.tick) || void 0 === _a ? void 0 : _a.style, style));
                } : transformToGraphic(spec.tick.style),
                state: transformStateStyle(spec.tick.state),
                dataFilter: spec.tick.dataFilter
            },
            subTick: !1 === spec.subTick.visible ? {
                visible: !1
            } : {
                visible: spec.subTick.visible,
                length: spec.subTick.tickSize,
                inside: spec.subTick.inside,
                count: spec.subTick.tickCount,
                style: isFunction(spec.subTick.style) ? (value, index, datum, data) => {
                    var _a;
                    const style = spec.subTick.style(value, index, datum, data);
                    return transformToGraphic(mergeSpec({}, null === (_a = this._theme.subTick) || void 0 === _a ? void 0 : _a.style, style));
                } : transformToGraphic(spec.subTick.style),
                state: transformStateStyle(spec.subTick.state)
            },
            title: !1 === spec.title.visible ? {
                visible: !1
            } : Object.assign({
                visible: spec.title.visible,
                position: spec.title.position,
                space: spec.title.space,
                autoRotate: !1,
                angle: titleAngle ? degreeToRadian(titleAngle) : null,
                textStyle: mergeSpec({}, titleTextStyle, transformToGraphic(spec.title.style)),
                padding: spec.title.padding,
                shape: !1 === (null === (_d = spec.title.shape) || void 0 === _d ? void 0 : _d.visible) ? {
                    visible: !1
                } : {
                    visible: null === (_e = spec.title.shape) || void 0 === _e ? void 0 : _e.visible,
                    space: null === (_f = spec.title.shape) || void 0 === _f ? void 0 : _f.space,
                    style: transformToGraphic(null === (_g = spec.title.shape) || void 0 === _g ? void 0 : _g.style)
                },
                background: !1 === titleBackgroundSpec.visible ? {
                    visible: !1
                } : {
                    visible: titleBackgroundSpec.visible,
                    style: transformToGraphic(titleBackgroundSpec.style)
                },
                state: {
                    text: transformStateStyle(spec.title.state),
                    shape: transformStateStyle(null === (_h = spec.title.shape) || void 0 === _h ? void 0 : _h.state),
                    background: transformStateStyle(null === (_j = spec.title.background) || void 0 === _j ? void 0 : _j.state)
                },
                pickable: !1 !== (null === (_k = spec.title.style) || void 0 === _k ? void 0 : _k.pickable),
                childrenPickable: !1 !== (null === (_l = spec.title.style) || void 0 === _l ? void 0 : _l.pickable)
            }, spec.title),
            panel: !1 === backgroundSpec.visible ? {
                visible: !1
            } : {
                visible: backgroundSpec.visible,
                style: transformToGraphic(backgroundSpec.style),
                state: transformStateStyle(backgroundSpec.state)
            }
        };
    }
    _getGridAttributes() {
        const spec = this._spec;
        return {
            alternateColor: spec.grid.alternateColor,
            alignWithLabel: spec.grid.alignWithLabel,
            style: isFunction(spec.grid.style) ? () => (datum, index) => {
                var _a, _b;
                const style = spec.grid.style(null === (_a = datum.datum) || void 0 === _a ? void 0 : _a.rawValue, index, datum.datum);
                return transformToGraphic(mergeSpec({}, null === (_b = this._theme.grid) || void 0 === _b ? void 0 : _b.style, style));
            } : transformToGraphic(spec.grid.style),
            subGrid: !1 === spec.subGrid.visible ? {
                visible: !1
            } : {
                type: "line",
                visible: spec.subGrid.visible,
                alternateColor: spec.subGrid.alternateColor,
                style: transformToGraphic(spec.subGrid.style)
            }
        };
    }
    _initTickDataSet(options) {
        registerDataSetInstanceParser(this._option.dataSet, "scale", scaleParser), registerDataSetInstanceTransform(this._option.dataSet, "ticks", ticks);
        return new DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_ticks`
        }).parse(this._scale, {
            type: "scale"
        }).transform({
            type: "ticks",
            options: options
        }, !1);
    }
    _tickTransformOption(coordinateType) {
        const tick = this._tick || {}, label = this._spec.label || {}, {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, tickMode: tickMode} = tick, {style: labelStyle, formatMethod: labelFormatter, minGap: labelGap} = label;
        return {
            sampling: !1 !== this._spec.sampling,
            tickCount: tickCount,
            forceTickCount: forceTickCount,
            tickStep: tickStep,
            tickMode: tickMode,
            axisOrientType: this._orient,
            coordinateType: coordinateType,
            labelStyle: labelStyle,
            labelFormatter: labelFormatter,
            labelGap: labelGap
        };
    }
    addTransformToTickData(options, execute) {
        var _a, _b;
        null === (_b = null === (_a = this._tickData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.transform(options, execute);
    }
    dataToPosition(values) {
        return this._scale.scale(values);
    }
}

AxisComponent.specKey = "axes";

export const registerAxis = () => {
    registerVGrammarAxis(), registerVGrammarGrid(), registerComponentMark(), Factory.registerAnimation("axis", (() => ({
        appear: {
            custom: GroupFadeIn
        },
        update: {
            custom: GroupTransition
        },
        exit: {
            custom: GroupFadeOut
        }
    })));
};
//# sourceMappingURL=base-axis.js.map
