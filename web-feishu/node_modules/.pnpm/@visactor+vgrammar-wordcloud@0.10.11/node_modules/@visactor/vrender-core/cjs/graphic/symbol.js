"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createSymbol = exports.Symbol = void 0;

const vutils_1 = require("@visactor/vutils"), vutils_2 = require("@visactor/vutils"), builtin_symbol_1 = require("./builtin-symbol"), graphic_1 = require("./graphic"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), custom_path2d_1 = require("../common/custom-path2d"), constants_1 = require("./constants"), xml_1 = require("../common/xml"), parser_1 = require("../common/xml/parser"), _tempBounds = new vutils_1.AABBBounds, SYMBOL_UPDATE_TAG_KEY = [ "symbolType", "size", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Symbol extends graphic_1.Graphic {
    constructor(params = {
        symbolType: "circle"
    }) {
        super(params), this.type = "symbol", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    getParsedPath() {
        return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), 
        this._parsedPath;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {size: size} = this.attribute;
        return (0, vutils_2.isArray)(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
    }
    doUpdateParsedPath() {
        const symbolTheme = (0, theme_1.getTheme)(this).symbol;
        let {symbolType: symbolType = symbolTheme.symbolType} = this.attribute, path = builtin_symbol_1.builtinSymbolsMap[symbolType];
        if (path) return this._parsedPath = path, path;
        if (path = Symbol.userSymbolMap[symbolType], path) return this._parsedPath = path, 
        path;
        symbolType = builtin_symbol_1.builtInSymbolStrMap[symbolType] || symbolType;
        if (!0 === (0, parser_1.isSvg)(symbolType)) {
            const parser = new xml_1.XMLParser, {svg: svg} = parser.parse(symbolType);
            if (!svg) return null;
            const path = (0, vutils_2.isArray)(svg.path) ? svg.path : [ svg.path ];
            _tempBounds.clear();
            const cacheList = [];
            path.forEach((item => {
                const cache = (new custom_path2d_1.CustomPath2D).fromString(item.d), attribute = {};
                constants_1.SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((k => {
                    item[k] && (attribute[constants_1.SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
                })), cacheList.push({
                    path: cache,
                    attribute: attribute
                }), _tempBounds.union(cache.bounds);
            }));
            const width = _tempBounds.width(), height = _tempBounds.height(), scale = 1 / (0, 
            vutils_2.max)(width, height);
            return cacheList.forEach((cache => cache.path.transform(0, 0, scale, scale))), this._parsedPath = new builtin_symbol_1.CustomSymbolClass(symbolType, cacheList, !0), 
            Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
        }
        const cache = (new custom_path2d_1.CustomPath2D).fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale = 1 / (0, 
        vutils_2.max)(width, height);
        return cache.transform(0, 0, scale, scale), this._parsedPath = new builtin_symbol_1.CustomSymbolClass(symbolType, cache), 
        Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
    }
    doUpdateAABBBounds(full) {
        const symbolTheme = (0, theme_1.getTheme)(this).symbol;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateSymbolAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).symbol, this._AABBBounds, full, this), {boundsPadding: boundsPadding = symbolTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).symbol[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = (0, 
        vutils_2.isArray)(size) ? size : [ size, size ];
        return symbolInstance.path ? (new custom_path2d_1.CustomPath2D).fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : (new custom_path2d_1.CustomPath2D).fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
    }
    clone() {
        return new Symbol(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Symbol.NOWORK_ANIMATE_ATTR;
    }
}

function createSymbol(attributes) {
    return new Symbol(attributes);
}

exports.Symbol = Symbol, Symbol.userSymbolMap = {}, Symbol.NOWORK_ANIMATE_ATTR = Object.assign({
    symbolType: 1
}, graphic_1.NOWORK_ANIMATE_ATTR), exports.createSymbol = createSymbol;
//# sourceMappingURL=symbol.js.map
