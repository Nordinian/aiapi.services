import { isObject } from "@visactor/vutils";

import { BaseRenderContributionTime } from "../../../../common/enums";

import { DefaultBaseBackgroundRenderContribution } from "./base-contribution-render";

import { boundsAllocate } from "../../../../allocator/bounds-allocate";

export class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const {backgroundMode: backgroundMode = graphicAttribute.backgroundMode, backgroundFit: backgroundFit = graphicAttribute.backgroundFit} = graphic.attribute;
        let b, {background: background} = graphic.attribute;
        if (!background) return;
        const shouldReCalBounds = isObject(background) && background.background, onlyTranslate = graphic.transMatrix.onlyTranslate();
        if (shouldReCalBounds) {
            const _b = graphic.AABBBounds, x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0), y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0), w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(), h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
            if (b = boundsAllocate.allocate(x, y, x + w, y + h), background = background.background, 
            !onlyTranslate) {
                const w = b.width(), h = b.height();
                b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w, h);
            }
        } else b = graphic.AABBBounds, onlyTranslate || b.set(0, 0, b.width(), b.height());
        if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), 
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), 
            context.highPerformanceRestore(), context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = background, context.fillRect(b.x1, b.y1, b.width(), b.height()), 
        context.highPerformanceRestore();
        shouldReCalBounds && boundsAllocate.free(b);
    }
}

export const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution;
//# sourceMappingURL=text-contribution-render.js.map
