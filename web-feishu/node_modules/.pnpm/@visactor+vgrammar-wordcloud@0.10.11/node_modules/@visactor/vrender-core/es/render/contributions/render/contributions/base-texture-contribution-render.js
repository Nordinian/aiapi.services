import { canvasAllocate } from "../../../../allocator/canvas-allocate";

import { BaseRenderContributionTime } from "../../../../common/enums";

import { pi2 } from "@visactor/vutils";

export class DefaultBaseTextureRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10;
    }
    createCommonPattern(size, padding, color, targetContext, cb) {
        const r = (size - 2 * padding) / 2, dpr = targetContext.dpr, canvas = canvasAllocate.allocate({
            width: size,
            height: size,
            dpr: dpr
        }), ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), 
        cb(r, ctx);
        const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
        return pattern.setTransform && pattern.setTransform(new DOMMatrix([ 1 / dpr, 0, 0, 1 / dpr, 0, 0 ])), 
        canvasAllocate.free(canvas), pattern;
    }
    createCirclePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
        }));
    }
    createDiamondPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = size / 2, y = x;
            ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), 
            ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
        }));
    }
    createRectPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding, y = x;
            ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
        }));
    }
    createVerticalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding;
            ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
        }));
    }
    createHorizontalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const y = padding;
            ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
        }));
    }
    createBiasLRLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
            const dx = size / 2, dy = -dx;
            ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), 
            ctx.stroke();
        }));
    }
    createBiasRLLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
            const dx = size / 2, dy = dx;
            ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), 
            ctx.lineTo(-dx, -dy + size), ctx.stroke();
        }));
    }
    createGridPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding, y = x;
            ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
        }));
    }
    initTextureMap(ctx, stage) {
        this.textureMap = new Map;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this.textureMap || this.initTextureMap(context, graphic.stage);
        const {texture: texture = graphicAttribute.texture, textureColor: textureColor = graphicAttribute.textureColor, textureSize: textureSize = graphicAttribute.textureSize, texturePadding: texturePadding = graphicAttribute.texturePadding} = graphic.attribute;
        texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
    }
    drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
        let pattern = this.textureMap.get(texture);
        if (!pattern) switch (texture) {
          case "circle":
            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "diamond":
            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "rect":
            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "vertical-line":
            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "horizontal-line":
            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-lr":
            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-rl":
            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "grid":
            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
        }
        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
    }
}

export const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution;
//# sourceMappingURL=base-texture-contribution-render.js.map
