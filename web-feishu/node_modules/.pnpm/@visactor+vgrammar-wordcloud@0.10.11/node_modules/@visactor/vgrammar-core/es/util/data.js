var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { DataSet, DataView, csvParser, dsvParser, tsvParser } from "@visactor/vdataset";

import { array, isString } from "@visactor/vutils";

const jsonParser = (data, options = {}, dataView) => {
    if (!isString(data)) return array(data);
    try {
        return array(JSON.parse(data));
    } catch (e) {
        return [];
    }
}, parsers = {
    csv: csvParser,
    dsv: dsvParser,
    tsv: tsvParser,
    json: jsonParser
};

export const parseFormat = (data, format) => {
    if (!format || !parsers[format.type]) return array(data);
    const options = "dsv" === format.type ? {
        delimiter: format.delimiter
    } : {};
    return parsers[format.type](data, options, new DataView(new DataSet));
};

export const load = url => __awaiter(void 0, void 0, void 0, (function*() {
    try {
        return (yield fetch(url)).text();
    } catch (error) {
        return null;
    }
}));
//# sourceMappingURL=data.js.map
