import { isNumber, isString } from "@visactor/vutils";

import { InteractionStateEnum } from "../graph/enums";

import { BaseInteraction } from "./base";

import { groupMarksByState } from "./utils";

export class ElementSelect extends BaseInteraction {
    constructor(view, options) {
        super(view, options), this.type = ElementSelect.type, this.clearPrevElements = () => {
            const {state: state, reverseState: reverseState} = this.options;
            this._statedElements && this._statedElements.length && (this.clearAllStates(state, reverseState), 
            this.dispatchEvent("reset", {
                elements: this._statedElements,
                options: this.options
            }), this._statedElements = []);
        }, this.handleStart = e => {
            const {state: state, reverseState: reverseState, isMultiple: isMultiple} = this.options;
            e.element && this._marks && this._marks.includes(e.element.mark) ? e.element.hasState(state) ? "self" === this._resetType && (this._statedElements && (this._statedElements = this._statedElements.filter((el => el !== e.element))), 
            this.updateStates(state, reverseState)) : (this._timer && clearTimeout(this._timer), 
            e.element.addState(state), this._statedElements || (this._statedElements = []), 
            isMultiple ? this._statedElements.push(e.element) : this._statedElements[0] = e.element, 
            this.updateStates(state, reverseState), this.dispatchEvent("start", {
                elements: this._statedElements,
                options: this.options
            }), "timeout" === this._resetType && (this._timer = setTimeout((() => {
                this.clearPrevElements();
            }), this.options.resetTrigger))) : "view" === this._resetType && this._statedElements && this._statedElements.length && this.clearPrevElements();
        }, this.handleReset = e => {
            const hasActiveElement = e.element && this._marks && this._marks.includes(e.element.mark);
            this._statedElements && this._statedElements.length && ("view" !== this._resetType || hasActiveElement ? "self" === this._resetType && hasActiveElement && this.clearPrevElements() : this.clearPrevElements());
        }, this.options = Object.assign({}, ElementSelect.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), 
        this._stateMarks = groupMarksByState(this._marks, [ this.options.state, this.options.reverseState ]);
    }
    getEvents() {
        const resetTrigger = this.options.resetTrigger, trigger = this.options.trigger, events = [ {
            type: trigger,
            handler: this.handleStart
        } ];
        let eventName = resetTrigger;
        return "empty" === resetTrigger ? (eventName = trigger, this._resetType = "view") : isString(resetTrigger) ? resetTrigger.includes("view:") ? (eventName = resetTrigger.replace("view:", ""), 
        this._resetType = "view") : (eventName = resetTrigger, this._resetType = "self") : isNumber(resetTrigger) ? (eventName = null, 
        this._resetType = "timeout") : this._resetType = null, eventName && eventName !== trigger && events.push({
            type: eventName,
            handler: this.handleReset
        }), events;
    }
}

ElementSelect.type = "element-select", ElementSelect.defaultOptions = {
    state: InteractionStateEnum.selected,
    trigger: "click"
};
//# sourceMappingURL=element-select.js.map