"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.load = exports.parseFormat = void 0;

const vdataset_1 = require("@visactor/vdataset"), vutils_1 = require("@visactor/vutils"), jsonParser = (data, options = {}, dataView) => {
    if (!(0, vutils_1.isString)(data)) return (0, vutils_1.array)(data);
    try {
        return (0, vutils_1.array)(JSON.parse(data));
    } catch (e) {
        return [];
    }
}, parsers = {
    csv: vdataset_1.csvParser,
    dsv: vdataset_1.dsvParser,
    tsv: vdataset_1.tsvParser,
    json: jsonParser
}, parseFormat = (data, format) => {
    if (!format || !parsers[format.type]) return (0, vutils_1.array)(data);
    const options = "dsv" === format.type ? {
        delimiter: format.delimiter
    } : {};
    return parsers[format.type](data, options, new vdataset_1.DataView(new vdataset_1.DataSet));
};

exports.parseFormat = parseFormat;

const load = url => __awaiter(void 0, void 0, void 0, (function*() {
    try {
        return (yield fetch(url)).text();
    } catch (error) {
        return null;
    }
}));

exports.load = load;
//# sourceMappingURL=data.js.map
