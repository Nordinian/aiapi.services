{"version":3,"sources":["../src/picker/contributions/canvas-picker/glyph-picker.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,iBAAiB,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAIrF,IAAM,wBAAwB,GAA9B,MAAM,wBAAwB;IAInC,YAAiD,cAA8B;QAA9B,mBAAc,GAAd,cAAc,CAAgB;QAH/E,SAAI,GAAW,OAAO,CAAC;QACvB,eAAU,GAAW,iBAAiB,CAAC;IAE2C,CAAC;IAEnF,QAAQ,CAAC,KAAa,EAAE,KAAa,EAAE,MAAoB;QACzD,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;YAC1C,OAAO,KAAK,CAAC;SACd;QACD,IAAI,KAAK,CAAC,SAAS,CAAC,QAAQ,KAAK,WAAW,EAAE;YAC5C,OAAO,IAAI,CAAC;SACb;QAED,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,aAAN,MAAM,cAAN,MAAM,GAAI,EAAE,CAAC;QACrC,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,KAAK,CAAC;SACd;QAED,MAAM,aAAa,GAAG,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,aAAa,CAAC;QAC5C,IAAI,aAAa,EAAE;YAEjB,IAAI,MAAM,GAAG,KAAK,CAAC;YACnB,KAAK,CAAC,aAAa,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBAChC,IAAI,MAAM,EAAE;oBACV,OAAO;iBACR;gBACD,MAAM,IAAI,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;gBAC5D,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;YACpC,CAAC,CAAC,CAAC;YACH,OAAO,MAAM,CAAC;SACf;QACD,OAAO,KAAK,CAAC;IA0Cf,CAAC;CACF,CAAA;AA3EY,wBAAwB;IADpC,UAAU,EAAE;IAKE,WAAA,MAAM,CAAC,WAAW,CAAC,CAAA;;GAJrB,wBAAwB,CA2EpC;SA3EY,wBAAwB","file":"glyph-picker.js","sourcesContent":["import type { IPoint } from '@visactor/vutils';\nimport { inject, injectable, GLYPH_NUMBER_TYPE, GlyphRender } from '@visactor/vrender-core';\nimport type { IGlyph, IGraphicPicker, IGraphicRender, IPickParams } from '@visactor/vrender-core';\n\n@injectable()\nexport class DefaultCanvasGlyphPicker implements IGraphicPicker {\n  type: string = 'glyph';\n  numberType: number = GLYPH_NUMBER_TYPE;\n\n  constructor(@inject(GlyphRender) public readonly canvasRenderer: IGraphicRender) {}\n\n  contains(glyph: IGlyph, point: IPoint, params?: IPickParams): boolean {\n    if (!glyph.AABBBounds.containsPoint(point)) {\n      return false;\n    }\n    if (glyph.attribute.pickMode === 'imprecise') {\n      return true;\n    }\n\n    const { pickContext } = params ?? {};\n    if (!pickContext) {\n      return false;\n    }\n\n    const pickerService = params?.pickerService;\n    if (pickerService) {\n      // 遍历所有的子元素pick\n      let picked = false;\n      glyph.getSubGraphic().forEach(g => {\n        if (picked) {\n          return;\n        }\n        const data = pickerService.pickItem(g, point, null, params);\n        picked = !!(data && data.graphic);\n      });\n      return picked;\n    }\n    return false;\n\n    // const { rectAttribute } = graphicService.themeService.getCurrentTheme();\n    // const glyphAttribute = getTheme(glyph).glyph;\n    // let { x = glyphAttribute.x, y = glyphAttribute.y } = glyph.attribute;\n\n    // pickContext.highPerformanceSave();\n    // if (!glyph.transMatrix.onlyTranslate()) {\n    //   // 性能较差\n    //   x = 0;\n    //   y = 0;\n    //   pickContext.transformFromMatrix(glyph.transMatrix, true);\n    // } else {\n    //   const { dx = glyphAttribute.dx, dy = glyphAttribute.dy } = glyph.attribute;\n    //   x += dx;\n    //   y += dy;\n    //   // 当前context有rotate/scale，重置matrix\n    //   pickContext.setTransformForCurrent();\n    // }\n    // // 详细形状判断\n    // let picked = false;\n    // this.canvasRenderer.drawShape(\n    //   glyph,\n    //   pickContext,\n    //   x,\n    //   y,\n    //   {\n    //     drawContribution: params.pickerService?.drawContribution\n    //   } as any,\n    //   null,\n    //   context => {\n    //     // 选中后面就不需要再走逻辑了\n    //     if (picked) {\n    //       return true;\n    //     }\n    //     picked = context.isPointInPath(point.x, point.y);\n    //     return picked;\n    //   }\n    // );\n\n    // pickContext.highPerformanceRestore();\n    // return picked; // 无圆角形状判断通过\n  }\n}\n"]}