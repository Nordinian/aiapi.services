{"version":3,"sources":["../src/render/contributions/render/area-render.ts"],"names":[],"mappings":"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","file":"area-render.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport { abs, isArray, min } from '@visactor/vutils';\nimport { inject, injectable, named } from '../../../common/inversify-lite';\nimport type {\n  IArea,\n  IAreaCacheItem,\n  IAreaGraphicAttribute,\n  IGraphicAttribute,\n  IContext2d,\n  ICurveType,\n  IMarkAttribute,\n  IThemeAttribute,\n  ISegPath2D,\n  IDirection,\n  IAreaRenderContribution,\n  IDrawContext,\n  IRenderService,\n  IGraphicRender,\n  IGraphicRenderDrawParams,\n  IContributionProvider,\n  IStrokeType\n} from '../../../interface';\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport { ContributionProvider } from '../../../common/contribution-provider';\nimport {\n  genLinearSegments,\n  genBasisSegments,\n  genMonotoneXSegments,\n  genMonotoneYSegments,\n  genStepSegments,\n  genLinearClosedSegments\n} from '../../../common/segment';\n\nimport { getTheme } from '../../../graphic/theme';\nimport { drawPathProxy, fillVisible, runFill, runStroke, strokeVisible } from './utils';\nimport { AreaRenderContribution } from './contributions/constants';\nimport { BaseRenderContributionTime, Direction } from '../../../common/enums';\nimport { drawAreaSegments } from '../../../common/render-area';\nimport { AREA_NUMBER_TYPE } from '../../../graphic/constants';\nimport { drawSegments } from '../../../common/render-curve';\nimport { BaseRender } from './base-render';\nimport {\n  defaultAreaBackgroundRenderContribution,\n  defaultAreaTextureRenderContribution\n} from './contributions/area-contribution-render';\nimport { segments } from '../../../common/shape/arc';\n\nfunction calcLineCache(\n  points: IPointLike[],\n  curveType: ICurveType,\n  params?: { direction?: IDirection; startPoint?: IPointLike }\n): ISegPath2D | null {\n  switch (curveType) {\n    case 'linear':\n      return genLinearSegments(points, params);\n    case 'basis':\n      return genBasisSegments(points, params);\n    case 'monotoneX':\n      return genMonotoneXSegments(points, params);\n    case 'monotoneY':\n      return genMonotoneYSegments(points, params);\n    case 'step':\n      return genStepSegments(points, 0.5, params);\n    case 'stepBefore':\n      return genStepSegments(points, 0, params);\n    case 'stepAfter':\n      return genStepSegments(points, 1, params);\n    case 'linearClosed':\n      return genLinearClosedSegments(points, params);\n    default:\n      return genLinearSegments(points, params);\n  }\n}\n\n@injectable()\nexport class DefaultCanvasAreaRender extends BaseRender<IArea> implements IGraphicRender {\n  type: 'area';\n  numberType: number = AREA_NUMBER_TYPE;\n\n  constructor(\n    @inject(ContributionProvider)\n    @named(AreaRenderContribution)\n    protected readonly areaRenderContribitions: IContributionProvider<IAreaRenderContribution>\n  ) {\n    super();\n    this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution];\n    this.init(areaRenderContribitions);\n  }\n\n  drawLinearAreaHighPerformance(\n    area: IArea,\n    context: IContext2d,\n    fill: boolean,\n    stroke: boolean,\n    fillOpacity: number,\n    strokeOpacity: number,\n    offsetX: number,\n    offsetY: number,\n    areaAttribute: Required<IAreaGraphicAttribute>,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    context.beginPath();\n\n    const z = this.z ?? 0;\n    const { points } = area.attribute;\n    const startP = points[0];\n\n    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);\n    for (let i = 1; i < points.length; i++) {\n      const p = points[i];\n      context.lineTo(p.x + offsetX, p.y + offsetY, z);\n    }\n    for (let i = points.length - 1; i >= 0; i--) {\n      const p = points[i];\n      context.lineTo((p.x1 ?? p.x) + offsetX, (p.y1 ?? p.y) + offsetY, z);\n    }\n    context.closePath();\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute);\n\n    this.beforeRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      areaAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute: area.attribute }\n    );\n\n    const { x: originX = 0, x: originY = 0 } = area.attribute;\n    if (fill !== false) {\n      if (fillCb) {\n        fillCb(context, area.attribute, areaAttribute);\n      } else if (fillOpacity) {\n        context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);\n        context.fill();\n      }\n    }\n\n    this.afterRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      areaAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute: area.attribute }\n    );\n\n    if (stroke) {\n      const { stroke = areaAttribute && areaAttribute.stroke } = area.attribute;\n      if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {\n        context.beginPath();\n        if (stroke[0]) {\n          context.moveTo(startP.x + offsetX, startP.y + offsetY, z);\n          for (let i = 1; i < points.length; i++) {\n            const p = points[i];\n            context.lineTo(p.x + offsetX, p.y + offsetY, z);\n          }\n        } else if (stroke[2]) {\n          const endP = points[points.length - 1];\n          context.moveTo(endP.x + offsetX, endP.y + offsetY, z);\n          for (let i = points.length - 2; i >= 0; i--) {\n            const p = points[i];\n            context.lineTo((p.x1 ?? p.x) + offsetX, (p.y1 ?? p.y) + offsetY, z);\n          }\n        }\n      }\n      if (strokeCb) {\n        strokeCb(context, area.attribute, areaAttribute);\n      } else {\n        context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);\n        context.stroke();\n      }\n    }\n  }\n\n  drawShape(\n    area: IArea,\n    context: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const areaAttribute = getTheme(area, params?.theme).area;\n    const {\n      fill = areaAttribute.fill,\n      stroke = areaAttribute.stroke,\n      fillOpacity = areaAttribute.fillOpacity,\n      z = areaAttribute.z,\n      strokeOpacity = areaAttribute.strokeOpacity\n    } = area.attribute;\n\n    const data = this.valid(area, areaAttribute, fillCb, strokeCb);\n    if (!data) {\n      return;\n    }\n    const { doFill, doStroke } = data;\n\n    const { clipRange = areaAttribute.clipRange, closePath, points, segments } = area.attribute;\n    let { curveType = areaAttribute.curveType } = area.attribute;\n    if (closePath && curveType === 'linear') {\n      curveType = 'linearClosed';\n    }\n\n    if (clipRange === 1 && !segments && !points.some(p => p.defined === false) && curveType === 'linear') {\n      return this.drawLinearAreaHighPerformance(\n        area,\n        context,\n        !!fill,\n        doStroke,\n        fillOpacity,\n        strokeOpacity,\n        x,\n        y,\n        areaAttribute,\n        drawContext,\n        params,\n        fillCb,\n        strokeCb\n      );\n    }\n\n    // 更新cache\n    if (area.shouldUpdateShape()) {\n      if (segments && segments.length) {\n        let startPoint: IPointLike;\n        let lastTopSeg: { endX: number; endY: number };\n        const topCaches = segments\n          .map((seg, index) => {\n            if (seg.points.length <= 1) {\n              // 第一个点的话，直接设置lastTopSeg\n              if (index === 0) {\n                seg.points[0] && (lastTopSeg = { endX: seg.points[0].x, endY: seg.points[0].y });\n                return null;\n              }\n            }\n            // 添加上一个segment结束的点作为这个segment的起始点\n            if (index === 1) {\n              startPoint = { x: lastTopSeg.endX, y: lastTopSeg.endY };\n            } else if (index > 1) {\n              startPoint.x = lastTopSeg.endX;\n              startPoint.y = lastTopSeg.endY;\n            }\n            const data = calcLineCache(seg.points, curveType, {\n              startPoint\n            });\n            lastTopSeg = data;\n            return data;\n          })\n          .filter(item => !!item);\n        let lastBottomSeg: ISegPath2D;\n        const bottomCaches = [];\n        for (let i = segments.length - 1; i >= 0; i--) {\n          const points = segments[i].points;\n          const bottomPoints: IPointLike[] = [];\n          for (let i = points.length - 1; i >= 0; i--) {\n            bottomPoints.push({\n              x: points[i].x1 ?? points[i].x,\n              y: points[i].y1 ?? points[i].y\n            });\n          }\n          // 处理一下bottom的segments，bottom的segments需要手动添加endPoints\n          if (i !== 0) {\n            const lastSegmentPoints = segments[i - 1].points;\n            const endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];\n            endPoint &&\n              bottomPoints.push({\n                x: endPoint.x1 ?? endPoint.x,\n                y: endPoint.y1 ?? endPoint.y\n              });\n          }\n          if (bottomPoints.length > 1) {\n            lastBottomSeg = calcLineCache(\n              bottomPoints,\n              curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType\n            );\n            bottomCaches.unshift(lastBottomSeg);\n          }\n        }\n        area.cacheArea = bottomCaches.map((item, index) => ({\n          top: topCaches[index],\n          bottom: item\n        }));\n      } else if (points && points.length) {\n        // 转换points\n        const topPoints = points;\n        const bottomPoints: IPointLike[] = [];\n        for (let i = points.length - 1; i >= 0; i--) {\n          bottomPoints.push({\n            x: points[i].x1 ?? points[i].x,\n            y: points[i].y1 ?? points[i].y\n          });\n        }\n        const topCache = calcLineCache(topPoints, curveType);\n        const bottomCache = calcLineCache(\n          bottomPoints,\n          curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType\n        );\n\n        area.cacheArea = { top: topCache, bottom: bottomCache };\n      } else {\n        area.cacheArea = null;\n        area.clearUpdateShapeTag();\n        return;\n      }\n      area.clearUpdateShapeTag();\n    }\n\n    if (Array.isArray(area.cacheArea)) {\n      const segments = area.attribute.segments.filter(item => item.points.length);\n      // 如果第一个seg只有一个点，那么shift出去\n      if (segments[0].points.length === 1) {\n        segments.shift();\n      }\n      if (clipRange === 1) {\n        let skip = false;\n        // 性能优化，不需要clip的线段不需要计算长度\n        area.cacheArea.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          skip = this.drawSegmentItem(\n            context,\n            cache,\n            doFill,\n            fillOpacity,\n            doStroke,\n            strokeOpacity,\n            segments[index],\n            [areaAttribute, area.attribute],\n            clipRange,\n            x,\n            y,\n            z,\n            area,\n            drawContext,\n            fillCb,\n            strokeCb\n          );\n        });\n      } else {\n        // 如果是segments的话，每个clipRange需要重新计算\n        // 整个线段的总长度\n        const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0);\n        // 总需要绘制的长度\n        const totalDrawLength = clipRange * totalLength;\n        // 直到上次绘制的长度\n        let drawedLengthUntilLast = 0;\n        let skip = false;\n        area.cacheArea.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          const curSegLength = cache.top.getLength();\n          const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;\n          drawedLengthUntilLast += curSegLength;\n          if (_cr > 0) {\n            skip = this.drawSegmentItem(\n              context,\n              cache,\n              doFill,\n              fillOpacity,\n              doStroke,\n              strokeOpacity,\n              segments[index],\n              [areaAttribute, area.attribute],\n              min(_cr, 1),\n              x,\n              y,\n              z,\n              area,\n              drawContext,\n              fillCb,\n              strokeCb\n            );\n          }\n        });\n      }\n    } else {\n      this.drawSegmentItem(\n        context,\n        area.cacheArea as IAreaCacheItem,\n        doFill,\n        fillOpacity,\n        doStroke,\n        strokeOpacity,\n        area.attribute,\n        areaAttribute,\n        clipRange,\n        x,\n        y,\n        z,\n        area,\n        drawContext,\n        fillCb,\n        strokeCb\n      );\n    }\n  }\n\n  draw(area: IArea, renderService: IRenderService, drawContext: IDrawContext, params?: IGraphicRenderDrawParams) {\n    const areaAttribute = getTheme(area, params?.theme).area;\n    this._draw(area, areaAttribute, false, drawContext, params);\n  }\n\n  /**\n   * 绘制segment\n   * @param context\n   * @param cache\n   * @param fill\n   * @param stroke\n   * @param attribute\n   * @param defaultAttribute\n   * @param clipRange\n   * @param offsetX\n   * @param offsetY\n   * @param fillCb\n   * @param strokeCb\n   * @returns 返回true代表跳过后续绘制\n   */\n  protected drawSegmentItem(\n    context: IContext2d,\n    cache: IAreaCacheItem,\n    fill: boolean,\n    fillOpacity: number,\n    stroke: boolean,\n    strokeOpacity: number,\n    attribute: Partial<IAreaGraphicAttribute>,\n    defaultAttribute: Required<IAreaGraphicAttribute> | Partial<IAreaGraphicAttribute>[],\n    clipRange: number,\n    offsetX: number,\n    offsetY: number,\n    offsetZ: number,\n    area: IArea,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean\n  ): boolean {\n    let ret = false;\n    ret =\n      ret ||\n      this._drawSegmentItem(\n        context,\n        cache,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeOpacity,\n        attribute,\n        defaultAttribute,\n        clipRange,\n        offsetX,\n        offsetY,\n        offsetZ,\n        area,\n        drawContext,\n        false,\n        fillCb,\n        strokeCb\n      );\n    ret =\n      ret ||\n      this._drawSegmentItem(\n        context,\n        cache,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeOpacity,\n        attribute,\n        defaultAttribute,\n        clipRange,\n        offsetX,\n        offsetY,\n        offsetZ,\n        area,\n        drawContext,\n        true,\n        fillCb,\n        strokeCb\n      );\n    return ret;\n  }\n\n  protected _drawSegmentItem(\n    context: IContext2d,\n    cache: IAreaCacheItem,\n    fill: boolean,\n    fillOpacity: number,\n    stroke: boolean,\n    strokeOpacity: number,\n    attribute: Partial<IAreaGraphicAttribute>,\n    defaultAttribute: Required<IAreaGraphicAttribute> | Partial<IAreaGraphicAttribute>[],\n    clipRange: number,\n    offsetX: number,\n    offsetY: number,\n    offsetZ: number,\n    area: IArea,\n    drawContext: IDrawContext,\n    connect: boolean,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean\n  ) {\n    // 绘制connect区域\n    let { connectedType, connectedX, connectedY, connectedStyle } = attribute;\n    const da = [];\n    if (connect) {\n      if (isArray(defaultAttribute)) {\n        connectedType = connectedType ?? defaultAttribute[0].connectedType ?? defaultAttribute[1].connectedType;\n        connectedX = connectedX ?? defaultAttribute[0].connectedX ?? defaultAttribute[1].connectedX;\n        connectedY = connectedY ?? defaultAttribute[0].connectedY ?? defaultAttribute[1].connectedY;\n        connectedStyle = connectedStyle ?? defaultAttribute[0].connectedStyle ?? defaultAttribute[1].connectedStyle;\n      } else {\n        connectedType = connectedType ?? defaultAttribute.connectedType;\n        connectedX = connectedX ?? defaultAttribute.connectedX;\n        connectedY = connectedY ?? defaultAttribute.connectedY;\n        connectedStyle = connectedStyle ?? defaultAttribute.connectedStyle;\n      }\n\n      // 如果有非法值就是none\n      if (connectedType !== 'connect' && connectedType !== 'zero') {\n        connectedType = 'none';\n      }\n\n      if (isArray(defaultAttribute)) {\n        defaultAttribute.forEach(i => da.push(i));\n      } else {\n        da.push(defaultAttribute);\n      }\n      da.push(attribute);\n    }\n\n    if (connect && connectedType === 'none') {\n      return false;\n    }\n\n    if (!cache) {\n      return;\n    }\n    context.beginPath();\n\n    const ret: boolean = false;\n    const { points, segments } = area.attribute;\n    let direction = Direction.ROW;\n    let endP: IPointLike;\n    let startP: IPointLike;\n    if (segments) {\n      const endSeg = segments[segments.length - 1];\n      const startSeg = segments[0];\n      startP = startSeg.points[0];\n      endP = endSeg.points[endSeg.points.length - 1];\n    } else {\n      startP = points[0];\n      endP = points[points.length - 1];\n    }\n    const xTotalLength = abs(endP.x - startP.x);\n    const yTotalLength = abs(endP.y - startP.y);\n    direction = xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN;\n    drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {\n      offsetX,\n      offsetY,\n      offsetZ,\n      direction,\n      drawConnect: connect,\n      mode: connectedType,\n      zeroX: connectedX,\n      zeroY: connectedY\n    });\n\n    this.beforeRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      defaultAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute }\n    );\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);\n\n    const { x: originX = 0, x: originY = 0 } = attribute;\n    if (fill !== false) {\n      if (fillCb) {\n        fillCb(context, attribute, defaultAttribute);\n      } else if (fillOpacity) {\n        context.setCommonStyle(\n          area,\n          connect ? connectedStyle : attribute,\n          originX - offsetX,\n          originY - offsetY,\n          connect ? da : defaultAttribute\n        );\n        context.fill();\n      }\n    }\n\n    this.afterRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      defaultAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute }\n    );\n\n    if (stroke !== false) {\n      if (strokeCb) {\n        strokeCb(context, attribute, defaultAttribute);\n      } else {\n        const { stroke = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;\n        if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {\n          context.beginPath();\n          drawSegments(\n            context.camera ? context : context.nativeContext,\n            stroke[0] ? cache.top : cache.bottom,\n            clipRange,\n            direction === Direction.ROW ? 'x' : 'y',\n            {\n              offsetX,\n              offsetY,\n              offsetZ,\n              drawConnect: connect,\n              mode: connectedType,\n              zeroX: connectedX,\n              zeroY: connectedY\n            }\n          );\n        }\n        context.setStrokeStyle(\n          area,\n          connect ? connectedStyle : attribute,\n          originX - offsetX,\n          originY - offsetY,\n          connect ? da : defaultAttribute\n        );\n        context.stroke();\n      }\n    }\n\n    return ret;\n  }\n}\n"]}