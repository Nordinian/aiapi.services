{"version":3,"sources":["../src/common/canvas-utils.ts"],"names":[],"mappings":"AAIA,OAAO,EAAW,OAAO,EAAE,MAAM,kBAAkB,CAAC;AACpD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,UAAU,eAAe,CAAC,OAAmB,EAAE,KAAa,EAAE,GAAW;IAC7E,IAAI,WAAW,GAAG,KAAK,CAAC;IACxB,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,CAAC,aAAa,CAAC;IAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAEvD,IAAI,MAAM,GAAG,MAAM,KAAK,CAAC,EAAE;QACzB,OAAO,CAAC,CAAC;KACV;IACD,WAAW,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;IAClE,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,MAAM,UAAU,WAAW,CACzB,OAAmB,EACnB,CAAqD,EACrD,MAAqE,EACrE,OAAe,EACf,OAAe;IAEf,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;QACpB,OAAO,OAAO,CAAC;KAChB;IACD,IAAI,MAA2C,CAAC;IAChD,IAAI,KAAsB,CAAC;IAC3B,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACjC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,IAAI,KAAK,EAAE;gBACT,MAAM;aACP;SACF;KACF;SAAM;QACL,KAAK,GAAG,CAAC,CAAC;KACX;IACD,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IACpC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;QAC/B,MAAM,GAAG,oBAAoB,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;KACzE;SAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,SAAS,EAAE;QACvC,MAAM,GAAG,mBAAmB,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;KACxE;SAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;QACtC,MAAM,GAAG,oBAAoB,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;KACzE;IACD,OAAO,MAAM,IAAI,QAAQ,CAAC;AAC5B,CAAC;AAED,SAAS,oBAAoB,CAC3B,OAAmB,EACnB,KAAsB,EACtB,MAAqE,EACrE,UAAkB,CAAC,EACnB,UAAkB,CAAC;;IAEnB,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC;IACjC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IACD,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,MAAM,CAAC,SAAS,EAAE;QACpB,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,GAAG,MAAM,CAAC,SAAS,CAAC;QACpD,IAAI,MAAM,GAAG,MAAM,KAAK,CAAC,EAAE;YACzB,OAAO;SACR;QACD,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;KACb;IAED,MAAM,cAAc,GAAG,OAAO,CAAC,oBAAoB,CACjD,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,CAAC,CAAC,GAAG,CAAC,EACvB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,CAAC,CAAC,GAAG,CAAC,EACvB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,CAAC,CAAC,GAAG,CAAC,EACvB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,CAAC,CAAC,GAAG,CAAC,CACxB,CAAC;IACF,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,SAAS,oBAAoB,CAC3B,OAAmB,EACnB,KAAsB,EACtB,MAAqE,EACrE,UAAkB,CAAC,EACnB,UAAkB,CAAC;;IAEnB,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC;IACjC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IACD,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,MAAM,CAAC,SAAS,EAAE;QACpB,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,GAAG,MAAM,CAAC,SAAS,CAAC;QACpD,IAAI,MAAM,GAAG,MAAM,KAAK,CAAC,EAAE;YACzB,OAAO;SACR;QACD,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;KACb;IACD,MAAM,cAAc,GAAG,OAAO,CAAC,oBAAoB,CACjD,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,GAAG,CAAC,GAAG,CAAC,EACzB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,GAAG,CAAC,GAAG,CAAC,EACzB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,CAAC,CAAC,EAChC,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,GAAG,CAAC,GAAG,CAAC,EACzB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,GAAG,CAAC,GAAG,CAAC,EACzB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,EAAE,mCAAI,GAAG,CAAC,CACnC,CAAC;IACF,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,SAAS,mBAAmB,CAC1B,OAAmB,EACnB,KAAuB,EACvB,MAAqE,EACrE,UAAkB,CAAC,EACnB,UAAkB,CAAC;;IAEnB,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC;IACjC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IACD,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;IAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,OAAO,CAAC;IAC5B,IAAI,MAAM,CAAC,SAAS,EAAE;QACpB,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,GAAG,MAAM,CAAC,SAAS,CAAC;QACpD,IAAI,MAAM,GAAG,MAAM,KAAK,CAAC,EAAE;YACzB,OAAO;SACR;QACD,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;QACZ,CAAC,IAAI,MAAM,CAAC;KACb;IAED,MAAM,cAAc,GAAG,OAAO,CAAC,mBAAmB,CAChD,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,CAAC,mCAAI,CAAC,CAAC,GAAG,CAAC,EACtB,CAAC,GAAG,CAAC,MAAA,KAAK,CAAC,CAAC,mCAAI,CAAC,CAAC,GAAG,CAAC,EACtB,KAAK,CAAC,UAAU,EAChB,KAAK,CAAC,QAAQ,CACf,CAAC;IACF,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACzB,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;IAEH,IAAI,UAAU,CAAC;IACf,OAAQ,cAAsB,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,UAAU,CAAC,CAAC;AACtE,CAAC","file":"canvas-utils.js","sourcesContent":["import type { IColor, IConicalGradient, ILinearGradient, IRadialGradient } from '../interface/color';\nimport type { IContext2d, ITransform } from '../interface';\nimport { ICommonStyleParams } from '../interface';\nimport type { IBoundsLike } from '@visactor/vutils';\nimport { IMatrix, isArray } from '@visactor/vutils';\nimport { GradientParser } from './color-utils';\n\nexport function getScaledStroke(context: IContext2d, width: number, dpr: number) {\n  let strokeWidth = width;\n  const { a, b, c, d } = context.currentMatrix;\n  const scaleX = Math.sign(a) * Math.sqrt(a * a + b * b);\n  const scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);\n  // 如果没有scaleX和scaleY，那么认为什么都不用绘制\n  if (scaleX + scaleY === 0) {\n    return 0;\n  }\n  strokeWidth = (strokeWidth / Math.abs(scaleX + scaleY)) * 2 * dpr;\n  return strokeWidth;\n}\n\nexport function createColor(\n  context: IContext2d,\n  c: string | IColor | Array<string | IColor> | boolean,\n  params: { AABBBounds?: IBoundsLike; attribute?: Partial<ITransform> },\n  offsetX: number,\n  offsetY: number\n): string | CanvasGradient {\n  if (!c || c === true) {\n    return 'black';\n  }\n  let result: string | CanvasGradient | undefined;\n  let color: string | IColor;\n  if (isArray(c)) {\n    for (let i = 0; i < c.length; i++) {\n      color = c[i];\n      if (color) {\n        break;\n      }\n    }\n  } else {\n    color = c;\n  }\n  color = GradientParser.Parse(color);\n  if (typeof color === 'string') {\n    return color;\n  }\n  // TODO 不同scaleCenter有问题\n  if (color.gradient === 'linear') {\n    result = createLinearGradient(context, color, params, offsetX, offsetY);\n  } else if (color.gradient === 'conical') {\n    result = createConicGradient(context, color, params, offsetX, offsetY);\n  } else if (color.gradient === 'radial') {\n    result = createRadialGradient(context, color, params, offsetX, offsetY);\n  }\n  return result || 'orange';\n}\n\nfunction createLinearGradient(\n  context: IContext2d,\n  color: ILinearGradient,\n  params: { AABBBounds?: IBoundsLike; attribute?: Partial<ITransform> },\n  offsetX: number = 0,\n  offsetY: number = 0\n) {\n  const bounds = params.AABBBounds;\n  if (!bounds) {\n    return;\n  }\n  let w = bounds.x2 - bounds.x1;\n  let h = bounds.y2 - bounds.y1;\n  let x = bounds.x1 - offsetX;\n  let y = bounds.y1 - offsetY;\n  if (params.attribute) {\n    const { scaleX = 1, scaleY = 1 } = params.attribute;\n    if (scaleX * scaleY === 0) {\n      return;\n    }\n    w /= scaleX;\n    h /= scaleY;\n    x /= scaleX;\n    y /= scaleY;\n  }\n\n  const canvasGradient = context.createLinearGradient(\n    x + (color.x0 ?? 0) * w,\n    y + (color.y0 ?? 0) * h,\n    x + (color.x1 ?? 1) * w,\n    y + (color.y1 ?? 0) * h\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n  return canvasGradient;\n}\n\nfunction createRadialGradient(\n  context: IContext2d,\n  color: IRadialGradient,\n  params: { AABBBounds?: IBoundsLike; attribute?: Partial<ITransform> },\n  offsetX: number = 0,\n  offsetY: number = 0\n) {\n  const bounds = params.AABBBounds;\n  if (!bounds) {\n    return;\n  }\n  let w = bounds.x2 - bounds.x1;\n  let h = bounds.y2 - bounds.y1;\n  let x = bounds.x1 - offsetX;\n  let y = bounds.y1 - offsetY;\n  if (params.attribute) {\n    const { scaleX = 1, scaleY = 1 } = params.attribute;\n    if (scaleX * scaleY === 0) {\n      return;\n    }\n    x /= scaleX;\n    y /= scaleY;\n    w /= scaleX;\n    h /= scaleY;\n  }\n  const canvasGradient = context.createRadialGradient(\n    x + (color.x0 ?? 0.5) * w,\n    y + (color.y0 ?? 0.5) * h,\n    Math.max(w, h) * (color.r0 ?? 0),\n    x + (color.x1 ?? 0.5) * w,\n    y + (color.y1 ?? 0.5) * h,\n    Math.max(w, h) * (color.r1 ?? 0.5)\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n  return canvasGradient;\n}\n\nfunction createConicGradient(\n  context: IContext2d,\n  color: IConicalGradient,\n  params: { AABBBounds?: IBoundsLike; attribute?: Partial<ITransform> },\n  offsetX: number = 0,\n  offsetY: number = 0\n) {\n  const bounds = params.AABBBounds;\n  if (!bounds) {\n    return;\n  }\n  let w = bounds.x2 - bounds.x1;\n  let h = bounds.y2 - bounds.y1;\n  let x = bounds.x1 - offsetX;\n  let y = bounds.y1 - offsetY;\n  if (params.attribute) {\n    const { scaleX = 1, scaleY = 1 } = params.attribute;\n    if (scaleX * scaleY === 0) {\n      return;\n    }\n    w /= scaleX;\n    h /= scaleY;\n    x /= scaleX;\n    y /= scaleY;\n  }\n\n  const canvasGradient = context.createConicGradient(\n    x + (color.x ?? 0) * w,\n    y + (color.y ?? 0) * h,\n    color.startAngle,\n    color.endAngle\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n\n  let deltaAngle;\n  return (canvasGradient as any).GetPattern(w + x, h + y, deltaAngle);\n}\n"]}