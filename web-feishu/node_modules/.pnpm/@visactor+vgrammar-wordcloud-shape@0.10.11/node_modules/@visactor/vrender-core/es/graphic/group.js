import { Point } from "@visactor/vutils";

import { application } from "../application";

import { Graphic, NOWORK_ANIMATE_ATTR } from "./graphic";

import { getTheme, Theme } from "./theme";

import { parsePadding } from "../common/utils";

import { UpdateTag, IContainPointMode } from "../common/enums";

import { GROUP_NUMBER_TYPE } from "./constants";

import { DefaultTransform } from "./config";

export var GroupUpdateAABBBoundsMode;

!function(GroupUpdateAABBBoundsMode) {
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", 
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));

export class Group extends Graphic {
    constructor(params) {
        super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = GROUP_NUMBER_TYPE, 
        this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
    }
    setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
        this.in3dMode = !0;
    }
    set2dMode() {
        this.in3dMode = !1;
    }
    setTheme(t) {
        return this.theme || (this.theme = new Theme), this.theme.setTheme(t, this);
    }
    createTheme() {
        this.theme || (this.theme = new Theme);
    }
    hideAll() {
        this.setAttribute("visible", !1), this.forEachChildren((item => {
            item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute("visible", !1);
        }));
    }
    showAll() {
        this.setAttribute("visible", !0), this.forEachChildren((item => {
            item.isContainer && item.showAll ? item.showAll() : item.setAttribute("visible", !0);
        }));
    }
    containsPoint(x, y, mode) {
        if (mode === IContainPointMode.GLOBAL) {
            const point = new Point(x, y);
            return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), 
            this.AABBBounds.contains(point.x, point.y);
        }
        return this.AABBBounds.contains(x, y);
    }
    shouldUpdateAABBBounds() {
        return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
    }
    tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
        return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), 
        bounds;
    }
    doUpdateLocalMatrix() {
        const {x: x = DefaultTransform.x, y: y = DefaultTransform.y, dx: dx = DefaultTransform.dx, dy: dy = DefaultTransform.dy, scaleX: scaleX = DefaultTransform.scaleX, scaleY: scaleY = DefaultTransform.scaleY, angle: angle = DefaultTransform.angle, postMatrix: postMatrix} = this.attribute;
        if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return super.doUpdateLocalMatrix();
        this._transMatrix.reset();
    }
    doUpdateAABBBounds() {
        const attribute = this.attribute, groupTheme = getTheme(this).group;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const bounds = application.graphicService.updateGroupAABBBounds(attribute, groupTheme, this._AABBBounds, this), {boundsPadding: boundsPadding = groupTheme.boundsPadding} = attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), 
        this.clearUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
    }
    clearUpdateBoundTag() {
        this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    addUpdateBoundTag() {
        this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
    }
    addChildUpdateBoundTag() {
        this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, 
        this.parent && this.parent.addChildUpdateBoundTag());
    }
    getTheme() {
        return this.theme.getTheme(this);
    }
    incrementalAppendChild(node) {
        const data = super.appendChild(node);
        return this.stage && data && (data.stage = this.stage, data.layer = this.layer), 
        this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), 
        data;
    }
    incrementalClearChild() {
        super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
    }
    appendChild(node, addStage = !0) {
        const data = super.appendChild(node);
        return addStage && this.stage && data && data.setStage(this.stage, this.layer), 
        this.addUpdateBoundTag(), data;
    }
    insertBefore(newNode, referenceNode) {
        const data = super.insertBefore(newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    insertAfter(newNode, referenceNode) {
        const data = super.insertAfter(newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    insertInto(newNode, idx) {
        const data = super.insertInto(newNode, idx);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    removeChild(child) {
        const data = super.removeChild(child);
        return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), 
        data;
    }
    removeAllChild() {
        this.forEachChildren((child => {
            application.graphicService.onRemove(child);
        })), super.removeAllChild(), this.addUpdateBoundTag();
    }
    setStage(stage, layer) {
        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), 
        this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), 
        this.forEachChildren((item => {
            item.setStage(stage, this.layer);
        })));
    }
    addUpdatePositionTag() {
        super.addUpdatePositionTag(), this.forEachChildren((g => {
            g.isContainer && g.addUpdateGlobalPositionTag();
        }));
    }
    addUpdateGlobalPositionTag() {
        super.addUpdateGlobalPositionTag(), this.forEachChildren((g => {
            g.isContainer && g.addUpdateGlobalPositionTag();
        }));
    }
    tryUpdateGlobalTransMatrix(clearTag = !0) {
        if (this.shouldUpdateGlobalMatrix()) {
            if (this._globalTransMatrix) {
                if (this.parent) {
                    const m = this.parent.globalTransMatrix;
                    this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
                }
            } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
            this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
        return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
    }
    _getChildByName(name, deep) {
        return this.find((node => node.name === name), deep);
    }
    createOrUpdateChild(graphicName, attributes, graphicType) {
        let graphic = this._getChildByName(graphicName);
        return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), 
        graphic.name = graphicName, this.add(graphic)), graphic;
    }
    clone() {
        return new Group(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Group.NOWORK_ANIMATE_ATTR;
    }
}

Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

export function createGroup(attributes) {
    return new Group(attributes);
}
//# sourceMappingURL=group.js.map
