"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FlexLayoutPlugin = void 0;

const graphic_1 = require("../../graphic"), generator_1 = require("../../common/generator"), util_1 = require("../../canvas/util"), utils_1 = require("../../common/utils"), vutils_1 = require("@visactor/vutils"), application_1 = require("../../application"), _tempBounds = new vutils_1.AABBBounds;

class FlexLayoutPlugin {
    constructor() {
        this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this.id, this.tempBounds = new vutils_1.AABBBounds;
    }
    tryLayout(graphic) {
        if (this.layouting) return;
        this.layouting = !0;
        const p = graphic.parent;
        if (!p || !graphic.needUpdateLayout()) return;
        const theme = (0, graphic_1.getTheme)(p).group, {display: display = theme.display} = p.attribute;
        if ("flex" !== display) return;
        const {flexDirection: flexDirection = theme.flexDirection, flexWrap: flexWrap = theme.flexWrap, justifyContent: justifyContent = theme.justifyContent, alignItems: alignItems = theme.alignItems, alignContent: alignContent = theme.alignContent, clip: clip = theme.clip} = p.attribute;
        let childrenWidth = 0, childrenHeight = 0, boundsLegal = 0;
        if (p.forEachChildren((child => {
            const bounds = child.AABBBounds;
            "column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), 
            childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), 
            childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, 
            boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2;
        })), !isFinite(boundsLegal)) return;
        const width = p.attribute.width || childrenWidth, height = p.attribute.height || childrenHeight;
        p.attribute.width || (p.attribute.width = 0), p.attribute.height || (p.attribute.height = 0), 
        this.tempBounds.copy(p._AABBBounds);
        const result = {
            main: {
                len: width,
                field: "x"
            },
            cross: {
                len: height,
                field: "y"
            },
            dir: 1
        }, main = result.main, cross = result.cross;
        "row-reverse" === flexDirection ? result.dir = -1 : "column" === flexDirection ? (main.len = height, 
        cross.len = width, main.field = "y", cross.field = "x") : "column-reverse" === flexDirection && (main.len = height, 
        cross.len = width, main.field = "y", cross.field = "x", result.dir = -1);
        let mainLen = 0, crossLen = 0;
        const mianLenArray = [];
        p.forEachChildren((c => {
            const b = c.AABBBounds, ml = "x" === main.field ? b.width() : b.height(), cl = "x" === cross.field ? b.width() : b.height();
            mianLenArray.push({
                mainLen: ml,
                crossLen: cl
            }), mainLen += ml, crossLen = Math.max(crossLen, cl);
        }));
        const mainList = [];
        if (mainLen > main.len && "wrap" === flexWrap) {
            let tempMainL = 0, tempCrossL = 0;
            mianLenArray.forEach((({mainLen: mainLen, crossLen: crossLen}, i) => {
                tempMainL + mainLen > main.len ? 0 === tempMainL ? (mainList.push({
                    idx: i,
                    mainLen: tempMainL + mainLen,
                    crossLen: crossLen
                }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
                    idx: i - 1,
                    mainLen: tempMainL,
                    crossLen: crossLen
                }), tempMainL = mainLen, tempCrossL = crossLen) : (tempMainL += mainLen, tempCrossL = Math.max(tempCrossL, crossLen));
            })), mainList.push({
                idx: mianLenArray.length - 1,
                mainLen: tempMainL,
                crossLen: tempCrossL
            });
        } else mainList.push({
            idx: mianLenArray.length - 1,
            mainLen: mainLen,
            crossLen: crossLen
        });
        const children = p.getChildren();
        let lastIdx = 0;
        if (mainList.forEach((s => {
            this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s), lastIdx = s.idx + 1;
        })), crossLen = mainList.reduce(((a, b) => a + b.crossLen), 0), 1 === mainList.length) if ("flex-end" === alignItems) {
            const anchorPos = cross.len;
            this.layoutCross(children, alignItems, cross, anchorPos, mianLenArray, mainList[0], 0);
        } else if ("center" === alignItems) {
            const anchorPos = cross.len / 2;
            this.layoutCross(children, alignItems, cross, anchorPos, mianLenArray, mainList[0], 0);
        } else children.forEach((child => {
            child.attribute[cross.field] = getPadding(child, cross.field);
        })); else if ("flex-start" === alignContent) {
            lastIdx = 0;
            let anchorPos = 0;
            mainList.forEach(((s, i) => {
                this.layoutCross(children, "flex-start", cross, anchorPos, mianLenArray, mainList[i], lastIdx), 
                lastIdx = s.idx + 1, anchorPos += s.crossLen;
            }));
        } else if ("center" === alignContent) {
            lastIdx = 0;
            let anchorPos = Math.max(0, (cross.len - crossLen) / 2);
            mainList.forEach(((s, i) => {
                this.layoutCross(children, "center", cross, anchorPos + s.crossLen / 2, mianLenArray, mainList[i], lastIdx), 
                lastIdx = s.idx + 1, anchorPos += s.crossLen;
            }));
        } else if ("space-around" === alignContent) {
            lastIdx = 0;
            const padding = Math.max(0, (cross.len - crossLen) / mainList.length / 2);
            let anchorPos = padding;
            mainList.forEach(((s, i) => {
                this.layoutCross(children, "flex-start", cross, anchorPos, mianLenArray, mainList[i], lastIdx), 
                lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
            }));
        } else if ("space-between" === alignContent) {
            lastIdx = 0;
            const padding = Math.max(0, (cross.len - crossLen) / (2 * mainList.length - 2));
            let anchorPos = 0;
            mainList.forEach(((s, i) => {
                this.layoutCross(children, "flex-start", cross, anchorPos, mianLenArray, mainList[i], lastIdx), 
                lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
            }));
        }
        children.forEach(((child, idx) => {
            child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
        })), p.addUpdateLayoutTag(), clip || this.tempBounds.equals(p.AABBBounds) || (this.tryLayout(p), 
        this.layouting = !1);
    }
    layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
        if ("flex-start" === justifyContent) {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen;
        } else if ("flex-end" === justifyContent) {
            let pos = main.len;
            for (let i = lastIdx; i <= currSeg.idx; i++) pos -= mianLenArray[i].mainLen, children[i].attribute[main.field] = pos + getPadding(children[i], main.field);
        } else if ("space-around" === justifyContent) if (currSeg.mainLen >= main.len) {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen;
        } else {
            const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / size / 2;
            let pos = padding;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen + 2 * padding;
        } else if ("space-between" === justifyContent) if (currSeg.mainLen >= main.len) {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen;
        } else {
            const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / (2 * size - 2);
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen + 2 * padding;
        } else if ("center" === justifyContent) {
            let pos = (main.len - currSeg.mainLen) / 2;
            for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[main.field] = pos + getPadding(children[i], main.field), 
            pos += mianLenArray[i].mainLen;
        }
    }
    layoutCross(children, alignItem, cross, anchorPos, lenArray, currSeg, lastIdx) {
        if ("flex-end" === alignItem) for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[cross.field] = anchorPos - lenArray[i].crossLen + getPadding(children[i], cross.field); else if ("center" === alignItem) for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[cross.field] = anchorPos - lenArray[i].crossLen / 2 + getPadding(children[i], cross.field); else for (let i = lastIdx; i <= currSeg.idx; i++) children[i].attribute[cross.field] = anchorPos + getPadding(children[i], cross.field);
    }
    activate(context) {
        this.pluginService = context, application_1.application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic => {
            graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic), this.layouting = !1;
        })), application_1.application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, ((graphic, stage, willUpdate, bounds) => {
            graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && _tempBounds.copy(bounds);
        })), application_1.application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, ((graphic, stage, bounds, params, selfChange) => {
            stage && stage === this.pluginService.stage && graphic.isContainer && (_tempBounds.equals(bounds) || (this.tryLayout(graphic), 
            this.layouting = !1));
        })), application_1.application.graphicService.hooks.onSetStage.tap(this.key, (graphic => {
            graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic), this.layouting = !1;
        }));
    }
    deactivate(context) {
        application_1.application.graphicService.hooks.onAttributeUpdate.taps = application_1.application.graphicService.hooks.onAttributeUpdate.taps.filter((item => item.name !== this.key)), 
        application_1.application.graphicService.hooks.onSetStage.taps = application_1.application.graphicService.hooks.onSetStage.taps.filter((item => item.name !== this.key));
    }
}

function getPadding(graphic, field) {
    if (!graphic.attribute.boundsPadding) return 0;
    if ((0, util_1.isNumber)(graphic.attribute.boundsPadding)) return graphic.attribute.boundsPadding;
    if ((0, vutils_1.isArray)(graphic.attribute.boundsPadding) && 1 === graphic.attribute.boundsPadding.length) return graphic.attribute.boundsPadding[0];
    const paddingArray = (0, utils_1.parsePadding)(graphic.attribute.boundsPadding);
    return "x" === field ? paddingArray[3] : "y" === field ? paddingArray[0] : 0;
}

exports.FlexLayoutPlugin = FlexLayoutPlugin;
//# sourceMappingURL=flex-layout-plugin.js.map
