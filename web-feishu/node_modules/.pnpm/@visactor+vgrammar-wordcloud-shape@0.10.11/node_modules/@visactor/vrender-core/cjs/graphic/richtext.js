"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createRichText = exports.RichText = void 0;

const graphic_1 = require("./graphic"), config_1 = require("./config"), frame_1 = __importDefault(require("./richtext/frame")), paragraph_1 = __importDefault(require("./richtext/paragraph")), wrapper_1 = __importDefault(require("./richtext/wrapper")), theme_1 = require("./theme"), icon_1 = require("./richtext/icon"), application_1 = require("../application"), utils_1 = require("../common/utils"), constants_1 = require("./constants"), RICHTEXT_UPDATE_TAG_KEY = [ "width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class RichText extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;
    }
    get width() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.width;
    }
    set width(w) {
        this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
    }
    get height() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.height;
    }
    set height(h) {
        this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
    }
    get maxWidth() {
        return this.attribute.maxWidth;
    }
    set maxWidth(mw) {
        this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
    }
    get maxHeight() {
        return this.attribute.maxHeight;
    }
    set maxHeight(mh) {
        this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
    }
    get ellipsis() {
        var _a;
        return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.ellipsis;
    }
    set ellipsis(e) {
        this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
    }
    get wordBreak() {
        var _a;
        return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.wordBreak;
    }
    set wordBreak(wb) {
        this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
    }
    get verticalDirection() {
        var _a;
        return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.verticalDirection;
    }
    set verticalDirection(vd) {
        this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, 
        this.addUpdateShapeAndBoundsTag());
    }
    get textAlign() {
        var _a;
        return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textAlign;
    }
    set textAlign(align) {
        this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
    }
    get textBaseline() {
        var _a;
        return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textBaseline;
    }
    set textBaseline(baseline) {
        this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, 
        this.addUpdateShapeAndBoundsTag());
    }
    get textConfig() {
        var _a;
        return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textConfig;
    }
    set textConfig(config) {
        this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
    }
    doUpdateAABBBounds() {
        const richTextTheme = (0, theme_1.getTheme)(this).richtext;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateRichTextAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).richtext, this._AABBBounds, this), {boundsPadding: boundsPadding = richTextTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return config_1.DefaultRichTextAttribute[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
    }
    getFrameCache() {
        return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), 
        this._frameCache;
    }
    doUpdateFrameCache() {
        var _a;
        const {textConfig: textConfig = [], maxWidth: maxWidth, maxHeight: maxHeight, width: width, height: height, ellipsis: ellipsis, wordBreak: wordBreak, verticalDirection: verticalDirection, textAlign: textAlign, textBaseline: textBaseline, layoutDirection: layoutDirection, singleLine: singleLine} = this.attribute, paragraphs = [];
        for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
            const config = textConfig[i], iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
            if (iconCache) paragraphs.push(iconCache); else {
                const icon = new icon_1.RichTextIcon(config);
                icon.successCallback = () => {
                    var _a;
                    this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
                }, icon.richtextId = config.id, paragraphs.push(icon);
            }
        } else if (textConfig[i].text.includes("\n")) {
            const textParts = textConfig[i].text.split("\n");
            for (let j = 0; j < textParts.length; j++) paragraphs.push(new paragraph_1.default(textParts[j], 0 !== j, textConfig[i]));
        } else paragraphs.push(new paragraph_1.default(textConfig[i].text, !1, textConfig[i]));
        const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0, maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0, richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth), richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight), frameWidth = richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0, frameHeight = richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0, frame = new frame_1.default(0, 0, frameWidth || 0, frameHeight || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new wrapper_1.default(frame);
        for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
        wrapper.send();
        if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
            const frameSize = frame.getActualSizeWidthEllipsis();
            let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
            ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), 
            frame.lines.forEach((function(l) {
                l.calcOffset(offsetSize, !1);
            }));
        }
        this._frameCache = frame;
    }
    clone() {
        return new RichText(Object.assign({}, this.attribute));
    }
    setStage(stage, layer) {
        super.setStage(stage, layer);
        this.getFrameCache().icons.forEach((icon => {
            icon.setStage(stage, layer);
        }));
    }
    bindIconEvent() {
        this.addEventListener("pointermove", (e => {
            var _a, _b, _c, _d, _e;
            const pickedIcon = this.pickIcon(e.global);
            pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), 
            this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), 
            null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), 
            this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), 
            null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame()));
        })), this.addEventListener("pointerleave", (e => {
            var _a, _b;
            this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, 
            null === (_a = this.stage) || void 0 === _a || _a.setCursor(), null === (_b = this.stage) || void 0 === _b || _b.renderNextFrame());
        }));
    }
    pickIcon(point) {
        const frameCache = this.getFrameCache(), {e: x, f: y} = this.globalTransMatrix;
        let pickIcon;
        return frameCache.icons.forEach((icon => {
            var _a, _b;
            icon.AABBBounds.containsPoint({
                x: point.x - x,
                y: point.y - y
            }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x, 
            pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y);
        })), pickIcon;
    }
    getNoWorkAnimateAttr() {
        return RichText.NOWORK_ANIMATE_ATTR;
    }
}

function createRichText(attributes) {
    return new RichText(attributes);
}

exports.RichText = RichText, RichText.NOWORK_ANIMATE_ATTR = Object.assign({
    ellipsis: 1,
    wordBreak: 1,
    verticalDirection: 1,
    textAlign: 1,
    textBaseline: 1,
    textConfig: 1,
    layoutDirection: 1
}, graphic_1.NOWORK_ANIMATE_ATTR), exports.createRichText = createRichText;
//# sourceMappingURL=richtext.js.map
