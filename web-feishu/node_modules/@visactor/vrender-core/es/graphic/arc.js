import { pi2, sin, epsilon, abs, asin, clampAngleByRadian, isNumber, cos, sqrt } from "@visactor/vutils";

import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { CustomPath2D } from "../common/custom-path2d";

import { parsePadding } from "../common/utils";

import { getTheme } from "./theme";

import { application } from "../application";

import { ARC_NUMBER_TYPE } from "./constants";

const ARC_UPDATE_TAG_KEY = [ "innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Arc extends Graphic {
    constructor(params) {
        super(params), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {startAngle: startAngle, endAngle: endAngle, outerRadius: outerRadius, innerRadius: innerRadius} = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
    }
    getParsedCornerRadius() {
        const arcTheme = getTheme(this).arc, {cornerRadius: cornerRadius = arcTheme.cornerRadius, outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute;
        if (0 === cornerRadius || "0%" === cornerRadius) return 0;
        const deltaRadius = Math.abs(outerRadius - innerRadius);
        return Math.min(isNumber(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
    }
    getParsedAngle() {
        const arcTheme = getTheme(this).arc;
        let {startAngle: startAngle = arcTheme.startAngle, endAngle: endAngle = arcTheme.endAngle} = this.attribute;
        const {cap: cap = arcTheme.cap} = this.attribute, sign = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
        if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, 
        cap && abs(deltaAngle) < pi2 - epsilon) {
            let startCap = 1, endCap = 1;
            cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
            const {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute, capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
            if (capWidth > epsilon && outerRadius > epsilon) return {
                startAngle: startAngle - sign * capAngle * startCap,
                endAngle: endAngle + sign * capAngle * endCap,
                sc: sign * capAngle * startCap,
                ec: sign * capAngle * endCap
            };
        }
        return {
            startAngle: startAngle,
            endAngle: endAngle
        };
    }
    getParsePadAngle(startAngle, endAngle) {
        const arcTheme = getTheme(this).arc, {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius, padAngle: padAngle = arcTheme.padAngle} = this.attribute, {padRadius: padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius)} = this.attribute, deltaAngle = abs(endAngle - startAngle);
        let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
        const halfPadAngle = padAngle / 2;
        let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
        if (halfPadAngle > epsilon && padRadius > epsilon) {
            const sign = endAngle > startAngle ? 1 : -1;
            let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)), p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
            return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, 
            innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), 
            (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, 
            outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
                outerStartAngle: outerStartAngle,
                outerEndAngle: outerEndAngle,
                innerStartAngle: innerStartAngle,
                innerEndAngle: innerEndAngle,
                innerDeltaAngle: innerDeltaAngle,
                outerDeltaAngle: outerDeltaAngle
            };
        }
        return {
            outerStartAngle: outerStartAngle,
            outerEndAngle: outerEndAngle,
            innerStartAngle: innerStartAngle,
            innerEndAngle: innerEndAngle,
            innerDeltaAngle: innerDeltaAngle,
            outerDeltaAngle: outerDeltaAngle
        };
    }
    doUpdateAABBBounds(full) {
        const arcTheme = getTheme(this).arc;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application.graphicService.updateArcAABBBounds(attribute, getTheme(this).arc, this._AABBBounds, full, this), {boundsPadding: boundsPadding = arcTheme.boundsPadding} = attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
    }
    getDefaultAttribute(name) {
        return getTheme(this).arc[name];
    }
    toCustomPath() {
        const attribute = this.attribute, {startAngle: startAngle, endAngle: endAngle} = this.getParsedAngle();
        let innerRadius = attribute.innerRadius, outerRadius = attribute.outerRadius;
        const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius, innerRadius = temp;
        }
        const path = new CustomPath2D;
        if (outerRadius <= epsilon) path.moveTo(0, 0); else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), 
        path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), 
        path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise)); else {
            const xors = outerRadius * cos(startAngle), yors = outerRadius * sin(startAngle), xire = innerRadius * cos(endAngle), yire = innerRadius * sin(endAngle);
            path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), 
            path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), 
            path.closePath();
        }
        return path;
    }
    clone() {
        return new Arc(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Arc.NOWORK_ANIMATE_ATTR;
    }
}

Arc.NOWORK_ANIMATE_ATTR = Object.assign({
    cap: 1
}, NOWORK_ANIMATE_ATTR);

export function createArc(attributes) {
    return new Arc(attributes);
}
//# sourceMappingURL=arc.js.map
