import { isString, isNil } from "@visactor/vutils";

import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { parsePadding } from "../common/utils";

import { CustomPath2D } from "../common/custom-path2d";

import { getTheme } from "./theme";

import { application } from "../application";

import { PATH_NUMBER_TYPE } from "./constants";

const PATH_UPDATE_TAG_KEY = [ "path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Path extends Graphic {
    constructor(params) {
        super(params), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
    }
    get pathShape() {
        return this.tryUpdateAABBBounds(), this.getParsedPathShape();
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {path: path} = this.attribute;
        return null != path && "" !== path;
    }
    getParsedPathShape() {
        const pathTheme = getTheme(this).path;
        if (!this.valid) return pathTheme.path;
        const attribute = this.attribute;
        return attribute.path instanceof CustomPath2D ? attribute.path : (isNil(this.cache) && this.doUpdatePathShape(), 
        this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
    }
    doUpdateAABBBounds() {
        const pathTheme = getTheme(this).path;
        this.doUpdatePathShape(), this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application.graphicService.updatePathAABBBounds(attribute, getTheme(this).path, this._AABBBounds, this), {boundsPadding: boundsPadding = pathTheme.boundsPadding} = attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    doUpdatePathShape() {
        const attribute = this.attribute;
        isString(attribute.path, !0) ? this.cache = (new CustomPath2D).fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D, 
        attribute.customPath(this.cache, this));
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return getTheme(this).path[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        return (new CustomPath2D).fromCustomPath2D(this.getParsedPathShape(), 0, 0);
    }
    clone() {
        return new Path(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Path.NOWORK_ANIMATE_ATTR;
    }
}

Path.NOWORK_ANIMATE_ATTR = Object.assign({
    path: 1,
    customPath: 1
}, NOWORK_ANIMATE_ATTR);

export function createPath(attributes) {
    return new Path(attributes);
}
//# sourceMappingURL=path.js.map
