"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SymlogScale = void 0;

const linear_scale_1 = require("./linear-scale"), type_1 = require("./type"), tick_sample_1 = require("./utils/tick-sample"), utils_1 = require("./utils/utils");

class SymlogScale extends linear_scale_1.LinearScale {
    constructor() {
        super((0, utils_1.symlog)(1), (0, utils_1.symexp)(1)), this.type = type_1.ScaleEnum.Symlog, 
        this._const = 1;
    }
    clone() {
        return (new SymlogScale).domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).constant(this._const);
    }
    constant(_, slience) {
        return arguments.length ? (this._const = _, this.transformer = (0, utils_1.symlog)(_), 
        this.untransformer = (0, utils_1.symexp)(_), this.rescale(slience)) : this._const;
    }
    d3Ticks(count = 10, options) {
        const d = this.domain(), u = d[0], v = d[d.length - 1];
        return (0, tick_sample_1.d3TicksForLog)(u, v, count, this._const, this.transformer, this.untransformer, options);
    }
    ticks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.ticksBaseTransform)(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
    }
    forceTicks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.forceTicksBaseTransform)(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
    }
    stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.forceTicksBaseTransform)(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
    }
    nice(count = 10, option) {
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [], niceType = null;
        if (option) {
            const res = (0, tick_sample_1.parseNiceOptions)(originalDomain, option);
            if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, 
            res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else niceType = "all";
        if (niceType) {
            const niceDomain = (0, utils_1.nice)(originalDomain.slice(), {
                floor: x => Math.floor(x),
                ceil: x => Math.ceil(x)
            });
            return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), 
            this._niceDomain = niceDomain, this.rescale(), this;
        }
        return this;
    }
    niceMin() {
        const maxD = this._domain[this._domain.length - 1];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, 
        this.rescale()), this;
    }
    niceMax() {
        const minD = this._domain[0];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), 
        this;
    }
}

exports.SymlogScale = SymlogScale;
//# sourceMappingURL=symlog-scale.js.map