import { degreeToRadian, isFunction, isNil, merge } from "@visactor/vutils";

import { getShapeFunction } from "./shapes";

import { functor, randomHslColor } from "./util";

export class BaseLayout {
    constructor(options) {
        var _a, _b;
        switch (this.options = merge({}, BaseLayout.defaultOptions, options), isFunction(this.options.shape) ? this.shape = this.options.shape : this.shape = getShapeFunction(this.options.shape), 
        this.getText = null !== (_a = functor(this.options.text)) && void 0 !== _a ? _a : d => d, 
        this.getTextFontWeight = functor(this.options.fontWeight), this.getTextFontSize = functor(this.options.fontSize), 
        this.getTextFontStyle = functor(this.options.fontStyle), this.getTextFontFamily = functor(this.options.fontFamily), 
        this.outputCallback = null !== (_b = this.options.outputCallback) && void 0 !== _b ? _b : res => res, 
        this.options.color) {
          case "random-dark":
            this.getTextColor = () => randomHslColor(10, 50);
            break;

          case "random-light":
            this.getTextColor = () => randomHslColor(50, 90);
            break;

          default:
            this.getTextColor = functor(this.options.color);
        }
        if (isNil(this.options.rotate)) if (this.options.useRandomRotate) {
            const rotationRange = Math.abs(this.options.maxRotation - this.options.minRotation), rotationSteps = Math.abs(Math.floor(this.options.rotationSteps)), minRotation = Math.min(this.options.maxRotation, this.options.minRotation);
            this.getTextRotate = () => 0 === this.options.rotateRatio || Math.random() > this.options.rotateRatio ? 0 : 0 === rotationRange ? minRotation : rotationSteps > 0 ? minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1) : minRotation + Math.random() * rotationRange;
        } else this.getTextRotate = () => 0; else this.getTextRotate = isFunction(this.options.rotate) ? d => {
            var _a;
            return degreeToRadian(null !== (_a = this.options.rotate(d)) && void 0 !== _a ? _a : 0);
        } : () => {
            var _a;
            return degreeToRadian(null !== (_a = this.options.rotate) && void 0 !== _a ? _a : 0);
        };
    }
    exceedTime() {
        var _a;
        return this.options.progressiveStep > 0 ? this.progressiveIndex >= ((null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : 0) + 1) * this.options.progressiveStep : this.options.progressiveTime > 0 && (new Date).getTime() - this.escapeTime > this.options.progressiveTime;
    }
    progressiveRun() {
        var _a;
        if (this.options.progressiveStep > 0 ? this.currentStepIndex = (null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : 0) + 1 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), 
        this.data && this.progressiveIndex && this.progressiveIndex < this.data.length) {
            this.progressiveResult = [];
            const len = this.data.length;
            let i = this.progressiveIndex;
            for (;i < len; ) {
                this.layoutWord(i);
                if (i++, this.progressiveIndex = i, this.exceedTime()) break;
            }
            return this.progressiveResult;
        }
        return this.result;
    }
    initProgressive() {
        this.progressiveIndex = -1, this.options.progressiveStep > 0 ? this.currentStepIndex = 0 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), 
        this.progressiveResult = [];
    }
    output() {
        return this.result ? this.outputCallback(this.result) : null;
    }
    progressiveOutput() {
        return this.progressiveResult ? this.outputCallback(this.progressiveResult) : null;
    }
    unfinished() {
        return this.data && this.data.length && !isNil(this.progressiveIndex) && this.progressiveIndex < this.data.length;
    }
    release() {
        this.data = null, this.result = null, this.progressiveIndex = null, this.progressiveResult = null;
    }
}

BaseLayout.defaultOptions = {
    fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", "Arial Unicode MS", "Droid Fallback Sans", sans-serif',
    fontWeight: "normal",
    color: "random-dark",
    fontStyle: "normal",
    minFontSize: 12,
    drawOutOfBound: !1,
    shrink: !1,
    minRotation: -Math.PI / 2,
    maxRotation: Math.PI / 2,
    rotationSteps: 0,
    rotateRatio: .1,
    random: !1,
    shape: "circle",
    progressiveTime: 0,
    progressiveStep: 0,
    backgroundColor: "#fff"
};