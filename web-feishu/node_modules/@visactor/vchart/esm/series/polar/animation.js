import { ACustomAnimate, TagPointsUpdate } from "@visactor/vrender-core";

import { Point, isFunction, isValidNumber } from "@visactor/vutils";

export class PolarPointUpdate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        const pointToCoord = this.params.pointToCoord, coordToPoint = this.params.coordToPoint;
        isFunction(pointToCoord) && isFunction(coordToPoint) || (this.valid = !1), this._pointToCoord = pointToCoord, 
        this._coordToPoint = coordToPoint;
    }
    getEndProps() {
        return !1 === this.valid ? {} : this._coordToPoint({
            angle: this._toAngle,
            radius: this._toRadius
        });
    }
    onBind() {
        const {angle: fromAngle, radius: fromRadius} = this._pointToCoord(this.from);
        isValidNumber(fromAngle * fromRadius) || (this.valid = !1), this._fromAngle = fromAngle, 
        this._fromRadius = fromRadius;
        const {angle: toAngle, radius: toRadius} = this._pointToCoord(this.to);
        isValidNumber(toAngle * toRadius) || (this.valid = !1), this._toAngle = toAngle, 
        this._toRadius = toRadius;
    }
    onUpdate(end, ratio, out) {
        if (!1 !== this.valid) if (end) {
            const {x: x, y: y} = this.getEndProps();
            out.x = x, out.y = y;
        } else {
            const {x: x, y: y} = this._coordToPoint({
                angle: this._fromAngle + (this._toAngle - this._fromAngle) * ratio,
                radius: this._fromRadius + (this._toRadius - this._fromRadius) * ratio
            });
            out.x = x, out.y = y;
        }
    }
}

export class PolarTagPointsUpdate extends TagPointsUpdate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        const pointToCoord = this.params.pointToCoord, coordToPoint = this.params.coordToPoint;
        this._pointToCoord = pointToCoord, this._coordToPoint = coordToPoint;
    }
    onUpdate(end, ratio, out) {
        this.points = this.points.map(((point, index) => {
            const newPoint = this.polarPointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
            return newPoint.context = point.context, newPoint;
        })), out.points = this.points;
    }
    polarPointInterpolation(pointA, pointB, ratio) {
        const polarPointA0 = this._pointToCoord(pointA), polarPointA1 = this._pointToCoord({
            x: pointA.x1,
            y: pointA.y1
        }), polarPointB0 = this._pointToCoord(pointB), polarPointB1 = this._pointToCoord({
            x: pointB.x1,
            y: pointB.y1
        }), angle0 = polarPointA0.angle + (polarPointB0.angle - polarPointA0.angle) * ratio, radius0 = polarPointA0.radius + (polarPointB0.radius - polarPointA0.radius) * ratio, angle1 = polarPointA1.angle + (polarPointB1.angle - polarPointA1.angle) * ratio, radius1 = polarPointA1.radius + (polarPointB1.radius - polarPointA1.radius) * ratio, {x: x, y: y} = this._coordToPoint({
            angle: angle0,
            radius: radius0
        }), {x: x1, y: y1} = this._coordToPoint({
            angle: angle1,
            radius: radius1
        }), point = new Point(x, y, x1, y1);
        return point.defined = pointB.defined, point;
    }
}
//# sourceMappingURL=animation.js.map
