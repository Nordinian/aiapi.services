import { BaseSeriesTooltipHelper } from "../base/tooltip-helper";

import { TimeUtil } from "../../component/axis/cartesian/util/time";

import { isValid } from "@visactor/vutils";

export class DotSeriesTooltipHelper extends BaseSeriesTooltipHelper {
    updateTooltipSpec() {
        var _a;
        super.updateTooltipSpec(), isValid(null === (_a = this.spec) || void 0 === _a ? void 0 : _a.mark) && (this.spec.mark.updateContent = (prev, datum, params) => {
            const childrenContent = [], childrenPrev = prev.filter((p => "children" === p.key));
            return childrenPrev.length > 0 && childrenPrev[0].value.forEach((element => {
                let flag = !0;
                for (const key in element) childrenContent.push({
                    shapeType: "circle",
                    hasShape: flag,
                    shapeColor: this.contentShapeColorCallback(datum[0].datum[0]),
                    shapeStroke: this.contentShapeColorCallback(datum[0].datum[0]),
                    key: key,
                    value: element[key] + ""
                }), flag = !1;
            })), prev.concat(childrenContent);
        });
    }
    getDefaultTooltipPattern(activeType) {
        return "mark" === activeType ? {
            visible: !0,
            activeType: activeType,
            title: {
                key: "event info",
                value: "event info"
            },
            content: [ {
                hasShape: !0,
                shapeType: "square",
                shapeColor: this.contentShapeColorCallback,
                shapeStroke: this.contentShapeColorCallback,
                key: datum => datum.type,
                value: datum => datum.id
            }, {
                hasShape: !0,
                shapeType: "square",
                shapeColor: this.contentShapeColorCallback,
                shapeStroke: this.contentShapeColorCallback,
                key: "event_time",
                value: datum => TimeUtil.getInstance().timeFormat("%Y%m%d", datum.event_time)
            }, {
                hasShape: !0,
                shapeType: "square",
                shapeColor: this.contentShapeColorCallback,
                shapeStroke: this.contentShapeColorCallback,
                key: "action_type",
                value: datum => datum.action_type
            }, {
                shapeType: "square",
                hasShape: !0,
                shapeColor: this.contentShapeColorCallback,
                shapeStroke: this.contentShapeColorCallback,
                key: "children",
                value: datum => datum.children
            } ],
            updateContent: (prev, datum, params) => {
                const childrenContent = [];
                return prev[3].value.forEach((element => {
                    let flag = !0;
                    for (const key in element) childrenContent.push({
                        shapeType: "circle",
                        hasShape: flag,
                        shapeColor: this.contentShapeColorCallback(datum[0].datum[0]),
                        shapeStroke: this.contentShapeColorCallback(datum[0].datum[0]),
                        key: key,
                        value: element[key] + ""
                    }), flag = !1;
                })), prev.concat(childrenContent);
            }
        } : null;
    }
}
//# sourceMappingURL=tooltip-helper.js.map
