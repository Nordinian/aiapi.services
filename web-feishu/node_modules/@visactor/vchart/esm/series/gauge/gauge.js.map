{"version":3,"sources":["../src/series/gauge/gauge.ts"],"names":[],"mappings":"AAEA,OAAO,EAAsB,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEvE,OAAO,EAAE,kBAAkB,EAAE,MAAM,sCAAsC,CAAC;AAE1E,OAAO,EAAE,gCAAgC,EAAE,MAAM,qBAAqB,CAAC;AACvE,OAAO,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;AAIxE,OAAO,EAAE,eAAe,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAE7E,OAAO,EAAmB,uBAAuB,EAAE,MAAM,yBAAyB,CAAC;AACnF,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAC7C,OAAO,EAAE,cAAc,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAC;AAC3D,OAAO,EAAE,OAAO,EAAE,MAAM,oBAAoB,CAAC;AAC7C,OAAO,EAAE,6BAA6B,EAAE,MAAM,wBAAwB,CAAC;AAEvE,OAAO,EAAE,0BAA0B,EAAE,MAAM,qBAAqB,CAAC;AAEjE,MAAM,OAAO,WAA2D,SAAQ,kBAAqB;IAArG;;QAEE,SAAI,GAAG,cAAc,CAAC,KAAK,CAAC;QAInB,2BAAsB,GAAG,0BAA0B,CAAC;QAErD,iBAAY,GAA4B,IAAI,CAAC;QAC7C,eAAU,GAA4B,IAAI,CAAC;QAEzC,WAAM,GAAY,KAAK,CAAC;QACxB,cAAS,GAAW,CAAC,CAAC;IAqJlC,CAAC;IAnJC,eAAe;;QACb,KAAK,CAAC,eAAe,EAAE,CAAC;QACxB,IAAI,CAAC,SAAS,GAAG,cAAc,CAAC,MAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,mCAAI,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,QAAQ;;QACN,KAAK,CAAC,QAAQ,EAAE,CAAC;QAKjB,MAAM,YAAY,GAAG,CAAC,IAAa,EAAE,EAAU,EAAE,EAAE;YAEjD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;YACjC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5E,WAAW,CAAC,OAAO,CAAC,CAAC,KAAU,EAAE,CAAC,EAAE,EAAE;gBACpC,KAAK,CAAC,iBAAiB,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtD,IAAI,CAAC,GAAG,CAAC,EAAE;oBACT,KAAK,CAAC,mBAAmB,CAAC,GAAG,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC;iBACpE;qBAAM;oBACL,KAAK,CAAC,mBAAmB,CAAC,GAAG,SAAS,CAAC;iBACxC;YACH,CAAC,CAAC,CAAC;YACH,OAAO,WAAW,CAAC;QACrB,CAAC,CAAC;QAEF,gCAAgC,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;QACrF,MAAA,IAAI,CAAC,WAAW,EAAE,0CAAE,SAAS,CAC3B;YACE,IAAI,EAAE,cAAc;SACrB,EACD,KAAK,CACN,CAAC;IACJ,CAAC;IAED,QAAQ;QACN,KAAK,CAAC,QAAQ,EAAE,CAAC;QACjB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,EAAE;YACzD,MAAM,EAAE,IAAI,CAAC,aAAa;YAC1B,QAAQ,EAAE,KAAK;SAChB,CAAqB,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE;YAC7D,MAAM,EAAE,IAAI,CAAC,aAAa;YAC1B,YAAY,EAAE,IAAI;SACnB,CAAqB,CAAC;IACzB,CAAC;IAED,aAAa;QACX,KAAK,CAAC,aAAa,EAAE,CAAC;QACtB,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC9B,CAAC;IAEO,oBAAoB;;QAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,WAAW,EAAE;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE;gBAC7B,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;gBACxC,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;gBACxC,UAAU,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC/C,QAAQ,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC3C,WAAW,EAAE,GAAG,EAAE,WAAC,OAAA,IAAI,CAAC,oBAAoB,EAAE,GAAG,CAAC,MAAA,IAAI,CAAC,KAAK,CAAC,WAAW,mCAAI,CAAC,CAAC,CAAA,EAAA;gBAC9E,WAAW,EAAE,GAAG,EAAE,eAAC,OAAA,IAAI,CAAC,oBAAoB,EAAE,GAAG,CAAC,MAAA,MAAA,IAAI,CAAC,KAAK,CAAC,MAAM,mCAAI,IAAI,CAAC,KAAK,CAAC,WAAW,mCAAI,CAAC,CAAC,CAAA,EAAA;gBACnG,GAAG,EAAE,MAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,mCAAI,KAAK;gBACjC,UAAU,EAAE,WAAW;gBACvB,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY;gBACrC,IAAI,EAAE,IAAI,CAAC,iBAAiB,EAAE;gBAC9B,MAAM,EAAE,GAAG;gBAIX,YAAY,EAAE,IAAI;aACnB,CAAC,CAAC;YACH,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;SACzC;IACH,CAAC;IAES,WAAW;QACnB,KAAK,CAAC,WAAW,EAAE,CAAC;QAEpB,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACxF,CAAC;IAEO,kBAAkB;;QACxB,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,IAAI,SAAS,EAAE;YACb,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC3B,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;gBACxC,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;gBACxC,UAAU,EAAE,IAAI,CAAC,WAAW;gBAC5B,QAAQ,EAAE,IAAI,CAAC,SAAS;gBACxB,WAAW,EAAE,GAAG,EAAE,WAAC,OAAA,IAAI,CAAC,oBAAoB,EAAE,GAAG,CAAC,MAAA,IAAI,CAAC,KAAK,CAAC,WAAW,mCAAI,CAAC,CAAC,CAAA,EAAA;gBAC9E,WAAW,EAAE,GAAG,EAAE,eAAC,OAAA,IAAI,CAAC,oBAAoB,EAAE,GAAG,CAAC,MAAA,MAAA,IAAI,CAAC,KAAK,CAAC,MAAM,mCAAI,IAAI,CAAC,KAAK,CAAC,WAAW,mCAAI,CAAC,CAAC,CAAA,EAAA;gBACnG,GAAG,EAAE,MAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,mCAAI,KAAK;gBACjC,UAAU,EAAE,WAAW;gBACvB,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY;gBACrC,MAAM,EAAE,GAAG;aACZ,CAAC,CAAC;YACH,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SACvC;IACH,CAAC;IAES,8BAA8B,CAAC,KAAY;QACnD,MAAM,UAAU,GAAG,IAAI,CAAC,kCAAkC,CAAC,KAAK,CAAC,CAAC;QAClE,MAAM,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,KAAK,CAAC,CAAC;QAC9D,OAAO,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE,CAAC,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;IAChF,CAAC;IAES,4BAA4B,CAAC,KAAY;QACjD,MAAM,UAAU,GAAG,IAAI,CAAC,kCAAkC,CAAC,KAAK,CAAC,CAAC;QAClE,MAAM,QAAQ,GAAG,IAAI,CAAC,gCAAgC,CAAC,KAAK,CAAC,CAAC;QAC9D,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE,CAAC,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9E,CAAC;IAES,kCAAkC,CAAC,KAAY;QACvD,OAAO,OAAO,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;YACxC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;YACnE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;IACvB,CAAC;IAES,gCAAgC,CAAC,KAAY;QACrD,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;IACzE,CAAC;IAED,aAAa;;QACX,MAAM,YAAY,GAAG,MAAC,MAAA,IAAI,CAAC,KAAK,0CAAE,eAA0C,0CAAE,MAAM,CAAC;QAErF,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAClC,eAAe,CACb,MAAA,OAAO,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,0CAC3C;YACE,UAAU,EAAE,IAAI,CAAC,WAAW;SAC7B,EACD,YAAY,CACb,EACD,mBAAmB,YAA6B,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,qBAAqB,CAAC,CACxF,CACF,CAAC;IACJ,CAAC;IAED,mBAAmB;QACjB,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,cAAc;QACZ,OAAO,EAAE,CAAC;IACZ,CAAC;;AA/Je,gBAAI,GAAW,cAAc,CAAC,KAAK,CAAC;AAGpC,gBAAI,GAAkB,eAAe,CAAC;AACtC,kCAAsB,GAAG,0BAAiC,CAAC;AA8J7E,MAAM,CAAC,MAAM,mBAAmB,GAAG,GAAG,EAAE;IACtC,uBAAuB,EAAE,CAAC;IAC1B,6BAA6B,EAAE,CAAC;IAChC,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;AACxD,CAAC,CAAC","file":"gauge.js","sourcesContent":["import type { SeriesMarkMap } from '../interface';\n// eslint-disable-next-line no-duplicate-imports\nimport { SeriesMarkNameEnum, SeriesTypeEnum } from '../interface/type';\nimport type { IGaugeSeriesSpec, IGaugeSeriesTheme } from './interface';\nimport { ProgressLikeSeries } from '../polar/progress-like/progress-like';\nimport type { IProgressArcMark } from '../../mark/progress-arc';\nimport { registerDataSetInstanceTransform } from '../../data/register';\nimport { SEGMENT_FIELD_END, SEGMENT_FIELD_START } from '../../constant';\nimport type { Datum } from '@visactor/vgrammar-core';\nimport type { Maybe } from '../../typings';\nimport type { IStateAnimateSpec } from '../../animation/spec';\nimport { animationConfig, userAnimationConfig } from '../../animation/utils';\n// eslint-disable-next-line no-duplicate-imports\nimport { ProgressArcMark, registerProgressArcMark } from '../../mark/progress-arc';\nimport { gaugeSeriesMark } from './constant';\nimport { degreeToRadian, isValid } from '@visactor/vutils';\nimport { Factory } from '../../core/factory';\nimport { registerProgressLikeAnimation } from '../polar/progress-like';\nimport type { IMark } from '../../mark/interface';\nimport { GaugeSeriesSpecTransformer } from './gauge-transformer';\n\nexport class GaugeSeries<T extends IGaugeSeriesSpec = IGaugeSeriesSpec> extends ProgressLikeSeries<T> {\n  static readonly type: string = SeriesTypeEnum.gauge;\n  type = SeriesTypeEnum.gauge;\n\n  static readonly mark: SeriesMarkMap = gaugeSeriesMark;\n  static readonly transformerConstructor = GaugeSeriesSpecTransformer as any;\n  readonly transformerConstructor = GaugeSeriesSpecTransformer;\n\n  private _segmentMark: IProgressArcMark | null = null;\n  private _trackMark: IProgressArcMark | null = null;\n\n  protected _stack: boolean = false;\n  protected _padAngle: number = 0;\n\n  setAttrFromSpec(): void {\n    super.setAttrFromSpec();\n    this._padAngle = degreeToRadian(this._spec.padAngle ?? 0);\n  }\n\n  initData(): void {\n    super.initData();\n\n    /**\n     * @description 将数据排序并调整图元的起始点为上一个数据的终点，但是终点维持不变\n     */\n    const spiltSegment = (data: Datum[], op: string) => {\n      // 数据处理\n      const dataCollect = data.slice();\n      dataCollect.sort((a, b) => a[this._angleField[0]] - b[this._angleField[0]]);\n      dataCollect.forEach((datum: any, i) => {\n        datum[SEGMENT_FIELD_END] = datum[this._angleField[0]];\n        if (i > 0) {\n          datum[SEGMENT_FIELD_START] = dataCollect[i - 1][SEGMENT_FIELD_END];\n        } else {\n          datum[SEGMENT_FIELD_START] = undefined;\n        }\n      });\n      return dataCollect;\n    };\n\n    registerDataSetInstanceTransform(this._option.dataSet, 'spiltSegment', spiltSegment);\n    this.getViewData()?.transform(\n      {\n        type: 'spiltSegment'\n      },\n      false\n    );\n  }\n\n  initMark(): void {\n    super.initMark();\n    this._trackMark = this._createMark(GaugeSeries.mark.track, {\n      parent: this._arcGroupMark,\n      dataView: false\n    }) as IProgressArcMark;\n    this._segmentMark = this._createMark(GaugeSeries.mark.segment, {\n      parent: this._arcGroupMark,\n      isSeriesMark: true\n    }) as IProgressArcMark;\n  }\n\n  initMarkStyle(): void {\n    super.initMarkStyle();\n    this.initTrackMarkStyle();\n    this.initSegmentMarkStyle();\n  }\n\n  private initSegmentMarkStyle() {\n    const segmentMark = this._segmentMark;\n    if (segmentMark) {\n      this.setMarkStyle(segmentMark, {\n        x: () => this.angleAxisHelper.center().x,\n        y: () => this.angleAxisHelper.center().y,\n        startAngle: this._getAngleValueStart.bind(this),\n        endAngle: this._getAngleValueEnd.bind(this),\n        innerRadius: () => this._computeLayoutRadius() * (this._spec.innerRadius ?? 0),\n        outerRadius: () => this._computeLayoutRadius() * (this._spec.radius ?? this._spec.outerRadius ?? 1), // 需要优先兼容this._spec.radius\n        cap: this._spec.roundCap ?? false,\n        boundsMode: 'imprecise',\n        cornerRadius: this._spec.cornerRadius,\n        fill: this.getColorAttribute(),\n        zIndex: 200,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        // forceShowCap 是内部属性，不在接口中暴露\n        forceShowCap: true\n      });\n      this._trigger.registerMark(segmentMark);\n    }\n  }\n\n  protected initTooltip() {\n    super.initTooltip();\n\n    this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);\n  }\n\n  private initTrackMarkStyle() {\n    const trackMark = this._trackMark;\n    if (trackMark) {\n      this.setMarkStyle(trackMark, {\n        x: () => this.angleAxisHelper.center().x,\n        y: () => this.angleAxisHelper.center().y,\n        startAngle: this._startAngle,\n        endAngle: this._endAngle,\n        innerRadius: () => this._computeLayoutRadius() * (this._spec.innerRadius ?? 0),\n        outerRadius: () => this._computeLayoutRadius() * (this._spec.radius ?? this._spec.outerRadius ?? 1), // 需要优先兼容this._spec.radius\n        cap: this._spec.roundCap ?? false,\n        boundsMode: 'imprecise',\n        cornerRadius: this._spec.cornerRadius,\n        zIndex: 100\n      });\n      this._trigger.registerMark(trackMark);\n    }\n  }\n\n  protected _getAngleValueStartWithoutMask(datum: Datum) {\n    const startAngle = this._getAngleValueStartWithoutPadAngle(datum);\n    const endAngle = this._getAngleValueEndWithoutPadAngle(datum);\n    return Math.min(startAngle + this._padAngle / 2, (startAngle + endAngle) / 2);\n  }\n\n  protected _getAngleValueEndWithoutMask(datum: Datum) {\n    const startAngle = this._getAngleValueStartWithoutPadAngle(datum);\n    const endAngle = this._getAngleValueEndWithoutPadAngle(datum);\n    return Math.max(endAngle - this._padAngle / 2, (startAngle + endAngle) / 2);\n  }\n\n  protected _getAngleValueStartWithoutPadAngle(datum: Datum) {\n    return isValid(datum[SEGMENT_FIELD_START])\n      ? this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_START]])\n      : this._startAngle;\n  }\n\n  protected _getAngleValueEndWithoutPadAngle(datum: Datum) {\n    return this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_END]]);\n  }\n\n  initAnimation() {\n    const appearPreset = (this._spec?.animationAppear as IStateAnimateSpec<any>)?.preset;\n\n    this._segmentMark.setAnimationConfig(\n      animationConfig(\n        Factory.getAnimationInKey('circularProgress')?.(\n          {\n            startAngle: this._startAngle\n          },\n          appearPreset\n        ),\n        userAnimationConfig(SeriesMarkNameEnum.segment, this._spec, this._markAttributeContext)\n      )\n    );\n  }\n\n  getDefaultShapeType() {\n    return 'circle';\n  }\n\n  getActiveMarks(): IMark[] {\n    return [];\n  }\n}\n\nexport const registerGaugeSeries = () => {\n  registerProgressArcMark();\n  registerProgressLikeAnimation();\n  Factory.registerSeries(GaugeSeries.type, GaugeSeries);\n};\n"]}