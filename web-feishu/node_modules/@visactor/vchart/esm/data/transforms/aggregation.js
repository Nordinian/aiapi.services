import { isArray, isFunction, isPlainObject, isValid } from "@visactor/vutils";

import { variance, average, min, max, sum, standardDeviation, median } from "../../util/math";

export const markerMin = (_data, opt) => {
    const data = _data[0].latestData;
    return min(data, opt.field);
};

export const markerMax = (_data, opt) => {
    const data = _data[0].latestData;
    return max(data, opt.field);
};

export function markerSum(_data, opt) {
    const data = _data[0].latestData;
    return sum(data, opt.field);
}

export function markerAverage(_data, opt) {
    const data = _data[0].latestData;
    return average(data, opt.field);
}

export function markerVariance(_data, opt) {
    const data = _data[0].latestData;
    return variance(data, opt.field);
}

export function markerStandardDeviation(_data, opt) {
    const data = _data[0].latestData;
    return standardDeviation(data, opt.field);
}

export function markerMedian(_data, opt) {
    const data = _data[0].latestData;
    return median(data, opt.field);
}

export function markerAggregation(_data, options) {
    const results = [];
    return options.forEach((option => {
        const result = {
            x: null,
            y: null
        };
        if (isValid(option.x)) {
            const x = option.x;
            isArray(x) ? result.x = x.map((item => getFinalValue(item, _data, option))) : result.x = getFinalValue(x, _data, option);
        }
        if (isValid(option.y)) {
            const y = option.y;
            isArray(y) ? result.y = y.map((item => getFinalValue(item, _data, option))) : result.y = getFinalValue(y, _data, option);
        }
        option.getRefRelativeSeries && (result.getRefRelativeSeries = option.getRefRelativeSeries), 
        results.push(result);
    })), results;
}

const aggrMap = {
    min: markerMin,
    max: markerMax,
    sum: markerSum,
    average: markerAverage,
    variance: markerVariance,
    standardDeviation: markerStandardDeviation,
    median: markerMedian
};

function getFinalValue(source, _data, option) {
    const relativeSeries = option.getRelativeSeries(), startSeries = option.getStartRelativeSeries(), endSeries = option.getEndRelativeSeries(), relativeSeriesData = relativeSeries.getData().getLatestData(), startRelativeSeriesData = startSeries.getData().getLatestData(), endRelativeSeriesData = endSeries.getData().getLatestData();
    if (isFunction(source)) return source(relativeSeriesData, startRelativeSeriesData, endRelativeSeriesData, relativeSeries, startSeries, endSeries);
    if (isPlainObject(source)) {
        const {aggrType: aggrType, field: field} = source;
        return aggrMap[aggrType](_data, {
            field: field
        });
    }
    return source;
}
//# sourceMappingURL=aggregation.js.map
