"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CartesianChartSpecTransformer = void 0;

const util_1 = require("../../util"), base_1 = require("../base"), util_2 = require("../util");

class CartesianChartSpecTransformer extends base_1.BaseChartSpecTransformer {
    needAxes() {
        return !0;
    }
    _isValidSeries(type) {
        return !this.seriesType || type === this.seriesType;
    }
    _getDefaultSeriesSpec(spec) {
        const series = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
            xField: spec.xField,
            yField: spec.yField,
            zField: spec.zField,
            seriesField: spec.seriesField,
            seriesStyle: spec.seriesStyle,
            direction: spec.direction,
            stack: spec.stack,
            percent: spec.percent,
            stackOffsetSilhouette: spec.stackOffsetSilhouette,
            totalLabel: spec.totalLabel,
            sortDataByAxis: spec.sortDataByAxis
        }), seriesType = this.seriesType;
        return seriesType && (series.type = seriesType, series[seriesType] = spec[seriesType]), 
        series;
    }
    transformSpec(spec) {
        if (super.transformSpec(spec), this.needAxes()) {
            spec.axes || (spec.axes = []);
            const haxAxes = {
                x: !1,
                y: !1,
                z: !1
            };
            spec.axes.forEach((axis => {
                const {orient: orient} = axis;
                "top" !== orient && "bottom" !== orient || (haxAxes.x = !0), "left" !== orient && "right" !== orient || (haxAxes.y = !0), 
                "z" === orient && (haxAxes.z = !0), (0, util_1.get)(axis, "trimPadding") && (0, 
                util_1.mergeSpec)(axis, (0, util_2.getTrimPaddingConfig)(this.type, spec));
            })), haxAxes.x || spec.axes.push({
                orient: "bottom"
            }), haxAxes.y || spec.axes.push({
                orient: "left"
            }), spec.zField && !haxAxes.z && spec.axes.push({
                orient: "z"
            });
        }
        const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
        spec.series && 0 !== spec.series.length ? spec.series.forEach((s => {
            this._isValidSeries(s.type) && Object.keys(defaultSeriesSpec).forEach((k => {
                k in s || (s[k] = defaultSeriesSpec[k]);
            }));
        })) : spec.series = [ defaultSeriesSpec ];
    }
}

exports.CartesianChartSpecTransformer = CartesianChartSpecTransformer;
//# sourceMappingURL=cartesian-transformer.js.map
