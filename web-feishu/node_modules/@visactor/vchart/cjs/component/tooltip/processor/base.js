"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTooltipProcessor = void 0;

const vutils_1 = require("@visactor/vutils"), common_1 = require("../interface/common"), constant_1 = require("../../../constant"), polar_1 = require("../../../event/events/dimension/util/polar"), cartesian_1 = require("../../../event/events/dimension/util/cartesian"), vscale_1 = require("@visactor/vscale");

class BaseTooltipProcessor {
    constructor(component) {
        this._showTooltipByHandler = (data, params) => {
            var _a, _b;
            return this.component.event.emit(constant_1.ChartEvent.tooltipShow, Object.assign(Object.assign({}, params), {
                tooltipData: data,
                activeType: this.activeType,
                tooltip: this.component
            })), (null === (_a = this.component.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip) && (0, 
            vutils_1.isValid)(data) ? null !== (_b = this.component.tooltipHandler.showTooltip(this.activeType, data, params)) && void 0 !== _b ? _b : common_1.TooltipResult.success : common_1.TooltipResult.failed;
        }, this.component = component;
    }
    _preprocessDimensionInfo(dimensionInfo) {
        const newDimensionInfo = [];
        if (null == dimensionInfo || dimensionInfo.forEach((info => {
            const di = Object.assign(Object.assign({}, info), {
                data: info.data.filter((({series: series}) => {
                    var _a, _b;
                    return !1 !== (null === (_b = null === (_a = series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) || void 0 === _b ? void 0 : _b.visible);
                }))
            });
            di.data.length > 0 && newDimensionInfo.push(di);
        })), newDimensionInfo.length > 0) return newDimensionInfo;
    }
    _getDimensionInfo(params) {
        var _a, _b;
        let targetDimensionInfo;
        const chart = this.component.getChart(), layer = chart.getCompiler().getStage().getLayer(void 0), point = {
            x: params.event.viewX,
            y: params.event.viewY
        };
        if (layer.globalTransMatrix.transformPoint({
            x: params.event.viewX,
            y: params.event.viewY
        }, point), targetDimensionInfo = [ ...null !== (_a = (0, cartesian_1.getCartesianDimensionInfo)(chart, point)) && void 0 !== _a ? _a : [], ...null !== (_b = (0, 
        polar_1.getPolarDimensionInfo)(chart, point)) && void 0 !== _b ? _b : [] ], 0 === targetDimensionInfo.length) targetDimensionInfo = void 0; else if (targetDimensionInfo.length > 1) {
            const dimensionAxisInfo = targetDimensionInfo.filter((info => {
                var _a;
                const axis = info.axis;
                if (!(0, vscale_1.isDiscrete)(axis.getScale().type)) return !1;
                let firstSeries;
                for (const region of null !== (_a = null == axis ? void 0 : axis.getRegions()) && void 0 !== _a ? _a : []) {
                    for (const series of region.getSeries()) if ("cartesian" === series.coordinate) {
                        firstSeries = series;
                        break;
                    }
                    if ((0, vutils_1.isValid)(firstSeries)) break;
                }
                return (0, vutils_1.isValid)(firstSeries) && firstSeries.getDimensionField()[0] === firstSeries.fieldY[0] ? "left" === axis.getOrient() || "right" === axis.getOrient() : "bottom" === axis.getOrient() || "top" === axis.getOrient();
            }));
            targetDimensionInfo = dimensionAxisInfo.length ? dimensionAxisInfo : targetDimensionInfo.slice(0, 1);
        }
        return targetDimensionInfo;
    }
}

exports.BaseTooltipProcessor = BaseTooltipProcessor;
//# sourceMappingURL=base.js.map
