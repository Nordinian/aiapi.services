var ScrollBarPlugin_1, __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

import { Generator, injectable } from "@visactor/vrender-core";

import { ScrollBar } from "./scrollbar";

import { AABBBounds, abs, max, min } from "@visactor/vutils";

let ScrollBarPlugin = ScrollBarPlugin_1 = class {
    constructor() {
        this.name = "scrollbar", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid, this.scroll = e => {
            var _a;
            const graphic = e.target, data = this.getScrollContainer(graphic), {g: scrollContainer} = data;
            let {showH: showH, showV: showV} = data;
            if (!scrollContainer || 1 === scrollContainer.count) return;
            this.scrollContainerBounds = scrollContainer.AABBBounds.clone(), abs(e.deltaX) > abs(e.deltaY) ? (showH = showH && !0, 
            showV = showV && !1) : (showH = showH && !1, showV = showV && !0), scrollContainer.setAttributes({
                scrollX: showH ? (scrollContainer.attribute.scrollX || 0) + e.deltaX : scrollContainer.attribute.scrollX || 0,
                scrollY: showV ? (scrollContainer.attribute.scrollY || 0) + e.deltaY : scrollContainer.attribute.scrollY || 0
            });
            const childrenBounds = this.childrenBounds, scrollContainerBounds = this.scrollContainerBounds;
            childrenBounds.clear(), scrollContainer.forEachChildren((c => {
                childrenBounds.union(c.AABBBounds);
            })), childrenBounds.transformWithMatrix(scrollContainer.transMatrix), showH && scrollContainerBounds.x1 <= childrenBounds.x1 && scrollContainerBounds.x2 >= childrenBounds.x2 && (showH = !1), 
            showV && scrollContainerBounds.y1 <= childrenBounds.y1 && scrollContainerBounds.y2 >= childrenBounds.y2 && (showV = !1);
            const m = scrollContainer.transMatrix;
            scrollContainerBounds.translate(-m.e, -m.f), childrenBounds.translate(-m.e, -m.f), 
            showH && (childrenBounds.x1 = min(childrenBounds.x1, scrollContainerBounds.x1), 
            childrenBounds.x2 = max(childrenBounds.x2, scrollContainerBounds.x2)), showV && (childrenBounds.y1 = min(childrenBounds.y1, scrollContainerBounds.y1), 
            childrenBounds.y2 = max(childrenBounds.y2, scrollContainerBounds.y2)), childrenBounds.translate(scrollContainer.attribute.scrollX, scrollContainer.attribute.scrollY);
            const container = (null !== (_a = scrollContainer.shadowRoot) && void 0 !== _a ? _a : scrollContainer.attachShadow()).createOrUpdateChild("scroll-bar", {}, "group"), {h: h, v: v, deltaH: deltaH, deltaV: deltaV} = this.addOrUpdateScroll(showH, showV, container, scrollContainer);
            scrollContainer.setAttributes({
                scrollX: h ? scrollContainer.attribute.scrollX || 0 : (scrollContainer.attribute.scrollX || 0) + deltaH,
                scrollY: v ? scrollContainer.attribute.scrollY || 0 : (scrollContainer.attribute.scrollY || 0) + deltaV
            });
        };
    }
    activate(context) {
        this.pluginService = context;
        const {stage: stage} = this.pluginService;
        this.childrenBounds = new AABBBounds, stage.addEventListener("wheel", this.scroll), 
        this.params = ScrollBarPlugin_1.defaultParams;
    }
    addOrUpdateScroll(showH, showV, container, scrollContainer) {
        const scrollbars = container.children;
        let h = !1, v = !1, deltaH = 0, deltaV = 0;
        if (showH) {
            const hScrollbar = scrollbars.filter((g => "vertical" !== g.attribute.direction))[0], d = this.addOrUpdateHScroll(this.scrollContainerBounds, container, hScrollbar);
            h = d.valid, deltaH = d.delta, this.disappearScrollBar(hScrollbar, v);
        }
        if (showV) {
            const vScrollbar = scrollbars.filter((g => "vertical" === g.attribute.direction))[0], d = this.addOrUpdateVScroll(this.scrollContainerBounds, container, vScrollbar);
            v = d.valid, deltaV = d.delta, this.disappearScrollBar(vScrollbar, v);
        }
        return {
            h: h,
            deltaH: deltaH,
            v: v,
            deltaV: deltaV
        };
    }
    addOrUpdateHScroll(scrollContainerB, container, scrollBar) {
        scrollBar || (scrollBar = new ScrollBar({
            direction: "horizontal",
            x: 0,
            y: 0,
            width: scrollContainerB.width(),
            height: 12,
            padding: [ 2, 0 ],
            railStyle: {
                fill: "rgba(0, 0, 0, .1)"
            },
            range: [ 0, .05 ]
        }), container.add(scrollBar));
        const b = scrollBar.AABBBounds, childrenBounds = this.childrenBounds, y = scrollContainerB.y2 - b.height(), ratio = Math.min(b.width() / this.childrenBounds.width(), 1);
        let start = (scrollContainerB.x1 - childrenBounds.x1) / (childrenBounds.width() - scrollContainerB.width()) * (1 - ratio), valid = !0, delta = 0;
        return start < 0 ? (start = 0, valid = !1, delta = scrollContainerB.x1 - childrenBounds.x1) : start + ratio > 1 && (start = 1 - ratio, 
        valid = !1, delta = scrollContainerB.x1 - childrenBounds.x1 - (childrenBounds.width() - scrollContainerB.width())), 
        scrollBar.setAttributes({
            y: y,
            visibleAll: !0,
            range: [ start, start + ratio ]
        }), {
            valid: valid,
            delta: delta
        };
    }
    addOrUpdateVScroll(scrollContainerB, container, scrollBar) {
        scrollBar || (scrollBar = new ScrollBar({
            direction: "vertical",
            x: 0,
            y: 0,
            width: 12,
            height: scrollContainerB.height(),
            padding: [ 2, 0 ],
            railStyle: {
                fill: "rgba(0, 0, 0, .1)"
            },
            range: [ 0, .05 ]
        }), container.add(scrollBar));
        const b = scrollBar.AABBBounds, x = scrollContainerB.x2 - b.width(), childrenBounds = this.childrenBounds, ratio = Math.min(b.height() / childrenBounds.height(), 1);
        let start = (scrollContainerB.y1 - childrenBounds.y1) / (childrenBounds.height() - scrollContainerB.height()) * (1 - ratio), valid = !0, delta = 0;
        return start < 0 ? (start = 0, valid = !1, delta = scrollContainerB.y1 - childrenBounds.y1) : start + ratio > 1 && (start = 1 - ratio, 
        valid = !1, delta = scrollContainerB.y1 - childrenBounds.y1 - (childrenBounds.height() - scrollContainerB.height())), 
        scrollBar.setAttributes({
            x: x,
            visibleAll: !0,
            range: [ start, start + ratio ]
        }), {
            valid: valid,
            delta: delta
        };
    }
    disappearScrollBar(scrollBar, valid) {
        var _a;
        scrollBar._plugin_timeout && clearTimeout(scrollBar._plugin_timeout), scrollBar._plugin_timeout = setTimeout((() => {
            scrollBar.setAttribute("visibleAll", !1);
        }), null !== (_a = this.params.timeout) && void 0 !== _a ? _a : 0);
    }
    getScrollContainer(graphic) {
        let g = graphic;
        for (;g; ) {
            if (g.attribute.overflow && "hidden" !== g.attribute.overflow) {
                const overflow = g.attribute.overflow;
                let showH = !1, showV = !1;
                return "scroll" === overflow ? (showH = !0, showV = !0) : (showH = "scroll-x" === overflow, 
                showV = !showH), {
                    g: g,
                    showH: showH,
                    showV: showV
                };
            }
            g = g.parent;
        }
        return null;
    }
    deactivate(context) {
        const {stage: stage} = this.pluginService;
        stage.removeEventListener("wheel", this.scroll);
    }
};

ScrollBarPlugin.defaultParams = {
    timeout: 500
}, ScrollBarPlugin = ScrollBarPlugin_1 = __decorate([ injectable() ], ScrollBarPlugin);

export { ScrollBarPlugin };
//# sourceMappingURL=scrollbar-plugin.js.map
