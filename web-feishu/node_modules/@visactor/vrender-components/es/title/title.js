import { merge, isValid, normalizePadding, isArray } from "@visactor/vutils";

import { AbstractComponent } from "../core/base";

import { DEFAULT_HTML_TEXT_SPEC } from "../constant";

import { loadTitleComponent } from "./register";

loadTitleComponent();

export class Title extends AbstractComponent {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Title.defaultAttributes, attributes)), 
        this.name = "title";
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
        const {textType: textType, text: text, subtextType: subtextType, textStyle: textStyle = {}, subtext: subtext, subtextStyle: subtextStyle = {}, width: width, height: height, minWidth: minWidth, maxWidth: maxWidth, minHeight: minHeight, maxHeight: maxHeight, align: align, verticalAlign: verticalAlign, padding: padding = 0} = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("title-container", {
            x: parsedPadding[3],
            y: parsedPadding[0],
            zIndex: 1
        }, "group");
        if (!1 !== this.attribute.visible && !1 !== textStyle.visible) if ("rich" === textType || isValid(textStyle.character)) {
            const attr = Object.assign({
                x: null !== (_a = textStyle.x) && void 0 !== _a ? _a : 0,
                y: null !== (_b = textStyle.y) && void 0 !== _b ? _b : 0,
                width: null !== (_d = null !== (_c = textStyle.width) && void 0 !== _c ? _c : width) && void 0 !== _d ? _d : 0,
                height: null !== (_f = null !== (_e = textStyle.height) && void 0 !== _e ? _e : height) && void 0 !== _f ? _f : 0,
                ellipsis: null === (_g = textStyle.ellipsis) || void 0 === _g || _g,
                wordBreak: null !== (_h = textStyle.wordBreak) && void 0 !== _h ? _h : "break-word",
                maxHeight: textStyle.maxHeight,
                maxWidth: textStyle.maxWidth,
                textConfig: null !== (_j = textStyle.character) && void 0 !== _j ? _j : text
            }, textStyle);
            this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
        } else if ("html" === textType) {
            const attr = Object.assign({
                html: Object.assign(Object.assign({
                    dom: text
                }, DEFAULT_HTML_TEXT_SPEC), textStyle),
                x: null !== (_k = textStyle.x) && void 0 !== _k ? _k : 0,
                y: null !== (_l = textStyle.y) && void 0 !== _l ? _l : 0,
                width: null !== (_o = null !== (_m = textStyle.width) && void 0 !== _m ? _m : width) && void 0 !== _o ? _o : 0,
                height: null !== (_q = null !== (_p = textStyle.height) && void 0 !== _p ? _p : height) && void 0 !== _q ? _q : 0,
                ellipsis: null === (_r = textStyle.ellipsis) || void 0 === _r || _r,
                wordBreak: null !== (_s = textStyle.wordBreak) && void 0 !== _s ? _s : "break-word",
                maxHeight: textStyle.maxHeight,
                maxWidth: textStyle.maxWidth,
                textConfig: []
            }, textStyle);
            this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
        } else isValid(text) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
            text: isArray(text) ? text : [ text ]
        }, textStyle), {
            maxLineWidth: null !== (_t = textStyle.maxLineWidth) && void 0 !== _t ? _t : width,
            heightLimit: textStyle.heightLimit,
            lineClamp: textStyle.lineClamp,
            ellipsis: null === (_u = textStyle.ellipsis) || void 0 === _u || _u,
            x: 0,
            y: 0
        }), "wrapText"));
        const maintextHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0, maintextWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
        if (!1 !== this.attribute.visible && !1 !== subtextStyle.visible) if ("rich" === subtextType || isValid(subtextStyle.character)) {
            const attr = Object.assign({
                x: null !== (_v = subtextStyle.x) && void 0 !== _v ? _v : 0,
                y: null !== (_w = subtextStyle.y) && void 0 !== _w ? _w : 0,
                width: null !== (_y = null !== (_x = subtextStyle.width) && void 0 !== _x ? _x : width) && void 0 !== _y ? _y : 0,
                height: null !== (_0 = null !== (_z = subtextStyle.height) && void 0 !== _z ? _z : height) && void 0 !== _0 ? _0 : 0,
                ellipsis: null === (_1 = subtextStyle.ellipsis) || void 0 === _1 || _1,
                wordBreak: null !== (_2 = subtextStyle.wordBreak) && void 0 !== _2 ? _2 : "break-word",
                maxHeight: subtextStyle.maxHeight,
                maxWidth: subtextStyle.maxWidth,
                textConfig: null !== (_3 = subtextStyle.character) && void 0 !== _3 ? _3 : subtext
            }, subtextStyle);
            this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
        } else if ("html" === subtextType) {
            const attr = Object.assign({
                html: Object.assign(Object.assign({
                    dom: subtext
                }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
                x: null !== (_4 = subtextStyle.x) && void 0 !== _4 ? _4 : 0,
                y: null !== (_5 = subtextStyle.y) && void 0 !== _5 ? _5 : 0,
                width: null !== (_7 = null !== (_6 = subtextStyle.width) && void 0 !== _6 ? _6 : width) && void 0 !== _7 ? _7 : 0,
                height: null !== (_9 = null !== (_8 = subtextStyle.height) && void 0 !== _8 ? _8 : height) && void 0 !== _9 ? _9 : 0,
                ellipsis: null === (_10 = subtextStyle.ellipsis) || void 0 === _10 || _10,
                wordBreak: null !== (_11 = subtextStyle.wordBreak) && void 0 !== _11 ? _11 : "break-word",
                maxHeight: subtextStyle.maxHeight,
                maxWidth: subtextStyle.maxWidth,
                textConfig: []
            }, subtextStyle);
            this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
        } else isValid(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
            text: isArray(subtext) ? subtext : [ subtext ]
        }, subtextStyle), {
            maxLineWidth: null !== (_12 = subtextStyle.maxLineWidth) && void 0 !== _12 ? _12 : width,
            heightLimit: subtextStyle.heightLimit,
            lineClamp: subtextStyle.lineClamp,
            ellipsis: null === (_13 = subtextStyle.ellipsis) || void 0 === _13 || _13,
            x: 0,
            y: maintextHeight
        }), "wrapText"));
        const subtextHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0, subtextWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
        let titleWidth = Math.max(maintextWidth, subtextWidth), titleHeight = maintextHeight + (null !== (_14 = subtextStyle.height) && void 0 !== _14 ? _14 : subtextHeight);
        if (isValid(width) && (titleWidth = width, this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", width), 
        this._subTitle && this._subTitle.setAttribute("maxLineWidth", width)), isValid(height) && (titleHeight = height), 
        isValid(minWidth) && titleWidth < minWidth && (titleWidth = minWidth), isValid(maxWidth) && (this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", maxWidth), 
        this._subTitle && this._subTitle.setAttribute("maxLineWidth", maxWidth), this._mainTitle && this._mainTitle.setAttribute("maxWidth", maxWidth), 
        this._subTitle && this._subTitle.setAttribute("maxWidth", maxWidth), titleWidth > maxWidth && (titleWidth = maxWidth)), 
        isValid(minHeight) && titleHeight < minHeight && (titleHeight = minHeight), isValid(maxHeight) && (this._mainTitle && this._mainTitle.setAttribute("maxHeight", maxHeight), 
        this._subTitle && this._subTitle.setAttribute("maxHeight", maxHeight - maintextHeight), 
        titleHeight > maxHeight && (titleHeight = maxHeight)), group.attribute.width = titleWidth, 
        group.attribute.height = titleHeight, group.attribute.boundsPadding = parsedPadding, 
        this._mainTitle) {
            if (isValid(align) || isValid(textStyle.align)) {
                const mainTitleAlign = textStyle.align ? textStyle.align : align, mainTitleWidth = null !== (_15 = textStyle.width) && void 0 !== _15 ? _15 : maintextWidth;
                "left" === mainTitleAlign ? (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left")) : "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), 
                this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign && (this._mainTitle.setAttribute("x", mainTitleWidth), 
                this._mainTitle.setAttribute("textAlign", "right"));
            }
            if (isValid(verticalAlign) || isValid(textStyle.verticalAlign)) {
                const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign, mainTitleHeight = textStyle.height ? textStyle.height : titleHeight;
                "top" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top")) : "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), 
                this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign && (this._mainTitle.setAttribute("y", mainTitleHeight), 
                this._mainTitle.setAttribute("textBaseline", "bottom"));
            }
        }
        if (this._subTitle) {
            if (isValid(align) || isValid(subtextStyle.align)) {
                const subTitleAlign = subtextStyle.align ? subtextStyle.align : align, subTitleWidth = null !== (_16 = subtextStyle.width) && void 0 !== _16 ? _16 : subtextWidth;
                "left" === subTitleAlign ? (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left")) : "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), 
                this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign && (this._subTitle.setAttribute("x", subTitleWidth), 
                this._subTitle.setAttribute("textAlign", "right"));
            }
            if (isValid(verticalAlign) || isValid(textStyle.verticalAlign)) {
                const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign, subTitleYStart = maintextHeight, subTitleHeight = null !== (_17 = subtextStyle.height) && void 0 !== _17 ? _17 : 0;
                "top" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart), 
                this._subTitle.setAttribute("textBaseline", "top")) : "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), 
                this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign && (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), 
                this._subTitle.setAttribute("textBaseline", "bottom"));
            }
        }
    }
}

Title.defaultAttributes = {
    textStyle: {
        ellipsis: "...",
        fill: "#333",
        fontSize: 20,
        fontWeight: "bold",
        textAlign: "left",
        textBaseline: "top"
    },
    subtextStyle: {
        ellipsis: "...",
        fill: "#6F6F6F",
        fontSize: 16,
        fontWeight: "normal",
        textAlign: "left",
        textBaseline: "top"
    }
};
//# sourceMappingURL=title.js.map
