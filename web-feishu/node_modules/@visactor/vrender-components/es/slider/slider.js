import { isNil, merge, clamp, isValid, array, isObject, isArray, clampRange } from "@visactor/vutils";

import { graphicCreator, vglobal } from "@visactor/vrender-core";

import { AbstractComponent } from "../core/base";

import { SLIDER_ELEMENT_NAME } from "./constant";

import { loadSliderComponent } from "./register";

function convertValueToRange(value) {
    return isArray(value) ? value : [ value, value ];
}

function getDefaultCursor(isHorizontal) {
    return isHorizontal ? "ew-resize" : "ns-resize";
}

loadSliderComponent();

export class Slider extends AbstractComponent {
    get track() {
        return this._track;
    }
    get currentValue() {
        return this._currentValue;
    }
    get startHandler() {
        return this._startHandler;
    }
    get endHandler() {
        return this._endHandler;
    }
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Slider.defaultAttributes, attributes)), 
        this.name = "slider", this._isHorizontal = !0, this._startHandler = null, this._endHandler = null, 
        this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, 
        this._currentValue = {}, this._onHandlerPointerdown = e => {
            e.stopPropagation(), this._currentHandler = e.target, this._prePos = this._isHorizontal ? e.clientX : e.clientY, 
            "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onHandlerPointerMove, {
                capture: !0
            }), vglobal.addEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.addEventListener("pointermove", this._onHandlerPointerMove, {
                capture: !0
            }), this.stage.addEventListener("pointerup", this._onHandlerPointerUp), this.stage.addEventListener("pointerupoutside", this._onHandlerPointerUp));
        }, this._onHandlerPointerMove = e => {
            var _a, _b;
            e.stopPropagation();
            const {railWidth: railWidth, railHeight: railHeight, min: min, max: max} = this.attribute;
            if (max === min) return;
            let currentPos, originPos, railLen, delta = 0;
            this._isHorizontal ? (currentPos = e.clientX, delta = currentPos - this._prePos, 
            originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, 
            railLen = railWidth) : (currentPos = e.clientY, delta = currentPos - this._prePos, 
            originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, 
            railLen = railHeight);
            const newPos = clamp(originPos + delta, 0, railLen), currentValue = newPos / railLen * (max - min) + min;
            "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), 
            this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
        }, this._onHandlerPointerUp = e => {
            e.preventDefault(), this._currentHandler = null, "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onHandlerPointerMove, {
                capture: !0
            }), vglobal.removeEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.removeEventListener("pointermove", this._onHandlerPointerMove, {
                capture: !0
            }), this.stage.removeEventListener("pointerup", this._onHandlerPointerUp), this.stage.removeEventListener("pointerupoutside", this._onHandlerPointerUp));
        }, this._onTrackPointerdown = e => {
            e.stopPropagation(), this._prePos = this._isHorizontal ? e.clientX : e.clientY, 
            "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onTrackPointerMove, {
                capture: !0
            }), vglobal.addEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.addEventListener("pointermove", this._onTrackPointerMove, {
                capture: !0
            }), this.stage.addEventListener("pointerup", this._onTrackPointerUp), this.stage.addEventListener("pointerupoutside", this._onTrackPointerUp));
        }, this._onTrackPointerMove = e => {
            e.stopPropagation();
            const {railWidth: railWidth, railHeight: railHeight, min: min, max: max} = this.attribute;
            if (max === min) return;
            const {startHandler: startHandler, endHandler: endHandler} = this._getHandlers();
            let currentPos, trackLen, railLen;
            this._isHorizontal ? (currentPos = e.clientX, trackLen = this._track.attribute.width, 
            railLen = railWidth) : (currentPos = e.clientY, trackLen = this._track.attribute.height, 
            railLen = railHeight);
            const delta = currentPos - this._prePos;
            if (startHandler) {
                const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y, newPos = clamp(originPos + delta, 0, railLen - trackLen), currentValue = newPos / railLen * (max - min) + min;
                this._updateHandler(startHandler, newPos, currentValue);
            }
            if (endHandler) {
                const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y, newPos = clamp(originPos + delta, trackLen, railLen), currentValue = newPos / railLen * (max - min) + min, startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
                this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
                    x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
                    width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
                } : {
                    y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
                    height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
                });
            }
            this._prePos = currentPos, this._dispatchChangeEvent();
        }, this._onTrackPointerUp = e => {
            e.preventDefault(), "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onTrackPointerMove, {
                capture: !0
            }), vglobal.removeEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.removeEventListener("pointermove", this._onTrackPointerMove, {
                capture: !0
            }), this.stage.removeEventListener("pointerup", this._onTrackPointerUp), this.stage.removeEventListener("pointerupoutside", this._onTrackPointerUp));
        }, this._onRailPointerDown = e => {
            e.stopPropagation();
            const {railWidth: railWidth, railHeight: railHeight, min: min, max: max} = this.attribute;
            if (max === min) return;
            const startHandler = this._startHandler, endHandler = this._endHandler;
            let currentPos, startHandlerPos, endHandlerPos, railLen;
            this._isHorizontal ? (currentPos = e.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, 
            endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railLen = railWidth) : (currentPos = e.viewY - this._rail.globalAABBBounds.y1, 
            startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, 
            railLen = railHeight);
            const currentValue = currentPos / railLen * (max - min) + min;
            if (isValid(endHandlerPos)) {
                const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
                this._updateHandler(updateHandler, currentPos, currentValue);
            } else this._updateHandler(startHandler, currentPos, currentValue);
            this._updateTrack(), this._dispatchChangeEvent();
        };
    }
    setValue(value) {
        const {layout: layout, railWidth: railWidth, railHeight: railHeight, min: min, max: max} = this.attribute;
        if (max === min) return;
        const [startValue, endValue] = array(value), {startHandler: startHandler, endHandler: endHandler} = this._getHandlers(), railLen = "vertical" === layout ? railHeight : railWidth, startPos = (startValue - min) / (max - min) * railLen;
        if (startHandler && this._updateHandler(startHandler, startPos, startValue), endHandler) {
            const endPos = (endValue - min) / (max - min) * railLen;
            this._updateHandler(endHandler, endPos, endValue);
        }
        this._updateTrack();
    }
    render() {
        var _a, _b;
        this.removeAllChild();
        const {layout: layout = "horizontal", railWidth: railWidth, railHeight: railHeight, startText: startText, endText: endText, min: min, max: max, showHandler: showHandler = !0} = this.attribute;
        let {value: value} = this.attribute;
        isNil(value) && (value = [ min, max ]), this._currentValue = {
            startValue: convertValueToRange(value)[0],
            endValue: convertValueToRange(value)[1]
        };
        const isHorizontal = "horizontal" === layout;
        this._isHorizontal = isHorizontal;
        const innerView = graphicCreator.group({
            x: 0,
            y: 0
        });
        innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
        let startTextShape, startLen = 0;
        if (startText && startText.visible) {
            startTextShape = graphicCreator.text(Object.assign({
                x: isHorizontal ? 0 : railWidth / 2,
                y: isHorizontal ? railHeight / 2 : 0,
                textAlign: isHorizontal ? "start" : "center",
                textBaseline: isHorizontal ? "middle" : "top",
                text: startText.text,
                lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
            }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
            const space = isValid(startText.space) ? startText.space : 0;
            startLen += (isHorizontal ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
        }
        const mainContainer = graphicCreator.group({
            x: isHorizontal ? startLen : 0,
            y: isHorizontal ? 0 : startLen
        });
        innerView.add(mainContainer);
        const railContainer = graphicCreator.group({
            x: 0,
            y: 0
        });
        let endTextShape;
        if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, 
        mainContainer.add(railContainer), this._renderRail(railContainer), startLen += isHorizontal ? railWidth : railHeight, 
        endText && endText.visible) {
            const space = isValid(endText.space) ? endText.space : 0;
            endTextShape = graphicCreator.text(Object.assign({
                x: isHorizontal ? startLen + space : railWidth / 2,
                y: isHorizontal ? railHeight / 2 : startLen + space,
                textAlign: isHorizontal ? "start" : "center",
                textBaseline: isHorizontal ? "middle" : "top",
                text: endText.text,
                lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
            }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
        }
        this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), 
        this._bindEvents());
    }
    _renderRail(container) {
        const {railWidth: railWidth, railHeight: railHeight, railStyle: railStyle, slidable: slidable} = this.attribute;
        let cursor = "default";
        !1 !== slidable && (cursor = "pointer");
        const railShape = graphicCreator.rect(Object.assign({
            x: 0,
            y: 0,
            width: railWidth,
            height: railHeight,
            cursor: cursor
        }, railStyle));
        return railShape.name = SLIDER_ELEMENT_NAME.rail, container.add(railShape), this._rail = railShape, 
        railShape;
    }
    _renderHandlers(container) {
        const {range: range, min: min, max: max, handlerSize: handlerSize = 14, handlerStyle: handlerStyle, handlerText: handlerText, railHeight: railHeight, railWidth: railWidth, slidable: slidable} = this.attribute;
        let {value: value} = this.attribute;
        isNil(value) && (value = [ min, max ]);
        const handlerTextVisible = handlerText && handlerText.visible, isHorizontal = this._isHorizontal, railLen = isHorizontal ? railWidth : railHeight, [startValue, endValue] = convertValueToRange(value), handlerStart = max === min ? range ? 0 : railLen : (startValue - min) / (max - min) * railLen, startHandler = this._renderHandler(Object.assign({
            x: isHorizontal ? handlerStart : railWidth / 2,
            y: isHorizontal ? railHeight / 2 : handlerStart,
            size: handlerSize,
            strokeBoundsBuffer: 0,
            cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
        }, handlerStyle));
        if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, 
        container.add(startHandler), this._currentValue.startPos = handlerStart, handlerTextVisible) {
            const startHandlerText = this._renderHandlerText(startValue, range ? "start" : "end");
            startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container.add(startHandlerText), 
            this._startHandlerText = startHandlerText;
        }
        if (range) {
            const handlerEnd = max === min ? railLen : (endValue - min) / (max - min) * railLen, endHandler = this._renderHandler(Object.assign({
                x: isHorizontal ? handlerEnd : railWidth / 2,
                y: isHorizontal ? railHeight / 2 : handlerEnd,
                size: handlerSize,
                strokeBoundsBuffer: 0,
                cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
            }, handlerStyle));
            if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, 
            container.add(endHandler), this._currentValue.endPos = handlerEnd, handlerTextVisible) {
                const endHandlerText = this._renderHandlerText(endValue, "end");
                endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container.add(endHandlerText), 
                this._endHandlerText = endHandlerText;
            }
        }
    }
    _renderTrack(container) {
        const {range: range, min: min, max: max, railHeight: railHeight, railWidth: railWidth, trackStyle: trackStyle, railStyle: railStyle, slidable: slidable, value: value} = this.attribute;
        let startValue, endValue;
        if (isNil(value)) range ? (startValue = min, endValue = max) : startValue = endValue = min; else if (range) {
            const clampValue = clampRange(value, min, max);
            startValue = clampValue[0], endValue = clampValue[1];
        } else startValue = min, endValue = clamp(value, min, max);
        const isHorizontal = this._isHorizontal, railLen = isHorizontal ? railWidth : railHeight;
        range || (startValue = min);
        const trackContainer = graphicCreator.group({
            x: 0,
            y: 0,
            width: railWidth,
            height: railHeight,
            cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
            clip: !0,
            pickable: !1
        });
        trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
        const draggableTrack = isObject(range) && !0 === range.draggableTrack;
        let cursor;
        cursor = !1 === slidable ? "default" : !1 === range || !1 === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal);
        const trackWidth = max === min ? railLen : (endValue - startValue) / (max - min) * railLen, startPos = max === min ? 0 : (startValue - min) / (max - min) * railLen, track = graphicCreator.rect(Object.assign({
            x: isHorizontal ? startPos : 0,
            y: isHorizontal ? 0 : startPos,
            width: isHorizontal ? trackWidth : railWidth,
            height: isHorizontal ? railHeight : trackWidth,
            cursor: cursor
        }, trackStyle));
        track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), 
        container.add(trackContainer);
    }
    _renderHandler(style) {
        return graphicCreator.symbol(style);
    }
    _renderHandlerText(value, position) {
        var _a, _b, _c;
        const {align: align, min: min, max: max, handlerSize: handlerSize = 14, handlerText: handlerText = {}, railHeight: railHeight, railWidth: railWidth, slidable: slidable} = this.attribute, isHorizontal = this._isHorizontal, railLen = isHorizontal ? railWidth : railHeight, handlerStart = max === min ? "start" === position ? 0 : railLen : (value - min) / (max - min) * railLen, textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4, textStyle = {
            text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
            lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
            cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
        };
        isHorizontal ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", 
        textStyle.x = handlerStart, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", 
        textStyle.textAlign = "center", textStyle.x = handlerStart, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", 
        textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, 
        textStyle.y = handlerStart) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", 
        textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = handlerStart);
        return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) return;
        const {slidable: slidable, range: range} = this.attribute;
        slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), 
        this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), 
        this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), 
        this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), 
        isObject(range) && range.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), 
        this._railContainer.addEventListener("pointerdown", this._onRailPointerDown));
    }
    _updateTrack() {
        const startHandler = this._startHandler, endHandler = this._endHandler;
        if (this._isHorizontal) {
            const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
            if (endHandler) {
                const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
                this._track.setAttributes({
                    x: Math.min(startHandlerPos, endHandlerPos),
                    width: Math.abs(startHandlerPos - endHandlerPos)
                });
            } else this._track.setAttributes({
                width: startHandlerPos
            });
        } else {
            const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
            if (endHandler) {
                const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
                this._track.setAttributes({
                    y: Math.min(startHandlerPos, endHandlerPos),
                    height: Math.abs(startHandlerPos - endHandlerPos)
                });
            } else this._track.setAttributes({
                height: startHandlerPos
            });
        }
    }
    _updateHandler(handler, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal;
        handler.setAttribute(isHorizontal ? "x" : "y", position);
        const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
        if (updateHandlerText) {
            const {handlerText: handlerText = {}} = this.attribute;
            updateHandlerText.setAttributes({
                text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
                [isHorizontal ? "x" : "y"]: position
            });
        }
        handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, 
        this._currentValue.startPos = position) : (this._currentValue.endValue = value, 
        this._currentValue.endPos = position);
    }
    _updateHandlerText(handlerText, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal, {handlerText: handlerTextAttr = {}} = this.attribute;
        handlerText.setAttributes({
            [isHorizontal ? "x" : "y"]: position,
            text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
        });
        const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
        updateHandler && updateHandler.setAttributes({
            [isHorizontal ? "x" : "y"]: position
        }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, 
        this._currentValue.startPos = position) : (this._currentValue.endValue = value, 
        this._currentValue.endPos = position);
    }
    _dispatchChangeEvent() {
        const isRange = !!this.attribute.range, currentValue = this._currentValue;
        this._dispatchEvent("change", {
            value: isRange ? [ Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue) ] : currentValue.startValue,
            position: isRange ? [ Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos) ] : currentValue.startPos
        });
    }
    _getHandlers() {
        let temp, startHandler = this._startHandler, endHandler = this._endHandler;
        return this._isHorizontal ? endHandler && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) && (temp = startHandler, 
        startHandler = endHandler, endHandler = temp) : endHandler && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) && (temp = startHandler, 
        startHandler = endHandler, endHandler = temp), {
            startHandler: startHandler,
            endHandler: endHandler
        };
    }
}

Slider.defaultAttributes = {
    slidable: !0,
    layout: "horizontal",
    align: "bottom",
    height: 8,
    showHandler: !0,
    handlerSize: 14,
    handlerStyle: {
        symbolType: "circle",
        fill: "#fff",
        stroke: "#91caff",
        lineWidth: 2
    },
    railStyle: {
        fill: "rgba(0,0,0,.04)"
    },
    trackStyle: {
        fill: "#91caff"
    },
    showValue: !0,
    valueStyle: {
        fill: "#2C3542",
        fontSize: 12
    },
    startText: {
        style: {
            fill: "#2C3542",
            fontSize: 12
        }
    },
    endText: {
        style: {
            fill: "#2C3542",
            fontSize: 12
        }
    },
    handlerText: {
        visible: !0,
        space: 4,
        precision: 0,
        style: {
            fill: "#2C3542",
            fontSize: 12
        }
    }
};
//# sourceMappingURL=slider.js.map
