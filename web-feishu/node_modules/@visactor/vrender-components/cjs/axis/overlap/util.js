"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.itemIntersect = exports.genRotateBounds = void 0;

const vutils_1 = require("@visactor/vutils");

function rotate(x, y, deg, originX, originY) {
    return {
        x: (x - originX) * Math.cos(deg) + (y - originY) * Math.sin(deg) + originX,
        y: (x - originX) * Math.sin(deg) + (originY - y) * Math.cos(deg) + originY
    };
}

function genNormalBounds(item) {
    const bounds = item.AABBBounds;
    return {
        x1: bounds.x1,
        x2: bounds.x2,
        y1: bounds.y1,
        y2: bounds.y2,
        centerX: item.attribute.x,
        centerY: item.attribute.y,
        angle: item.attribute.angle
    };
}

function genRotateBounds(items) {
    items.forEach((item => {
        if (item.rotatedBounds || !item.attribute.angle) return;
        const bounds = genNormalBounds(item), rotatedCenter = rotate(bounds.centerX, bounds.centerY, bounds.angle, item.attribute.x, item.attribute.y), deltaX = rotatedCenter.x - bounds.centerX, deltaY = rotatedCenter.y - bounds.centerY;
        bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, 
        bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
    }));
}

function itemIntersect(item1, item2) {
    return (0, vutils_1.isRectIntersect)(item1.AABBBounds, item2.AABBBounds, !1) && (!item1.rotatedBounds || !item2.rotatedBounds || (0, 
    vutils_1.isRotateAABBIntersect)(item1.rotatedBounds, item2.rotatedBounds, !0));
}

exports.genRotateBounds = genRotateBounds, exports.itemIntersect = itemIntersect;
//# sourceMappingURL=util.js.map
