import { transformsByType } from "../graph/attributes";

import { DefaultKey, DefaultMarkData } from "../graph/constants";

import { GrammarMarkType, HOOK_EVENT } from "../graph/enums";

import { createElement } from "../graph/util/element";

import { createGraphicItem } from "../graph/util/graphic";

import { Mark } from "./mark";

export class GroupMark extends Mark {
    constructor(view, group) {
        super(view, GrammarMarkType.group, group), this.children = [];
    }
    parseRenderContext() {
        return {
            large: !1
        };
    }
    appendChild(mark) {
        return this.children.push(mark), this;
    }
    removeChild(mark) {
        return this.children = this.children.filter((child => child !== mark)), this;
    }
    includesChild(mark, descendant = !0) {
        return !!this.children.includes(mark) || !!descendant && this.children.some((child => child.markType === GrammarMarkType.group && child.includesChild(mark, !0)));
    }
    updateLayoutChildren() {
        return this.children.length ? (this.layoutChildren || (this.layoutChildren = []), 
        this.layoutChildren = this.children.filter((child => child.needLayout())), this) : this;
    }
    getAttributeTransforms() {
        return transformsByType.rect;
    }
    evaluateJoin(data) {
        if (!this.elements.length) {
            const el = createElement(this);
            el.updateData(DefaultKey, DefaultMarkData, (() => ""), this.view), this.elements = [ el ], 
            this.elementMap.set(DefaultKey, el);
        }
    }
    addGraphicItem(attrs, groupKey, newGraphicItem) {
        const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
        if (graphicItem) return this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK), graphicItem.name = `${this.id() || this.markType}`, 
        this.graphicParent.insertIntoKeepIdx(graphicItem, this.graphicIndex), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK), 
        graphicItem;
    }
}
//# sourceMappingURL=group.js.map
