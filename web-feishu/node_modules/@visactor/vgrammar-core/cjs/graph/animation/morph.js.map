{"version":3,"sources":["../src/graph/animation/morph.ts"],"names":[],"mappings":"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","file":"morph.js","sourcesContent":["import { morphPath, multiToOneMorph, oneToMultiMorph } from '@visactor/vrender-core';\nimport { isNil, isNumber, isValidNumber } from '@visactor/vutils';\nimport type { IElement, IGrammarBase, IMark, IRunningConfig, MarkSpec } from '../../types';\nimport type { DiffResult } from '../../types/base';\nimport type { IMorph, MorphData, MorphElements } from '../../types/morph';\nimport { invokeFunctionType, parseField } from '../../parse/util';\nimport { diffMultiple, diffSingle, groupData } from '../mark/differ';\nimport { GrammarMarkType } from '../enums';\n\nconst EmptyKey = Symbol.for('key');\n\nexport class Morph implements IMorph {\n  diffGrammar<U extends IGrammarBase>(prevGrammars: U[], nextGrammars: U[]): DiffResult<U, U> {\n    const key = (grammar: U) => grammar.id() ?? Symbol();\n    return diffSingle(prevGrammars, nextGrammars, key);\n  }\n\n  diffMark(prevMarks: IMark[], nextMarks: IMark[], runningConfig: IRunningConfig): DiffResult<IMark[], IMark[]> {\n    const diffResult: DiffResult<IMark[], IMark[]> = {\n      enter: [],\n      exit: [],\n      update: []\n    };\n\n    let prevDiffMarks: IMark[] = [];\n    let nextDiffMarks: IMark[] = [];\n\n    // filter out marks & specs which will not morph\n    prevMarks.forEach(mark => {\n      if (\n        // group mark does not support reusing or morphing\n        mark.markType !== GrammarMarkType.group &&\n        ((runningConfig.morph && mark.getMorphConfig().morph) || runningConfig.morphAll || runningConfig.reuse)\n      ) {\n        prevDiffMarks.push(mark);\n      } else {\n        diffResult.exit.push({ prev: [mark] });\n      }\n    });\n    nextMarks.forEach(mark => {\n      if (\n        mark.markType !== GrammarMarkType.group &&\n        ((runningConfig.morph && mark.getMorphConfig().morph) || runningConfig.morphAll || runningConfig.reuse)\n      ) {\n        nextDiffMarks.push(mark);\n      } else {\n        diffResult.enter.push({ next: [mark] });\n      }\n    });\n\n    // 1. match by custom key\n    const keyDiffResult = this.diffUpdateByGroup(\n      prevDiffMarks,\n      nextDiffMarks,\n      mark => mark.getMorphConfig().morphKey,\n      mark => mark.getMorphConfig().morphKey\n    );\n    prevDiffMarks = keyDiffResult.prev;\n    nextDiffMarks = keyDiffResult.next;\n    diffResult.update = diffResult.update.concat(keyDiffResult.update);\n\n    // 2. match by name\n    const nameDiffResult = this.diffUpdateByGroup(\n      prevDiffMarks,\n      nextDiffMarks,\n      mark => mark.id(),\n      mark => mark.id()\n    );\n    prevDiffMarks = nameDiffResult.prev;\n    nextDiffMarks = nameDiffResult.next;\n    diffResult.update = diffResult.update.concat(nameDiffResult.update);\n\n    // 3. match by index\n\n    // FIXME: mark index cannot be get before executing, index is decided by remove/order for now\n    const prevParentGroup = groupData(prevDiffMarks, mark => mark.group?.id?.());\n    const nextParentGroup = groupData(nextDiffMarks, mark => mark.group?.id?.());\n\n    Object.keys(nextParentGroup).forEach(groupName => {\n      const prevChildren = prevParentGroup.data.get(groupName);\n      const nextChildren = nextParentGroup.data.get(groupName);\n      if (prevChildren && nextChildren) {\n        for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {\n          const prevChild = prevChildren[i];\n          const nextChild = nextChildren[i];\n          if (prevChild && nextChild) {\n            diffResult.update.push({ prev: [prevChild], next: [nextChild] });\n          } else if (prevChild) {\n            diffResult.exit.push({ prev: [prevChild] });\n          } else if (nextChild) {\n            diffResult.enter.push({ next: [nextChild] });\n          }\n        }\n\n        prevDiffMarks = prevDiffMarks.filter(mark => !prevChildren.includes(mark));\n        nextDiffMarks = nextDiffMarks.filter(mark => !nextChildren.includes(mark));\n      }\n    });\n\n    // 4. handle unmatched marks\n    prevDiffMarks.forEach(mark => diffResult.exit.push({ prev: [mark] }));\n    nextDiffMarks.forEach(mark => diffResult.enter.push({ next: [mark] }));\n\n    return diffResult;\n  }\n\n  private _appendMorphKeyToElements(mark: IMark) {\n    const config = mark.getMorphConfig();\n\n    if (!isNil(config.morphElementKey)) {\n      const getter = parseField(config.morphElementKey);\n\n      if (mark.elements) {\n        mark.elements.forEach(el => {\n          (el as any).morphKey = getter(el.getDatum());\n        });\n      }\n    }\n  }\n\n  morph(prevMarks: IMark[], nextMarks: IMark[], runningConfig: IRunningConfig) {\n    const prevElements = prevMarks.reduce((elements, mark) => {\n      this._appendMorphKeyToElements(mark);\n\n      return elements.concat(mark.elements);\n    }, [] as IElement[]);\n    const nextElements = nextMarks.reduce((elements, mark) => {\n      this._appendMorphKeyToElements(mark);\n\n      return elements.concat(mark.elements);\n    }, [] as IElement[]);\n\n    const key = (element: IElement) => (element as any).morphKey ?? element.key;\n    const diffResult = diffMultiple(prevElements, nextElements, key);\n\n    // disable normal animations of previous marks\n    prevMarks.forEach(mark => mark.animate?.disable?.());\n    nextMarks.forEach(mark => mark.animate?.disable?.());\n\n    const parameters = prevMarks.concat(nextMarks).reduce((parameters, mark) => {\n      Object.assign(parameters, mark.parameters());\n      return parameters;\n    }, {});\n\n    let morphCount = 0;\n    const onMorphEnd = () => {\n      morphCount -= 1;\n      if (morphCount === 0) {\n        nextMarks.forEach(mark => {\n          mark.animate?.enable?.();\n        });\n      }\n    };\n    // no animation for exit result\n    diffResult.enter.forEach(diff => {\n      diff.next.forEach(element => {\n        this.doMorph([], [element], runningConfig, onMorphEnd, parameters);\n      });\n      morphCount += 1;\n    });\n    diffResult.update.forEach(diff => {\n      const divideCount = Math.min(diff.prev.length, diff.next.length);\n      const prevDivide = this.divideElements(diff.prev, divideCount);\n      const nextDivide = this.divideElements(diff.next, divideCount);\n      for (let i = 0; i < divideCount; i++) {\n        this.doMorph(prevDivide[i], nextDivide[i], runningConfig, onMorphEnd, parameters);\n        morphCount += 1;\n      }\n    });\n  }\n\n  private diffUpdateByGroup<U extends IMark | MarkSpec, V extends IMark | MarkSpec>(\n    prev: U[],\n    next: V[],\n    prevKey: (datum: U) => symbol | string,\n    nextKey: (datum: V) => symbol | string\n  ) {\n    const prevGroup = groupData(prev, datum => prevKey(datum) ?? EmptyKey);\n    const nextGroup = groupData(next, datum => nextKey(datum) ?? EmptyKey);\n\n    let prevAfterDiff = prev;\n    let nextAfterDiff = next;\n    const update: { prev: U[]; next: V[] }[] = [];\n    nextGroup.keys.forEach(key => {\n      if (key !== EmptyKey) {\n        const prevKeyData = prevGroup.data.get(key);\n        const nextKeyData = nextGroup.data.get(key);\n        if (prevKeyData && nextKeyData) {\n          update.push({ prev: prevKeyData, next: nextKeyData });\n          prevAfterDiff = prevAfterDiff.filter(datum => !prevKeyData.includes(datum));\n          nextAfterDiff = nextAfterDiff.filter(datum => !nextKeyData.includes(datum));\n        }\n      }\n    });\n    return {\n      prev: prevAfterDiff,\n      next: nextAfterDiff,\n      update\n    };\n  }\n\n  private doMorph(\n    prev: IElement[],\n    next: IElement[],\n    runningConfig: IRunningConfig,\n    onEnd: () => void,\n    parameters: any\n  ) {\n    const morphData: MorphData = {\n      prev: prev.map(element => element.getDatum()),\n      next: next.map(element => element.getDatum())\n    };\n    const morphElements: MorphElements = {\n      prev: prev.slice(),\n      next: next.slice()\n    };\n    const easing = runningConfig.animation.easing;\n    const delay = invokeFunctionType(runningConfig.animation.delay, parameters, morphData, morphElements);\n    const duration = invokeFunctionType(runningConfig.animation.duration, parameters, morphData, morphElements);\n    const oneByOne = invokeFunctionType(runningConfig.animation.oneByOne, parameters, morphData, morphElements);\n    const splitPath = invokeFunctionType(runningConfig.animation.splitPath, parameters, morphData, morphElements);\n    const individualDelay =\n      isValidNumber(oneByOne) && oneByOne > 0\n        ? (index: number) => {\n            if (isNumber(oneByOne)) {\n              return index * oneByOne;\n            } else if (oneByOne === true) {\n              return index * duration;\n            }\n            return 0;\n          }\n        : undefined;\n\n    // if no previous item, still execute morph animation\n    if ((prev.length === 1 || prev.length === 0) && next.length === 1) {\n      morphPath(prev[0]?.getGraphicItem?.(), next[0].getGraphicItem(), { delay, duration, easing, onEnd });\n    } else if (prev.length === 1 && next.length > 1) {\n      oneToMultiMorph(\n        prev[0].getGraphicItem(),\n        next.map(element => element.getGraphicItem()),\n        { delay, duration, easing, onEnd, individualDelay, splitPath }\n      );\n    } else if (prev.length > 1 && next.length === 1) {\n      multiToOneMorph(\n        prev.map(element => element.getGraphicItem()),\n        next[0].getGraphicItem(),\n        { delay, duration, easing, onEnd, individualDelay, splitPath }\n      );\n    }\n  }\n\n  private divideElements(elements: IElement[], count: number) {\n    const divideLength = Math.floor(elements.length / count);\n    return new Array(count).fill(0).map((i, index) => {\n      return elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1));\n    });\n  }\n}\n"]}