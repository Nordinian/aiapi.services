import { isFunction, isValid, maxInArray, minInArray } from "@visactor/vutils";

import { convertDomainToTickData, getPolarAngleLabelBounds, labelOverlap } from "../util";

export const polarAngleAxisDiscreteTicks = (scale, op) => {
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, getRadius: getRadius, labelOffset: labelOffset, labelGap: labelGap = 0, labelStyle: labelStyle} = op, radius = null == getRadius ? void 0 : getRadius();
    if (!radius) return convertDomainToTickData(scale.domain());
    let scaleTicks;
    if (isValid(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if (isValid(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if (isValid(tickCount)) {
        const range = scale.range(), rangeSize = Math.abs(range[range.length - 1] - range[0]), count = isFunction(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(count);
    } else if (op.sampling) {
        const domain = scale.domain(), range = scale.range(), labelBoundsList = getPolarAngleLabelBounds(scale, domain, op), rangeStart = minInArray(range), rangeEnd = maxInArray(range), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, {step: step, delCount: delCount} = getStep(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce(((min, curBounds) => Math.min(min, curBounds.width(), curBounds.height())), Number.MAX_VALUE) / incrementUnit));
        scaleTicks = scale.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
    } else scaleTicks = scale.domain();
    return convertDomainToTickData(scaleTicks);
};

const getStep = (domain, labelBoundsList, labelGap, defaultStep) => {
    let step = defaultStep;
    do {
        let success = !0;
        step++;
        let ptr = 0;
        do {
            ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), 
            ptr += step;
        } while (success && ptr < domain.length);
        if (success) break;
    } while (step <= domain.length);
    let delCount = 0;
    if (domain.length > 2) {
        let ptr = domain.length - domain.length % step;
        for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]); ) delCount++, 
        ptr -= step;
    }
    return {
        step: step,
        delCount: delCount
    };
};
//# sourceMappingURL=polar-angle.js.map