"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.continuousTicks = void 0;

const vscale_1 = require("@visactor/vscale"), vutils_1 = require("@visactor/vutils"), config_1 = require("./config"), util_1 = require("./util"), continuousTicks = (scale, op) => {
    if (!(0, vscale_1.isContinuous)(scale.type)) return (0, util_1.convertDomainToTickData)(scale.domain());
    const range = scale.range(), rangeSize = Math.abs(range[range.length - 1] - range[0]);
    if (rangeSize < 2) return (0, util_1.convertDomainToTickData)([ scale.domain()[0] ]);
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, noDecimals: noDecimals = !1, labelStyle: labelStyle} = op;
    let scaleTicks;
    if ((0, vutils_1.isValid)(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if ((0, 
    vutils_1.isValid)(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if ("d3" === op.tickMode) {
        const count = (0, vutils_1.isFunction)(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.d3Ticks(null != count ? count : config_1.DEFAULT_CONTINUOUS_TICK_COUNT, {
            noDecimals: noDecimals
        });
    } else {
        const count = (0, vutils_1.isFunction)(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(null != count ? count : config_1.DEFAULT_CONTINUOUS_TICK_COUNT, {
            noDecimals: noDecimals
        });
    }
    if (op.sampling && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
        const {labelGap: labelGap = 4, labelFlush: labelFlush} = op;
        let items = (0, util_1.getCartesianLabelBounds)(scale, scaleTicks, op).map(((bounds, i) => ({
            AABBBounds: bounds,
            value: scaleTicks[i]
        })));
        for (;items.length >= 3 && (0, util_1.hasOverlap)(items, labelGap); ) items = methods.parity(items);
        const ticks = items.map((item => item.value));
        ticks.length < 3 && labelFlush && (ticks.length > 1 && ticks.pop(), (0, vutils_1.last)(ticks) !== (0, 
        vutils_1.last)(scaleTicks) && ticks.push((0, vutils_1.last)(scaleTicks))), scaleTicks = ticks;
    }
    return (0, util_1.convertDomainToTickData)(scaleTicks);
};

exports.continuousTicks = continuousTicks;

const methods = {
    parity: function(items) {
        return items.filter(((item, i) => i % 2 == 0));
    },
    greedy: function(items, sep) {
        let a;
        return items.filter(((b, i) => (!i || !(0, util_1.intersect)(a.AABBBounds, b.AABBBounds, sep)) && (a = b, 
        !0)));
    }
};
//# sourceMappingURL=continuous.js.map