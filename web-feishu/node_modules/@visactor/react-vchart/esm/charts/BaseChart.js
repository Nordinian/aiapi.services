import React, { useState, useEffect, useRef, useImperativeHandle } from "react";

import withContainer from "../containers/withContainer";

import RootChartContext from "../context/chart";

import { isEqual, pickWithout } from "@visactor/vutils";

import ViewContext from "../context/view";

import { toArray } from "../util";

import { REACT_PRIVATE_PROPS } from "../constants";

import { bindEventsToChart, CHART_EVENTS_KEYS, CHART_EVENTS } from "../eventsUtils";

const notSpecKeys = [ ...REACT_PRIVATE_PROPS, ...CHART_EVENTS_KEYS, "skipFunctionDiff", "onError", "onReady", "spec", "container", "options" ], BaseChart = React.forwardRef(((props, ref) => {
    const [updateId, setUpdateId] = useState(0), chartContext = useRef({
        specFromChildren: {}
    });
    useImperativeHandle(ref, (() => {
        var _a;
        return null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.chart;
    }));
    const hasSpec = !!props.spec, [view, setView] = useState(null), isUnmount = useRef(!1), prevSpec = useRef(pickWithout(props, notSpecKeys)), eventsBinded = React.useRef(null), skipFunctionDiff = !!props.skipFunctionDiff, useSyncRender = !!props.useSyncRender, parseSpec = props => {
        var _a;
        return hasSpec && props.spec ? props.spec : Object.assign(Object.assign({}, prevSpec.current), null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.specFromChildren);
    }, handleChartRender = () => {
        if (!isUnmount.current) {
            if (!chartContext.current || !chartContext.current.chart) return;
            bindEventsToChart(chartContext.current.chart, props, eventsBinded.current, CHART_EVENTS);
            const newView = chartContext.current.chart.getCompiler().getVGrammarView();
            setUpdateId(updateId + 1), props.onReady && props.onReady(chartContext.current.chart, 0 === updateId), 
            setView(newView);
        }
    };
    return useEffect((() => {
        var _a;
        if (!(null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.chart)) return (props => {
            const cs = new props.vchartConstrouctor(parseSpec(props), Object.assign(Object.assign({}, props.options), {
                onError: props.onError,
                autoFit: !0,
                dom: props.container
            }));
            chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
                chart: cs
            });
        })(props), chartContext.current.chart && (useSyncRender ? (chartContext.current.chart.renderSync(), 
        handleChartRender()) : chartContext.current.chart.renderAsync().then(handleChartRender)), 
        bindEventsToChart(chartContext.current.chart, props, null, CHART_EVENTS), chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
            isChildrenUpdated: !1
        }), void (eventsBinded.current = props);
        if (hasSpec) return void (isEqual(eventsBinded.current.spec, props.spec, {
            skipFunction: skipFunctionDiff
        }) || (eventsBinded.current = props, useSyncRender ? (chartContext.current.chart.updateSpecSync(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }), handleChartRender()) : chartContext.current.chart.updateSpec(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }).then(handleChartRender)));
        const newSpec = pickWithout(props, notSpecKeys);
        isEqual(newSpec, prevSpec.current, {
            skipFunction: skipFunctionDiff
        }) && !chartContext.current.isChildrenUpdated || (prevSpec.current = newSpec, useSyncRender ? (chartContext.current.chart.updateSpecSync(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }), handleChartRender()) : chartContext.current.chart.updateSpec(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }).then(handleChartRender)), chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
            isChildrenUpdated: !1
        });
    }), [ props ]), useEffect((() => () => {
        chartContext && (chartContext.current.chart && chartContext.current.chart.release(), 
        chartContext.current = null), isUnmount.current = !0;
    }), []), React.createElement(RootChartContext.Provider, {
        value: chartContext.current
    }, React.createElement(ViewContext.Provider, {
        value: view
    }, toArray(props.children).map(((child, index) => {
        var _a, _b, _c;
        return React.createElement(React.Fragment, {
            key: null !== (_c = null !== (_b = null === (_a = null == child ? void 0 : child.props) || void 0 === _a ? void 0 : _a.id) && void 0 !== _b ? _b : null == child ? void 0 : child.id) && void 0 !== _c ? _c : `child-${index}`
        }, React.cloneElement(child, {
            updateId: updateId
        }));
    }))));
}));

export const createChart = (componentName, defaultProps, callback) => {
    const Com = withContainer(BaseChart, componentName, (props => callback ? callback(props, defaultProps) : defaultProps ? Object.assign(props, defaultProps) : props));
    return Com.displayName = componentName, Com;
};
//# sourceMappingURL=BaseChart.js.map