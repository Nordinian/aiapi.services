"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
}, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createChart = void 0;

const react_1 = __importStar(require("react")), withContainer_1 = __importDefault(require("../containers/withContainer")), chart_1 = __importDefault(require("../context/chart")), vutils_1 = require("@visactor/vutils"), view_1 = __importDefault(require("../context/view")), util_1 = require("../util"), constants_1 = require("../constants"), eventsUtils_1 = require("../eventsUtils"), notSpecKeys = [ ...constants_1.REACT_PRIVATE_PROPS, ...eventsUtils_1.CHART_EVENTS_KEYS, "skipFunctionDiff", "onError", "onReady", "spec", "container", "options" ], BaseChart = react_1.default.forwardRef(((props, ref) => {
    const [updateId, setUpdateId] = (0, react_1.useState)(0), chartContext = (0, react_1.useRef)({
        specFromChildren: {}
    });
    (0, react_1.useImperativeHandle)(ref, (() => {
        var _a;
        return null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.chart;
    }));
    const hasSpec = !!props.spec, [view, setView] = (0, react_1.useState)(null), isUnmount = (0, 
    react_1.useRef)(!1), prevSpec = (0, react_1.useRef)((0, vutils_1.pickWithout)(props, notSpecKeys)), eventsBinded = react_1.default.useRef(null), skipFunctionDiff = !!props.skipFunctionDiff, useSyncRender = !!props.useSyncRender, parseSpec = props => {
        var _a;
        return hasSpec && props.spec ? props.spec : Object.assign(Object.assign({}, prevSpec.current), null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.specFromChildren);
    }, handleChartRender = () => {
        if (!isUnmount.current) {
            if (!chartContext.current || !chartContext.current.chart) return;
            (0, eventsUtils_1.bindEventsToChart)(chartContext.current.chart, props, eventsBinded.current, eventsUtils_1.CHART_EVENTS);
            const newView = chartContext.current.chart.getCompiler().getVGrammarView();
            setUpdateId(updateId + 1), props.onReady && props.onReady(chartContext.current.chart, 0 === updateId), 
            setView(newView);
        }
    };
    return (0, react_1.useEffect)((() => {
        var _a;
        if (!(null === (_a = chartContext.current) || void 0 === _a ? void 0 : _a.chart)) return (props => {
            const cs = new props.vchartConstrouctor(parseSpec(props), Object.assign(Object.assign({}, props.options), {
                onError: props.onError,
                autoFit: !0,
                dom: props.container
            }));
            chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
                chart: cs
            });
        })(props), chartContext.current.chart && (useSyncRender ? (chartContext.current.chart.renderSync(), 
        handleChartRender()) : chartContext.current.chart.renderAsync().then(handleChartRender)), 
        (0, eventsUtils_1.bindEventsToChart)(chartContext.current.chart, props, null, eventsUtils_1.CHART_EVENTS), 
        chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
            isChildrenUpdated: !1
        }), void (eventsBinded.current = props);
        if (hasSpec) return void ((0, vutils_1.isEqual)(eventsBinded.current.spec, props.spec, {
            skipFunction: skipFunctionDiff
        }) || (eventsBinded.current = props, useSyncRender ? (chartContext.current.chart.updateSpecSync(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }), handleChartRender()) : chartContext.current.chart.updateSpec(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }).then(handleChartRender)));
        const newSpec = (0, vutils_1.pickWithout)(props, notSpecKeys);
        (0, vutils_1.isEqual)(newSpec, prevSpec.current, {
            skipFunction: skipFunctionDiff
        }) && !chartContext.current.isChildrenUpdated || (prevSpec.current = newSpec, useSyncRender ? (chartContext.current.chart.updateSpecSync(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }), handleChartRender()) : chartContext.current.chart.updateSpec(parseSpec(props), void 0, {
            morph: !1,
            enableExitAnimation: !1
        }).then(handleChartRender)), chartContext.current = Object.assign(Object.assign({}, chartContext.current), {
            isChildrenUpdated: !1
        });
    }), [ props ]), (0, react_1.useEffect)((() => () => {
        chartContext && (chartContext.current.chart && chartContext.current.chart.release(), 
        chartContext.current = null), isUnmount.current = !0;
    }), []), react_1.default.createElement(chart_1.default.Provider, {
        value: chartContext.current
    }, react_1.default.createElement(view_1.default.Provider, {
        value: view
    }, (0, util_1.toArray)(props.children).map(((child, index) => {
        var _a, _b, _c;
        return react_1.default.createElement(react_1.default.Fragment, {
            key: null !== (_c = null !== (_b = null === (_a = null == child ? void 0 : child.props) || void 0 === _a ? void 0 : _a.id) && void 0 !== _b ? _b : null == child ? void 0 : child.id) && void 0 !== _c ? _c : `child-${index}`
        }, react_1.default.cloneElement(child, {
            updateId: updateId
        }));
    }))));
})), createChart = (componentName, defaultProps, callback) => {
    const Com = (0, withContainer_1.default)(BaseChart, componentName, (props => callback ? callback(props, defaultProps) : defaultProps ? Object.assign(props, defaultProps) : props));
    return Com.displayName = componentName, Com;
};

exports.createChart = createChart;
//# sourceMappingURL=BaseChart.js.map