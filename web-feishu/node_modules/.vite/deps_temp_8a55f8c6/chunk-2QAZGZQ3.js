import {
  merge_default
} from "./chunk-7EWILLDK.js";
import {
  csvParse,
  dsv_default,
  tsvParse
} from "./chunk-XUX2WAK7.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-75NXEXD4.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a32, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j2;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a22);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a22, a32);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/topojson-server/src/object.js
var hasOwnProperty3;
var init_object = __esm({
  "node_modules/topojson-server/src/object.js"() {
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
  }
});

// node_modules/topojson-server/src/bounds.js
function bounds_default3(objects) {
  var x05 = Infinity, y05 = Infinity, x14 = -Infinity, y14 = -Infinity;
  function boundGeometry(geometry) {
    if (geometry != null && hasOwnProperty3.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
  }
  var boundGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(boundGeometry);
    },
    Point: function(o2) {
      boundPoint(o2.coordinates);
    },
    MultiPoint: function(o2) {
      o2.coordinates.forEach(boundPoint);
    },
    LineString: function(o2) {
      boundLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs.forEach(boundLine);
    },
    Polygon: function(o2) {
      o2.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o2) {
      o2.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    if (x3 < x05) x05 = x3;
    if (x3 > x14) x14 = x3;
    if (y3 < y05) y05 = y3;
    if (y3 > y14) y14 = y3;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key in objects) {
    boundGeometry(objects[key]);
  }
  return x14 >= x05 && y14 >= y05 ? [x05, y05, x14, y14] : void 0;
}
var init_bounds = __esm({
  "node_modules/topojson-server/src/bounds.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/hash/hashset.js
function hashset_default(size, hash, equal, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask = size - 1;
  for (var i2 = 0; i2 < size; ++i2) {
    store[i2] = empty;
  }
  function add2(value) {
    var index = hash(value) & mask, match = store[index], collisions = 0;
    while (match != empty) {
      if (equal(match, value)) return true;
      if (++collisions >= size) throw new Error("full hashset");
      match = store[index = index + 1 & mask];
    }
    store[index] = value;
    return true;
  }
  function has2(value) {
    var index = hash(value) & mask, match = store[index], collisions = 0;
    while (match != empty) {
      if (equal(match, value)) return true;
      if (++collisions >= size) break;
      match = store[index = index + 1 & mask];
    }
    return false;
  }
  function values() {
    var values2 = [];
    for (var i3 = 0, n2 = store.length; i3 < n2; ++i3) {
      var match = store[i3];
      if (match != empty) values2.push(match);
    }
    return values2;
  }
  return {
    add: add2,
    has: has2,
    values
  };
}
var init_hashset = __esm({
  "node_modules/topojson-server/src/hash/hashset.js"() {
  }
});

// node_modules/topojson-server/src/hash/hashmap.js
function hashmap_default(size, hash, equal, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask = size - 1;
  for (var i2 = 0; i2 < size; ++i2) {
    keystore[i2] = keyEmpty;
  }
  function set2(key, value) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index] = value;
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index = index + 1 & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }
  function maybeSet(key, value) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index];
      if (++collisions >= size) throw new Error("full hashmap");
      matchKey = keystore[index = index + 1 & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }
  function get2(key, missingValue) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key)) return valstore[index];
      if (++collisions >= size) break;
      matchKey = keystore[index = index + 1 & mask];
    }
    return missingValue;
  }
  function keys2() {
    var keys3 = [];
    for (var i3 = 0, n2 = keystore.length; i3 < n2; ++i3) {
      var matchKey = keystore[i3];
      if (matchKey != keyEmpty) keys3.push(matchKey);
    }
    return keys3;
  }
  return {
    set: set2,
    maybeSet,
    // set if unset
    get: get2,
    keys: keys2
  };
}
var init_hashmap = __esm({
  "node_modules/topojson-server/src/hash/hashmap.js"() {
  }
});

// node_modules/topojson-server/src/hash/point-equal.js
function point_equal_default(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}
var init_point_equal = __esm({
  "node_modules/topojson-server/src/hash/point-equal.js"() {
  }
});

// node_modules/topojson-server/src/hash/point-hash.js
function point_hash_default(point6) {
  floats[0] = point6[0];
  floats[1] = point6[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}
var buffer, floats, uints;
var init_point_hash = __esm({
  "node_modules/topojson-server/src/hash/point-hash.js"() {
    buffer = new ArrayBuffer(16);
    floats = new Float64Array(buffer);
    uints = new Uint32Array(buffer);
  }
});

// node_modules/topojson-server/src/join.js
function join_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i2, n2, previousIndex, currentIndex, nextIndex;
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    visitedByIndex[i2] = leftByIndex[i2] = rightByIndex[i2] = -1;
  }
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    var line2 = lines[i2], lineStart = line2[0], lineEnd = line2[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i2, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    visitedByIndex[i2] = -1;
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    var ring = rings[i2], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i2, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i2, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i3, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i3) return;
    visitedByIndex[currentIndex2] = i3;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index() {
    var indexByPoint = hashmap_default(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i3 = 0, n3 = coordinates.length; i3 < n3; ++i3) {
      indexes2[i3] = indexByPoint.maybeSet(i3, i3);
    }
    return indexes2;
  }
  function hashIndex(i3) {
    return point_hash_default(coordinates[i3]);
  }
  function equalIndex(i3, j3) {
    return point_equal_default(coordinates[i3], coordinates[j3]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset_default(junctionCount * 1.4, point_hash_default, point_equal_default), j2;
  for (i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
    if (junctionByIndex[j2 = indexes[i2]]) {
      junctionByPoint.add(coordinates[j2]);
    }
  }
  return junctionByPoint;
}
var init_join = __esm({
  "node_modules/topojson-server/src/join.js"() {
    init_hashset();
    init_hashmap();
    init_point_equal();
    init_point_hash();
  }
});

// node_modules/topojson-server/src/cut.js
function cut_default(topology) {
  var junctions = join_default(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next, i2, n2;
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    var line2 = lines[i2], lineMid = line2[0], lineEnd = line2[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next = { 0: lineMid, 1: line2[1] };
        line2[1] = lineMid;
        line2 = line2.next = next;
      }
    }
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    var ring = rings[i2], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology;
}
function rotateArray(array2, start, end, offset) {
  reverse(array2, start, end);
  reverse(array2, start, start + offset);
  reverse(array2, start + offset, end);
}
function reverse(array2, start, end) {
  for (var mid = start + (end-- - start >> 1), t2; start < mid; ++start, --end) {
    t2 = array2[start], array2[start] = array2[end], array2[end] = t2;
  }
}
var init_cut = __esm({
  "node_modules/topojson-server/src/cut.js"() {
    init_join();
  }
});

// node_modules/topojson-server/src/dedup.js
function dedup_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, line2, rings = topology.rings, ring, arcCount = lines.length + rings.length, i2, n2;
  delete topology.lines;
  delete topology.rings;
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    line2 = lines[i2];
    while (line2 = line2.next) ++arcCount;
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    ring = rings[i2];
    while (ring = ring.next) ++arcCount;
  }
  var arcsByEnd = hashmap_default(arcCount * 2 * 1.4, point_hash_default, point_equal_default), arcs = topology.arcs = [];
  for (i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    line2 = lines[i2];
    do {
      dedupLine(line2);
    } while (line2 = line2.next);
  }
  for (i2 = 0, n2 = rings.length; i2 < n2; ++i2) {
    ring = rings[i2];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i3, n3;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i3 = 0, n3 = startArcs.length; i3 < n3; ++i3) {
        startArc = startArcs[i3];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs) startArcs.push(arc);
    else arcsByEnd.set(startPoint, [arc]);
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i3, n3;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i3 = 0, n3 = endArcs.length; i3 < n3; ++i3) {
        endArc = endArcs[i3];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs) endArcs.push(arc);
    else arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, ++ib) if (!point_equal_default(coordinates[ia], coordinates[ib])) return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb) return false;
    for (; ia <= ja; ++ia, --jb) if (!point_equal_default(coordinates[ia], coordinates[jb])) return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n3 = ja - ia;
    if (n3 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i3 = 0; i3 < n3; ++i3) {
      if (!point_equal_default(coordinates[ia + (i3 + ka) % n3], coordinates[ib + (i3 + kb) % n3])) return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n3 = ja - ia;
    if (n3 !== jb - ib) return false;
    var ka = findMinimumOffset(arcA), kb = n3 - findMinimumOffset(arcB);
    for (var i3 = 0; i3 < n3; ++i3) {
      if (!point_equal_default(coordinates[ia + (i3 + ka) % n3], coordinates[jb - (i3 + kb) % n3])) return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point6 = coordinates[mid];
      if (point6[0] < minimumPoint[0] || point6[0] === minimumPoint[0] && point6[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point6;
      }
    }
    return minimum - start;
  }
  return topology;
}
var init_dedup = __esm({
  "node_modules/topojson-server/src/dedup.js"() {
    init_hashmap();
    init_point_equal();
    init_point_hash();
  }
});

// node_modules/topojson-server/src/delta.js
function delta_default(arcs) {
  var i2 = -1, n2 = arcs.length;
  while (++i2 < n2) {
    var arc = arcs[i2], j2 = 0, k3 = 1, m5 = arc.length, point6 = arc[0], x05 = point6[0], y05 = point6[1], x14, y14;
    while (++j2 < m5) {
      point6 = arc[j2], x14 = point6[0], y14 = point6[1];
      if (x14 !== x05 || y14 !== y05) arc[k3++] = [x14 - x05, y14 - y05], x05 = x14, y05 = y14;
    }
    if (k3 === 1) arc[k3++] = [0, 0];
    arc.length = k3;
  }
  return arcs;
}
var init_delta = __esm({
  "node_modules/topojson-server/src/delta.js"() {
  }
});

// node_modules/topojson-server/src/extract.js
function extract_default(objects) {
  var index = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry(geometry) {
    if (geometry && hasOwnProperty3.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
  }
  var extractGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(extractGeometry);
    },
    LineString: function(o2) {
      o2.arcs = extractLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(extractLine);
    },
    Polygon: function(o2) {
      o2.arcs = o2.arcs.map(extractRing);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line2) {
    for (var i2 = 0, n2 = line2.length; i2 < n2; ++i2) coordinates[++index] = line2[i2];
    var arc = { 0: index - n2 + 1, 1: index };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i2 = 0, n2 = ring.length; i2 < n2; ++i2) coordinates[++index] = ring[i2];
    var arc = { 0: index - n2 + 1, 1: index };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key in objects) {
    extractGeometry(objects[key]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}
var init_extract = __esm({
  "node_modules/topojson-server/src/extract.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/geometry.js
function geometry_default(inputs) {
  var outputs = {}, key;
  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key;
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  for (key in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null) return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
var init_geometry = __esm({
  "node_modules/topojson-server/src/geometry.js"() {
  }
});

// node_modules/topojson-server/src/prequantize.js
function prequantize_default(objects, bbox, n2) {
  var x05 = bbox[0], y05 = bbox[1], x14 = bbox[2], y14 = bbox[3], kx2 = x14 - x05 ? (n2 - 1) / (x14 - x05) : 1, ky2 = y14 - y05 ? (n2 - 1) / (y14 - y05) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x05) * kx2), Math.round((input[1] - y05) * ky2)];
  }
  function quantizePoints(input, m5) {
    var i2 = -1, j2 = 0, n3 = input.length, output = new Array(n3), pi4, px, py, x3, y3;
    while (++i2 < n3) {
      pi4 = input[i2];
      x3 = Math.round((pi4[0] - x05) * kx2);
      y3 = Math.round((pi4[1] - y05) * ky2);
      if (x3 !== px || y3 !== py) output[j2++] = [px = x3, py = y3];
    }
    output.length = j2;
    while (j2 < m5) j2 = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o2) {
    if (o2 != null && hasOwnProperty3.call(quantizeGeometryType, o2.type)) quantizeGeometryType[o2.type](o2);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(quantizeGeometry);
    },
    Point: function(o2) {
      o2.coordinates = quantizePoint(o2.coordinates);
    },
    MultiPoint: function(o2) {
      o2.coordinates = o2.coordinates.map(quantizePoint);
    },
    LineString: function(o2) {
      o2.arcs = quantizeLine(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(quantizeLine);
    },
    Polygon: function(o2) {
      o2.arcs = quantizePolygon(o2.arcs);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(quantizePolygon);
    }
  };
  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }
  return {
    scale: [1 / kx2, 1 / ky2],
    translate: [x05, y05]
  };
}
var init_prequantize = __esm({
  "node_modules/topojson-server/src/prequantize.js"() {
    init_object();
  }
});

// node_modules/topojson-server/src/topology.js
function topology_default(objects, quantization) {
  var bbox = bounds_default3(objects = geometry_default(objects)), transform29 = quantization > 0 && bbox && prequantize_default(objects, bbox, quantization), topology = dedup_default(cut_default(extract_default(objects))), coordinates = topology.coordinates, indexByArc = hashmap_default(topology.arcs.length * 1.4, hashArc, equalArc);
  objects = topology.objects;
  topology.bbox = bbox;
  topology.arcs = topology.arcs.map(function(arc, i2) {
    indexByArc.set(arc, i2);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology.coordinates;
  coordinates = null;
  function indexGeometry(geometry) {
    if (geometry && hasOwnProperty3.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
  }
  var indexGeometryType = {
    GeometryCollection: function(o2) {
      o2.geometries.forEach(indexGeometry);
    },
    LineString: function(o2) {
      o2.arcs = indexArcs(o2.arcs);
    },
    MultiLineString: function(o2) {
      o2.arcs = o2.arcs.map(indexArcs);
    },
    Polygon: function(o2) {
      o2.arcs = o2.arcs.map(indexArcs);
    },
    MultiPolygon: function(o2) {
      o2.arcs = o2.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index : ~index);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key in objects) {
    indexGeometry(objects[key]);
  }
  if (transform29) {
    topology.transform = transform29;
    topology.arcs = delta_default(topology.arcs);
  }
  return topology;
}
function hashArc(arc) {
  var i2 = arc[0], j2 = arc[1], t2;
  if (j2 < i2) t2 = i2, i2 = j2, j2 = t2;
  return i2 + 31 * j2;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t2;
  if (ja < ia) t2 = ia, ia = ja, ja = t2;
  if (jb < ib) t2 = ib, ib = jb, jb = t2;
  return ia === ib && ja === jb;
}
var init_topology = __esm({
  "node_modules/topojson-server/src/topology.js"() {
    init_bounds();
    init_cut();
    init_dedup();
    init_delta();
    init_extract();
    init_geometry();
    init_hashmap();
    init_object();
    init_prequantize();
  }
});

// node_modules/topojson-server/src/index.js
var src_exports = {};
__export(src_exports, {
  topology: () => topology_default
});
var init_src = __esm({
  "node_modules/topojson-server/src/index.js"() {
    init_topology();
  }
});

// node_modules/topojson-client/src/identity.js
function identity_default3(x3) {
  return x3;
}
var init_identity = __esm({
  "node_modules/topojson-client/src/identity.js"() {
  }
});

// node_modules/topojson-client/src/transform.js
function transform_default2(transform29) {
  if (transform29 == null) return identity_default3;
  var x05, y05, kx2 = transform29.scale[0], ky2 = transform29.scale[1], dx = transform29.translate[0], dy = transform29.translate[1];
  return function(input, i2) {
    if (!i2) x05 = y05 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2);
    output[0] = (x05 += input[0]) * kx2 + dx;
    output[1] = (y05 += input[1]) * ky2 + dy;
    while (j2 < n2) output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_transform = __esm({
  "node_modules/topojson-client/src/transform.js"() {
    init_identity();
  }
});

// node_modules/topojson-client/src/bbox.js
function bbox_default(topology) {
  var t2 = transform_default2(topology.transform), key, x05 = Infinity, y05 = x05, x14 = -x05, y14 = -x05;
  function bboxPoint(p2) {
    p2 = t2(p2);
    if (p2[0] < x05) x05 = p2[0];
    if (p2[0] > x14) x14 = p2[0];
    if (p2[1] < y05) y05 = p2[1];
    if (p2[1] > y14) y14 = p2[1];
  }
  function bboxGeometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(bboxGeometry);
        break;
      case "Point":
        bboxPoint(o2.coordinates);
        break;
      case "MultiPoint":
        o2.coordinates.forEach(bboxPoint);
        break;
    }
  }
  topology.arcs.forEach(function(arc) {
    var i2 = -1, n2 = arc.length, p2;
    while (++i2 < n2) {
      p2 = t2(arc[i2], i2);
      if (p2[0] < x05) x05 = p2[0];
      if (p2[0] > x14) x14 = p2[0];
      if (p2[1] < y05) y05 = p2[1];
      if (p2[1] > y14) y14 = p2[1];
    }
  });
  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }
  return [x05, y05, x14, y14];
}
var init_bbox = __esm({
  "node_modules/topojson-client/src/bbox.js"() {
    init_transform();
  }
});

// node_modules/topojson-client/src/reverse.js
function reverse_default(array2, n2) {
  var t2, j2 = array2.length, i2 = j2 - n2;
  while (i2 < --j2) t2 = array2[i2], array2[i2++] = array2[j2], array2[j2] = t2;
}
var init_reverse = __esm({
  "node_modules/topojson-client/src/reverse.js"() {
  }
});

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o2) {
  if (typeof o2 === "string") o2 = topology.objects[o2];
  return o2.type === "GeometryCollection" ? { type: "FeatureCollection", features: o2.geometries.map(function(o3) {
    return feature2(topology, o3);
  }) } : feature2(topology, o2);
}
function feature2(topology, o2) {
  var id2 = o2.id, bbox = o2.bbox, properties = o2.properties == null ? {} : o2.properties, geometry = object(topology, o2);
  return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
}
function object(topology, o2) {
  var transformPoint = transform_default2(topology.transform), arcs = topology.arcs;
  function arc(i2, points) {
    if (points.length) points.pop();
    for (var a4 = arcs[i2 < 0 ? ~i2 : i2], k3 = 0, n2 = a4.length; k3 < n2; ++k3) {
      points.push(transformPoint(a4[k3], k3));
    }
    if (i2 < 0) reverse_default(points, n2);
  }
  function point6(p2) {
    return transformPoint(p2);
  }
  function line2(arcs2) {
    var points = [];
    for (var i2 = 0, n2 = arcs2.length; i2 < n2; ++i2) arc(arcs2[i2], points);
    if (points.length < 2) points.push(points[0]);
    return points;
  }
  function ring(arcs2) {
    var points = line2(arcs2);
    while (points.length < 4) points.push(points[0]);
    return points;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o3) {
    var type = o3.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o3.geometries.map(geometry) };
      case "Point":
        coordinates = point6(o3.coordinates);
        break;
      case "MultiPoint":
        coordinates = o3.coordinates.map(point6);
        break;
      case "LineString":
        coordinates = line2(o3.arcs);
        break;
      case "MultiLineString":
        coordinates = o3.arcs.map(line2);
        break;
      case "Polygon":
        coordinates = polygon(o3.arcs);
        break;
      case "MultiPolygon":
        coordinates = o3.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry(o2);
}
var init_feature = __esm({
  "node_modules/topojson-client/src/feature.js"() {
    init_reverse();
    init_transform();
  }
});

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i2, j2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], t2;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t2 = arcs[++emptyIndex], arcs[emptyIndex] = i2, arcs[j2] = t2;
    }
  });
  arcs.forEach(function(i2) {
    var e3 = ends(i2), start = e3[0], end = e3[1], f2, g3;
    if (f2 = fragmentByEnd[start]) {
      delete fragmentByEnd[f2.end];
      f2.push(i2);
      f2.end = end;
      if (g3 = fragmentByStart[end]) {
        delete fragmentByStart[g3.start];
        var fg = g3 === f2 ? f2 : f2.concat(g3);
        fragmentByStart[fg.start = f2.start] = fragmentByEnd[fg.end = g3.end] = fg;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else if (f2 = fragmentByStart[end]) {
      delete fragmentByStart[f2.start];
      f2.unshift(i2);
      f2.start = start;
      if (g3 = fragmentByEnd[start]) {
        delete fragmentByEnd[g3.end];
        var gf = g3 === f2 ? f2 : g3.concat(f2);
        fragmentByStart[gf.start = g3.start] = fragmentByEnd[gf.end = f2.end] = gf;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else {
      f2 = [i2];
      fragmentByStart[f2.start = start] = fragmentByEnd[f2.end = end] = f2;
    }
  });
  function ends(i2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });
    else p1 = arc[arc.length - 1];
    return i2 < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k3 in fragmentByEnd2) {
      var f2 = fragmentByEnd2[k3];
      delete fragmentByStart2[f2.start];
      delete f2.start;
      delete f2.end;
      f2.forEach(function(i2) {
        stitchedArcs[i2 < 0 ? ~i2 : i2] = 1;
      });
      fragments.push(f2);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i2) {
    if (!stitchedArcs[i2 < 0 ? ~i2 : i2]) fragments.push([i2]);
  });
  return fragments;
}
var init_stitch = __esm({
  "node_modules/topojson-client/src/stitch.js"() {
  }
});

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter2) {
  var arcs, i2, n2;
  if (arguments.length > 1) arcs = extractArcs(topology, object2, filter2);
  else for (i2 = 0, arcs = new Array(n2 = topology.arcs.length); i2 < n2; ++i2) arcs[i2] = i2;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter2) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i2) {
    var j2 = i2 < 0 ? ~i2 : i2;
    (geomsByArc[j2] || (geomsByArc[j2] = [])).push({ i: i2, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o2) {
    switch (geom = o2, o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o2.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o2.arcs);
        break;
      case "MultiPolygon":
        extract3(o2.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter2 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter2(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}
var init_mesh = __esm({
  "node_modules/topojson-client/src/mesh.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i2 = -1, n2 = ring.length, a4, b2 = ring[n2 - 1], area2 = 0;
  while (++i2 < n2) a4 = b2, b2 = ring[i2], area2 += a4[0] * b2[1] - a4[1] * b2[0];
  return Math.abs(area2);
}
function merge_default2(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons = [], groups2 = [];
  objects.forEach(geometry);
  function geometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "Polygon":
        extract(o2.arcs);
        break;
      case "MultiPolygon":
        o2.arcs.forEach(extract);
        break;
    }
  }
  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }
  function area2(ring) {
    return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [], neighbors = [polygon];
      polygon._ = 1;
      groups2.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
              if (!polygon2._) {
                polygon2._ = 1;
                neighbors.push(polygon2);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function(polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups2.map(function(polygons2) {
      var arcs = [], n2;
      polygons2.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default(topology, arcs);
      if ((n2 = arcs.length) > 1) {
        for (var i2 = 1, k3 = area2(arcs[0]), ki, t2; i2 < n2; ++i2) {
          if ((ki = area2(arcs[i2])) > k3) {
            t2 = arcs[0], arcs[0] = arcs[i2], arcs[i2] = t2, k3 = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}
var init_merge = __esm({
  "node_modules/topojson-client/src/merge.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/topojson-client/src/bisect.js
function bisect_default(a4, x3) {
  var lo = 0, hi = a4.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a4[mid] < x3) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}
var init_bisect = __esm({
  "node_modules/topojson-client/src/bisect.js"() {
  }
});

// node_modules/topojson-client/src/neighbors.js
function neighbors_default(objects) {
  var indexesByArc = {}, neighbors = objects.map(function() {
    return [];
  });
  function line2(arcs, i3) {
    arcs.forEach(function(a4) {
      if (a4 < 0) a4 = ~a4;
      var o2 = indexesByArc[a4];
      if (o2) o2.push(i3);
      else indexesByArc[a4] = [i3];
    });
  }
  function polygon(arcs, i3) {
    arcs.forEach(function(arc) {
      line2(arc, i3);
    });
  }
  function geometry(o2, i3) {
    if (o2.type === "GeometryCollection") o2.geometries.forEach(function(o3) {
      geometry(o3, i3);
    });
    else if (o2.type in geometryType) geometryType[o2.type](o2.arcs, i3);
  }
  var geometryType = {
    LineString: line2,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i3) {
      arcs.forEach(function(arc) {
        polygon(arc, i3);
      });
    }
  };
  objects.forEach(geometry);
  for (var i2 in indexesByArc) {
    for (var indexes = indexesByArc[i2], m5 = indexes.length, j2 = 0; j2 < m5; ++j2) {
      for (var k3 = j2 + 1; k3 < m5; ++k3) {
        var ij = indexes[j2], ik = indexes[k3], n2;
        if ((n2 = neighbors[ij])[i2 = bisect_default(n2, ik)] !== ik) n2.splice(i2, 0, ik);
        if ((n2 = neighbors[ik])[i2 = bisect_default(n2, ij)] !== ij) n2.splice(i2, 0, ij);
      }
    }
  }
  return neighbors;
}
var init_neighbors = __esm({
  "node_modules/topojson-client/src/neighbors.js"() {
    init_bisect();
  }
});

// node_modules/topojson-client/src/untransform.js
function untransform_default(transform29) {
  if (transform29 == null) return identity_default3;
  var x05, y05, kx2 = transform29.scale[0], ky2 = transform29.scale[1], dx = transform29.translate[0], dy = transform29.translate[1];
  return function(input, i2) {
    if (!i2) x05 = y05 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2), x14 = Math.round((input[0] - dx) / kx2), y14 = Math.round((input[1] - dy) / ky2);
    output[0] = x14 - x05, x05 = x14;
    output[1] = y14 - y05, y05 = y14;
    while (j2 < n2) output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_untransform = __esm({
  "node_modules/topojson-client/src/untransform.js"() {
    init_identity();
  }
});

// node_modules/topojson-client/src/quantize.js
function quantize_default(topology, transform29) {
  if (topology.transform) throw new Error("already quantized");
  if (!transform29 || !transform29.scale) {
    if (!((n2 = Math.floor(transform29)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || bbox_default(topology);
    var x05 = box[0], y05 = box[1], x14 = box[2], y14 = box[3], n2;
    transform29 = { scale: [x14 - x05 ? (x14 - x05) / (n2 - 1) : 1, y14 - y05 ? (y14 - y05) / (n2 - 1) : 1], translate: [x05, y05] };
  } else {
    box = topology.bbox;
  }
  var t2 = untransform_default(transform29), box, key, inputs = topology.objects, outputs = {};
  function quantizePoint(point6) {
    return t2(point6);
  }
  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection":
        output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
        break;
      case "MultiPoint":
        output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
        break;
      default:
        return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }
  function quantizeArc(input) {
    var i2 = 0, j2 = 1, n3 = input.length, p2, output = new Array(n3);
    output[0] = t2(input[0], 0);
    while (++i2 < n3) if ((p2 = t2(input[i2], i2))[0] || p2[1]) output[j2++] = p2;
    if (j2 === 1) output[j2++] = [0, 0];
    output.length = j2;
    return output;
  }
  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);
  return {
    type: "Topology",
    bbox: box,
    transform: transform29,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}
var init_quantize = __esm({
  "node_modules/topojson-client/src/quantize.js"() {
    init_bbox();
    init_untransform();
  }
});

// node_modules/topojson-client/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  bbox: () => bbox_default,
  feature: () => feature_default,
  merge: () => merge_default2,
  mergeArcs: () => mergeArcs,
  mesh: () => mesh_default,
  meshArcs: () => meshArcs,
  neighbors: () => neighbors_default,
  quantize: () => quantize_default,
  transform: () => transform_default2,
  untransform: () => untransform_default
});
var init_src2 = __esm({
  "node_modules/topojson-client/src/index.js"() {
    init_bbox();
    init_feature();
    init_mesh();
    init_merge();
    init_neighbors();
    init_quantize();
    init_transform();
    init_untransform();
  }
});

// node_modules/geojson-linestring-dissolve/index.js
var require_geojson_linestring_dissolve = __commonJS({
  "node_modules/geojson-linestring-dissolve/index.js"(exports, module) {
    module.exports = mergeViableLineStrings;
    function coordId(coord) {
      return coord[0].toString() + "," + coord[1].toString();
    }
    function mergeLineStrings(a4, b2) {
      var s1 = coordId(a4.coordinates[0]);
      var e1 = coordId(a4.coordinates[a4.coordinates.length - 1]);
      var s22 = coordId(b2.coordinates[0]);
      var e24 = coordId(b2.coordinates[b2.coordinates.length - 1]);
      var coords;
      if (s1 === e24) {
        coords = b2.coordinates.concat(a4.coordinates.slice(1));
      } else if (s22 === e1) {
        coords = a4.coordinates.concat(b2.coordinates.slice(1));
      } else if (s1 === s22) {
        coords = a4.coordinates.slice(1).reverse().concat(b2.coordinates);
      } else if (e1 === e24) {
        coords = a4.coordinates.concat(b2.coordinates.reverse().slice(1));
      } else {
        return null;
      }
      return {
        type: "LineString",
        coordinates: coords
      };
    }
    function mergeViableLineStrings(geoms) {
      var lineStrings = geoms.slice();
      var result2 = [];
      while (lineStrings.length > 0) {
        var ls = lineStrings.shift();
        lineStrings = lineStrings.reduce(function(accum, cur) {
          var merged = mergeLineStrings(ls, cur);
          if (merged) {
            ls = merged;
          } else {
            accum.push(cur);
          }
          return accum;
        }, []);
        result2.push(ls);
      }
      if (result2.length === 1) {
        result2 = result2[0];
      } else {
        result2 = {
          type: "MultiLineString",
          coordinates: result2.map(function(ls2) {
            return ls2.coordinates;
          })
        };
      }
      return result2;
    }
  }
});

// node_modules/geojson-dissolve/node_modules/@turf/meta/index.js
var require_meta = __commonJS({
  "node_modules/geojson-dissolve/node_modules/@turf/meta/index.js"(exports, module) {
    function coordEach(layer, callback, excludeWrapCoord) {
      var i2, j2, k3, g3, l2, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, currentIndex = 0, isGeometryCollection, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
      for (i2 = 0; i2 < stop; i2++) {
        geometryMaybeCollection = isFeatureCollection ? layer.features[i2].geometry : isFeature ? layer.geometry : layer;
        isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g3 = 0; g3 < stopG; g3++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
          coords = geometry.coordinates;
          wrapShrink = excludeWrapCoord && (geometry.type === "Polygon" || geometry.type === "MultiPolygon") ? 1 : 0;
          if (geometry.type === "Point") {
            callback(coords, currentIndex);
            currentIndex++;
          } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
            for (j2 = 0; j2 < coords.length; j2++) {
              callback(coords[j2], currentIndex);
              currentIndex++;
            }
          } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
            for (j2 = 0; j2 < coords.length; j2++)
              for (k3 = 0; k3 < coords[j2].length - wrapShrink; k3++) {
                callback(coords[j2][k3], currentIndex);
                currentIndex++;
              }
          } else if (geometry.type === "MultiPolygon") {
            for (j2 = 0; j2 < coords.length; j2++)
              for (k3 = 0; k3 < coords[j2].length; k3++)
                for (l2 = 0; l2 < coords[j2][k3].length - wrapShrink; l2++) {
                  callback(coords[j2][k3][l2], currentIndex);
                  currentIndex++;
                }
          } else if (geometry.type === "GeometryCollection") {
            for (j2 = 0; j2 < geometry.geometries.length; j2++)
              coordEach(geometry.geometries[j2], callback, excludeWrapCoord);
          } else {
            throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    module.exports.coordEach = coordEach;
    function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(layer, function(currentCoords, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentCoords;
        } else {
          previousValue = callback(previousValue, currentCoords, currentIndex);
        }
      }, excludeWrapCoord);
      return previousValue;
    }
    module.exports.coordReduce = coordReduce;
    function propEach(layer, callback) {
      var i2;
      switch (layer.type) {
        case "FeatureCollection":
          for (i2 = 0; i2 < layer.features.length; i2++) {
            callback(layer.features[i2].properties, i2);
          }
          break;
        case "Feature":
          callback(layer.properties, 0);
          break;
      }
    }
    module.exports.propEach = propEach;
    function propReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      propEach(layer, function(currentProperties, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentProperties;
        } else {
          previousValue = callback(previousValue, currentProperties, currentIndex);
        }
      });
      return previousValue;
    }
    module.exports.propReduce = propReduce;
    function featureEach2(layer, callback) {
      if (layer.type === "Feature") {
        callback(layer, 0);
      } else if (layer.type === "FeatureCollection") {
        for (var i2 = 0; i2 < layer.features.length; i2++) {
          callback(layer.features[i2], i2);
        }
      }
    }
    module.exports.featureEach = featureEach2;
    function featureReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      featureEach2(layer, function(currentFeature, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentFeature;
        } else {
          previousValue = callback(previousValue, currentFeature, currentIndex);
        }
      });
      return previousValue;
    }
    module.exports.featureReduce = featureReduce;
    function coordAll(layer) {
      var coords = [];
      coordEach(layer, function(coord) {
        coords.push(coord);
      });
      return coords;
    }
    module.exports.coordAll = coordAll;
    function geomEach2(layer, callback) {
      var i2, j2, g3, geometry, stopG, geometryMaybeCollection, isGeometryCollection, currentIndex = 0, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
      for (i2 = 0; i2 < stop; i2++) {
        geometryMaybeCollection = isFeatureCollection ? layer.features[i2].geometry : isFeature ? layer.geometry : layer;
        isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g3 = 0; g3 < stopG; g3++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
          if (geometry.type === "Point" || geometry.type === "LineString" || geometry.type === "MultiPoint" || geometry.type === "Polygon" || geometry.type === "MultiLineString" || geometry.type === "MultiPolygon") {
            callback(geometry, currentIndex);
            currentIndex++;
          } else if (geometry.type === "GeometryCollection") {
            for (j2 = 0; j2 < geometry.geometries.length; j2++) {
              callback(geometry.geometries[j2], currentIndex);
              currentIndex++;
            }
          } else {
            throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    module.exports.geomEach = geomEach2;
    function geomReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      geomEach2(layer, function(currentGeometry, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) {
          previousValue = currentGeometry;
        } else {
          previousValue = callback(previousValue, currentGeometry, currentIndex);
        }
      });
      return previousValue;
    }
    module.exports.geomReduce = geomReduce;
  }
});

// node_modules/geojson-flatten/dist/index.js
var require_dist = __commonJS({
  "node_modules/geojson-flatten/dist/index.js"(exports, module) {
    module.exports = function e3(t2) {
      switch (t2 && t2.type || null) {
        case "FeatureCollection":
          return t2.features = t2.features.reduce(function(t3, r2) {
            return t3.concat(e3(r2));
          }, []), t2;
        case "Feature":
          return t2.geometry ? e3(t2.geometry).map(function(e4) {
            var r2 = { type: "Feature", properties: JSON.parse(JSON.stringify(t2.properties)), geometry: e4 };
            return void 0 !== t2.id && (r2.id = t2.id), r2;
          }) : t2;
        case "MultiPoint":
          return t2.coordinates.map(function(e4) {
            return { type: "Point", coordinates: e4 };
          });
        case "MultiPolygon":
          return t2.coordinates.map(function(e4) {
            return { type: "Polygon", coordinates: e4 };
          });
        case "MultiLineString":
          return t2.coordinates.map(function(e4) {
            return { type: "LineString", coordinates: e4 };
          });
        case "GeometryCollection":
          return t2.geometries.map(e3).reduce(function(e4, t3) {
            return e4.concat(t3);
          }, []);
        case "Point":
        case "Polygon":
        case "LineString":
          return [t2];
      }
    };
  }
});

// node_modules/geojson-dissolve/index.js
var require_geojson_dissolve = __commonJS({
  "node_modules/geojson-dissolve/index.js"(exports, module) {
    var createTopology = (init_src(), __toCommonJS(src_exports)).topology;
    var mergeTopology = (init_src2(), __toCommonJS(src_exports2)).merge;
    var dissolveLineStrings = require_geojson_linestring_dissolve();
    var geomEach2 = require_meta().geomEach;
    var flatten3 = require_dist();
    module.exports = dissolve2;
    function toArray(args) {
      if (!args.length) return [];
      return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args);
    }
    function dissolvePolygons(geoms) {
      var objects = {
        geoms: {
          type: "GeometryCollection",
          geometries: JSON.parse(JSON.stringify(geoms))
        }
      };
      var topo = createTopology(objects);
      return mergeTopology(topo, topo.objects.geoms.geometries);
    }
    function getHomogenousType(geoms) {
      var type = null;
      for (var i2 = 0; i2 < geoms.length; i2++) {
        if (!type) {
          type = geoms[i2].type;
        } else if (type !== geoms[i2].type) {
          return null;
        }
      }
      return type;
    }
    function dissolve2() {
      var objects = toArray(arguments);
      var geoms = objects.reduce(function(acc, o2) {
        var flat = flatten3(o2);
        if (!Array.isArray(flat)) flat = [flat];
        for (var i2 = 0; i2 < flat.length; i2++) {
          geomEach2(flat[i2], function(geom) {
            acc.push(geom);
          });
        }
        return acc;
      }, []);
      var type = getHomogenousType(geoms);
      if (!type) {
        throw new Error("List does not contain only homoegenous GeoJSON");
      }
      switch (type) {
        case "LineString":
          return dissolveLineStrings(geoms);
        case "Polygon":
          return dissolvePolygons(geoms);
        default:
          return geoms;
      }
    }
  }
});

// node_modules/simplify-geometry/lib/line.js
var require_line = __commonJS({
  "node_modules/simplify-geometry/lib/line.js"(exports, module) {
    var Line3 = function(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
    };
    Line3.prototype.rise = function() {
      return this.p2[1] - this.p1[1];
    };
    Line3.prototype.run = function() {
      return this.p2[0] - this.p1[0];
    };
    Line3.prototype.slope = function() {
      return this.rise() / this.run();
    };
    Line3.prototype.yIntercept = function() {
      return this.p1[1] - this.p1[0] * this.slope(this.p1, this.p2);
    };
    Line3.prototype.isVertical = function() {
      return !isFinite(this.slope());
    };
    Line3.prototype.isHorizontal = function() {
      return this.p1[1] == this.p2[1];
    };
    Line3.prototype._perpendicularDistanceHorizontal = function(point6) {
      return Math.abs(this.p1[1] - point6[1]);
    };
    Line3.prototype._perpendicularDistanceVertical = function(point6) {
      return Math.abs(this.p1[0] - point6[0]);
    };
    Line3.prototype._perpendicularDistanceHasSlope = function(point6) {
      var slope = this.slope();
      var y_intercept = this.yIntercept();
      return Math.abs(slope * point6[0] - point6[1] + y_intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
    };
    Line3.prototype.perpendicularDistance = function(point6) {
      if (this.isVertical()) {
        return this._perpendicularDistanceVertical(point6);
      } else if (this.isHorizontal()) {
        return this._perpendicularDistanceHorizontal(point6);
      } else {
        return this._perpendicularDistanceHasSlope(point6);
      }
    };
    module.exports = Line3;
  }
});

// node_modules/simplify-geometry/lib/index.js
var require_lib = __commonJS({
  "node_modules/simplify-geometry/lib/index.js"(exports, module) {
    var Line3 = require_line();
    var simplifyGeometry = function(points, tolerance) {
      var dmax = 0;
      var index = 0;
      for (var i2 = 1; i2 <= points.length - 2; i2++) {
        var d2 = new Line3(points[0], points[points.length - 1]).perpendicularDistance(points[i2]);
        if (d2 > dmax) {
          index = i2;
          dmax = d2;
        }
      }
      if (dmax > tolerance) {
        var results_one = simplifyGeometry(points.slice(0, index), tolerance);
        var results_two = simplifyGeometry(points.slice(index, points.length), tolerance);
        var results = results_one.concat(results_two);
      } else if (points.length > 1) {
        results = [points[0], points[points.length - 1]];
      } else {
        results = [points[0]];
      }
      return results;
    };
    module.exports = simplifyGeometry;
  }
});

// node_modules/simplify-geojson/index.js
var require_simplify_geojson = __commonJS({
  "node_modules/simplify-geojson/index.js"(exports, module) {
    var simplify2 = require_lib();
    module.exports = function(geojson, tolerance, dontClone) {
      if (!dontClone) geojson = JSON.parse(JSON.stringify(geojson));
      if (geojson.features) return simplifyFeatureCollection(geojson, tolerance);
      else if (geojson.type && geojson.type === "Feature") return simplifyFeature(geojson, tolerance);
      else return new Error("FeatureCollection or individual Feature required");
    };
    module.exports.simplify = function(coordinates, tolerance) {
      return simplify2(coordinates, tolerance);
    };
    function simplifyFeature(feat, tolerance) {
      var geom = feat.geometry;
      var type = geom.type;
      if (type === "LineString") {
        geom.coordinates = module.exports.simplify(geom.coordinates, tolerance);
      } else if (type === "Polygon" || type === "MultiLineString") {
        for (var j2 = 0; j2 < geom.coordinates.length; j2++) {
          geom.coordinates[j2] = module.exports.simplify(geom.coordinates[j2], tolerance);
        }
      } else if (type === "MultiPolygon") {
        for (var k3 = 0; k3 < geom.coordinates.length; k3++) {
          for (var l2 = 0; l2 < geom.coordinates[k3].length; l2++) {
            geom.coordinates[k3][l2] = module.exports.simplify(geom.coordinates[k3][l2], tolerance);
          }
        }
      }
      return feat;
    }
    function simplifyFeatureCollection(fc, tolerance) {
      for (var i2 = 0; i2 < fc.features.length; i2++) {
        fc.features[i2] = simplifyFeature(fc.features[i2], tolerance);
      }
      return fc;
    }
  }
});

// node_modules/geobuf/encode.js
var require_encode = __commonJS({
  "node_modules/geobuf/encode.js"(exports, module) {
    "use strict";
    module.exports = encode;
    var keys2;
    var keysNum;
    var keysArr;
    var dim;
    var e3;
    var maxPrecision = 1e6;
    var geometryTypes = {
      "Point": 0,
      "MultiPoint": 1,
      "LineString": 2,
      "MultiLineString": 3,
      "Polygon": 4,
      "MultiPolygon": 5,
      "GeometryCollection": 6
    };
    function encode(obj, pbf) {
      keys2 = {};
      keysArr = [];
      keysNum = 0;
      dim = 0;
      e3 = 1;
      analyze(obj);
      e3 = Math.min(e3, maxPrecision);
      var precision = Math.ceil(Math.log(e3) / Math.LN10);
      for (var i2 = 0; i2 < keysArr.length; i2++) pbf.writeStringField(1, keysArr[i2]);
      if (dim !== 2) pbf.writeVarintField(2, dim);
      if (precision !== 6) pbf.writeVarintField(3, precision);
      if (obj.type === "FeatureCollection") pbf.writeMessage(4, writeFeatureCollection, obj);
      else if (obj.type === "Feature") pbf.writeMessage(5, writeFeature, obj);
      else pbf.writeMessage(6, writeGeometry, obj);
      keys2 = null;
      return pbf.finish();
    }
    function analyze(obj) {
      var i2, key;
      if (obj.type === "FeatureCollection") {
        for (i2 = 0; i2 < obj.features.length; i2++) analyze(obj.features[i2]);
      } else if (obj.type === "Feature") {
        if (obj.geometry !== null) analyze(obj.geometry);
        for (key in obj.properties) saveKey(key);
      } else if (obj.type === "Point") analyzePoint(obj.coordinates);
      else if (obj.type === "MultiPoint") analyzePoints(obj.coordinates);
      else if (obj.type === "GeometryCollection") {
        for (i2 = 0; i2 < obj.geometries.length; i2++) analyze(obj.geometries[i2]);
      } else if (obj.type === "LineString") analyzePoints(obj.coordinates);
      else if (obj.type === "Polygon" || obj.type === "MultiLineString") analyzeMultiLine(obj.coordinates);
      else if (obj.type === "MultiPolygon") {
        for (i2 = 0; i2 < obj.coordinates.length; i2++) analyzeMultiLine(obj.coordinates[i2]);
      }
      for (key in obj) {
        if (!isSpecialKey(key, obj.type)) saveKey(key);
      }
    }
    function analyzeMultiLine(coords) {
      for (var i2 = 0; i2 < coords.length; i2++) analyzePoints(coords[i2]);
    }
    function analyzePoints(coords) {
      for (var i2 = 0; i2 < coords.length; i2++) analyzePoint(coords[i2]);
    }
    function analyzePoint(point6) {
      dim = Math.max(dim, point6.length);
      for (var i2 = 0; i2 < point6.length; i2++) {
        while (Math.round(point6[i2] * e3) / e3 !== point6[i2] && e3 < maxPrecision) e3 *= 10;
      }
    }
    function saveKey(key) {
      if (keys2[key] === void 0) {
        keysArr.push(key);
        keys2[key] = keysNum++;
      }
    }
    function writeFeatureCollection(obj, pbf) {
      for (var i2 = 0; i2 < obj.features.length; i2++) {
        pbf.writeMessage(1, writeFeature, obj.features[i2]);
      }
      writeProps(obj, pbf, true);
    }
    function writeFeature(feature3, pbf) {
      if (feature3.geometry !== null) pbf.writeMessage(1, writeGeometry, feature3.geometry);
      if (feature3.id !== void 0) {
        if (typeof feature3.id === "number" && feature3.id % 1 === 0) pbf.writeSVarintField(12, feature3.id);
        else pbf.writeStringField(11, feature3.id);
      }
      if (feature3.properties) writeProps(feature3.properties, pbf);
      writeProps(feature3, pbf, true);
    }
    function writeGeometry(geom, pbf) {
      pbf.writeVarintField(1, geometryTypes[geom.type]);
      var coords = geom.coordinates;
      if (geom.type === "Point") writePoint(coords, pbf);
      else if (geom.type === "MultiPoint") writeLine(coords, pbf, true);
      else if (geom.type === "LineString") writeLine(coords, pbf);
      else if (geom.type === "MultiLineString") writeMultiLine(coords, pbf);
      else if (geom.type === "Polygon") writeMultiLine(coords, pbf, true);
      else if (geom.type === "MultiPolygon") writeMultiPolygon(coords, pbf);
      else if (geom.type === "GeometryCollection") {
        for (var i2 = 0; i2 < geom.geometries.length; i2++) pbf.writeMessage(4, writeGeometry, geom.geometries[i2]);
      }
      writeProps(geom, pbf, true);
    }
    function writeProps(props, pbf, isCustom) {
      var indexes = [], valueIndex = 0;
      for (var key in props) {
        if (isCustom && isSpecialKey(key, props.type)) {
          continue;
        }
        pbf.writeMessage(13, writeValue, props[key]);
        indexes.push(keys2[key]);
        indexes.push(valueIndex++);
      }
      pbf.writePackedVarint(isCustom ? 15 : 14, indexes);
    }
    function writeValue(value, pbf) {
      if (value === null) return;
      var type = typeof value;
      if (type === "string") pbf.writeStringField(1, value);
      else if (type === "boolean") pbf.writeBooleanField(5, value);
      else if (type === "object") pbf.writeStringField(6, JSON.stringify(value));
      else if (type === "number") {
        if (value % 1 !== 0) pbf.writeDoubleField(2, value);
        else if (value >= 0) pbf.writeVarintField(3, value);
        else pbf.writeVarintField(4, -value);
      }
    }
    function writePoint(point6, pbf) {
      var coords = [];
      for (var i2 = 0; i2 < dim; i2++) coords.push(Math.round(point6[i2] * e3));
      pbf.writePackedSVarint(3, coords);
    }
    function writeLine(line2, pbf) {
      var coords = [];
      populateLine(coords, line2);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiLine(lines, pbf, closed) {
      var len = lines.length, i2;
      if (len !== 1) {
        var lengths = [];
        for (i2 = 0; i2 < len; i2++) lengths.push(lines[i2].length - (closed ? 1 : 0));
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i2 = 0; i2 < len; i2++) populateLine(coords, lines[i2], closed);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiPolygon(polygons, pbf) {
      var len = polygons.length, i2, j2;
      if (len !== 1 || polygons[0].length !== 1) {
        var lengths = [len];
        for (i2 = 0; i2 < len; i2++) {
          lengths.push(polygons[i2].length);
          for (j2 = 0; j2 < polygons[i2].length; j2++) lengths.push(polygons[i2][j2].length - 1);
        }
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i2 = 0; i2 < len; i2++) {
        for (j2 = 0; j2 < polygons[i2].length; j2++) populateLine(coords, polygons[i2][j2], true);
      }
      pbf.writePackedSVarint(3, coords);
    }
    function populateLine(coords, line2, closed) {
      var i2, j2, len = line2.length - (closed ? 1 : 0), sum5 = new Array(dim);
      for (j2 = 0; j2 < dim; j2++) sum5[j2] = 0;
      for (i2 = 0; i2 < len; i2++) {
        for (j2 = 0; j2 < dim; j2++) {
          var n2 = Math.round(line2[i2][j2] * e3) - sum5[j2];
          coords.push(n2);
          sum5[j2] += n2;
        }
      }
    }
    function isSpecialKey(key, type) {
      if (key === "type") return true;
      else if (type === "FeatureCollection") {
        if (key === "features") return true;
      } else if (type === "Feature") {
        if (key === "id" || key === "properties" || key === "geometry") return true;
      } else if (type === "GeometryCollection") {
        if (key === "geometries") return true;
      } else if (key === "coordinates") return true;
      return false;
    }
  }
});

// node_modules/geobuf/decode.js
var require_decode = __commonJS({
  "node_modules/geobuf/decode.js"(exports, module) {
    "use strict";
    module.exports = decode2;
    var keys2;
    var values;
    var lengths;
    var dim;
    var e3;
    var geometryTypes = [
      "Point",
      "MultiPoint",
      "LineString",
      "MultiLineString",
      "Polygon",
      "MultiPolygon",
      "GeometryCollection"
    ];
    function decode2(pbf) {
      dim = 2;
      e3 = Math.pow(10, 6);
      lengths = null;
      keys2 = [];
      values = [];
      var obj = pbf.readFields(readDataField, {});
      keys2 = null;
      return obj;
    }
    function readDataField(tag, obj, pbf) {
      if (tag === 1) keys2.push(pbf.readString());
      else if (tag === 2) dim = pbf.readVarint();
      else if (tag === 3) e3 = Math.pow(10, pbf.readVarint());
      else if (tag === 4) readFeatureCollection(pbf, obj);
      else if (tag === 5) readFeature(pbf, obj);
      else if (tag === 6) readGeometry(pbf, obj);
    }
    function readFeatureCollection(pbf, obj) {
      obj.type = "FeatureCollection";
      obj.features = [];
      return pbf.readMessage(readFeatureCollectionField, obj);
    }
    function readFeature(pbf, feature3) {
      feature3.type = "Feature";
      var f2 = pbf.readMessage(readFeatureField, feature3);
      if (!("geometry" in f2)) f2.geometry = null;
      return f2;
    }
    function readGeometry(pbf, geom) {
      geom.type = "Point";
      return pbf.readMessage(readGeometryField, geom);
    }
    function readFeatureCollectionField(tag, obj, pbf) {
      if (tag === 1) obj.features.push(readFeature(pbf, {}));
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, obj);
    }
    function readFeatureField(tag, feature3, pbf) {
      if (tag === 1) feature3.geometry = readGeometry(pbf, {});
      else if (tag === 11) feature3.id = pbf.readString();
      else if (tag === 12) feature3.id = pbf.readSVarint();
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 14) feature3.properties = readProps(pbf, {});
      else if (tag === 15) readProps(pbf, feature3);
    }
    function readGeometryField(tag, geom, pbf) {
      if (tag === 1) geom.type = geometryTypes[pbf.readVarint()];
      else if (tag === 2) lengths = pbf.readPackedVarint();
      else if (tag === 3) readCoords(geom, pbf, geom.type);
      else if (tag === 4) {
        geom.geometries = geom.geometries || [];
        geom.geometries.push(readGeometry(pbf, {}));
      } else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, geom);
    }
    function readCoords(geom, pbf, type) {
      if (type === "Point") geom.coordinates = readPoint(pbf);
      else if (type === "MultiPoint") geom.coordinates = readLine(pbf, true);
      else if (type === "LineString") geom.coordinates = readLine(pbf);
      else if (type === "MultiLineString") geom.coordinates = readMultiLine(pbf);
      else if (type === "Polygon") geom.coordinates = readMultiLine(pbf, true);
      else if (type === "MultiPolygon") geom.coordinates = readMultiPolygon(pbf);
    }
    function readValue(pbf) {
      var end = pbf.readVarint() + pbf.pos, value = null;
      while (pbf.pos < end) {
        var val = pbf.readVarint(), tag = val >> 3;
        if (tag === 1) value = pbf.readString();
        else if (tag === 2) value = pbf.readDouble();
        else if (tag === 3) value = pbf.readVarint();
        else if (tag === 4) value = -pbf.readVarint();
        else if (tag === 5) value = pbf.readBoolean();
        else if (tag === 6) value = JSON.parse(pbf.readString());
      }
      return value;
    }
    function readProps(pbf, props) {
      var end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) props[keys2[pbf.readVarint()]] = values[pbf.readVarint()];
      values = [];
      return props;
    }
    function readPoint(pbf) {
      var end = pbf.readVarint() + pbf.pos, coords = [];
      while (pbf.pos < end) coords.push(pbf.readSVarint() / e3);
      return coords;
    }
    function readLinePart(pbf, end, len, closed) {
      var i2 = 0, coords = [], p2, d2;
      var prevP = [];
      for (d2 = 0; d2 < dim; d2++) prevP[d2] = 0;
      while (len ? i2 < len : pbf.pos < end) {
        p2 = [];
        for (d2 = 0; d2 < dim; d2++) {
          prevP[d2] += pbf.readSVarint();
          p2[d2] = prevP[d2] / e3;
        }
        coords.push(p2);
        i2++;
      }
      if (closed) coords.push(coords[0]);
      return coords;
    }
    function readLine(pbf) {
      return readLinePart(pbf, pbf.readVarint() + pbf.pos);
    }
    function readMultiLine(pbf, closed) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [readLinePart(pbf, end, null, closed)];
      var coords = [];
      for (var i2 = 0; i2 < lengths.length; i2++) coords.push(readLinePart(pbf, end, lengths[i2], closed));
      lengths = null;
      return coords;
    }
    function readMultiPolygon(pbf) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [[readLinePart(pbf, end, null, true)]];
      var coords = [];
      var j2 = 1;
      for (var i2 = 0; i2 < lengths[0]; i2++) {
        var rings = [];
        for (var k3 = 0; k3 < lengths[j2]; k3++) rings.push(readLinePart(pbf, end, lengths[j2 + 1 + k3], true));
        j2 += lengths[j2] + 1;
        coords.push(rings);
      }
      lengths = null;
      return coords;
    }
  }
});

// node_modules/geobuf/index.js
var require_geobuf = __commonJS({
  "node_modules/geobuf/index.js"(exports) {
    "use strict";
    exports.encode = require_encode();
    exports.decode = require_decode();
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e3, m5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s3 = buffer2[offset + i2];
      i2 += d2;
      e3 = s3 & (1 << -nBits) - 1;
      s3 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      m5 = e3 & (1 << -nBits) - 1;
      e3 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m5 = m5 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e3 === 0) {
        e3 = 1 - eBias;
      } else if (e3 === eMax) {
        return m5 ? NaN : (s3 ? -1 : 1) * Infinity;
      } else {
        m5 = m5 + Math.pow(2, mLen);
        e3 = e3 - eBias;
      }
      return (s3 ? -1 : 1) * m5 * Math.pow(2, e3 - mLen);
    };
    exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e3, m5, c4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m5 = isNaN(value) ? 1 : 0;
        e3 = eMax;
      } else {
        e3 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c4 = Math.pow(2, -e3)) < 1) {
          e3--;
          c4 *= 2;
        }
        if (e3 + eBias >= 1) {
          value += rt / c4;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c4 >= 2) {
          e3++;
          c4 /= 2;
        }
        if (e3 + eBias >= eMax) {
          m5 = 0;
          e3 = eMax;
        } else if (e3 + eBias >= 1) {
          m5 = (value * c4 - 1) * Math.pow(2, mLen);
          e3 = e3 + eBias;
        } else {
          m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e3 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m5 & 255, i2 += d2, m5 /= 256, mLen -= 8) {
      }
      e3 = e3 << mLen | m5;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d2] |= s3 * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf2;
    var ieee754 = require_ieee754();
    function Pbf2(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf2.Varint = 0;
    Pbf2.Fixed64 = 1;
    Pbf2.Bytes = 2;
    Pbf2.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    Pbf2.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result2, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result2, this);
          if (this.pos === startPos) this.skip(val);
        }
        return result2;
      },
      readMessage: function(readField, result2) {
        return this.readFields(readField, result2, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b2;
        b2 = buf[this.pos++];
        val = b2 & 127;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 7;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 14;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 21;
        if (b2 < 128) return val;
        b2 = buf[this.pos];
        val |= (b2 & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer2;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf2.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf2.Varint) while (this.buf[this.pos++] > 127) {
        }
        else if (type === Pbf2.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf2.Fixed32) this.pos += 4;
        else if (type === Pbf2.Fixed64) this.pos += 8;
        else throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min4) {
        var length2 = this.length || 16;
        while (length2 < this.pos + min4) length2 *= 2;
        if (length2 !== this.length) {
          var buf = new Uint8Array(length2);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length2;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128) makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer2) {
        var len = buffer2.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i2 = 0; i2 < len; i2++) this.buf[this.pos++] = buffer2[i2];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128) makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf2.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer2) {
        this.writeTag(tag, Pbf2.Bytes);
        this.writeBytes(buffer2);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf2.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf2.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf2.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf2.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l2, s3, p2) {
      var buf = p2.buf, h2, b2;
      b2 = buf[p2.pos++];
      h2 = (b2 & 112) >> 4;
      if (b2 < 128) return toNum(l2, h2, s3);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 3;
      if (b2 < 128) return toNum(l2, h2, s3);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 10;
      if (b2 < 128) return toNum(l2, h2, s3);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 17;
      if (b2 < 128) return toNum(l2, h2, s3);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 127) << 24;
      if (b2 < 128) return toNum(l2, h2, s3);
      b2 = buf[p2.pos++];
      h2 |= (b2 & 1) << 31;
      if (b2 < 128) return toNum(l2, h2, s3);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf2.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i2 = pbf.pos - 1; i2 >= startPos; i2--) pbf.buf[i2 + extraLen] = pbf.buf[i2];
    }
    function writePackedVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeVarint(arr[i2]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSVarint(arr[i2]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFloat(arr[i2]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeDouble(arr[i2]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeBoolean(arr[i2]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFixed32(arr[i2]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSFixed32(arr[i2]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeFixed64(arr[i2]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++) pbf.writeSFixed64(arr[i2]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i2 = pos;
      while (i2 < end) {
        var b0 = buf[i2];
        var c4 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i2 + bytesPerSequence > end) break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c4 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i2 + 1];
          if ((b1 & 192) === 128) {
            c4 = (b0 & 31) << 6 | b1 & 63;
            if (c4 <= 127) {
              c4 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c4 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c4 <= 2047 || c4 >= 55296 && c4 <= 57343) {
              c4 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          b3 = buf[i2 + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c4 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c4 <= 65535 || c4 >= 1114112) {
              c4 = null;
            }
          }
        }
        if (c4 === null) {
          c4 = 65533;
          bytesPerSequence = 1;
        } else if (c4 > 65535) {
          c4 -= 65536;
          str += String.fromCharCode(c4 >>> 10 & 1023 | 55296);
          c4 = 56320 | c4 & 1023;
        }
        str += String.fromCharCode(c4);
        i2 += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i2 = 0, c4, lead; i2 < str.length; i2++) {
        c4 = str.charCodeAt(i2);
        if (c4 > 55295 && c4 < 57344) {
          if (lead) {
            if (c4 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c4;
              continue;
            } else {
              c4 = lead - 55296 << 10 | c4 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c4 > 56319 || i2 + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c4;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c4 < 128) {
          buf[pos++] = c4;
        } else {
          if (c4 < 2048) {
            buf[pos++] = c4 >> 6 | 192;
          } else {
            if (c4 < 65536) {
              buf[pos++] = c4 >> 12 | 224;
            } else {
              buf[pos++] = c4 >> 18 | 240;
              buf[pos++] = c4 >> 12 & 63 | 128;
            }
            buf[pos++] = c4 >> 6 & 63 | 128;
          }
          buf[pos++] = c4 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@visactor/vchart/esm/data/parser/array.js
var arrayParser = (array2) => array2;

// node_modules/@visactor/vchart/esm/typings/spec/common.js
var RenderModeEnum;
!function(RenderModeEnum2) {
  RenderModeEnum2["desktop-browser"] = "desktop-browser", RenderModeEnum2["mobile-browser"] = "mobile-browser", RenderModeEnum2.node = "node", RenderModeEnum2.worker = "worker", RenderModeEnum2.miniApp = "miniApp", RenderModeEnum2.wx = "wx", RenderModeEnum2["desktop-miniApp"] = "desktop-miniApp", RenderModeEnum2.lynx = "lynx";
}(RenderModeEnum || (RenderModeEnum = {}));

// node_modules/@visactor/vchart/esm/component/interface/type.js
var ComponentTypeEnum;
!function(ComponentTypeEnum2) {
  ComponentTypeEnum2.cartesianAxis = "cartesianAxis", ComponentTypeEnum2.cartesianBandAxis = "cartesianAxis-band", ComponentTypeEnum2.cartesianLinearAxis = "cartesianAxis-linear", ComponentTypeEnum2.cartesianTimeAxis = "cartesianAxis-time", ComponentTypeEnum2.cartesianLogAxis = "cartesianAxis-log", ComponentTypeEnum2.cartesianSymlogAxis = "cartesianAxis-symlog", ComponentTypeEnum2.polarAxis = "polarAxis", ComponentTypeEnum2.polarBandAxis = "polarAxis-band", ComponentTypeEnum2.polarLinearAxis = "polarAxis-linear", ComponentTypeEnum2.crosshair = "crosshair", ComponentTypeEnum2.cartesianCrosshair = "cartesianCrosshair", ComponentTypeEnum2.polarCrosshair = "polarCrosshair", ComponentTypeEnum2.dataZoom = "dataZoom", ComponentTypeEnum2.geoCoordinate = "geoCoordinate", ComponentTypeEnum2.indicator = "indicator", ComponentTypeEnum2.discreteLegend = "discreteLegend", ComponentTypeEnum2.continuousLegend = "continuousLegend", ComponentTypeEnum2.colorLegend = "colorLegend", ComponentTypeEnum2.sizeLegend = "sizeLegend", ComponentTypeEnum2.mapLabel = "mapLabel", ComponentTypeEnum2.markLine = "markLine", ComponentTypeEnum2.markArea = "markArea", ComponentTypeEnum2.markPoint = "markPoint", ComponentTypeEnum2.tooltip = "tooltip", ComponentTypeEnum2.title = "title", ComponentTypeEnum2.player = "player", ComponentTypeEnum2.scrollBar = "scrollBar", ComponentTypeEnum2.label = "label", ComponentTypeEnum2.totalLabel = "totalLabel", ComponentTypeEnum2.brush = "brush", ComponentTypeEnum2.poptip = "poptip", ComponentTypeEnum2.customMark = "customMark";
}(ComponentTypeEnum || (ComponentTypeEnum = {}));

// node_modules/d3-hexbin/src/hexbin.js
var thirdPi = Math.PI / 3;
var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

// node_modules/@visactor/vutils/es/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/@visactor/vutils/es/common/isType.js
var isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType_default = isType;

// node_modules/@visactor/vutils/es/common/isBoolean.js
var isBoolean = (value, fuzzy = false) => fuzzy ? "boolean" == typeof value : true === value || false === value || isType_default(value, "Boolean");
var isBoolean_default = isBoolean;

// node_modules/@visactor/vutils/es/common/isFunction.js
var isFunction = (value) => "function" == typeof value;
var isFunction_default = isFunction;

// node_modules/@visactor/vutils/es/common/isNil.js
var isNil = (value) => null == value;
var isNil_default = isNil;

// node_modules/@visactor/vutils/es/common/isValid.js
var isValid = (value) => null != value;
var isValid_default = isValid;

// node_modules/@visactor/vutils/es/common/isObject.js
var isObject = (value) => {
  const type = typeof value;
  return null !== value && "object" === type || "function" === type;
};
var isObject_default = isObject;

// node_modules/@visactor/vutils/es/common/isObjectLike.js
var isObjectLike = (value) => "object" == typeof value && null !== value;
var isObjectLike_default = isObjectLike;

// node_modules/@visactor/vutils/es/common/isPlainObject.js
var isPlainObject = function(value) {
  if (!isObjectLike_default(value) || !isType_default(value, "Object")) return false;
  if (null === Object.getPrototypeOf(value)) return true;
  let proto = value;
  for (; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
};
var isPlainObject_default = isPlainObject;

// node_modules/@visactor/vutils/es/common/isUndefined.js
var isUndefined = (value) => void 0 === value;
var isUndefined_default = isUndefined;

// node_modules/@visactor/vutils/es/common/isString.js
var isString = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType_default(value, "String");
};
var isString_default = isString;

// node_modules/@visactor/vutils/es/common/isArray.js
var isArray = (value) => Array.isArray ? Array.isArray(value) : isType_default(value, "Array");
var isArray_default = isArray;

// node_modules/@visactor/vutils/es/common/isArrayLike.js
var isArrayLike = function(value) {
  return null !== value && "function" != typeof value && Number.isFinite(value.length);
};
var isArrayLike_default = isArrayLike;

// node_modules/@visactor/vutils/es/common/isDate.js
var isDate = (value) => isType_default(value, "Date");
var isDate_default = isDate;

// node_modules/@visactor/vutils/es/common/isNumber.js
var isNumber = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType_default(value, "Number");
};
var isNumber_default = isNumber;

// node_modules/@visactor/vutils/es/common/isNumeric.js
var isNumeric = (value) => "string" == typeof value && (!isNaN(Number(value)) && !isNaN(parseFloat(value)));
var isNumeric_default = isNumeric;

// node_modules/@visactor/vutils/es/common/isValidNumber.js
var isValidNumber = (value) => isNumber_default(value) && Number.isFinite(value);
var isValidNumber_default = isValidNumber;

// node_modules/@visactor/vutils/es/common/isValidUrl.js
var isValidUrl = (value) => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
var isValidUrl_default = isValidUrl;

// node_modules/@visactor/vutils/es/common/isBase64.js
var isBase64 = (value) => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
var isBase64_default = isBase64;

// node_modules/@visactor/vutils/es/common/getType.js
var getType = (value) => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
var getType_default = getType;

// node_modules/@visactor/vutils/es/common/isPrototype.js
var objectProto = Object.prototype;
var isPrototype = function(value) {
  const Ctor = value && value.constructor;
  return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
};
var isPrototype_default = isPrototype;

// node_modules/@visactor/vutils/es/common/isEmpty.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmpty(value) {
  if (isNil_default(value)) return true;
  if (isArrayLike_default(value)) return !value.length;
  const type = getType_default(value);
  if ("Map" === type || "Set" === type) return !value.size;
  if (isPrototype_default(value)) return !Object.keys(value).length;
  for (const key in value) if (hasOwnProperty.call(value, key)) return false;
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/@visactor/vutils/es/common/get.js
var get = (obj, path, defaultValue) => {
  const paths = isString_default(path) ? path.split(".") : path;
  for (let p2 = 0; p2 < paths.length; p2++) obj = obj ? obj[paths[p2]] : void 0;
  return void 0 === obj ? defaultValue : obj;
};
var get_default = get;

// node_modules/@visactor/vutils/es/common/has.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var has = (object2, key) => null != object2 && hasOwnProperty2.call(object2, key);
var has_default = has;

// node_modules/@visactor/vutils/es/common/cloneDeep.js
function cloneDeep(value) {
  let result2;
  if (!isValid_default(value) || "object" != typeof value) return value;
  const isArr = isArray_default(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default(value) || isNumber_default(value) || isString_default(value) ? value : isDate_default(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2) for (; ++index < (props || value).length; ) {
    const key = props ? props[index] : index, subValue = value[key];
    result2[key] = cloneDeep(subValue);
  }
  return result2;
}

// node_modules/@visactor/vutils/es/common/merge.js
function baseMerge(target, source, shallowArray = false) {
  if (source) {
    if (target === source) return;
    if (isValid_default(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key in iterable) props.push(key);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key = props[++propIndex];
        isValid_default(iterable[key]) && "object" == typeof iterable[key] ? baseMergeDeep(target, source, key, shallowArray) : assignMergeValue(target, key, iterable[key]);
      }
    }
  }
}
function baseMergeDeep(target, source, key, shallowArray = false) {
  const objValue = target[key], srcValue = source[key];
  let newValue = source[key], isCommon = true;
  if (isArray_default(srcValue)) {
    if (shallowArray) newValue = [];
    else if (isArray_default(objValue)) newValue = objValue;
    else if (isArrayLike_default(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length2 = objValue.length;
      for (; ++index < length2; ) newValue[index] = objValue[index];
    }
  } else isPlainObject_default(srcValue) ? (newValue = objValue, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge(newValue, srcValue, shallowArray), assignMergeValue(target, key, newValue);
}
function assignMergeValue(target, key, value) {
  (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function merge(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge(target, sources[sourceIndex], true);
  }
  return target;
}

// node_modules/@visactor/vutils/es/common/pickWithout.js
function pickWithout(obj, keys2) {
  if (!obj || !isPlainObject_default(obj)) return obj;
  const result2 = {};
  return Object.keys(obj).forEach((k3) => {
    const v2 = obj[k3];
    let match = false;
    keys2.forEach((itKey) => {
      (isString_default(itKey) && itKey === k3 || itKey instanceof RegExp && k3.match(itKey)) && (match = true);
    }), match || (result2[k3] = v2);
  }), result2;
}

// node_modules/@visactor/vutils/es/common/isEqual.js
function objToString(obj) {
  return Object.prototype.toString.call(obj);
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function isEqual(a4, b2, options) {
  if (a4 === b2) return true;
  if (typeof a4 != typeof b2) return false;
  if (null == a4 || null == b2) return false;
  if (Number.isNaN(a4) && Number.isNaN(b2)) return true;
  if (objToString(a4) !== objToString(b2)) return false;
  if (isFunction_default(a4)) return !!(null == options ? void 0 : options.skipFunction);
  if ("object" != typeof a4) return false;
  if (isArray_default(a4)) {
    if (a4.length !== b2.length) return false;
    for (let i2 = a4.length - 1; i2 >= 0; i2--) if (!isEqual(a4[i2], b2[i2], options)) return false;
    return true;
  }
  if (!isPlainObject_default(a4)) return false;
  const ka = objectKeys(a4), kb = objectKeys(b2);
  if (ka.length !== kb.length) return false;
  ka.sort(), kb.sort();
  for (let i2 = ka.length - 1; i2 >= 0; i2--) if (ka[i2] != kb[i2]) return false;
  for (let i2 = ka.length - 1; i2 >= 0; i2--) {
    const key = ka[i2];
    if (!isEqual(a4[key], b2[key], options)) return false;
  }
  return true;
}

// node_modules/@visactor/vutils/es/common/mixin.js
function keys(obj) {
  if (!obj) return [];
  if (Object.keys) return Object.keys(obj);
  const keyList = [];
  for (const key in obj) obj.hasOwnProperty(key) && keyList.push(key);
  return keyList;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i2 = 0; i2 < keysArr.length; i2++) {
    const key = keysArr[i2];
    (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
  }
  return target;
}
function mixin(target, source, override = true) {
  if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i2 = 0; i2 < keyList.length; i2++) {
      const key = keyList[i2];
      "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
    }
  } else defaults(target, source, override);
}

// node_modules/@visactor/vutils/es/common/array.js
function array(arr) {
  return isValid_default(arr) ? isArray_default(arr) ? arr : [arr] : [];
}
function last(val) {
  if (isArrayLike_default(val)) {
    return val[val.length - 1];
  }
}
var maxInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length) return;
  let max4 = arr[0];
  for (let i2 = 1; i2 < arr.length; i2++) {
    const value = arr[i2];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value, max4)) && void 0 !== _a ? _a : value - max4 > 0) && (max4 = value);
  }
  return max4;
};
var minInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length) return;
  let min4 = arr[0];
  for (let i2 = 1; i2 < arr.length; i2++) {
    const value = arr[i2];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value, min4)) && void 0 !== _a ? _a : value - min4 < 0) && (min4 = value);
  }
  return min4;
};
function arrayEqual(a4, b2) {
  if (!isArray_default(a4) || !isArray_default(b2)) return false;
  if (a4.length !== b2.length) return false;
  for (let i2 = 0; i2 < a4.length; i2++) if (a4[i2] !== b2[i2]) return false;
  return true;
}
function uniqArray(arr) {
  return arr && isArray_default(arr) ? Array.from(new Set(array(arr))) : arr;
}
function shuffleArray(arr, random = Math.random) {
  let j2, x3, i2 = arr.length;
  for (; i2; ) j2 = Math.floor(random() * i2), x3 = arr[--i2], arr[i2] = arr[j2], arr[j2] = x3;
  return arr;
}
function flattenArray(arr) {
  if (!isArray_default(arr)) return [arr];
  const result2 = [];
  for (const value of arr) result2.push(...flattenArray(value));
  return result2;
}

// node_modules/@visactor/vutils/es/common/range.js
function range(start, stop, step) {
  isValid_default(stop) || (stop = start, start = 0), isValid_default(step) || (step = 1);
  let i2 = -1;
  const n2 = 0 | Math.max(0, Math.ceil((stop - start) / step)), range2 = new Array(n2);
  for (; ++i2 < n2; ) range2[i2] = start + i2 * step;
  return range2;
}

// node_modules/@visactor/vutils/es/common/ascending.js
function ascending(a4, b2) {
  return a4 < b2 ? -1 : a4 > b2 ? 1 : a4 >= b2 ? 0 : NaN;
}

// node_modules/@visactor/vutils/es/common/toNumber.js
function toNumber(a4) {
  return Number(a4);
}

// node_modules/@visactor/vutils/es/common/quantileSorted.js
function quantileSorted(values, percent, valueof = toNumber) {
  const n2 = values.length;
  if (!n2) return;
  if (percent <= 0 || n2 < 2) return valueof(values[0], 0, values);
  if (percent >= 1) return valueof(values[n2 - 1], n2 - 1, values);
  const i2 = (n2 - 1) * percent, i0 = Math.floor(i2), value0 = valueof(values[i0], i0, values);
  return value0 + (valueof(values[i0 + 1], i0 + 1, values) - value0) * (i2 - i0);
}

// node_modules/@visactor/vutils/es/common/bisect.js
function bisect(a4, x3, lo = 0, hi) {
  for (isNil_default(hi) && (hi = a4.length); lo < hi; ) {
    const mid = lo + hi >>> 1;
    ascending(a4[mid], x3) > 0 ? hi = mid : lo = mid + 1;
  }
  return lo;
}

// node_modules/@visactor/vutils/es/common/median.js
var median = (values, isSorted) => {
  let sorted = values;
  return true !== isSorted && (sorted = values.sort(ascending)), quantileSorted(sorted, 0.5);
};

// node_modules/@visactor/vutils/es/common/tickStep.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/@visactor/vutils/es/common/number.js
var DEFAULT_ABSOLUTE_TOLERATE = 1e-10;
var DEFAULT_RELATIVE_TOLERATE = 1e-10;
function isNumberClose(a4, b2, relTol = DEFAULT_RELATIVE_TOLERATE, absTol = DEFAULT_ABSOLUTE_TOLERATE) {
  const abs3 = absTol, rel = relTol * Math.max(a4, b2);
  return Math.abs(a4 - b2) <= Math.max(abs3, rel);
}
function isGreater(a4, b2, relTol, absTol) {
  return a4 > b2 && !isNumberClose(a4, b2, relTol, absTol);
}
function isLess(a4, b2, relTol, absTol) {
  return a4 < b2 && !isNumberClose(a4, b2, relTol, absTol);
}

// node_modules/@visactor/vutils/es/common/memoize.js
var memoize = (func) => {
  let lastArgs = null, lastResult = null;
  return (...args) => (lastArgs && args.every((val, i2) => val === lastArgs[i2]) || (lastArgs = args, lastResult = func(...args)), lastResult);
};

// node_modules/@visactor/vutils/es/common/clamp.js
var clamp = function(input, min4, max4) {
  return input < min4 ? min4 : input > max4 ? max4 : input;
};
var clamp_default = clamp;

// node_modules/@visactor/vutils/es/common/clampRange.js
var clampRange = (range2, min4, max4) => {
  let [lowValue, highValue] = range2;
  highValue < lowValue && (lowValue = range2[1], highValue = range2[0]);
  const span = highValue - lowValue;
  return span >= max4 - min4 ? [min4, max4] : (lowValue = Math.min(Math.max(lowValue, min4), max4 - span), [lowValue, lowValue + span]);
};
var clampRange_default = clampRange;

// node_modules/@visactor/vutils/es/common/clamper.js
function clamper(a4, b2) {
  let t2;
  return a4 > b2 && (t2 = a4, a4 = b2, b2 = t2), (x3) => Math.max(a4, Math.min(b2, x3));
}

// node_modules/@visactor/vutils/es/common/debounce.js
var hasRaf = false;
try {
  hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf = false;
}
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  const useRAF = !wait && 0 !== wait && hasRaf;
  if ("function" != typeof func) throw new TypeError("Expected a function");
  function invokeFunc(time) {
    const args = lastArgs, thisArg = lastThis;
    return lastArgs = lastThis = void 0, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
  }
  function startTimer(pendingFunc, wait2) {
    return useRAF ? (cancelAnimationFrame(timerId), requestAnimationFrame(pendingFunc)) : setTimeout(pendingFunc, wait2);
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) return trailingEdge(time);
    timerId = startTimer(timerExpired, function(time2) {
      const timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - (time2 - lastCallTime);
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }(time));
  }
  function trailingEdge(time) {
    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result2);
  }
  function debounced(...args) {
    const time = Date.now(), isInvoking = shouldInvoke(time);
    if (lastArgs = args, lastThis = this, lastCallTime = time, isInvoking) {
      if (void 0 === timerId) return function(time2) {
        return lastInvokeTime = time2, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time2) : result2;
      }(lastCallTime);
      if (maxing) return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
    }
    return void 0 === timerId && (timerId = startTimer(timerExpired, wait)), result2;
  }
  return wait = +wait || 0, isObject_default(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxing && (maxWait = Math.max(isValidNumber_default(options.maxWait) ? options.maxWait : 0, wait)), trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
    void 0 !== timerId && function(id2) {
      if (useRAF) return cancelAnimationFrame(id2);
      clearTimeout(id2);
    }(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
  }, debounced.flush = function() {
    return void 0 === timerId ? result2 : trailingEdge(Date.now());
  }, debounced.pending = function() {
    return void 0 !== timerId;
  }, debounced;
}
hasRaf = false;
var debounce_default = debounce;

// node_modules/@visactor/vutils/es/common/throttle.js
function throttle(func, wait, options) {
  let leading = true, trailing = true;
  if ("function" != typeof func) throw new TypeError("Expected a function");
  return isObject_default(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce_default(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
}
var throttle_default = throttle;

// node_modules/@visactor/vutils/es/common/interpolate.js
function interpolateNumber(a4, b2) {
  return (t2) => a4 * (1 - t2) + b2 * t2;
}
function interpolateNumberRound(a4, b2) {
  return function(t2) {
    return Math.round(a4 * (1 - t2) + b2 * t2);
  };
}
function interpolateDate(a4, b2) {
  const aVal = a4.valueOf(), bVal = b2.valueOf(), d2 = /* @__PURE__ */ new Date();
  return (t2) => (d2.setTime(aVal * (1 - t2) + bVal * t2), d2);
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a4, b2) {
  let am, bm, bs, bi = reA.lastIndex = reB.lastIndex = 0, i2 = -1;
  const s3 = [], q2 = [];
  for (a4 += "", b2 += ""; (am = reA.exec(a4)) && (bm = reB.exec(b2)); ) (bs = bm.index) > bi && (bs = b2.slice(bi, bs), s3[i2] ? s3[i2] += bs : s3[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s3[i2] ? s3[i2] += bm : s3[++i2] = bm : (s3[++i2] = null, q2.push({
    i: i2,
    x: interpolateNumber(am, bm)
  })), bi = reB.lastIndex;
  return bi < b2.length && (bs = b2.slice(bi), s3[i2] ? s3[i2] += bs : s3[++i2] = bs), s3.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (let o2, i3 = 0; i3 < b2; ++i3) s3[(o2 = q2[i3]).i] = o2.x(t2);
    return s3.join("");
  });
}

// node_modules/@visactor/vutils/es/common/substitute.js
function substitute(str, o2) {
  return str && o2 ? str.replace(/\\?\{([^{}]+)\}/g, (match, name) => "\\" === match.charAt(0) ? match.slice(1) : void 0 === o2[name] ? "" : o2[name]) : str;
}

// node_modules/@visactor/vutils/es/math.js
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
var pi2 = 2 * Math.PI;
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var pow = Math.pow;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}
function pointAt(x14, y14, x23, y23, t2) {
  let x3, y3;
  return "number" == typeof x14 && "number" == typeof x23 && (x3 = (1 - t2) * x14 + t2 * x23), "number" == typeof y14 && "number" == typeof y23 && (y3 = (1 - t2) * y14 + t2 * y23), {
    x: x3,
    y: y3
  };
}
function crossProduct(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
function fuzzyEqualVec(a4, b2) {
  return abs(a4[0] - b2[0]) + abs(a4[1] - b2[1]) < 1e-12;
}
function fixPrecision(num, precision = 10) {
  return Math.round(num * precision) / precision;
}
function getDecimalPlaces(n2) {
  const dStr = n2.toString().split(/[eE]/), s3 = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
  return s3 > 0 ? s3 : 0;
}
function precisionAdd(a4, b2) {
  return fixPrecision(a4 + b2, 10 ** Math.max(getDecimalPlaces(a4), getDecimalPlaces(b2)));
}
function precisionSub(a4, b2) {
  return fixPrecision(a4 - b2, 10 ** Math.max(getDecimalPlaces(a4), getDecimalPlaces(b2)));
}

// node_modules/@visactor/vutils/es/data-structure/point.js
var Point = class _Point {
  constructor(x3 = 0, y3 = 0, x14, y14) {
    this.x = 0, this.y = 0, this.x = x3, this.y = y3, this.x1 = x14, this.y1 = y14;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  copyFrom(p2) {
    return this.x = p2.x, this.y = p2.y, this.x1 = p2.x1, this.y1 = p2.y1, this.defined = p2.defined, this.context = p2.context, this;
  }
  set(x3, y3) {
    return this.x = x3, this.y = y3, this;
  }
  add(point6) {
    return isNumber_default(point6) ? (this.x += point6, void (this.y += point6)) : (this.x += point6.x, this.y += point6.y, this);
  }
  sub(point6) {
    return isNumber_default(point6) ? (this.x -= point6, void (this.y -= point6)) : (this.x -= point6.x, this.y -= point6.y, this);
  }
  multi(point6) {
    throw new Error("暂不支持");
  }
  div(point6) {
    throw new Error("暂不支持");
  }
};
var PointService = class {
  static distancePP(p1, p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
  }
  static distanceNN(x3, y3, x14, y14) {
    return sqrt(pow(x3 - x14, 2) + pow(y3 - y14, 2));
  }
  static distancePN(point6, x3, y3) {
    return sqrt(pow(x3 - point6.x, 2) + pow(y3 - point6.y, 2));
  }
  static pointAtPP(p1, p2, t2) {
    return new Point((p2.x - p1.x) * t2 + p1.x, (p2.y - p1.y) * t2 + p1.y);
  }
};

// node_modules/@visactor/vutils/es/data-structure/bounds.js
function transformBoundsWithMatrix(out, bounds, matrix) {
  const { x1: x14, y1: y14, x2: x23, y2: y23 } = bounds;
  return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x14 + matrix.c * y14 + matrix.e, matrix.b * x14 + matrix.d * y14 + matrix.f), out.add(matrix.a * x23 + matrix.c * y14 + matrix.e, matrix.b * x23 + matrix.d * y14 + matrix.f), out.add(matrix.a * x23 + matrix.c * y23 + matrix.e, matrix.b * x23 + matrix.d * y23 + matrix.f), out.add(matrix.a * x14 + matrix.c * y23 + matrix.e, matrix.b * x14 + matrix.d * y23 + matrix.f), bounds);
}
var Bounds = class _Bounds {
  constructor(bounds) {
    bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
  }
  clone() {
    return new _Bounds(this);
  }
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  }
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  }
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  }
  setValue(x14 = 0, y14 = 0, x23 = 0, y23 = 0) {
    return this.x1 = x14, this.y1 = y14, this.x2 = x23, this.y2 = y23, this;
  }
  set(x14 = 0, y14 = 0, x23 = 0, y23 = 0) {
    return x23 < x14 ? (this.x2 = x14, this.x1 = x23) : (this.x1 = x14, this.x2 = x23), y23 < y14 ? (this.y2 = y14, this.y1 = y23) : (this.y1 = y14, this.y2 = y23), this;
  }
  add(x3 = 0, y3 = 0) {
    return x3 < this.x1 && (this.x1 = x3), y3 < this.y1 && (this.y1 = y3), x3 > this.x2 && (this.x2 = x3), y3 > this.y2 && (this.y2 = y3), this;
  }
  expand(d2 = 0) {
    return isArray_default(d2) ? (this.y1 -= d2[0], this.x2 += d2[1], this.y2 += d2[2], this.x1 -= d2[3]) : (this.x1 -= d2, this.y1 -= d2, this.x2 += d2, this.y2 += d2), this;
  }
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  }
  translate(dx = 0, dy = 0) {
    return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
  }
  rotate(angle2 = 0, x3 = 0, y3 = 0) {
    const p2 = this.rotatedPoints(angle2, x3, y3);
    return this.clear().add(p2[0], p2[1]).add(p2[2], p2[3]).add(p2[4], p2[5]).add(p2[6], p2[7]);
  }
  scale(sx = 0, sy = 0, x3 = 0, y3 = 0) {
    const p2 = this.scalePoints(sx, sy, x3, y3);
    return this.clear().add(p2[0], p2[1]).add(p2[2], p2[3]);
  }
  union(b2) {
    return b2.x1 < this.x1 && (this.x1 = b2.x1), b2.y1 < this.y1 && (this.y1 = b2.y1), b2.x2 > this.x2 && (this.x2 = b2.x2), b2.y2 > this.y2 && (this.y2 = b2.y2), this;
  }
  intersect(b2) {
    return b2.x1 > this.x1 && (this.x1 = b2.x1), b2.y1 > this.y1 && (this.y1 = b2.y1), b2.x2 < this.x2 && (this.x2 = b2.x2), b2.y2 < this.y2 && (this.y2 = b2.y2), this;
  }
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  }
  alignsWith(b2) {
    return b2 && (this.x1 === b2.x1 || this.x2 === b2.x2 || this.y1 === b2.y1 || this.y2 === b2.y2);
  }
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  }
  contains(x3 = 0, y3 = 0) {
    return !(x3 < this.x1 || x3 > this.x2 || y3 < this.y1 || y3 > this.y2);
  }
  containsPoint(p2) {
    return !(p2.x < this.x1 || p2.x > this.x2 || p2.y < this.y1 || p2.y > this.y2);
  }
  width() {
    return this.empty() ? 0 : this.x2 - this.x1;
  }
  height() {
    return this.empty() ? 0 : this.y2 - this.y1;
  }
  scaleX(s3 = 0) {
    return this.x1 *= s3, this.x2 *= s3, this;
  }
  scaleY(s3 = 0) {
    return this.y1 *= s3, this.y2 *= s3, this;
  }
  transformWithMatrix(matrix) {
    return transformBoundsWithMatrix(this, this, matrix), this;
  }
  copy(b2) {
    return this.x1 = b2.x1, this.y1 = b2.y1, this.x2 = b2.x2, this.y2 = b2.y2, this;
  }
  rotatedPoints(angle2, x3, y3) {
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = this, cos3 = Math.cos(angle2), sin3 = Math.sin(angle2), cx = x3 - x3 * cos3 + y3 * sin3, cy = y3 - x3 * sin3 - y3 * cos3;
    return [cos3 * x14 - sin3 * y14 + cx, sin3 * x14 + cos3 * y14 + cy, cos3 * x14 - sin3 * y23 + cx, sin3 * x14 + cos3 * y23 + cy, cos3 * x23 - sin3 * y14 + cx, sin3 * x23 + cos3 * y14 + cy, cos3 * x23 - sin3 * y23 + cx, sin3 * x23 + cos3 * y23 + cy];
  }
  scalePoints(sx, sy, x3, y3) {
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = this;
    return [sx * x14 + (1 - sx) * x3, sy * y14 + (1 - sy) * y3, sx * x23 + (1 - sx) * x3, sy * y23 + (1 - sy) * y3];
  }
};
var AABBBounds = class extends Bounds {
};

// node_modules/@visactor/vutils/es/angle.js
function degreeToRadian(degree) {
  return degree * (Math.PI / 180);
}
function radianToDegree(radian) {
  return 180 * radian / Math.PI;
}
var clampRadian = (angle2 = 0) => {
  if (angle2 < 0) for (; angle2 < -tau; ) angle2 += tau;
  else if (angle2 > 0) for (; angle2 > tau; ) angle2 -= tau;
  return angle2;
};
var clampAngleByRadian = clampRadian;
function polarToCartesian(center2, radius, angleInRadian) {
  return {
    x: center2.x + radius * Math.cos(angleInRadian),
    y: center2.y + radius * Math.sin(angleInRadian)
  };
}
function getAngleByPoint(center2, point6) {
  return Math.atan2(point6.y - center2.y, point6.x - center2.x);
}

// node_modules/@visactor/vutils/es/data-structure/matrix.js
var Matrix = class _Matrix {
  constructor(a4 = 1, b2 = 0, c4 = 0, d2 = 1, e3 = 0, f2 = 0) {
    this.a = a4, this.b = b2, this.c = c4, this.d = d2, this.e = e3, this.f = f2;
  }
  equalToMatrix(m22) {
    return !(this.e !== m22.e || this.f !== m22.f || this.a !== m22.a || this.d !== m22.d || this.b !== m22.b || this.c !== m22.c);
  }
  equalTo(a4, b2, c4, d2, e3, f2) {
    return !(this.e !== e3 || this.f !== f2 || this.a !== a4 || this.d !== d2 || this.b !== b2 || this.c !== c4);
  }
  setValue(a4, b2, c4, d2, e3, f2) {
    return this.a = a4, this.b = b2, this.c = c4, this.d = d2, this.e = e3, this.f = f2, this;
  }
  reset() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  getInverse() {
    const a4 = this.a, b2 = this.b, c4 = this.c, d2 = this.d, e3 = this.e, f2 = this.f, m5 = new _Matrix(), dt = a4 * d2 - b2 * c4;
    return m5.a = d2 / dt, m5.b = -b2 / dt, m5.c = -c4 / dt, m5.d = a4 / dt, m5.e = (c4 * f2 - d2 * e3) / dt, m5.f = -(a4 * f2 - b2 * e3) / dt, m5;
  }
  rotate(rad) {
    const c4 = Math.cos(rad), s3 = Math.sin(rad), m11 = this.a * c4 + this.c * s3, m12 = this.b * c4 + this.d * s3, m21 = this.a * -s3 + this.c * c4, m22 = this.b * -s3 + this.d * c4;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
  }
  rotateByCenter(rad, cx, cy) {
    const cos3 = Math.cos(rad), sin3 = Math.sin(rad), rotateM13 = (1 - cos3) * cx + sin3 * cy, rotateM23 = (1 - cos3) * cy - sin3 * cx, m11 = cos3 * this.a - sin3 * this.b, m21 = sin3 * this.a + cos3 * this.b, m12 = cos3 * this.c - sin3 * this.d, m22 = sin3 * this.c + cos3 * this.d, m13 = cos3 * this.e - sin3 * this.f + rotateM13, m23 = sin3 * this.e + cos3 * this.f + rotateM23;
    return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
  }
  scale(sx, sy) {
    return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
  }
  setScale(sx, sy) {
    return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
  }
  transform(a4, b2, c4, d2, e3, f2) {
    return this.multiply(a4, b2, c4, d2, e3, f2), this;
  }
  translate(x3, y3) {
    return this.e += this.a * x3 + this.c * y3, this.f += this.b * x3 + this.d * y3, this;
  }
  transpose() {
    const { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = this;
    return this.a = b2, this.b = a4, this.c = d2, this.d = c4, this.e = f2, this.f = e3, this;
  }
  multiply(a22, b2, c22, d2, e24, f2) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, m11 = a1 * a22 + c1 * b2, m12 = b1 * a22 + d1 * b2, m21 = a1 * c22 + c1 * d2, m22 = b1 * c22 + d1 * d2, dx = a1 * e24 + c1 * f2 + this.e, dy = b1 * e24 + d1 * f2 + this.f;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
  }
  interpolate(m22, t2) {
    const m5 = new _Matrix();
    return m5.a = this.a + (m22.a - this.a) * t2, m5.b = this.b + (m22.b - this.b) * t2, m5.c = this.c + (m22.c - this.c) * t2, m5.d = this.d + (m22.d - this.d) * t2, m5.e = this.e + (m22.e - this.e) * t2, m5.f = this.f + (m22.f - this.f) * t2, m5;
  }
  transformPoint(source, target) {
    const { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = this, dt = a4 * d2 - b2 * c4, nextA = d2 / dt, nextB = -b2 / dt, nextC = -c4 / dt, nextD = a4 / dt, nextE = (c4 * f2 - d2 * e3) / dt, nextF = -(a4 * f2 - b2 * e3) / dt, { x: x3, y: y3 } = source;
    target.x = x3 * nextA + y3 * nextC + nextE, target.y = x3 * nextB + y3 * nextD + nextF;
  }
  onlyTranslate(scale4 = 1) {
    return this.a === scale4 && 0 === this.b && 0 === this.c && this.d === scale4;
  }
  clone() {
    return new _Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  toTransformAttrs() {
    const a4 = this.a, b2 = this.b, c4 = this.c, d2 = this.d, delta = a4 * d2 - b2 * c4, result2 = {
      x: this.e,
      y: this.f,
      rotateDeg: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (0 !== a4 || 0 !== b2) {
      const r2 = Math.sqrt(a4 * a4 + b2 * b2);
      result2.rotateDeg = b2 > 0 ? Math.acos(a4 / r2) : -Math.acos(a4 / r2), result2.scaleX = r2, result2.scaleY = delta / r2, result2.skewX = (a4 * c4 + b2 * d2) / delta, result2.skewY = 0;
    } else if (0 !== c4 || 0 !== d2) {
      const s3 = Math.sqrt(c4 * c4 + d2 * d2);
      result2.rotateDeg = Math.PI / 2 - (d2 > 0 ? Math.acos(-c4 / s3) : -Math.acos(c4 / s3)), result2.scaleX = delta / s3, result2.scaleY = s3, result2.skewX = 0, result2.skewY = (a4 * c4 + b2 * d2) / delta;
    }
    return result2.rotateDeg = radianToDegree(result2.rotateDeg), result2;
  }
};
function normalTransform(out, origin, x3, y3, scaleX, scaleY, angle2, rotateCenter) {
  const oa = origin.a, ob = origin.b, oc = origin.c, od = origin.d, oe = origin.e, of = origin.f, cosTheta = cos(angle2), sinTheta = sin(angle2);
  let rotateCenterX, rotateCenterY;
  rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x3, rotateCenterY = y3);
  const offsetX = rotateCenterX - x3, offsetY = rotateCenterY - y3, a1 = oa * cosTheta + oc * sinTheta, b1 = ob * cosTheta + od * sinTheta, c1 = oc * cosTheta - oa * sinTheta, d1 = od * cosTheta - ob * sinTheta;
  out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
}

// node_modules/@visactor/vutils/es/lru.js
var LRU = class {
  constructor() {
    this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
  }
  clearCache(cache, params2) {
    const { CLEAN_THRESHOLD = this.CLEAN_THRESHOLD, L_TIME = this.L_TIME, R_COUNT = this.R_COUNT } = params2;
    if (cache.size < CLEAN_THRESHOLD) return 0;
    let clearNum = 0;
    const clear = (key) => {
      clearNum++, cache.delete(key);
    }, now = Date.now();
    return cache.forEach((item, key) => {
      if (item.timestamp.length < R_COUNT) return clear(key);
      let useCount = 0;
      for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)); ) ;
      if (useCount < R_COUNT) return clear(key);
      for (; now - item.timestamp[0] > L_TIME; ) item.timestamp.shift();
    }), clearNum;
  }
  addLimitedTimestamp(cacheItem, t2, params2) {
    const { R_TIMESTAMP_MAX_SIZE = this.R_TIMESTAMP_MAX_SIZE } = params2;
    cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t2);
  }
  clearTimeStamp(cache, params2) {
    const { L_TIME = this.L_TIME } = params2, now = Date.now();
    cache.forEach((item) => {
      for (; now - item.timestamp[0] > L_TIME; ) item.timestamp.shift();
    });
  }
  clearItemTimestamp(cacheItem, params2) {
    const { L_TIME = this.L_TIME } = params2, now = Date.now();
    for (; now - cacheItem.timestamp[0] > L_TIME; ) cacheItem.timestamp.shift();
  }
};

// node_modules/@visactor/vutils/es/color/index.js
var color_exports = {};
__export(color_exports, {
  Color: () => Color,
  DEFAULT_COLORS: () => DEFAULT_COLORS,
  RGB: () => RGB,
  hexToRgb: () => hexToRgb,
  hslToRgb: () => hslToRgb,
  interpolateRgb: () => interpolateRgb,
  rgbToHex: () => rgbToHex,
  rgbToHsl: () => rgbToHsl
});

// node_modules/@visactor/vutils/es/color/hslToRgb.js
function hslToRgb(h2, s3, l2) {
  s3 /= 100, l2 /= 100;
  const c4 = (1 - Math.abs(2 * l2 - 1)) * s3, x3 = c4 * (1 - Math.abs(h2 / 60 % 2 - 1)), m5 = l2 - c4 / 2;
  let r2 = 0, g3 = 0, b2 = 0;
  return 0 <= h2 && h2 < 60 ? (r2 = c4, g3 = x3, b2 = 0) : 60 <= h2 && h2 < 120 ? (r2 = x3, g3 = c4, b2 = 0) : 120 <= h2 && h2 < 180 ? (r2 = 0, g3 = c4, b2 = x3) : 180 <= h2 && h2 < 240 ? (r2 = 0, g3 = x3, b2 = c4) : 240 <= h2 && h2 < 300 ? (r2 = x3, g3 = 0, b2 = c4) : 300 <= h2 && h2 < 360 && (r2 = c4, g3 = 0, b2 = x3), r2 = Math.round(255 * (r2 + m5)), g3 = Math.round(255 * (g3 + m5)), b2 = Math.round(255 * (b2 + m5)), {
    r: r2,
    g: g3,
    b: b2
  };
}

// node_modules/@visactor/vutils/es/color/rgbToHsl.js
function rgbToHsl(r2, g3, b2) {
  r2 /= 255, g3 /= 255, b2 /= 255;
  const cMin = Math.min(r2, g3, b2), cMax = Math.max(r2, g3, b2), delta = cMax - cMin;
  let h2 = 0, s3 = 0, l2 = 0;
  return h2 = 0 === delta ? 0 : cMax === r2 ? (g3 - b2) / delta % 6 : cMax === g3 ? (b2 - r2) / delta + 2 : (r2 - g3) / delta + 4, h2 = Math.round(60 * h2), h2 < 0 && (h2 += 360), l2 = (cMax + cMin) / 2, s3 = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l2 - 1)), s3 = +(100 * s3).toFixed(1), l2 = +(100 * l2).toFixed(1), {
    h: h2,
    s: s3,
    l: l2
  };
}

// node_modules/@visactor/vutils/es/color/Color.js
var REG_HEX = /^#([0-9a-f]{3,8})$/;
var DEFAULT_COLORS_OPACITY = {
  transparent: 4294967040
};
var DEFAULT_COLORS = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function hex(value) {
  return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
}
function rgb(value) {
  return isNumber_default(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray_default(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
}
function rgba(value) {
  return isNumber_default(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray_default(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
}
function SRGBToLinear(c4) {
  return c4 < 0.04045 ? 0.0773993808 * c4 : Math.pow(0.9478672986 * c4 + 0.0521327014, 2.4);
}
function LinearToSRGB(c4) {
  return c4 < 31308e-7 ? 12.92 * c4 : 1.055 * Math.pow(c4, 0.41666) - 0.055;
}
var Color = class _Color {
  static Brighter(source, b2 = 1) {
    return 1 === b2 ? source : new _Color(source).brighter(b2).toRGBA();
  }
  static SetOpacity(source, o2 = 1) {
    return 1 === o2 ? source : new _Color(source).setOpacity(o2).toRGBA();
  }
  static getColorBrightness(source, model = "hsl") {
    const color = source instanceof _Color ? source : new _Color(source);
    switch (model) {
      case "hsv":
      default:
        return color.getHSVBrightness();
      case "hsl":
        return color.getHSLBrightness();
      case "lum":
        return color.getLuminance();
      case "lum2":
        return color.getLuminance2();
      case "lum3":
        return color.getLuminance3();
    }
  }
  static parseColorString(value) {
    if (isValid_default(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
    if (isValid_default(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
    const formatValue = `${value}`.trim().toLowerCase(), isHex = REG_HEX.exec(formatValue);
    if (isHex) {
      const hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
      return 3 === hexLength ? new RGB((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : void 0;
    }
    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","), rgb2 = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
      return new RGB(rgb2.r, rgb2.g, rgb2.b, parseFloat(aColor[3]));
    }
  }
  constructor(value) {
    const color = _Color.parseColorString(value);
    color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(k3) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r2 * k3))), this.color.g = Math.max(0, Math.min(255, Math.floor(g3 * k3))), this.color.b = Math.max(0, Math.min(255, Math.floor(b2 * k3))), this;
  }
  add(color) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r += Math.min(255, r2 + color.color.r), this.color.g += Math.min(255, g3 + color.color.g), this.color.b += Math.min(255, b2 + color.color.b), this;
  }
  sub(color) {
    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
  }
  multiply(color) {
    const { r: r2, g: g3, b: b2 } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r2 * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g3 * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b2 * color.color.b))), this;
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return 0.5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
  }
  setHsl(h2, s3, l2) {
    const opacity = this.color.opacity, hsl = rgbToHsl(this.color.r, this.color.g, this.color.b), rgb2 = hslToRgb(isNil_default(h2) ? hsl.h : clamp_default(h2, 0, 360), isNil_default(s3) ? hsl.s : s3 >= 0 && s3 <= 1 ? 100 * s3 : s3, isNil_default(l2) ? hsl.l : l2 <= 1 && l2 >= 0 ? 100 * l2 : l2);
    return this.color = new RGB(rgb2.r, rgb2.g, rgb2.b, opacity), this;
  }
  setRGB(r2, g3, b2) {
    return !isNil_default(r2) && (this.color.r = r2), !isNil_default(g3) && (this.color.g = g3), !isNil_default(b2) && (this.color.b = b2), this;
  }
  setHex(value) {
    const formatValue = `${value}`.trim().toLowerCase(), isHex = REG_HEX.exec(formatValue), hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
    return 3 === hexLength ? new RGB((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : this;
  }
  setColorName(name) {
    const hex2 = DEFAULT_COLORS[name.toLowerCase()];
    return void 0 !== hex2 ? this.setHex(hex2) : console.warn("THREE.Color: Unknown color " + name), this;
  }
  setScalar(scalar) {
    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
  }
  setOpacity(o2 = 1) {
    return this.color.opacity = o2, this;
  }
  getLuminance() {
    return (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) / 255;
  }
  getLuminance2() {
    return (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) / 255;
  }
  getLuminance3() {
    return (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255;
  }
  clone() {
    return new _Color(this.color.toString());
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  copySRGBToLinear(color) {
    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
  }
  copyLinearToSRGB(color) {
    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
};
var RGB = class {
  constructor(r2, g3, b2, opacity) {
    this.r = isNaN(+r2) ? 255 : Math.max(0, Math.min(255, +r2)), this.g = isNaN(+g3) ? 255 : Math.max(0, Math.min(255, +g3)), this.b = isNaN(+b2) ? 255 : Math.max(0, Math.min(255, +b2)), isValid_default(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
  }
  formatHex() {
    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
  }
  formatRgb() {
    const opacity = this.opacity;
    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
  }
  formatHsl() {
    const opacity = this.opacity, { h: h2, s: s3, l: l2 } = rgbToHsl(this.r, this.g, this.b);
    return `${1 === opacity ? "hsl(" : "hsla("}${h2},${s3}%,${l2}%${1 === opacity ? ")" : `,${opacity})`}`;
  }
  toString() {
    return this.formatHex();
  }
};

// node_modules/@visactor/vutils/es/color/hexToRgb.js
function hexToRgb(str) {
  let r2 = "", g3 = "", b2 = "";
  const strtIndex = "#" === str[0] ? 1 : 0;
  for (let i2 = strtIndex; i2 < str.length; i2++) "#" !== str[i2] && (i2 < strtIndex + 2 ? r2 += str[i2] : i2 < strtIndex + 4 ? g3 += str[i2] : i2 < strtIndex + 6 && (b2 += str[i2]));
  return [parseInt(r2, 16), parseInt(g3, 16), parseInt(b2, 16)];
}

// node_modules/@visactor/vutils/es/color/rgbToHex.js
function rgbToHex(r2, g3, b2) {
  return Number((1 << 24) + (r2 << 16) + (g3 << 8) + b2).toString(16).slice(1);
}

// node_modules/@visactor/vutils/es/color/interpolate.js
function interpolateRgb(colorA, colorB) {
  const redA = colorA.r, redB = colorB.r, greenA = colorA.g, greenB = colorB.g, blueA = colorA.b, blueB = colorB.b, opacityA = colorA.opacity, opacityB = colorB.opacity;
  return (t2) => {
    const r2 = Math.round(redA * (1 - t2) + redB * t2), g3 = Math.round(greenA * (1 - t2) + greenB * t2), b2 = Math.round(blueA * (1 - t2) + blueB * t2);
    return new RGB(r2, g3, b2, opacityA * (1 - t2) + opacityB * t2);
  };
}

// node_modules/@visactor/vutils/es/graphics/algorithm/intersect.js
function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
}
var x11;
var x12;
var y11;
var y12;
var x21;
var x22;
var y21;
var y22;
function isIntersect(left1, right1, left2, right2) {
  let _temp, min1 = left1[0], max1 = right1[0], min22 = left2[0], max22 = right2[0];
  return max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max22 < min22 && (_temp = max22, max22 = min22, min22 = _temp), !(max1 < min22 || max22 < min1) && (min1 = left1[1], max1 = right1[1], min22 = left2[1], max22 = right2[1], max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max22 < min22 && (_temp = max22, max22 = min22, min22 = _temp), !(max1 < min22 || max22 < min1));
}
function getIntersectPoint(left1, right1, left2, right2) {
  if (!isIntersect(left1, right1, left2, right2)) return false;
  const dir1 = [0, 0], dir2 = [0, 0], tempVec = [0, 0];
  if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return true;
  sub(tempVec, left2, left1);
  const t2 = crossProduct(tempVec, dir2) / crossProduct(dir1, dir2);
  return t2 >= 0 && t2 <= 1 && [left1[0] + dir1[0] * t2, left1[1] + dir1[1] * t2];
}
function getRectIntersect(bbox1, bbox2, format) {
  return null === bbox1 ? bbox2 : null === bbox2 ? bbox1 : (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0
  } : {
    x1: Math.max(x11, x21),
    y1: Math.max(y11, y21),
    x2: Math.min(x12, x22),
    y2: Math.min(y12, y22)
  });
}
var InnerBBox;
!function(InnerBBox2) {
  InnerBBox2[InnerBBox2.NONE = 0] = "NONE", InnerBBox2[InnerBBox2.BBOX1 = 1] = "BBOX1", InnerBBox2[InnerBBox2.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));
function rectInsideAnotherRect(bbox1, bbox2, format) {
  return bbox1 && bbox2 ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), x11 > x21 && x12 < x22 && y11 > y21 && y12 < y22 ? InnerBBox.BBOX1 : x21 > x11 && x22 < x12 && y21 > y11 && y22 < y12 ? InnerBBox.BBOX2 : InnerBBox.NONE) : InnerBBox.NONE;
}
function isRectIntersect(bbox1, bbox2, format) {
  return !bbox1 || !bbox2 || (format ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21]), !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21)) : !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1));
}
function pointInRect(point6, bbox, format) {
  return !bbox || (format ? (x11 = bbox.x1, x12 = bbox.x2, y11 = bbox.y1, y12 = bbox.y2, x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), point6.x >= x11 && point6.x <= x12 && point6.y >= y11 && point6.y <= y12) : point6.x >= bbox.x1 && point6.x <= bbox.x2 && point6.y >= bbox.y1 && point6.y <= bbox.y2);
}
function getProjectionRadius(checkAxis, axis2) {
  return Math.abs(axis2[0] * checkAxis[0] + axis2[1] * checkAxis[1]);
}
function rotate({ x: x3, y: y3 }, deg, origin = {
  x: 0,
  y: 0
}) {
  return {
    x: (x3 - origin.x) * Math.cos(deg) + (y3 - origin.y) * Math.sin(deg) + origin.x,
    y: (x3 - origin.x) * Math.sin(deg) + (origin.y - y3) * Math.cos(deg) + origin.y
  };
}
function toDeg(angle2) {
  return angle2 / 180 * Math.PI;
}
function getCenterPoint(box) {
  return {
    x: (box.x1 + box.x2) / 2,
    y: (box.y1 + box.y2) / 2
  };
}
function toRect(box, isDeg) {
  const deg = isDeg ? box.angle : toDeg(box.angle), cp = getCenterPoint(box);
  return [rotate({
    x: box.x1,
    y: box.y1
  }, deg, cp), rotate({
    x: box.x2,
    y: box.y1
  }, deg, cp), rotate({
    x: box.x2,
    y: box.y2
  }, deg, cp), rotate({
    x: box.x1,
    y: box.y2
  }, deg, cp)];
}
function isRotateAABBIntersect(box1, box2, isDeg = false, ctx) {
  const rect1 = toRect(box1, isDeg), rect2 = toRect(box2, isDeg), vector = (start, end) => [end.x - start.x, end.y - start.y];
  ctx && (ctx.save(), ctx.fillStyle = "red", ctx.globalAlpha = 0.6, rect1.forEach((item, index) => {
    0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
  }), ctx.fill(), ctx.restore(), ctx.save(), ctx.fillStyle = "green", ctx.globalAlpha = 0.6, rect2.forEach((item, index) => {
    0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
  }), ctx.fill(), ctx.restore());
  const p1 = getCenterPoint(box1), p2 = getCenterPoint(box2);
  ctx && ctx.fillRect(p1.x, p1.y, 2, 2), ctx && ctx.fillRect(p2.x, p2.y, 2, 2);
  const vp1p2 = vector(p1, p2), AB = vector(rect1[0], rect1[1]), BC = vector(rect1[1], rect1[2]), A1B1 = vector(rect2[0], rect2[1]), B1C1 = vector(rect2[1], rect2[2]), deg11 = isDeg ? box1.angle : toDeg(box1.angle);
  let deg12 = isDeg ? box1.angle + halfPi : toDeg(90 - box1.angle);
  const deg21 = isDeg ? box2.angle : toDeg(box2.angle);
  let deg22 = isDeg ? box2.angle + halfPi : toDeg(90 - box2.angle);
  deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
  const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
    const checkAxis = [Math.cos(deg), Math.sin(deg)];
    return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
  };
  return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
}

// node_modules/@visactor/vutils/es/graphics/algorithm/aabb.js
var x1;
var y1;
var x2;
var y2;
function getAABBFromPoints(points) {
  return x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0, points.forEach((point6) => {
    x1 > point6.x && (x1 = point6.x), x2 < point6.x && (x2 = point6.x), y1 > point6.y && (y1 = point6.y), y2 < point6.y && (y2 = point6.y);
  }), {
    x1,
    y1,
    x2,
    y2
  };
}

// node_modules/@visactor/vutils/es/graphics/polygon.js
var EPSILON = 1e-8;
function lineIntersectPolygon(a1x, a1y, a2x, a2y, points) {
  for (let i2 = 0, p2 = points[points.length - 1]; i2 < points.length; i2++) {
    const p3 = points[i2];
    if (isIntersect([a1x, a1y], [a2x, a2y], [p3.x, p3.y], [p2.x, p2.y])) return true;
    p2 = p3;
  }
  return false;
}
function polygonContainPoint(points, x3, y3) {
  let w2 = 0, p2 = points[0];
  if (!p2) return false;
  for (let i2 = 1; i2 < points.length; i2++) {
    const p22 = points[i2];
    w2 += isPointInLine(p2.x, p2.y, p22.x, p22.y, x3, y3), p2 = p22;
  }
  const p0 = points[0];
  return isAroundEqual(p2.x, p0.x) && isAroundEqual(p2.y, p0.y) || (w2 += isPointInLine(p2.x, p2.y, p0.x, p0.y, x3, y3)), 0 !== w2;
}
function isPointInLine(x05, y05, x14, y14, x3, y3) {
  if (y3 > y05 && y3 > y14 || y3 < y05 && y3 < y14) return 0;
  if (y14 === y05) return 0;
  const t2 = (y3 - y05) / (y14 - y05);
  let dir = y14 < y05 ? 1 : -1;
  1 !== t2 && 0 !== t2 || (dir = y14 < y05 ? 0.5 : -0.5);
  const x_ = t2 * (x14 - x05) + x05;
  return x_ === x3 ? 1 / 0 : x_ > x3 ? dir : 0;
}
function isAroundEqual(a4, b2) {
  return Math.abs(a4 - b2) < EPSILON;
}
function polygonIntersectPolygon(pointsA, pointsB) {
  for (let i2 = 0; i2 < pointsB.length; i2++) {
    if (polygonContainPoint(pointsA, pointsB[i2].x, pointsB[i2].y)) return true;
    if (i2 > 0 && lineIntersectPolygon(pointsB[i2 - 1].x, pointsB[i2 - 1].y, pointsB[i2].x, pointsB[i2].y, pointsA)) return true;
  }
  return false;
}

// node_modules/@visactor/vutils/es/graphics/text/stringWidth.js
var eastAsianCharacterInfo = (character) => {
  let x3 = character.charCodeAt(0), y3 = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x3;
  return 55296 <= x3 && x3 <= 56319 && 56320 <= y3 && y3 <= 57343 && (x3 &= 1023, y3 &= 1023, codePoint = x3 << 10 | y3, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// node_modules/@visactor/vutils/es/graphics/text/measure/util.js
function getContextFont(text2, defaultAttr = {}) {
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize + "px " + (fontFamily || "sans-serif");
}

// node_modules/@visactor/vutils/es/graphics/text/measure/textMeasure.js
var TextMeasure = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return false;
    if (isNil_default(this._canvas) && (isValid_default(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default(this._context) && isValid_default(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale4 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale4;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default(text2)) return {
      width: 0,
      height: 0
    };
    if (isNil_default(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e3) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i2 = 0; i2 < text2.length; i2++) {
      const char = text2[i2];
      let size = this._measureSpecialChar(char);
      isNil_default(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil_default(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i2 = 0; i2 < text2.length; i2++) {
      const char = text2[i2], size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default(text2)) return defaultResult;
    if (isArray_default(text2)) {
      const textArr = text2.filter(isValid_default).map((s3) => s3.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default(this._canvas) && (this._canvas = null), isValid_default(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

// node_modules/@visactor/vutils/es/logger.js
var hasConsole = "undefined" != typeof console;
function log(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole && console[method].apply(console, args);
}
var LoggerLevel;
!function(LoggerLevel2) {
  LoggerLevel2[LoggerLevel2.None = 0] = "None", LoggerLevel2[LoggerLevel2.Error = 1] = "Error", LoggerLevel2[LoggerLevel2.Warn = 2] = "Warn", LoggerLevel2[LoggerLevel2.Info = 3] = "Info", LoggerLevel2[LoggerLevel2.Debug = 4] = "Debug";
}(LoggerLevel || (LoggerLevel = {}));
var Logger = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h2) => h2 === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex((h2) => h2 === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h2) => h2(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
  }
};
Logger._instance = null;

// node_modules/@visactor/vutils/es/padding.js
function normalizePadding(padding) {
  if (isValidNumber_default(padding)) return [padding, padding, padding, padding];
  if (isArray_default(padding)) {
    const length2 = padding.length;
    if (1 === length2) {
      const paddingValue = padding[0];
      return [paddingValue, paddingValue, paddingValue, paddingValue];
    }
    if (2 === length2) {
      const [vertical, horizontal] = padding;
      return [vertical, horizontal, vertical, horizontal];
    }
    if (3 === length2) {
      const [top, horizontal, bottom] = padding;
      return [top, horizontal, bottom, horizontal];
    }
    if (4 === length2) return padding;
  }
  if (isObject_default(padding)) {
    const { top = 0, right: right2 = 0, bottom = 0, left: left2 = 0 } = padding;
    return [top, right2, bottom, left2];
  }
  return [0, 0, 0, 0];
}

// node_modules/@visactor/vutils/es/time/interval.js
var SECOND = 1e3;
var MINUTE = 6e4;
var HOUR = 36e5;
var DAY = 24 * HOUR;
var MONTH = 31 * DAY;
var YEAR = 365 * DAY;

// node_modules/@visactor/vutils/es/dom.js
function getContainerSize(el, defaultWidth = 0, defaultHeight = 0) {
  if (!el) return {
    width: defaultWidth,
    height: defaultHeight
  };
  let getComputedStyle;
  try {
    getComputedStyle = null === window || void 0 === window ? void 0 : window.getComputedStyle;
  } catch (e3) {
    getComputedStyle = () => ({});
  }
  const style = getComputedStyle(el);
  if (/^(\d*\.?\d+)(px)$/.exec(style.width)) {
    const computedWidth = parseFloat(style.width) - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight) || el.clientWidth - 1, computedHeight = parseFloat(style.height) - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom) || el.clientHeight - 1;
    return {
      width: computedWidth <= 0 ? defaultWidth : computedWidth,
      height: computedHeight <= 0 ? defaultHeight : computedHeight
    };
  }
  return {
    width: defaultWidth,
    height: defaultHeight
  };
}
function getElementAbsolutePosition(element) {
  const { x: x3, y: y3 } = element.getBoundingClientRect();
  return {
    x: x3,
    y: y3
  };
}
function hasParentElement(element, target) {
  let parent = element.parentNode;
  for (; null !== parent; ) {
    if (parent === target) return true;
    parent = parent.parentNode;
  }
  return false;
}

// node_modules/@turf/helpers/dist/es/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function lengthToRadians(distance2, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function isObject2(input) {
  return !!input && input.constructor === Object;
}

// node_modules/@visactor/vutils/es/geo/invariant.js
function getGeom(geojson) {
  return "Feature" === geojson.type ? geojson.geometry : geojson;
}
function isPointInPolygon(point6, polygon) {
  if (!point6) return false;
  if (!polygon) return false;
  const geom = getGeom(polygon), type = geom.type, bbox = polygon.bbox;
  let polys = geom.coordinates;
  if (bbox && true === pointInRect(point6, {
    x1: bbox[0],
    x2: bbox[1],
    y1: bbox[1],
    y2: bbox[3]
  }, true)) return false;
  "Polygon" === type && (polys = [polys]);
  let result2 = false;
  for (let i2 = 0; i2 < polys.length; ++i2) for (let j2 = 0; j2 < polys[i2].length; ++j2) {
    if (polygonContainPoint(polys[i2][j2].map((p2) => ({
      x: p2[0],
      y: p2[1]
    })), point6.x, point6.y)) return result2 = true, result2;
  }
  return result2;
}
function destination(point6, distance2, bearing, options = {}) {
  const longitude1 = degreeToRadian(point6[0]), latitude1 = degreeToRadian(point6[1]), bearingRad = degreeToRadian(bearing), radians2 = lengthToRadians(distance2, options.units), latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad)), longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
  return {
    x: radianToDegree(longitude2),
    y: radianToDegree(latitude2)
  };
}

// node_modules/@visactor/vdataset/es/transform/filter.js
var filter = (data, options) => {
  const { callback } = options;
  return callback && (data = data.filter(callback)), data;
};

// node_modules/d3-geo/src/adder.js
function adder_default() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(y3) {
    add(temp, y3, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder, a4, b2) {
  var x3 = adder.s = a4 + b2, bv = x3 - a4, av = x3 - bv;
  adder.t = a4 - av + (b2 - bv);
}

// node_modules/d3-geo/src/math.js
var epsilon2 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau2 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log2 = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
}
function asin2(x3) {
  return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i2 = -1, n2 = features.length;
    while (++i2 < n2) streamGeometry(features[i2].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) object2 = coordinates[i2], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamLine(coordinates[i2], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates = object2.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamPolygon(coordinates[i2], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i2 = -1, n2 = geometries.length;
    while (++i2 < n2) streamGeometry(geometries[i2], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i2 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2) coordinate = coordinates[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i2 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i2 < n2) streamLine(coordinates[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = adder_default();
var areaSum = adder_default();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos2(phi);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi)];
}
function cartesianDot(a4, b2) {
  return a4[0] * b2[0] + a4[1] * b2[1] + a4[2] * b2[2];
}
function cartesianCross(a4, b2) {
  return [a4[1] * b2[2] - a4[2] * b2[1], a4[2] * b2[0] - a4[0] * b2[2], a4[0] * b2[1] - a4[1] * b2[0]];
}
function cartesianAddInPlace(a4, b2) {
  a4[0] += b2[0], a4[1] += b2[1], a4[2] += b2[2];
}
function cartesianScale(vector, k3) {
  return [vector[0] * k3, vector[1] * k3, vector[2] * k3];
}
function cartesianNormalizeInPlace(d2) {
  var l2 = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
}

// node_modules/d3-geo/src/bounds.js
var deltaSum = adder_default();

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b2) {
  function compose(x3, y3) {
    return x3 = a4(x3, y3), b2(x3[0], x3[1]);
  }
  if (a4.invert && b2.invert) compose.invert = function(x3, y3) {
    return x3 = b2.invert(x3, y3), x3 && a4.invert(x3[0], x3[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau2) * tau2 : lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau2 : lambda < -pi3 ? lambda + tau2 : lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos2(phi), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z2 = sin2(phi), k3 = z2 * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan22(y3 * cosDeltaGamma - k3 * sinDeltaGamma, x3 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin2(k3 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos2(phi), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z2 = sin2(phi), k3 = z2 * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan22(y3 * cosDeltaGamma + z2 * sinDeltaGamma, x3 * cosDeltaPhi + k3 * sinDeltaPhi),
      asin2(k3 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate3) {
  rotate3 = rotateRadians(rotate3[0] * radians, rotate3[1] * radians, rotate3.length > 2 ? rotate3[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate3(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate3.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction2, t0, t1) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction2 * delta;
  if (t0 == null) {
    t0 = radius + direction2 * tau2;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction2 > 0 ? t0 < t1 : t0 > t1) t0 += direction2 * tau2;
  }
  for (var point6, t2 = t0; direction2 > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos2(t2), -sinRadius * sin2(t2)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius = acos2(-point6[1]);
  return ((-point6[2] < 0 ? -radius : radius) + tau2 - epsilon2) % tau2;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line2;
  return {
    point: function(x3, y3, m5) {
      line2.push([x3, y3, m5]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result2 = lines;
      lines = [];
      line2 = null;
      return result2;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b2) {
  return abs2(a4[0] - b2[0]) < epsilon2 && abs2(a4[1] - b2[1]) < epsilon2;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i2, n2;
  segments2.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0) return;
    var n3, p0 = segment[0], p1 = segment[n3], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2) stream.point((p0 = segment[i2])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon2;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points, point6;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points.length; i2 < n2; ++i2) stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i2 = points.length - 1; i2 >= 0; --i2) stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array2) {
  if (!(n2 = array2.length)) return;
  var n2, i2 = 0, a4 = array2[0], b2;
  while (++i2 < n2) {
    a4.n = b2 = array2[i2];
    b2.p = a4;
    a4 = b2;
  }
  a4.n = b2 = array2[0];
  b2.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
var sum = adder_default();
function longitude(point6) {
  if (abs2(point6[0]) <= pi3)
    return point6[0];
  else
    return sign(point6[0]) * ((abs2(point6[0]) + pi3) % tau2 - pi3);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi = point6[1], sinPhi = sin2(phi), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  sum.reset();
  if (sinPhi === 1) phi = halfPi2 + epsilon2;
  else if (sinPhi === -1) phi = -halfPi2 - epsilon2;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m5 = (ring = polygon[i2]).length)) continue;
    var ring, m5, point0 = ring[m5 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j2 = 0; j2 < m5; ++j2, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign4 = delta >= 0 ? 1 : -1, absDelta = sign4 * delta, antimeridian = absDelta > pi3, k3 = sinPhi0 * sinPhi1;
      sum.add(atan22(k3 * sign4 * sin2(absDelta), cosPhi0 * cosPhi1 + k3 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign4 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon2 || angle2 < epsilon2 && sum < -epsilon2) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(sink) {
    var line2 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments2, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments2 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments2 = merge_default(segments2);
        var startInside = polygonContains_default(polygon, start);
        if (segments2.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments2, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments2 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line2.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line2.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m5, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m5 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m5; ++i2) sink.point((point7 = segment[i2])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments2.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b2) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon2 : halfPi2 - a4[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi2 - epsilon2 : halfPi2 - b2[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon2) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon2) lambda0 -= sign0 * epsilon2;
        if (abs2(lambda1 - sign1) < epsilon2) lambda1 -= sign1 * epsilon2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon2 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction2, stream) {
  var phi;
  if (from == null) {
    phi = direction2 * halfPi2;
    stream.point(-pi3, phi);
    stream.point(0, phi);
    stream.point(pi3, phi);
    stream.point(pi3, 0);
    stream.point(pi3, -phi);
    stream.point(0, -phi);
    stream.point(-pi3, -phi);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi);
  } else if (abs2(from[0] - to[0]) > epsilon2) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi = direction2 * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default(radius) {
  var cr = cos2(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon2;
  function interpolate2(from, to, direction2, stream) {
    circleStream(stream, radius, delta, direction2, from, to);
  }
  function visible(lambda, phi) {
    return cos2(lambda) * cos2(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v2 = visible(lambda, phi), c4 = smallRadius ? v2 ? 0 : code(lambda, phi) : v2 ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect4(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect4(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect4(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t2;
          if (!(c4 & c0) && (t2 = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c4;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a4, b2, two) {
    var pa = cartesian(a4), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a4;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B2);
    var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t2 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t2 < 0) return;
    var t3 = sqrt2(t2), q2 = cartesianScale(u2, (-w2 - t3) / uu);
    cartesianAddInPlace(q2, A5);
    q2 = spherical(q2);
    if (!two) return q2;
    var lambda0 = a4[0], lambda1 = b2[0], phi0 = a4[1], phi1 = b2[1], z2;
    if (lambda1 < lambda0) z2 = lambda0, lambda0 = lambda1, lambda1 = z2;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon2, meridian = polar || delta2 < epsilon2;
    if (!polar && phi1 < phi0) z2 = phi0, phi0 = phi1, phi1 = z2;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q2[1] < (abs2(q2[0] - lambda0) < epsilon2 ? phi0 : phi1) : phi0 <= q2[1] && q2[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q2[0] && q2[0] <= lambda1)) {
      var q1 = cartesianScale(u2, (-w2 + t3) / uu);
      cartesianAddInPlace(q1, A5);
      return [q2, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r2 = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r2) code2 |= 1;
    else if (lambda > r2) code2 |= 2;
    if (phi < -r2) code2 |= 4;
    else if (phi > r2) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a4, b2, x05, y05, x14, y14) {
  var ax = a4[0], ay = a4[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x05 - ax;
  if (!dx && r2 > 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = x14 - ax;
  if (!dx && r2 < 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  r2 = y05 - ay;
  if (!dy && r2 > 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = y14 - ay;
  if (!dy && r2 < 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  if (t0 > 0) a4[0] = ax + t0 * dx, a4[1] = ay + t0 * dy;
  if (t1 < 1) b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x14, y14) {
  function visible(x3, y3) {
    return x05 <= x3 && x3 <= x14 && y05 <= y3 && y3 <= y14;
  }
  function interpolate2(from, to, direction2, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from, to) < 0 ^ direction2 > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x14, a4 > 1 ? y14 : y05);
      while ((a4 = (a4 + direction2 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction2) {
    return abs2(p2[0] - x05) < epsilon2 ? direction2 > 0 ? 0 : 3 : abs2(p2[0] - x14) < epsilon2 ? direction2 > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon2 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b2) {
    return comparePoint(a4.x, b2.x);
  }
  function comparePoint(a4, b2) {
    var ca = corner(a4, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a4[1] : ca === 1 ? a4[0] - b2[0] : ca === 2 ? a4[1] - b2[1] : b2[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x3, y3) {
      if (visible(x3, y3)) activeStream.point(x3, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j2 = 1, m5 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j2 < m5; ++j2) {
          a0 = b0, a1 = b1, point7 = ring2[j2], b0 = point7[0], b1 = point7[1];
          if (a1 <= y14) {
            if (b1 > y14 && (b0 - a0) * (y14 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
          } else {
            if (b1 <= y14 && (b0 - a0) * (y14 - a1) < (b1 - a1) * (x05 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge_default(segments2)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments2 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments2) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments2.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x3, y3) {
      var v2 = visible(x3, y3);
      if (polygon) ring.push([x3, y3]);
      if (first) {
        x__ = x3, y__ = y3, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x3, y3);
        }
      } else {
        if (v2 && v_) activeStream.point(x3, y3);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default(a4, b2, x05, y05, x14, y14)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y3, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/length.js
var lengthSum = adder_default();

// node_modules/d3-geo/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/d3-geo/src/path/area.js
var areaSum2 = adder_default();
var areaRingSum2 = adder_default();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2.reset();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2.reset();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x3, y3) {
  areaStream2.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y3;
}
function areaPoint(x3, y3) {
  areaRingSum2.add(y0 * x3 - x0 * y3);
  x0 = x3, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x13 = -x02;
var y13 = x13;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x13, y13]];
    x13 = y13 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y3) {
  if (x3 < x02) x02 = x3;
  if (x3 > x13) x13 = x3;
  if (y3 < y02) y02 = y3;
  if (y3 > y13) y13 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y3) {
  X0 += x3;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidPointLine(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z2 = sqrt2(dx * dx + dy * dy);
  X1 += z2 * (x03 + x3) / 2;
  Y1 += z2 * (y03 + y3) / 2;
  Z1 += z2;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
}
function centroidPointRing(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z2 = sqrt2(dx * dx + dy * dy);
  X1 += z2 * (x03 + x3) / 2;
  Y1 += z2 * (y03 + y3) / 2;
  Z1 += z2;
  z2 = y03 * x3 - x03 * y3;
  X2 += z2 * (x03 + x3);
  Y2 += z2 * (y03 + y3);
  Z2 += z2 * 3;
  centroidPoint(x03 = x3, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y3);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y3);
        this._context.arc(x3, y3, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum2 = adder_default();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum2;
    lengthSum2.reset();
    return length2;
  }
};
function lengthPointFirst(x3, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y3;
}
function lengthPoint(x3, y3) {
  x04 -= x3, y04 -= y3;
  lengthSum2.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_2) {
    if ((_2 = +_2) !== this._radius) this._radius = _2, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x3, ",", y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x3, ",", y3);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x3, ",", y3, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result2 = this._string.join("");
      this._string = [];
      return result2;
    } else {
      return null;
    }
  }
};
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection4, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path(object2) {
    if (object2) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path.area = function(object2) {
    stream_default(object2, projectionStream(area_default));
    return area_default.result();
  };
  path.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path.projection = function(_2) {
    return arguments.length ? (projectionStream = _2 == null ? (projection4 = null, identity_default) : (projection4 = _2).stream, path) : projection4;
  };
  path.context = function(_2) {
    if (!arguments.length) return context;
    contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };
  path.pointRadius = function(_2) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path;
  };
  return path.projection(projection4).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods4) {
  return function(stream) {
    var s3 = new TransformStream();
    for (var key in methods4) s3[key] = methods4[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y3) {
    this.stream.point(x3, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection4, fitBounds, object2) {
  var clip = projection4.clipExtent && projection4.clipExtent();
  projection4.scale(150).translate([0, 0]);
  if (clip != null) projection4.clipExtent(null);
  stream_default(object2, projection4.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection4.clipExtent(clip);
  return projection4;
}
function fitExtent(projection4, extent5, object2) {
  return fit(projection4, function(b2) {
    var w2 = extent5[1][0] - extent5[0][0], h2 = extent5[1][1] - extent5[0][1], k3 = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x3 = +extent5[0][0] + (w2 - k3 * (b2[1][0] + b2[0][0])) / 2, y3 = +extent5[0][1] + (h2 - k3 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k3).translate([x3, y3]);
  }, object2);
}
function fitSize(projection4, size, object2) {
  return fitExtent(projection4, [[0, 0], size], object2);
}
function fitWidth(projection4, width, object2) {
  return fit(projection4, function(b2) {
    var w2 = +width, k3 = w2 / (b2[1][0] - b2[0][0]), x3 = (w2 - k3 * (b2[1][0] + b2[0][0])) / 2, y3 = -k3 * b2[0][1];
    projection4.scale(150 * k3).translate([x3, y3]);
  }, object2);
}
function fitHeight(projection4, height, object2) {
  return fit(projection4, function(b2) {
    var h2 = +height, k3 = h2 / (b2[1][1] - b2[0][1]), x3 = -k3 * b2[0][0], y3 = (h2 - k3 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k3).translate([x3, y3]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x3, y3) {
      x3 = project2(x3, y3);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x14, y14, lambda1, a1, b1, c1, depth, stream) {
    var dx = x14 - x05, dy = y14 - y05, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b2 = b0 + b1, c4 = c0 + c1, m5 = sqrt2(a4 * a4 + b2 * b2 + c4 * c4), phi2 = asin2(c4 /= m5), lambda2 = abs2(abs2(c4) - 1) < epsilon2 || abs2(lambda0 - lambda1) < epsilon2 ? (lambda0 + lambda1) / 2 : atan22(b2, a4), p2 = project2(lambda2, phi2), x23 = p2[0], y23 = p2[1], dx2 = x23 - x05, dy2 = y23 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x23, y23, lambda2, a4 /= m5, b2 /= m5, c4, depth, stream);
        stream.point(x23, y23);
        resampleLineTo(x23, y23, lambda2, a4, b2, c4, x14, y14, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x3, y3) {
      x3 = project2(x3, y3);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c4 = cartesian([lambda, phi]), p2 = project2(lambda, phi);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c4[0], b0 = c4[1], c0 = c4[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y3) {
    this.stream.point(x3 * radians, y3 * radians);
  }
});
function transformRotate(rotate3) {
  return transformer({
    point: function(x3, y3) {
      var r2 = rotate3(x3, y3);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k3, dx, dy, sx, sy) {
  function transform29(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [dx + k3 * x3, dy - k3 * y3];
  }
  transform29.invert = function(x3, y3) {
    return [(x3 - dx) / k3 * sx, (dy - y3) / k3 * sy];
  };
  return transform29;
}
function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k3, b2 = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
  function transform29(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [a4 * x3 - b2 * y3 + dx, dy - b2 * x3 - a4 * y3];
  }
  transform29.invert = function(x3, y3) {
    return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
  };
  return transform29;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k3 = 150, x3 = 480, y3 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate3, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x14, y14, postclip = identity_default, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection4(point6) {
    return projectRotateTransform(point6[0] * radians, point6[1] * radians);
  }
  function invert(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees, point6[1] * degrees];
  }
  projection4.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate3)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection4.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset3()) : preclip;
  };
  projection4.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x14 = y14 = null, reset3()) : postclip;
  };
  projection4.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians) : (theta = null, antimeridian_default), reset3()) : theta * degrees;
  };
  projection4.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x14 = y14 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x14 = +_2[1][0], y14 = +_2[1][1]), reset3()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  projection4.scale = function(_2) {
    return arguments.length ? (k3 = +_2, recenter()) : k3;
  };
  projection4.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
  };
  projection4.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };
  projection4.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection4.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection4.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection4.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection4.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset3()) : sqrt2(delta2);
  };
  projection4.fitExtent = function(extent5, object2) {
    return fitExtent(projection4, extent5, object2);
  };
  projection4.fitSize = function(size, object2) {
    return fitSize(projection4, size, object2);
  };
  projection4.fitWidth = function(width, object2) {
    return fitWidth(projection4, width, object2);
  };
  projection4.fitHeight = function(height, object2) {
    return fitHeight(projection4, height, object2);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi)), transform29 = (alpha ? scaleTranslateRotate : scaleTranslate)(k3, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
    rotate3 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform29);
    projectRotateTransform = compose_default(rotate3, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache = cacheStream = null;
    return projection4;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection4.invert = project2.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m5 = projectionMutator(projectAt), p2 = m5(phi0, phi1);
  p2.parallels = function(_2) {
    return arguments.length ? m5(phi0 = _2[0] * radians, phi1 = _2[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p2;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin2(phi) / cosPhi0];
  }
  forward.invert = function(x3, y3) {
    return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y14) {
  var sy0 = sin2(y05), n2 = (sy0 + sin2(y14)) / 2;
  if (abs2(n2) < epsilon2) return cylindricalEqualAreaRaw(y05);
  var c4 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c4) / n2;
  function project2(x3, y3) {
    var r2 = sqrt2(c4 - 2 * n2 * sin2(y3)) / n2;
    return [r2 * sin2(x3 *= n2), r0 - r2 * cos2(x3)];
  }
  project2.invert = function(x3, y3) {
    var r0y = r0 - y3, l2 = atan22(x3, abs2(r0y)) * sign(r0y);
    if (r0y * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(r0y);
    return [l2 / n2, asin2((c4 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x3, y3) {
      var i2 = -1;
      while (++i2 < n2) streams[i2].point(x3, y3);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x3, y3) {
    point6 = [x3, y3];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    return point6 = null, (lower48Point.point(x3, y3), point6) || (alaskaPoint.point(x3, y3), point6) || (hawaiiPoint.point(x3, y3), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k3 = lower48.scale(), t2 = lower48.translate(), x3 = (coordinates[0] - t2[0]) / k3, y3 = (coordinates[1] - t2[1]) / k3;
    return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset3();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length) return lower48.translate();
    var k3 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k3, y3 - 0.238 * k3], [x3 + 0.455 * k3, y3 + 0.238 * k3]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k3, y3 + 0.201 * k3]).clipExtent([[x3 - 0.425 * k3 + epsilon2, y3 + 0.12 * k3 + epsilon2], [x3 - 0.214 * k3 - epsilon2, y3 + 0.234 * k3 - epsilon2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k3, y3 + 0.212 * k3]).clipExtent([[x3 - 0.214 * k3 + epsilon2, y3 + 0.166 * k3 + epsilon2], [x3 - 0.115 * k3 - epsilon2, y3 + 0.234 * k3 - epsilon2]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent5, object2) {
    return fitExtent(albersUsa, extent5, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width, object2) {
    return fitWidth(albersUsa, width, object2);
  };
  albersUsa.fitHeight = function(height, object2) {
    return fitHeight(albersUsa, height, object2);
  };
  function reset3() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale4) {
  return function(x3, y3) {
    var cx = cos2(x3), cy = cos2(y3), k3 = scale4(cx * cy);
    return [
      k3 * cy * sin2(x3),
      k3 * sin2(y3)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x3, y3) {
    var z2 = sqrt2(x3 * x3 + y3 * y3), c4 = angle2(z2), sc = sin2(c4), cc = cos2(c4);
    return [
      atan22(x3 * sc, z2 * cc),
      asin2(z2 && y3 * sc / z2)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
  return 2 * asin2(z2 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c4) {
  return (c4 = acos2(c4)) && c4 / sin2(c4);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
  return z2;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log2(tan((halfPi2 + phi) / 2))];
}
mercatorRaw.invert = function(x3, y3) {
  return [x3, 2 * atan(exp(y3)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project2) {
  var m5 = projection(project2), center2 = m5.center, scale4 = m5.scale, translate2 = m5.translate, clipExtent = m5.clipExtent, x05 = null, y05, x14, y14;
  m5.scale = function(_2) {
    return arguments.length ? (scale4(_2), reclip()) : scale4();
  };
  m5.translate = function(_2) {
    return arguments.length ? (translate2(_2), reclip()) : translate2();
  };
  m5.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m5.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x14 = y14 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x14 = +_2[1][0], y14 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  function reclip() {
    var k3 = pi3 * scale4(), t2 = m5(rotation_default(m5.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t2[0] - k3, t2[1] - k3], [t2[0] + k3, t2[1] + k3]] : project2 === mercatorRaw ? [[Math.max(t2[0] - k3, x05), y05], [Math.min(t2[0] + k3, x14), y14]] : [[x05, Math.max(t2[1] - k3, y05)], [x14, Math.min(t2[1] + k3, y14)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi2 + y3) / 2);
}
function conicConformalRaw(y05, y14) {
  var cy0 = cos2(y05), n2 = y05 === y14 ? sin2(y05) : log2(cy0 / cos2(y14)) / log2(tany(y14) / tany(y05)), f2 = cy0 * pow2(tany(y05), n2) / n2;
  if (!n2) return mercatorRaw;
  function project2(x3, y3) {
    if (f2 > 0) {
      if (y3 < -halfPi2 + epsilon2) y3 = -halfPi2 + epsilon2;
    } else {
      if (y3 > halfPi2 - epsilon2) y3 = halfPi2 - epsilon2;
    }
    var r2 = f2 / pow2(tany(y3), n2);
    return [r2 * sin2(n2 * x3), f2 - r2 * cos2(n2 * x3)];
  }
  project2.invert = function(x3, y3) {
    var fy = f2 - y3, r2 = sign(n2) * sqrt2(x3 * x3 + fy * fy), l2 = atan22(x3, abs2(fy)) * sign(fy);
    if (fy * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(fy);
    return [l2 / n2, 2 * atan(pow2(f2 / r2, 1 / n2)) - halfPi2];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y14) {
  var cy0 = cos2(y05), n2 = y05 === y14 ? sin2(y05) : (cy0 - cos2(y14)) / (y14 - y05), g3 = cy0 / n2 + y05;
  if (abs2(n2) < epsilon2) return equirectangularRaw;
  function project2(x3, y3) {
    var gy = g3 - y3, nx = n2 * x3;
    return [gy * sin2(nx), g3 - gy * cos2(nx)];
  }
  project2.invert = function(x3, y3) {
    var gy = g3 - y3, l2 = atan22(x3, abs2(gy)) * sign(gy);
    if (gy * n2 < 0)
      l2 -= pi3 * sign(x3) * sign(gy);
    return [l2 / n2, g3 - sign(n2) * sqrt2(x3 * x3 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l2 = asin2(M * sin2(phi)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos2(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x3, y3) {
  var l2 = y3, l22 = l2 * l2, l6 = l22 * l22 * l22;
  for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
    fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y3;
    fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
    l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x3 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
    asin2(sin2(l2) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y3) {
  var cy = cos2(y3), k3 = cos2(x3) * cy;
  return [cy * sin2(x3) / k3, sin2(y3) / k3];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default2() {
  var k3 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x14, y14, kx2 = 1, ky2 = 1, transform29 = transformer({
    point: function(x3, y3) {
      var p2 = projection4([x3, y3]);
      this.stream.point(p2[0], p2[1]);
    }
  }), postclip = identity_default, cache, cacheStream;
  function reset3() {
    kx2 = k3 * sx;
    ky2 = k3 * sy;
    cache = cacheStream = null;
    return projection4;
  }
  function projection4(p2) {
    var x3 = p2[0] * kx2, y3 = p2[1] * ky2;
    if (alpha) {
      var t2 = y3 * ca - x3 * sa;
      x3 = x3 * ca + y3 * sa;
      y3 = t2;
    }
    return [x3 + tx, y3 + ty];
  }
  projection4.invert = function(p2) {
    var x3 = p2[0] - tx, y3 = p2[1] - ty;
    if (alpha) {
      var t2 = y3 * ca + x3 * sa;
      x3 = x3 * ca - y3 * sa;
      y3 = t2;
    }
    return [x3 / kx2, y3 / ky2];
  };
  projection4.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform29(postclip(cacheStream = stream));
  };
  projection4.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x14 = y14 = null, reset3()) : postclip;
  };
  projection4.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x14 = y14 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x14 = +_2[1][0], y14 = +_2[1][1]), reset3()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  projection4.scale = function(_2) {
    return arguments.length ? (k3 = +_2, reset3()) : k3;
  };
  projection4.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset3()) : [tx, ty];
  };
  projection4.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset3()) : alpha * degrees;
  };
  projection4.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset3()) : sx < 0;
  };
  projection4.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset3()) : sy < 0;
  };
  projection4.fitExtent = function(extent5, object2) {
    return fitExtent(projection4, extent5, object2);
  };
  projection4.fitSize = function(size, object2) {
    return fitSize(projection4, size, object2);
  };
  projection4.fitWidth = function(width, object2) {
    return fitWidth(projection4, width, object2);
  };
  projection4.fitHeight = function(height, object2) {
    return fitHeight(projection4, height, object2);
  };
  return projection4;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x3, y3) {
  var phi = y3, i2 = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y3) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon2 && --i2 > 0);
  return [
    x3 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
    phi
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y3) {
  return [cos2(y3) * sin2(x3), sin2(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon2);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y3) {
  var cy = cos2(y3), k3 = 1 + cos2(x3) * cy;
  return [cy * sin2(x3) / k3, sin2(y3) / k3];
}
stereographicRaw.invert = azimuthalInvert(function(z2) {
  return 2 * atan(z2);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log2(tan((halfPi2 + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y3) {
  return [-y3, 2 * atan(exp(x3)) - halfPi2];
};
function transverseMercator_default() {
  var m5 = mercatorProjection(transverseMercatorRaw), center2 = m5.center, rotate3 = m5.rotate;
  m5.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m5.rotate = function(_2) {
    return arguments.length ? rotate3([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate3(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate3([0, 0, 90]).scale(159.155);
}

// node_modules/@visactor/vdataset/es/utils/geo.js
var WORLD_SIZE = 63781 * Math.PI * 2;
var fov = 0.25 * Math.PI;
var WORLD_HEIGHT = WORLD_SIZE / 2 / Math.tan(fov);
var PROJECTION_MERCATOR = mercator_default().translate([0, 0]).center([0, 0]).scale(63781);

// node_modules/@visactor/vdataset/es/transform/geo/dissolve.js
var import_geojson_dissolve = __toESM(require_geojson_dissolve());

// node_modules/@visactor/vdataset/es/transform/geo/simplify.js
var import_simplify_geojson = __toESM(require_simplify_geojson());

// node_modules/@visactor/vdataset/es/utils/js.js
var mergeDeepImmer = function(target, ...sources) {
  return mergeOption(cloneDeep(target), ...sources);
};
function _mergeOptionDeep(target, source, key) {
  const sourceValue = source[key];
  if (void 0 === sourceValue) target[key] = null;
  else if (isObject_default(sourceValue)) {
    isObject_default(target[key]) || (target[key] = {});
    for (const _key in sourceValue) _mergeOptionDeep(target[key], sourceValue, _key);
  } else target[key] = sourceValue;
}
function _mergeOptionBase(target, source) {
  if (isObject_default(source) && target !== source) for (const key in source) _mergeOptionDeep(target, source, key);
}
function mergeOption(target, ...sources) {
  target || (target = {});
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    _mergeOptionBase(target, sources[sourceIndex]);
  }
  return target;
}

// node_modules/@visactor/vdataset/es/transform/geo/simplify.js
var DEFAULT_SIMPLIFY_OPTIONS = {
  tolerance: 0.01
};
var simplify = (data, options) => {
  const mergeOptions = mergeDeepImmer(DEFAULT_SIMPLIFY_OPTIONS, options), { tolerance } = mergeOptions;
  return (0, import_simplify_geojson.default)(data, tolerance);
};

// node_modules/simple-statistics/dist/simple-statistics.mjs
var simple_statistics_exports = {};
__export(simple_statistics_exports, {
  BayesianClassifier: () => BayesianClassifier,
  PerceptronModel: () => PerceptronModel,
  addToMean: () => addToMean,
  approxEqual: () => approxEqual,
  average: () => mean,
  averageSimple: () => meanSimple,
  bayesian: () => BayesianClassifier,
  bernoulliDistribution: () => bernoulliDistribution,
  binomialDistribution: () => binomialDistribution,
  bisect: () => bisect2,
  chiSquaredDistributionTable: () => chiSquaredDistributionTable,
  chiSquaredGoodnessOfFit: () => chiSquaredGoodnessOfFit,
  chunk: () => chunk,
  ckmeans: () => ckmeans,
  coefficientOfVariation: () => coefficientOfVariation,
  combinations: () => combinations,
  combinationsReplacement: () => combinationsReplacement,
  combineMeans: () => combineMeans,
  combineVariances: () => combineVariances,
  cumulativeStdLogisticProbability: () => cumulativeStdLogisticProbability,
  cumulativeStdNormalProbability: () => cumulativeStdNormalProbability,
  epsilon: () => epsilon3,
  equalIntervalBreaks: () => equalIntervalBreaks,
  erf: () => errorFunction,
  errorFunction: () => errorFunction,
  extent: () => extent,
  extentSorted: () => extentSorted,
  factorial: () => factorial,
  gamma: () => gamma,
  gammaln: () => gammaln,
  geometricMean: () => geometricMean,
  harmonicMean: () => harmonicMean,
  interquartileRange: () => interquartileRange,
  inverseErrorFunction: () => inverseErrorFunction,
  iqr: () => interquartileRange,
  jenks: () => jenks,
  kMeansCluster: () => kMeansCluster,
  kde: () => kernelDensityEstimation,
  kernelDensityEstimation: () => kernelDensityEstimation,
  linearRegression: () => linearRegression,
  linearRegressionLine: () => linearRegressionLine,
  logAverage: () => logAverage,
  logit: () => logit,
  mad: () => medianAbsoluteDeviation,
  max: () => max2,
  maxSorted: () => maxSorted,
  mean: () => mean,
  meanSimple: () => meanSimple,
  median: () => median2,
  medianAbsoluteDeviation: () => medianAbsoluteDeviation,
  medianSorted: () => medianSorted,
  min: () => min2,
  minSorted: () => minSorted,
  mode: () => mode,
  modeFast: () => modeFast,
  modeSorted: () => modeSorted,
  numericSort: () => numericSort,
  perceptron: () => PerceptronModel,
  permutationTest: () => permutationTest,
  permutationsHeap: () => permutationsHeap,
  poissonDistribution: () => poissonDistribution,
  probit: () => probit,
  product: () => product,
  quantile: () => quantile,
  quantileRank: () => quantileRank,
  quantileRankSorted: () => quantileRankSorted,
  quantileSorted: () => quantileSorted2,
  quickselect: () => quickselect,
  rSquared: () => rSquared,
  relativeError: () => relativeError,
  rms: () => rootMeanSquare,
  rootMeanSquare: () => rootMeanSquare,
  sample: () => sample,
  sampleCorrelation: () => sampleCorrelation,
  sampleCovariance: () => sampleCovariance,
  sampleKurtosis: () => sampleKurtosis,
  sampleRankCorrelation: () => sampleRankCorrelation,
  sampleSkewness: () => sampleSkewness,
  sampleStandardDeviation: () => sampleStandardDeviation,
  sampleVariance: () => sampleVariance,
  sampleWithReplacement: () => sampleWithReplacement,
  shuffle: () => shuffle,
  shuffleInPlace: () => shuffleInPlace,
  sign: () => sign2,
  silhouette: () => silhouette,
  silhouetteMetric: () => silhouetteMetric,
  standardDeviation: () => standardDeviation,
  standardNormalTable: () => standardNormalTable,
  subtractFromMean: () => subtractFromMean,
  sum: () => sum2,
  sumNthPowerDeviations: () => sumNthPowerDeviations,
  sumSimple: () => sumSimple,
  tTest: () => tTest,
  tTestTwoSample: () => tTestTwoSample,
  uniqueCountSorted: () => uniqueCountSorted,
  variance: () => variance2,
  wilcoxonRankSum: () => wilcoxonRankSum,
  zScore: () => zScore
});
function linearRegression(data) {
  var m5;
  var b2;
  var dataLength = data.length;
  if (dataLength === 1) {
    m5 = 0;
    b2 = data[0][1];
  } else {
    var sumX = 0;
    var sumY = 0;
    var sumXX = 0;
    var sumXY = 0;
    var point6;
    var x3;
    var y3;
    for (var i2 = 0; i2 < dataLength; i2++) {
      point6 = data[i2];
      x3 = point6[0];
      y3 = point6[1];
      sumX += x3;
      sumY += y3;
      sumXX += x3 * x3;
      sumXY += x3 * y3;
    }
    m5 = (dataLength * sumXY - sumX * sumY) / (dataLength * sumXX - sumX * sumX);
    b2 = sumY / dataLength - m5 * sumX / dataLength;
  }
  return {
    m: m5,
    b: b2
  };
}
function linearRegressionLine(mb) {
  return function(x3) {
    return mb.b + mb.m * x3;
  };
}
function sum2(x3) {
  if (x3.length === 0) {
    return 0;
  }
  var sum5 = x3[0];
  var correction = 0;
  var transition;
  if (typeof sum5 !== "number") {
    return Number.NaN;
  }
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (typeof x3[i2] !== "number") {
      return Number.NaN;
    }
    transition = sum5 + x3[i2];
    if (Math.abs(sum5) >= Math.abs(x3[i2])) {
      correction += sum5 - transition + x3[i2];
    } else {
      correction += x3[i2] - transition + sum5;
    }
    sum5 = transition;
  }
  return sum5 + correction;
}
function mean(x3) {
  if (x3.length === 0) {
    throw new Error("mean requires at least one data point");
  }
  return sum2(x3) / x3.length;
}
function sumNthPowerDeviations(x3, n2) {
  var meanValue = mean(x3);
  var sum5 = 0;
  var tempValue;
  var i2;
  if (n2 === 2) {
    for (i2 = 0; i2 < x3.length; i2++) {
      tempValue = x3[i2] - meanValue;
      sum5 += tempValue * tempValue;
    }
  } else {
    for (i2 = 0; i2 < x3.length; i2++) {
      sum5 += Math.pow(x3[i2] - meanValue, n2);
    }
  }
  return sum5;
}
function variance2(x3) {
  if (x3.length === 0) {
    throw new Error("variance requires at least one data point");
  }
  return sumNthPowerDeviations(x3, 2) / x3.length;
}
function standardDeviation(x3) {
  if (x3.length === 1) {
    return 0;
  }
  var v2 = variance2(x3);
  return Math.sqrt(v2);
}
function rSquared(x3, func) {
  if (x3.length < 2) {
    return 1;
  }
  var sum5 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sum5 += x3[i2][1];
  }
  var average3 = sum5 / x3.length;
  var sumOfSquares = 0;
  for (var j2 = 0; j2 < x3.length; j2++) {
    sumOfSquares += Math.pow(average3 - x3[j2][1], 2);
  }
  var err = 0;
  for (var k3 = 0; k3 < x3.length; k3++) {
    err += Math.pow(x3[k3][1] - func(x3[k3][0]), 2);
  }
  return 1 - err / sumOfSquares;
}
function modeSorted(sorted) {
  if (sorted.length === 0) {
    throw new Error("mode requires at least one data point");
  }
  if (sorted.length === 1) {
    return sorted[0];
  }
  var last2 = sorted[0];
  var value = Number.NaN;
  var maxSeen = 0;
  var seenThis = 1;
  for (var i2 = 1; i2 < sorted.length + 1; i2++) {
    if (sorted[i2] !== last2) {
      if (seenThis > maxSeen) {
        maxSeen = seenThis;
        value = last2;
      }
      seenThis = 1;
      last2 = sorted[i2];
    } else {
      seenThis++;
    }
  }
  return value;
}
function numericSort(x3) {
  return x3.slice().sort(function(a4, b2) {
    return a4 - b2;
  });
}
function mode(x3) {
  return modeSorted(numericSort(x3));
}
function modeFast(x3) {
  var index = /* @__PURE__ */ new Map();
  var mode2;
  var modeCount = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    var newCount = index.get(x3[i2]);
    if (newCount === void 0) {
      newCount = 1;
    } else {
      newCount++;
    }
    if (newCount > modeCount) {
      mode2 = x3[i2];
      modeCount = newCount;
    }
    index.set(x3[i2], newCount);
  }
  if (modeCount === 0) {
    throw new Error("mode requires at last one data point");
  }
  return mode2;
}
function min2(x3) {
  if (x3.length === 0) {
    throw new Error("min requires at least one data point");
  }
  var value = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] < value) {
      value = x3[i2];
    }
  }
  return value;
}
function max2(x3) {
  if (x3.length === 0) {
    throw new Error("max requires at least one data point");
  }
  var value = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] > value) {
      value = x3[i2];
    }
  }
  return value;
}
function extent(x3) {
  if (x3.length === 0) {
    throw new Error("extent requires at least one data point");
  }
  var min4 = x3[0];
  var max4 = x3[0];
  for (var i2 = 1; i2 < x3.length; i2++) {
    if (x3[i2] > max4) {
      max4 = x3[i2];
    }
    if (x3[i2] < min4) {
      min4 = x3[i2];
    }
  }
  return [min4, max4];
}
function minSorted(x3) {
  return x3[0];
}
function maxSorted(x3) {
  return x3[x3.length - 1];
}
function extentSorted(x3) {
  return [x3[0], x3[x3.length - 1]];
}
function sumSimple(x3) {
  var value = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (typeof x3[i2] !== "number") {
      return Number.NaN;
    }
    value += x3[i2];
  }
  return value;
}
function product(x3) {
  var value = 1;
  for (var i2 = 0; i2 < x3.length; i2++) {
    value *= x3[i2];
  }
  return value;
}
function quantileSorted2(x3, p2) {
  var idx = x3.length * p2;
  if (x3.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p2 < 0 || p2 > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p2 === 1) {
    return x3[x3.length - 1];
  } else if (p2 === 0) {
    return x3[0];
  } else if (idx % 1 !== 0) {
    return x3[Math.ceil(idx) - 1];
  } else if (x3.length % 2 === 0) {
    return (x3[idx - 1] + x3[idx]) / 2;
  } else {
    return x3[idx];
  }
}
function quickselect(arr, k3, left2, right2) {
  left2 = left2 || 0;
  right2 = right2 || arr.length - 1;
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      var n2 = right2 - left2 + 1;
      var m5 = k3 - left2 + 1;
      var z2 = Math.log(n2);
      var s3 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s3 * (n2 - s3) / n2);
      if (m5 - n2 / 2 < 0) {
        sd *= -1;
      }
      var newLeft = Math.max(left2, Math.floor(k3 - m5 * s3 / n2 + sd));
      var newRight = Math.min(
        right2,
        Math.floor(k3 + (n2 - m5) * s3 / n2 + sd)
      );
      quickselect(arr, k3, newLeft, newRight);
    }
    var t2 = arr[k3];
    var i2 = left2;
    var j2 = right2;
    swap(arr, left2, k3);
    if (arr[right2] > t2) {
      swap(arr, left2, right2);
    }
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (arr[i2] < t2) {
        i2++;
      }
      while (arr[j2] > t2) {
        j2--;
      }
    }
    if (arr[left2] === t2) {
      swap(arr, left2, j2);
    } else {
      j2++;
      swap(arr, j2, right2);
    }
    if (j2 <= k3) {
      left2 = j2 + 1;
    }
    if (k3 <= j2) {
      right2 = j2 - 1;
    }
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function quantile(x3, p2) {
  var copy = x3.slice();
  if (Array.isArray(p2)) {
    multiQuantileSelect(copy, p2);
    var results = [];
    for (var i2 = 0; i2 < p2.length; i2++) {
      results[i2] = quantileSorted2(copy, p2[i2]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy.length, p2);
    quantileSelect(copy, idx, 0, copy.length - 1);
    return quantileSorted2(copy, p2);
  }
}
function quantileSelect(arr, k3, left2, right2) {
  if (k3 % 1 === 0) {
    quickselect(arr, k3, left2, right2);
  } else {
    k3 = Math.floor(k3);
    quickselect(arr, k3, left2, right2);
    quickselect(arr, k3 + 1, k3 + 1, right2);
  }
}
function multiQuantileSelect(arr, p2) {
  var indices = [0];
  for (var i2 = 0; i2 < p2.length; i2++) {
    indices.push(quantileIndex(arr.length, p2[i2]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack2 = [0, indices.length - 1];
  while (stack2.length) {
    var r2 = Math.ceil(stack2.pop());
    var l2 = Math.floor(stack2.pop());
    if (r2 - l2 <= 1) {
      continue;
    }
    var m5 = Math.floor((l2 + r2) / 2);
    quantileSelect(
      arr,
      indices[m5],
      Math.floor(indices[l2]),
      Math.ceil(indices[r2])
    );
    stack2.push(l2, m5, m5, r2);
  }
}
function compare(a4, b2) {
  return a4 - b2;
}
function quantileIndex(len, p2) {
  var idx = len * p2;
  if (p2 === 1) {
    return len - 1;
  } else if (p2 === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}
function quantileRankSorted(x3, value) {
  if (value < x3[0]) {
    return 0;
  }
  if (value > x3[x3.length - 1]) {
    return 1;
  }
  var l2 = lowerBound(x3, value);
  if (x3[l2] !== value) {
    return l2 / x3.length;
  }
  l2++;
  var u2 = upperBound(x3, value);
  if (u2 === l2) {
    return l2 / x3.length;
  }
  var r2 = u2 - l2 + 1;
  var sum5 = r2 * (u2 + l2) / 2;
  var mean2 = sum5 / r2;
  return mean2 / x3.length;
}
function lowerBound(x3, value) {
  var mid = 0;
  var lo = 0;
  var hi = x3.length;
  while (lo < hi) {
    mid = lo + hi >>> 1;
    if (value <= x3[mid]) {
      hi = mid;
    } else {
      lo = -~mid;
    }
  }
  return lo;
}
function upperBound(x3, value) {
  var mid = 0;
  var lo = 0;
  var hi = x3.length;
  while (lo < hi) {
    mid = lo + hi >>> 1;
    if (value >= x3[mid]) {
      lo = -~mid;
    } else {
      hi = mid;
    }
  }
  return lo;
}
function quantileRank(x3, value) {
  var sortedCopy = numericSort(x3);
  return quantileRankSorted(sortedCopy, value);
}
function interquartileRange(x3) {
  var q1 = quantile(x3, 0.75);
  var q2 = quantile(x3, 0.25);
  if (typeof q1 === "number" && typeof q2 === "number") {
    return q1 - q2;
  }
}
function median2(x3) {
  return +quantile(x3, 0.5);
}
function medianAbsoluteDeviation(x3) {
  var medianValue = median2(x3);
  var medianAbsoluteDeviations = [];
  for (var i2 = 0; i2 < x3.length; i2++) {
    medianAbsoluteDeviations.push(Math.abs(x3[i2] - medianValue));
  }
  return median2(medianAbsoluteDeviations);
}
function chunk(x3, chunkSize) {
  var output = [];
  if (chunkSize < 1) {
    throw new Error("chunk size must be a positive number");
  }
  if (Math.floor(chunkSize) !== chunkSize) {
    throw new Error("chunk size must be an integer");
  }
  for (var start = 0; start < x3.length; start += chunkSize) {
    output.push(x3.slice(start, start + chunkSize));
  }
  return output;
}
function sampleWithReplacement(x3, n2, randomSource) {
  if (x3.length === 0) {
    return [];
  }
  randomSource = randomSource || Math.random;
  var length2 = x3.length;
  var sample3 = [];
  for (var i2 = 0; i2 < n2; i2++) {
    var index = Math.floor(randomSource() * length2);
    sample3.push(x3[index]);
  }
  return sample3;
}
function shuffleInPlace(x3, randomSource) {
  randomSource = randomSource || Math.random;
  var length2 = x3.length;
  var temporary;
  var index;
  while (length2 > 0) {
    index = Math.floor(randomSource() * length2--);
    temporary = x3[length2];
    x3[length2] = x3[index];
    x3[index] = temporary;
  }
  return x3;
}
function shuffle(x3, randomSource) {
  var sample3 = x3.slice();
  return shuffleInPlace(sample3, randomSource);
}
function sample(x3, n2, randomSource) {
  var shuffled = shuffle(x3, randomSource);
  return shuffled.slice(0, n2);
}
function makeMatrix(columns, rows) {
  var matrix = [];
  for (var i2 = 0; i2 < columns; i2++) {
    var column = [];
    for (var j2 = 0; j2 < rows; j2++) {
      column.push(0);
    }
    matrix.push(column);
  }
  return matrix;
}
function uniqueCountSorted(x3) {
  var uniqueValueCount = 0;
  var lastSeenValue;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (i2 === 0 || x3[i2] !== lastSeenValue) {
      lastSeenValue = x3[i2];
      uniqueValueCount++;
    }
  }
  return uniqueValueCount;
}
function ssq(j2, i2, sums, sumsOfSquares) {
  var sji;
  if (j2 > 0) {
    var muji = (sums[i2] - sums[j2 - 1]) / (i2 - j2 + 1);
    sji = sumsOfSquares[i2] - sumsOfSquares[j2 - 1] - (i2 - j2 + 1) * muji * muji;
  } else {
    sji = sumsOfSquares[i2] - sums[i2] * sums[i2] / (i2 + 1);
  }
  if (sji < 0) {
    return 0;
  }
  return sji;
}
function fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {
  if (iMin > iMax) {
    return;
  }
  var i2 = Math.floor((iMin + iMax) / 2);
  matrix[cluster][i2] = matrix[cluster - 1][i2 - 1];
  backtrackMatrix[cluster][i2] = i2;
  var jlow = cluster;
  if (iMin > cluster) {
    jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
  }
  jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i2] || 0);
  var jhigh = i2 - 1;
  if (iMax < matrix[0].length - 1) {
    jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
  }
  var sji;
  var sjlowi;
  var ssqjlow;
  var ssqj;
  for (var j2 = jhigh; j2 >= jlow; --j2) {
    sji = ssq(j2, i2, sums, sumsOfSquares);
    if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i2]) {
      break;
    }
    sjlowi = ssq(jlow, i2, sums, sumsOfSquares);
    ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];
    if (ssqjlow < matrix[cluster][i2]) {
      matrix[cluster][i2] = ssqjlow;
      backtrackMatrix[cluster][i2] = jlow;
    }
    jlow++;
    ssqj = sji + matrix[cluster - 1][j2 - 1];
    if (ssqj < matrix[cluster][i2]) {
      matrix[cluster][i2] = ssqj;
      backtrackMatrix[cluster][i2] = j2;
    }
  }
  fillMatrixColumn(
    iMin,
    i2 - 1,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
  );
  fillMatrixColumn(
    i2 + 1,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
  );
}
function fillMatrices(data, matrix, backtrackMatrix) {
  var nValues = matrix[0].length;
  var shift = data[Math.floor(nValues / 2)];
  var sums = [];
  var sumsOfSquares = [];
  for (var i2 = 0, shiftedValue = void 0; i2 < nValues; ++i2) {
    shiftedValue = data[i2] - shift;
    if (i2 === 0) {
      sums.push(shiftedValue);
      sumsOfSquares.push(shiftedValue * shiftedValue);
    } else {
      sums.push(sums[i2 - 1] + shiftedValue);
      sumsOfSquares.push(
        sumsOfSquares[i2 - 1] + shiftedValue * shiftedValue
      );
    }
    matrix[0][i2] = ssq(0, i2, sums, sumsOfSquares);
    backtrackMatrix[0][i2] = 0;
  }
  var iMin;
  for (var cluster = 1; cluster < matrix.length; ++cluster) {
    if (cluster < matrix.length - 1) {
      iMin = cluster;
    } else {
      iMin = nValues - 1;
    }
    fillMatrixColumn(
      iMin,
      nValues - 1,
      cluster,
      matrix,
      backtrackMatrix,
      sums,
      sumsOfSquares
    );
  }
}
function ckmeans(x3, nClusters) {
  if (nClusters > x3.length) {
    throw new Error(
      "cannot generate more classes than there are data values"
    );
  }
  var sorted = numericSort(x3);
  var uniqueCount = uniqueCountSorted(sorted);
  if (uniqueCount === 1) {
    return [sorted];
  }
  var matrix = makeMatrix(nClusters, sorted.length);
  var backtrackMatrix = makeMatrix(nClusters, sorted.length);
  fillMatrices(sorted, matrix, backtrackMatrix);
  var clusters = [];
  var clusterRight = backtrackMatrix[0].length - 1;
  for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
    var clusterLeft = backtrackMatrix[cluster][clusterRight];
    clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);
    if (cluster > 0) {
      clusterRight = clusterLeft - 1;
    }
  }
  return clusters;
}
function jenksBreaks(data, lowerClassLimits, nClasses) {
  var k3 = data.length;
  var kclass = [];
  var countNum = nClasses;
  kclass[nClasses] = data[data.length - 1];
  while (countNum > 0) {
    kclass[countNum - 1] = data[lowerClassLimits[k3][countNum] - 1];
    k3 = lowerClassLimits[k3][countNum] - 1;
    countNum--;
  }
  return kclass;
}
function jenksMatrices(data, nClasses) {
  var lowerClassLimits = [];
  var varianceCombinations = [];
  var i2;
  var j2;
  var variance4 = 0;
  for (i2 = 0; i2 < data.length + 1; i2++) {
    var tmp1 = [];
    var tmp2 = [];
    for (j2 = 0; j2 < nClasses + 1; j2++) {
      tmp1.push(0);
      tmp2.push(0);
    }
    lowerClassLimits.push(tmp1);
    varianceCombinations.push(tmp2);
  }
  for (i2 = 1; i2 < nClasses + 1; i2++) {
    lowerClassLimits[1][i2] = 1;
    varianceCombinations[1][i2] = 0;
    for (j2 = 2; j2 < data.length + 1; j2++) {
      varianceCombinations[j2][i2] = Number.POSITIVE_INFINITY;
    }
  }
  for (var l2 = 2; l2 < data.length + 1; l2++) {
    var sum5 = 0;
    var sumSquares = 0;
    var w2 = 0;
    var i4 = 0;
    for (var m5 = 1; m5 < l2 + 1; m5++) {
      var lowerClassLimit = l2 - m5 + 1;
      var val = data[lowerClassLimit - 1];
      w2++;
      sum5 += val;
      sumSquares += val * val;
      variance4 = sumSquares - sum5 * sum5 / w2;
      i4 = lowerClassLimit - 1;
      if (i4 !== 0) {
        for (j2 = 2; j2 < nClasses + 1; j2++) {
          if (varianceCombinations[l2][j2] >= variance4 + varianceCombinations[i4][j2 - 1]) {
            lowerClassLimits[l2][j2] = lowerClassLimit;
            varianceCombinations[l2][j2] = variance4 + varianceCombinations[i4][j2 - 1];
          }
        }
      }
    }
    lowerClassLimits[l2][1] = 1;
    varianceCombinations[l2][1] = variance4;
  }
  return {
    lowerClassLimits,
    varianceCombinations
  };
}
function jenks(data, nClasses) {
  if (nClasses > data.length) {
    return null;
  }
  data = data.slice().sort(function(a4, b2) {
    return a4 - b2;
  });
  var matrices = jenksMatrices(data, nClasses);
  var lowerClassLimits = matrices.lowerClassLimits;
  return jenksBreaks(data, lowerClassLimits, nClasses);
}
function equalIntervalBreaks(x3, nClasses) {
  if (x3.length < 2) {
    return x3;
  }
  var theMin = min2(x3);
  var theMax = max2(x3);
  var breaks = [theMin];
  var breakSize = (theMax - theMin) / nClasses;
  for (var i2 = 1; i2 < nClasses; i2++) {
    breaks.push(breaks[0] + breakSize * i2);
  }
  breaks.push(theMax);
  return breaks;
}
function sampleCovariance(x3, y3) {
  if (x3.length !== y3.length) {
    throw new Error("sampleCovariance requires samples with equal lengths");
  }
  if (x3.length < 2) {
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  }
  var xmean = mean(x3);
  var ymean = mean(y3);
  var sum5 = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sum5 += (x3[i2] - xmean) * (y3[i2] - ymean);
  }
  var besselsCorrection = x3.length - 1;
  return sum5 / besselsCorrection;
}
function sampleVariance(x3) {
  if (x3.length < 2) {
    throw new Error("sampleVariance requires at least two data points");
  }
  var sumSquaredDeviationsValue = sumNthPowerDeviations(x3, 2);
  var besselsCorrection = x3.length - 1;
  return sumSquaredDeviationsValue / besselsCorrection;
}
function sampleStandardDeviation(x3) {
  var sampleVarianceX = sampleVariance(x3);
  return Math.sqrt(sampleVarianceX);
}
function sampleCorrelation(x3, y3) {
  var cov = sampleCovariance(x3, y3);
  var xstd = sampleStandardDeviation(x3);
  var ystd = sampleStandardDeviation(y3);
  return cov / xstd / ystd;
}
function sampleRankCorrelation(x3, y3) {
  var xIndexes = x3.map(function(value, index) {
    return [value, index];
  }).sort(function(a4, b2) {
    return a4[0] - b2[0];
  }).map(function(pair) {
    return pair[1];
  });
  var yIndexes = y3.map(function(value, index) {
    return [value, index];
  }).sort(function(a4, b2) {
    return a4[0] - b2[0];
  }).map(function(pair) {
    return pair[1];
  });
  var xRanks = Array(xIndexes.length);
  var yRanks = Array(xIndexes.length);
  for (var i2 = 0; i2 < xIndexes.length; i2++) {
    xRanks[xIndexes[i2]] = i2;
    yRanks[yIndexes[i2]] = i2;
  }
  return sampleCorrelation(xRanks, yRanks);
}
function sampleSkewness(x3) {
  if (x3.length < 3) {
    throw new Error("sampleSkewness requires at least three data points");
  }
  var meanValue = mean(x3);
  var tempValue;
  var sumSquaredDeviations = 0;
  var sumCubedDeviations = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    tempValue = x3[i2] - meanValue;
    sumSquaredDeviations += tempValue * tempValue;
    sumCubedDeviations += tempValue * tempValue * tempValue;
  }
  var besselsCorrection = x3.length - 1;
  var theSampleStandardDeviation = Math.sqrt(
    sumSquaredDeviations / besselsCorrection
  );
  var n2 = x3.length;
  var cubedS = Math.pow(theSampleStandardDeviation, 3);
  return n2 * sumCubedDeviations / ((n2 - 1) * (n2 - 2) * cubedS);
}
function sampleKurtosis(x3) {
  var n2 = x3.length;
  if (n2 < 4) {
    throw new Error("sampleKurtosis requires at least four data points");
  }
  var meanValue = mean(x3);
  var tempValue;
  var secondCentralMoment = 0;
  var fourthCentralMoment = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    tempValue = x3[i2] - meanValue;
    secondCentralMoment += tempValue * tempValue;
    fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
  }
  return (n2 - 1) / ((n2 - 2) * (n2 - 3)) * (n2 * (n2 + 1) * fourthCentralMoment / (secondCentralMoment * secondCentralMoment) - 3 * (n2 - 1));
}
function permutationsHeap(elements) {
  var indexes = new Array(elements.length);
  var permutations = [elements.slice()];
  for (var i2 = 0; i2 < elements.length; i2++) {
    indexes[i2] = 0;
  }
  for (var i$1 = 0; i$1 < elements.length; ) {
    if (indexes[i$1] < i$1) {
      var swapFrom = 0;
      if (i$1 % 2 !== 0) {
        swapFrom = indexes[i$1];
      }
      var temp3 = elements[swapFrom];
      elements[swapFrom] = elements[i$1];
      elements[i$1] = temp3;
      permutations.push(elements.slice());
      indexes[i$1]++;
      i$1 = 0;
    } else {
      indexes[i$1] = 0;
      i$1++;
    }
  }
  return permutations;
}
function combinations(x3, k3) {
  var i2;
  var subI;
  var combinationList = [];
  var subsetCombinations;
  var next;
  for (i2 = 0; i2 < x3.length; i2++) {
    if (k3 === 1) {
      combinationList.push([x3[i2]]);
    } else {
      subsetCombinations = combinations(x3.slice(i2 + 1, x3.length), k3 - 1);
      for (subI = 0; subI < subsetCombinations.length; subI++) {
        next = subsetCombinations[subI];
        next.unshift(x3[i2]);
        combinationList.push(next);
      }
    }
  }
  return combinationList;
}
function combinationsReplacement(x3, k3) {
  var combinationList = [];
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (k3 === 1) {
      combinationList.push([x3[i2]]);
    } else {
      var subsetCombinations = combinationsReplacement(
        x3.slice(i2, x3.length),
        k3 - 1
      );
      for (var j2 = 0; j2 < subsetCombinations.length; j2++) {
        combinationList.push([x3[i2]].concat(subsetCombinations[j2]));
      }
    }
  }
  return combinationList;
}
function addToMean(mean2, n2, newValue) {
  return mean2 + (newValue - mean2) / (n2 + 1);
}
function combineMeans(mean1, n1, mean2, n2) {
  return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}
function combineVariances(variance1, mean1, n1, variance22, mean2, n2) {
  var newMean = combineMeans(mean1, n1, mean2, n2);
  return (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) + n2 * (variance22 + Math.pow(mean2 - newMean, 2))) / (n1 + n2);
}
function geometricMean(x3) {
  if (x3.length === 0) {
    throw new Error("geometricMean requires at least one data point");
  }
  var value = 1;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] < 0) {
      throw new Error(
        "geometricMean requires only non-negative numbers as input"
      );
    }
    value *= x3[i2];
  }
  return Math.pow(value, 1 / x3.length);
}
function logAverage(x3) {
  if (x3.length === 0) {
    throw new Error("logAverage requires at least one data point");
  }
  var value = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] < 0) {
      throw new Error(
        "logAverage requires only non-negative numbers as input"
      );
    }
    value += Math.log(x3[i2]);
  }
  return Math.exp(value / x3.length);
}
function harmonicMean(x3) {
  if (x3.length === 0) {
    throw new Error("harmonicMean requires at least one data point");
  }
  var reciprocalSum = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    if (x3[i2] <= 0) {
      throw new Error(
        "harmonicMean requires only positive numbers as input"
      );
    }
    reciprocalSum += 1 / x3[i2];
  }
  return x3.length / reciprocalSum;
}
function meanSimple(x3) {
  if (x3.length === 0) {
    throw new Error("meanSimple requires at least one data point");
  }
  return sumSimple(x3) / x3.length;
}
function medianSorted(sorted) {
  return quantileSorted2(sorted, 0.5);
}
function subtractFromMean(mean2, n2, value) {
  return (mean2 * n2 - value) / (n2 - 1);
}
function rootMeanSquare(x3) {
  if (x3.length === 0) {
    throw new Error("rootMeanSquare requires at least one data point");
  }
  var sumOfSquares = 0;
  for (var i2 = 0; i2 < x3.length; i2++) {
    sumOfSquares += Math.pow(x3[i2], 2);
  }
  return Math.sqrt(sumOfSquares / x3.length);
}
function coefficientOfVariation(x3) {
  return sampleStandardDeviation(x3) / mean(x3);
}
function tTest(x3, expectedValue) {
  var sampleMean = mean(x3);
  var sd = standardDeviation(x3);
  var rootN = Math.sqrt(x3.length);
  return (sampleMean - expectedValue) / (sd / rootN);
}
function tTestTwoSample(sampleX, sampleY, difference) {
  var n2 = sampleX.length;
  var m5 = sampleY.length;
  if (!n2 || !m5) {
    return null;
  }
  if (!difference) {
    difference = 0;
  }
  var meanX2 = mean(sampleX);
  var meanY = mean(sampleY);
  var sampleVarianceX = sampleVariance(sampleX);
  var sampleVarianceY = sampleVariance(sampleY);
  if (typeof meanX2 === "number" && typeof meanY === "number" && typeof sampleVarianceX === "number" && typeof sampleVarianceY === "number") {
    var weightedVariance = ((n2 - 1) * sampleVarianceX + (m5 - 1) * sampleVarianceY) / (n2 + m5 - 2);
    return (meanX2 - meanY - difference) / Math.sqrt(weightedVariance * (1 / n2 + 1 / m5));
  }
}
function wilcoxonRankSum(sampleX, sampleY) {
  if (!sampleX.length || !sampleY.length) {
    throw new Error("Neither sample can be empty");
  }
  var pooledSamples = sampleX.map(function(x3) {
    return { label: "x", value: x3 };
  }).concat(sampleY.map(function(y3) {
    return { label: "y", value: y3 };
  })).sort(function(a4, b2) {
    return a4.value - b2.value;
  });
  for (var rank = 0; rank < pooledSamples.length; rank++) {
    pooledSamples[rank].rank = rank;
  }
  var tiedRanks = [pooledSamples[0].rank];
  for (var i2 = 1; i2 < pooledSamples.length; i2++) {
    if (pooledSamples[i2].value === pooledSamples[i2 - 1].value) {
      tiedRanks.push(pooledSamples[i2].rank);
      if (i2 === pooledSamples.length - 1) {
        replaceRanksInPlace(pooledSamples, tiedRanks);
      }
    } else if (tiedRanks.length > 1) {
      replaceRanksInPlace(pooledSamples, tiedRanks);
    } else {
      tiedRanks = [pooledSamples[i2].rank];
    }
  }
  function replaceRanksInPlace(pooledSamples2, tiedRanks2) {
    var average3 = (tiedRanks2[0] + tiedRanks2[tiedRanks2.length - 1]) / 2;
    for (var i3 = 0; i3 < tiedRanks2.length; i3++) {
      pooledSamples2[tiedRanks2[i3]].rank = average3;
    }
  }
  var rankSum = 0;
  for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
    var sample3 = pooledSamples[i$1];
    if (sample3.label === "x") {
      rankSum += sample3.rank + 1;
    }
  }
  return rankSum;
}
var BayesianClassifier = function BayesianClassifier2() {
  this.totalCount = 0;
  this.data = {};
};
BayesianClassifier.prototype.train = function train(item, category) {
  if (!this.data[category]) {
    this.data[category] = {};
  }
  for (var k3 in item) {
    var v2 = item[k3];
    if (this.data[category][k3] === void 0) {
      this.data[category][k3] = {};
    }
    if (this.data[category][k3][v2] === void 0) {
      this.data[category][k3][v2] = 0;
    }
    this.data[category][k3][v2]++;
  }
  this.totalCount++;
};
BayesianClassifier.prototype.score = function score(item) {
  var odds = {};
  var category;
  for (var k3 in item) {
    var v2 = item[k3];
    for (category in this.data) {
      odds[category] = {};
      if (this.data[category][k3]) {
        odds[category][k3 + "_" + v2] = (this.data[category][k3][v2] || 0) / this.totalCount;
      } else {
        odds[category][k3 + "_" + v2] = 0;
      }
    }
  }
  var oddsSums = {};
  for (category in odds) {
    oddsSums[category] = 0;
    for (var combination in odds[category]) {
      oddsSums[category] += odds[category][combination];
    }
  }
  return oddsSums;
};
var PerceptronModel = function PerceptronModel2() {
  this.weights = [];
  this.bias = 0;
};
PerceptronModel.prototype.predict = function predict(features) {
  if (features.length !== this.weights.length) {
    return null;
  }
  var score3 = 0;
  for (var i2 = 0; i2 < this.weights.length; i2++) {
    score3 += this.weights[i2] * features[i2];
  }
  score3 += this.bias;
  if (score3 > 0) {
    return 1;
  } else {
    return 0;
  }
};
PerceptronModel.prototype.train = function train2(features, label) {
  if (label !== 0 && label !== 1) {
    return null;
  }
  if (features.length !== this.weights.length) {
    this.weights = features;
    this.bias = 1;
  }
  var prediction = this.predict(features);
  if (typeof prediction === "number" && prediction !== label) {
    var gradient = label - prediction;
    for (var i2 = 0; i2 < this.weights.length; i2++) {
      this.weights[i2] += gradient * features[i2];
    }
    this.bias += gradient;
  }
  return this;
};
var epsilon3 = 1e-4;
function factorial(n2) {
  if (n2 < 0) {
    throw new Error("factorial requires a non-negative value");
  }
  if (Math.floor(n2) !== n2) {
    throw new Error("factorial requires an integer input");
  }
  var accumulator = 1;
  for (var i2 = 2; i2 <= n2; i2++) {
    accumulator *= i2;
  }
  return accumulator;
}
function gamma(n2) {
  if (Number.isInteger(n2)) {
    if (n2 <= 0) {
      return Number.NaN;
    } else {
      return factorial(n2 - 1);
    }
  }
  n2--;
  if (n2 < 0) {
    return Math.PI / (Math.sin(Math.PI * -n2) * gamma(-n2));
  } else {
    var seriesCoefficient = Math.pow(n2 / Math.E, n2) * Math.sqrt(2 * Math.PI * (n2 + 1 / 6));
    var seriesDenom = n2 + 1 / 4;
    var seriesExpansion = 1 + 1 / 144 / Math.pow(seriesDenom, 2) - 1 / 12960 / Math.pow(seriesDenom, 3) - 257 / 207360 / Math.pow(seriesDenom, 4) - 52 / 2612736 / Math.pow(seriesDenom, 5) + 5741173 / 9405849600 / Math.pow(seriesDenom, 6) + 37529 / 18811699200 / Math.pow(seriesDenom, 7);
    return seriesCoefficient * seriesExpansion;
  }
}
var COEFFICIENTS = [
  0.9999999999999971,
  57.15623566586292,
  -59.59796035547549,
  14.136097974741746,
  -0.4919138160976202,
  3399464998481189e-20,
  4652362892704858e-20,
  -9837447530487956e-20,
  1580887032249125e-19,
  -21026444172410488e-20,
  21743961811521265e-20,
  -1643181065367639e-19,
  8441822398385275e-20,
  -26190838401581408e-21,
  36899182659531625e-22
];
var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));
function gammaln(n2) {
  if (n2 <= 0) {
    return Number.POSITIVE_INFINITY;
  }
  n2--;
  var a4 = COEFFICIENTS[0];
  for (var i2 = 1; i2 < 15; i2++) {
    a4 += COEFFICIENTS[i2] / (n2 + i2);
  }
  var tmp = g + 0.5 + n2;
  return LOGSQRT2PI + Math.log(a4) - tmp + (n2 + 0.5) * Math.log(tmp);
}
function bernoulliDistribution(p2) {
  if (p2 < 0 || p2 > 1) {
    throw new Error(
      "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
    );
  }
  return [1 - p2, p2];
}
function binomialDistribution(trials, probability) {
  if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
    return void 0;
  }
  var x3 = 0;
  var cumulativeProbability = 0;
  var cells = [];
  var binomialCoefficient = 1;
  do {
    cells[x3] = binomialCoefficient * Math.pow(probability, x3) * Math.pow(1 - probability, trials - x3);
    cumulativeProbability += cells[x3];
    x3++;
    binomialCoefficient = binomialCoefficient * (trials - x3 + 1) / x3;
  } while (cumulativeProbability < 1 - epsilon3);
  return cells;
}
function poissonDistribution(lambda) {
  if (lambda <= 0) {
    return void 0;
  }
  var x3 = 0;
  var cumulativeProbability = 0;
  var cells = [];
  var factorialX = 1;
  do {
    cells[x3] = Math.exp(-lambda) * Math.pow(lambda, x3) / factorialX;
    cumulativeProbability += cells[x3];
    x3++;
    factorialX *= x3;
  } while (cumulativeProbability < 1 - epsilon3);
  return cells;
}
var chiSquaredDistributionTable = {
  1: {
    0.995: 0,
    0.99: 0,
    0.975: 0,
    0.95: 0,
    0.9: 0.02,
    0.5: 0.45,
    0.1: 2.71,
    0.05: 3.84,
    0.025: 5.02,
    0.01: 6.63,
    5e-3: 7.88
  },
  2: {
    0.995: 0.01,
    0.99: 0.02,
    0.975: 0.05,
    0.95: 0.1,
    0.9: 0.21,
    0.5: 1.39,
    0.1: 4.61,
    0.05: 5.99,
    0.025: 7.38,
    0.01: 9.21,
    5e-3: 10.6
  },
  3: {
    0.995: 0.07,
    0.99: 0.11,
    0.975: 0.22,
    0.95: 0.35,
    0.9: 0.58,
    0.5: 2.37,
    0.1: 6.25,
    0.05: 7.81,
    0.025: 9.35,
    0.01: 11.34,
    5e-3: 12.84
  },
  4: {
    0.995: 0.21,
    0.99: 0.3,
    0.975: 0.48,
    0.95: 0.71,
    0.9: 1.06,
    0.5: 3.36,
    0.1: 7.78,
    0.05: 9.49,
    0.025: 11.14,
    0.01: 13.28,
    5e-3: 14.86
  },
  5: {
    0.995: 0.41,
    0.99: 0.55,
    0.975: 0.83,
    0.95: 1.15,
    0.9: 1.61,
    0.5: 4.35,
    0.1: 9.24,
    0.05: 11.07,
    0.025: 12.83,
    0.01: 15.09,
    5e-3: 16.75
  },
  6: {
    0.995: 0.68,
    0.99: 0.87,
    0.975: 1.24,
    0.95: 1.64,
    0.9: 2.2,
    0.5: 5.35,
    0.1: 10.65,
    0.05: 12.59,
    0.025: 14.45,
    0.01: 16.81,
    5e-3: 18.55
  },
  7: {
    0.995: 0.99,
    0.99: 1.25,
    0.975: 1.69,
    0.95: 2.17,
    0.9: 2.83,
    0.5: 6.35,
    0.1: 12.02,
    0.05: 14.07,
    0.025: 16.01,
    0.01: 18.48,
    5e-3: 20.28
  },
  8: {
    0.995: 1.34,
    0.99: 1.65,
    0.975: 2.18,
    0.95: 2.73,
    0.9: 3.49,
    0.5: 7.34,
    0.1: 13.36,
    0.05: 15.51,
    0.025: 17.53,
    0.01: 20.09,
    5e-3: 21.96
  },
  9: {
    0.995: 1.73,
    0.99: 2.09,
    0.975: 2.7,
    0.95: 3.33,
    0.9: 4.17,
    0.5: 8.34,
    0.1: 14.68,
    0.05: 16.92,
    0.025: 19.02,
    0.01: 21.67,
    5e-3: 23.59
  },
  10: {
    0.995: 2.16,
    0.99: 2.56,
    0.975: 3.25,
    0.95: 3.94,
    0.9: 4.87,
    0.5: 9.34,
    0.1: 15.99,
    0.05: 18.31,
    0.025: 20.48,
    0.01: 23.21,
    5e-3: 25.19
  },
  11: {
    0.995: 2.6,
    0.99: 3.05,
    0.975: 3.82,
    0.95: 4.57,
    0.9: 5.58,
    0.5: 10.34,
    0.1: 17.28,
    0.05: 19.68,
    0.025: 21.92,
    0.01: 24.72,
    5e-3: 26.76
  },
  12: {
    0.995: 3.07,
    0.99: 3.57,
    0.975: 4.4,
    0.95: 5.23,
    0.9: 6.3,
    0.5: 11.34,
    0.1: 18.55,
    0.05: 21.03,
    0.025: 23.34,
    0.01: 26.22,
    5e-3: 28.3
  },
  13: {
    0.995: 3.57,
    0.99: 4.11,
    0.975: 5.01,
    0.95: 5.89,
    0.9: 7.04,
    0.5: 12.34,
    0.1: 19.81,
    0.05: 22.36,
    0.025: 24.74,
    0.01: 27.69,
    5e-3: 29.82
  },
  14: {
    0.995: 4.07,
    0.99: 4.66,
    0.975: 5.63,
    0.95: 6.57,
    0.9: 7.79,
    0.5: 13.34,
    0.1: 21.06,
    0.05: 23.68,
    0.025: 26.12,
    0.01: 29.14,
    5e-3: 31.32
  },
  15: {
    0.995: 4.6,
    0.99: 5.23,
    0.975: 6.27,
    0.95: 7.26,
    0.9: 8.55,
    0.5: 14.34,
    0.1: 22.31,
    0.05: 25,
    0.025: 27.49,
    0.01: 30.58,
    5e-3: 32.8
  },
  16: {
    0.995: 5.14,
    0.99: 5.81,
    0.975: 6.91,
    0.95: 7.96,
    0.9: 9.31,
    0.5: 15.34,
    0.1: 23.54,
    0.05: 26.3,
    0.025: 28.85,
    0.01: 32,
    5e-3: 34.27
  },
  17: {
    0.995: 5.7,
    0.99: 6.41,
    0.975: 7.56,
    0.95: 8.67,
    0.9: 10.09,
    0.5: 16.34,
    0.1: 24.77,
    0.05: 27.59,
    0.025: 30.19,
    0.01: 33.41,
    5e-3: 35.72
  },
  18: {
    0.995: 6.26,
    0.99: 7.01,
    0.975: 8.23,
    0.95: 9.39,
    0.9: 10.87,
    0.5: 17.34,
    0.1: 25.99,
    0.05: 28.87,
    0.025: 31.53,
    0.01: 34.81,
    5e-3: 37.16
  },
  19: {
    0.995: 6.84,
    0.99: 7.63,
    0.975: 8.91,
    0.95: 10.12,
    0.9: 11.65,
    0.5: 18.34,
    0.1: 27.2,
    0.05: 30.14,
    0.025: 32.85,
    0.01: 36.19,
    5e-3: 38.58
  },
  20: {
    0.995: 7.43,
    0.99: 8.26,
    0.975: 9.59,
    0.95: 10.85,
    0.9: 12.44,
    0.5: 19.34,
    0.1: 28.41,
    0.05: 31.41,
    0.025: 34.17,
    0.01: 37.57,
    5e-3: 40
  },
  21: {
    0.995: 8.03,
    0.99: 8.9,
    0.975: 10.28,
    0.95: 11.59,
    0.9: 13.24,
    0.5: 20.34,
    0.1: 29.62,
    0.05: 32.67,
    0.025: 35.48,
    0.01: 38.93,
    5e-3: 41.4
  },
  22: {
    0.995: 8.64,
    0.99: 9.54,
    0.975: 10.98,
    0.95: 12.34,
    0.9: 14.04,
    0.5: 21.34,
    0.1: 30.81,
    0.05: 33.92,
    0.025: 36.78,
    0.01: 40.29,
    5e-3: 42.8
  },
  23: {
    0.995: 9.26,
    0.99: 10.2,
    0.975: 11.69,
    0.95: 13.09,
    0.9: 14.85,
    0.5: 22.34,
    0.1: 32.01,
    0.05: 35.17,
    0.025: 38.08,
    0.01: 41.64,
    5e-3: 44.18
  },
  24: {
    0.995: 9.89,
    0.99: 10.86,
    0.975: 12.4,
    0.95: 13.85,
    0.9: 15.66,
    0.5: 23.34,
    0.1: 33.2,
    0.05: 36.42,
    0.025: 39.36,
    0.01: 42.98,
    5e-3: 45.56
  },
  25: {
    0.995: 10.52,
    0.99: 11.52,
    0.975: 13.12,
    0.95: 14.61,
    0.9: 16.47,
    0.5: 24.34,
    0.1: 34.28,
    0.05: 37.65,
    0.025: 40.65,
    0.01: 44.31,
    5e-3: 46.93
  },
  26: {
    0.995: 11.16,
    0.99: 12.2,
    0.975: 13.84,
    0.95: 15.38,
    0.9: 17.29,
    0.5: 25.34,
    0.1: 35.56,
    0.05: 38.89,
    0.025: 41.92,
    0.01: 45.64,
    5e-3: 48.29
  },
  27: {
    0.995: 11.81,
    0.99: 12.88,
    0.975: 14.57,
    0.95: 16.15,
    0.9: 18.11,
    0.5: 26.34,
    0.1: 36.74,
    0.05: 40.11,
    0.025: 43.19,
    0.01: 46.96,
    5e-3: 49.65
  },
  28: {
    0.995: 12.46,
    0.99: 13.57,
    0.975: 15.31,
    0.95: 16.93,
    0.9: 18.94,
    0.5: 27.34,
    0.1: 37.92,
    0.05: 41.34,
    0.025: 44.46,
    0.01: 48.28,
    5e-3: 50.99
  },
  29: {
    0.995: 13.12,
    0.99: 14.26,
    0.975: 16.05,
    0.95: 17.71,
    0.9: 19.77,
    0.5: 28.34,
    0.1: 39.09,
    0.05: 42.56,
    0.025: 45.72,
    0.01: 49.59,
    5e-3: 52.34
  },
  30: {
    0.995: 13.79,
    0.99: 14.95,
    0.975: 16.79,
    0.95: 18.49,
    0.9: 20.6,
    0.5: 29.34,
    0.1: 40.26,
    0.05: 43.77,
    0.025: 46.98,
    0.01: 50.89,
    5e-3: 53.67
  },
  40: {
    0.995: 20.71,
    0.99: 22.16,
    0.975: 24.43,
    0.95: 26.51,
    0.9: 29.05,
    0.5: 39.34,
    0.1: 51.81,
    0.05: 55.76,
    0.025: 59.34,
    0.01: 63.69,
    5e-3: 66.77
  },
  50: {
    0.995: 27.99,
    0.99: 29.71,
    0.975: 32.36,
    0.95: 34.76,
    0.9: 37.69,
    0.5: 49.33,
    0.1: 63.17,
    0.05: 67.5,
    0.025: 71.42,
    0.01: 76.15,
    5e-3: 79.49
  },
  60: {
    0.995: 35.53,
    0.99: 37.48,
    0.975: 40.48,
    0.95: 43.19,
    0.9: 46.46,
    0.5: 59.33,
    0.1: 74.4,
    0.05: 79.08,
    0.025: 83.3,
    0.01: 88.38,
    5e-3: 91.95
  },
  70: {
    0.995: 43.28,
    0.99: 45.44,
    0.975: 48.76,
    0.95: 51.74,
    0.9: 55.33,
    0.5: 69.33,
    0.1: 85.53,
    0.05: 90.53,
    0.025: 95.02,
    0.01: 100.42,
    5e-3: 104.22
  },
  80: {
    0.995: 51.17,
    0.99: 53.54,
    0.975: 57.15,
    0.95: 60.39,
    0.9: 64.28,
    0.5: 79.33,
    0.1: 96.58,
    0.05: 101.88,
    0.025: 106.63,
    0.01: 112.33,
    5e-3: 116.32
  },
  90: {
    0.995: 59.2,
    0.99: 61.75,
    0.975: 65.65,
    0.95: 69.13,
    0.9: 73.29,
    0.5: 89.33,
    0.1: 107.57,
    0.05: 113.14,
    0.025: 118.14,
    0.01: 124.12,
    5e-3: 128.3
  },
  100: {
    0.995: 67.33,
    0.99: 70.06,
    0.975: 74.22,
    0.95: 77.93,
    0.9: 82.36,
    0.5: 99.33,
    0.1: 118.5,
    0.05: 124.34,
    0.025: 129.56,
    0.01: 135.81,
    5e-3: 140.17
  }
};
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
  var inputMean = mean(data);
  var chiSquared = 0;
  var c4 = 1;
  var hypothesizedDistribution = distributionType(inputMean);
  var observedFrequencies = [];
  var expectedFrequencies = [];
  for (var i2 = 0; i2 < data.length; i2++) {
    if (observedFrequencies[data[i2]] === void 0) {
      observedFrequencies[data[i2]] = 0;
    }
    observedFrequencies[data[i2]]++;
  }
  for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
    if (observedFrequencies[i$1] === void 0) {
      observedFrequencies[i$1] = 0;
    }
  }
  for (var k3 in hypothesizedDistribution) {
    if (k3 in observedFrequencies) {
      expectedFrequencies[+k3] = hypothesizedDistribution[k3] * data.length;
    }
  }
  for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
    if (expectedFrequencies[k$1] < 3) {
      expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
      expectedFrequencies.pop();
      observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
      observedFrequencies.pop();
    }
  }
  for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
    chiSquared += Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) / expectedFrequencies[k$2];
  }
  var degreesOfFreedom = observedFrequencies.length - c4 - 1;
  return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared;
}
var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);
var kernels = {
  /**
   * The gaussian kernel.
   * @private
   */
  gaussian: function(u2) {
    return Math.exp(-0.5 * u2 * u2) / SQRT_2PI$1;
  }
};
var bandwidthMethods = {
  /**
   * The ["normal reference distribution"
   * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
   * a commonly used version of [Silverman's
   * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
   * @private
   */
  nrd: function(x3) {
    var s3 = sampleStandardDeviation(x3);
    var iqr = interquartileRange(x3);
    if (typeof iqr === "number") {
      s3 = Math.min(s3, iqr / 1.34);
    }
    return 1.06 * s3 * Math.pow(x3.length, -0.2);
  }
};
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
  var kernelFn;
  if (kernel === void 0) {
    kernelFn = kernels.gaussian;
  } else if (typeof kernel === "string") {
    if (!kernels[kernel]) {
      throw new Error('Unknown kernel "' + kernel + '"');
    }
    kernelFn = kernels[kernel];
  } else {
    kernelFn = kernel;
  }
  var bandwidth;
  if (typeof bandwidthMethod === "undefined") {
    bandwidth = bandwidthMethods.nrd(X);
  } else if (typeof bandwidthMethod === "string") {
    if (!bandwidthMethods[bandwidthMethod]) {
      throw new Error(
        'Unknown bandwidth method "' + bandwidthMethod + '"'
      );
    }
    bandwidth = bandwidthMethods[bandwidthMethod](X);
  } else {
    bandwidth = bandwidthMethod;
  }
  return function(x3) {
    var i2 = 0;
    var sum5 = 0;
    for (i2 = 0; i2 < X.length; i2++) {
      sum5 += kernelFn((x3 - X[i2]) / bandwidth);
    }
    return sum5 / bandwidth / X.length;
  };
}
function zScore(x3, mean2, standardDeviation3) {
  return (x3 - mean2) / standardDeviation3;
}
var SQRT_2PI = Math.sqrt(2 * Math.PI);
function cumulativeDistribution(z2) {
  var sum5 = z2;
  var tmp = z2;
  for (var i2 = 1; i2 < 15; i2++) {
    tmp *= z2 * z2 / (2 * i2 + 1);
    sum5 += tmp;
  }
  return Math.round((0.5 + sum5 / SQRT_2PI * Math.exp(-z2 * z2 / 2)) * 1e4) / 1e4;
}
var standardNormalTable = [];
for (z2 = 0; z2 <= 3.09; z2 += 0.01) {
  standardNormalTable.push(cumulativeDistribution(z2));
}
var z2;
function cumulativeStdNormalProbability(z2) {
  var absZ = Math.abs(z2);
  var index = Math.min(
    Math.round(absZ * 100),
    standardNormalTable.length - 1
  );
  if (z2 >= 0) {
    return standardNormalTable[index];
  } else {
    return Math.round((1 - standardNormalTable[index]) * 1e4) / 1e4;
  }
}
function cumulativeStdLogisticProbability(x3) {
  return 1 / (Math.exp(-x3) + 1);
}
function errorFunction(x3) {
  var t2 = 1 / (1 + 0.5 * Math.abs(x3));
  var tau3 = t2 * Math.exp(
    -x3 * x3 + ((((((((0.17087277 * t2 - 0.82215223) * t2 + 1.48851587) * t2 - 1.13520398) * t2 + 0.27886807) * t2 - 0.18628806) * t2 + 0.09678418) * t2 + 0.37409196) * t2 + 1.00002368) * t2 - 1.26551223
  );
  if (x3 >= 0) {
    return 1 - tau3;
  } else {
    return tau3 - 1;
  }
}
function inverseErrorFunction(x3) {
  var a4 = 8 * (Math.PI - 3) / (3 * Math.PI * (4 - Math.PI));
  var inv = Math.sqrt(
    Math.sqrt(
      Math.pow(2 / (Math.PI * a4) + Math.log(1 - x3 * x3) / 2, 2) - Math.log(1 - x3 * x3) / a4
    ) - (2 / (Math.PI * a4) + Math.log(1 - x3 * x3) / 2)
  );
  if (x3 >= 0) {
    return inv;
  } else {
    return -inv;
  }
}
function probit(p2) {
  if (p2 === 0) {
    p2 = epsilon3;
  } else if (p2 >= 1) {
    p2 = 1 - epsilon3;
  }
  return Math.sqrt(2) * inverseErrorFunction(2 * p2 - 1);
}
function logit(p2) {
  if (p2 <= 0 || p2 >= 1) {
    throw new Error("p must be strictly between zero and one");
  }
  return Math.log(p2 / (1 - p2));
}
function permutationTest(sampleX, sampleY, alternative, k3, randomSource) {
  if (k3 === void 0) {
    k3 = 1e4;
  }
  if (alternative === void 0) {
    alternative = "two_side";
  }
  if (alternative !== "two_side" && alternative !== "greater" && alternative !== "less") {
    throw new Error(
      "`alternative` must be either 'two_side', 'greater', or 'less'."
    );
  }
  var meanX2 = mean(sampleX);
  var meanY = mean(sampleY);
  var testStatistic = meanX2 - meanY;
  var testStatDsn = new Array(k3);
  var allData = sampleX.concat(sampleY);
  var midIndex = Math.floor(allData.length / 2);
  for (var i2 = 0; i2 < k3; i2++) {
    shuffleInPlace(allData, randomSource);
    var permLeft = allData.slice(0, midIndex);
    var permRight = allData.slice(midIndex, allData.length);
    var permTestStatistic = mean(permLeft) - mean(permRight);
    testStatDsn[i2] = permTestStatistic;
  }
  var numExtremeTStats = 0;
  if (alternative === "two_side") {
    for (var i$1 = 0; i$1 <= k3; i$1++) {
      if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
        numExtremeTStats += 1;
      }
    }
  } else if (alternative === "greater") {
    for (var i$2 = 0; i$2 <= k3; i$2++) {
      if (testStatDsn[i$2] >= testStatistic) {
        numExtremeTStats += 1;
      }
    }
  } else {
    for (var i$3 = 0; i$3 <= k3; i$3++) {
      if (testStatDsn[i$3] <= testStatistic) {
        numExtremeTStats += 1;
      }
    }
  }
  return numExtremeTStats / k3;
}
function sign2(x3) {
  if (typeof x3 === "number") {
    if (x3 < 0) {
      return -1;
    } else if (x3 === 0) {
      return 0;
    } else {
      return 1;
    }
  } else {
    throw new TypeError("not a number");
  }
}
function bisect2(func, start, end, maxIterations, errorTolerance) {
  if (typeof func !== "function") {
    throw new TypeError("func must be a function");
  }
  for (var i2 = 0; i2 < maxIterations; i2++) {
    var output = (start + end) / 2;
    if (func(output) === 0 || Math.abs((end - start) / 2) < errorTolerance) {
      return output;
    }
    if (sign2(func(output)) === sign2(func(start))) {
      start = output;
    } else {
      end = output;
    }
  }
  throw new Error("maximum number of iterations exceeded");
}
function euclideanDistance(left2, right2) {
  var sum5 = 0;
  for (var i2 = 0; i2 < left2.length; i2++) {
    var diff = left2[i2] - right2[i2];
    sum5 += diff * diff;
  }
  return Math.sqrt(sum5);
}
function kMeansCluster(points, numCluster, randomSource) {
  if (randomSource === void 0) randomSource = Math.random;
  var oldCentroids = null;
  var newCentroids = sample(points, numCluster, randomSource);
  var labels = null;
  var change = Number.MAX_VALUE;
  while (change !== 0) {
    labels = labelPoints(points, newCentroids);
    oldCentroids = newCentroids;
    newCentroids = calculateCentroids(points, labels, numCluster);
    change = calculateChange(newCentroids, oldCentroids);
  }
  return {
    labels,
    centroids: newCentroids
  };
}
function labelPoints(points, centroids) {
  return points.map(function(p2) {
    var minDist = Number.MAX_VALUE;
    var label = -1;
    for (var i2 = 0; i2 < centroids.length; i2++) {
      var dist = euclideanDistance(p2, centroids[i2]);
      if (dist < minDist) {
        minDist = dist;
        label = i2;
      }
    }
    return label;
  });
}
function calculateCentroids(points, labels, numCluster) {
  var dimension = points[0].length;
  var centroids = makeMatrix(numCluster, dimension);
  var counts = Array(numCluster).fill(0);
  var numPoints = points.length;
  for (var i2 = 0; i2 < numPoints; i2++) {
    var point6 = points[i2];
    var label = labels[i2];
    var current = centroids[label];
    for (var j2 = 0; j2 < dimension; j2++) {
      current[j2] += point6[j2];
    }
    counts[label] += 1;
  }
  for (var i$1 = 0; i$1 < numCluster; i$1++) {
    if (counts[i$1] === 0) {
      throw new Error("Centroid " + i$1 + " has no friends");
    }
    var centroid = centroids[i$1];
    for (var j$1 = 0; j$1 < dimension; j$1++) {
      centroid[j$1] /= counts[i$1];
    }
  }
  return centroids;
}
function calculateChange(left2, right2) {
  var total = 0;
  for (var i2 = 0; i2 < left2.length; i2++) {
    total += euclideanDistance(left2[i2], right2[i2]);
  }
  return total;
}
function silhouette(points, labels) {
  if (points.length !== labels.length) {
    throw new Error("must have exactly as many labels as points");
  }
  var groupings = createGroups(labels);
  var distances = calculateAllDistances(points);
  var result2 = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var s3 = 0;
    if (groupings[labels[i2]].length > 1) {
      var a4 = meanDistanceFromPointToGroup(
        i2,
        groupings[labels[i2]],
        distances
      );
      var b2 = meanDistanceToNearestGroup(
        i2,
        labels,
        groupings,
        distances
      );
      s3 = (b2 - a4) / Math.max(a4, b2);
    }
    result2.push(s3);
  }
  return result2;
}
function createGroups(labels) {
  var numGroups = 1 + max2(labels);
  var result2 = Array(numGroups);
  for (var i2 = 0; i2 < labels.length; i2++) {
    var label = labels[i2];
    if (result2[label] === void 0) {
      result2[label] = [];
    }
    result2[label].push(i2);
  }
  return result2;
}
function calculateAllDistances(points) {
  var numPoints = points.length;
  var result2 = makeMatrix(numPoints, numPoints);
  for (var i2 = 0; i2 < numPoints; i2++) {
    for (var j2 = 0; j2 < i2; j2++) {
      result2[i2][j2] = euclideanDistance(points[i2], points[j2]);
      result2[j2][i2] = result2[i2][j2];
    }
  }
  return result2;
}
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
  var label = labels[which];
  var result2 = Number.MAX_VALUE;
  for (var i2 = 0; i2 < groupings.length; i2++) {
    if (i2 !== label) {
      var d2 = meanDistanceFromPointToGroup(
        which,
        groupings[i2],
        distances
      );
      if (d2 < result2) {
        result2 = d2;
      }
    }
  }
  return result2;
}
function meanDistanceFromPointToGroup(which, group, distances) {
  var total = 0;
  for (var i2 = 0; i2 < group.length; i2++) {
    total += distances[which][group[i2]];
  }
  return total / group.length;
}
function silhouetteMetric(points, labels) {
  var values = silhouette(points, labels);
  return max2(values);
}
function relativeError(actual, expected) {
  if (actual === 0 && expected === 0) {
    return 0;
  }
  return Math.abs((actual - expected) / expected);
}
function approxEqual(actual, expected, tolerance) {
  if (tolerance === void 0) tolerance = epsilon3;
  return relativeError(actual, expected) <= tolerance;
}

// node_modules/@visactor/vdataset/es/constants.js
var DATAVIEW_TYPE;
!function(DATAVIEW_TYPE2) {
  DATAVIEW_TYPE2.DSV = "dsv", DATAVIEW_TYPE2.TREE = "tree", DATAVIEW_TYPE2.GEO = "geo", DATAVIEW_TYPE2.BYTE = "bytejson", DATAVIEW_TYPE2.HEX = "hex", DATAVIEW_TYPE2.GRAPH = "graph", DATAVIEW_TYPE2.TABLE = "table", DATAVIEW_TYPE2.GEO_GRATICULE = "geo-graticule";
}(DATAVIEW_TYPE || (DATAVIEW_TYPE = {}));
var STATISTICS_METHODS = ["max", "mean", "median", "min", "mode", "product", "standardDeviation", "sum", "sumSimple", "variance"];

// node_modules/@visactor/vdataset/es/transform/statistics.js
var aggregates = {
  count: (data) => data.length,
  distinct: (data, field5) => uniqArray(data.map((row) => row[field5])).length
};
STATISTICS_METHODS.forEach((method) => {
  aggregates[method] = (data, field5) => {
    let values = data.map((row) => row[field5]);
    return isArray_default(values) && isArray_default(values[0]) && (values = flattenArray(values)), simple_statistics_exports[method](values);
  };
}), aggregates.average = aggregates.mean;

// node_modules/@visactor/vdataset/es/transform/fold.js
var fold = (data, options) => {
  const { fields: fields2, key, value, retains } = options, results = [];
  for (let i2 = 0; i2 < data.length; i2++) fields2.forEach((field5) => {
    const item = {};
    if (item[key] = field5, item[value] = data[i2][field5], retains) retains.forEach((retain) => {
      item[retain] = data[i2][retain];
    });
    else for (const prop in data[i2]) -1 === fields2.indexOf(prop) && (item[prop] = data[i2][prop]);
    results.push(item);
  });
  return results;
};

// node_modules/@visactor/vdataset/es/transform/fields.js
var fields = (data, options) => {
  var _a, _b;
  if (!(null == options ? void 0 : options.fields)) return data;
  if (0 === data.length) return data;
  const fields2 = options.fields, dataTemp = data[0], filterFields = {}, sortFields = [];
  for (const key in fields2) if (Object.prototype.hasOwnProperty.call(fields2, key)) {
    const fieldInfo = fields2[key];
    if (!fieldInfo.type) {
      let dataCheck = dataTemp;
      key in dataTemp || (dataCheck = null !== (_a = data.find((d2) => key in d2)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
    }
    let sortInfo;
    if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
      key,
      type: fieldInfo.type,
      index: fieldInfo.sortIndex,
      sortIndex: {},
      sortIndexCount: 0,
      sortReverse: true === fieldInfo.sortReverse
    }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0) if ("ordinal" === fieldInfo.type) {
      fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
      const _domainCache = {};
      fieldInfo.domain.forEach((d2, i2) => {
        _domainCache[d2] = i2, fieldInfo._domainCache[d2] = i2;
      }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
    } else fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
  }
  return Object.keys(filterFields).length > 0 && (data = data.filter((d2) => {
    for (const key in filterFields) {
      const fieldInfo = filterFields[key];
      if ("ordinal" === fieldInfo.type) {
        if (!(d2[key] in fieldInfo._domainCache)) return false;
      } else if (fieldInfo.domain[0] > d2[key] || fieldInfo.domain[1] < d2[key]) return false;
    }
    return true;
  })), sortFields.sort((a4, b2) => a4.index - b2.index), data.sort((a4, b2) => sortData(a4, b2, sortFields)), data;
};
function sortData(a4, b2, sortFields) {
  for (let i2 = 0; i2 < sortFields.length; i2++) {
    const sortInfo = sortFields[i2];
    let v2 = 0;
    if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b2[sortInfo.key]] && (sortInfo.sortIndex[b2[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a4[sortInfo.key]] && (sortInfo.sortIndex[a4[sortInfo.key]] = sortInfo.sortIndexCount++), v2 = sortInfo.sortIndex[a4[sortInfo.key]] - sortInfo.sortIndex[b2[sortInfo.key]]) : "linear" === sortInfo.type && (v2 = a4[sortInfo.key] - b2[sortInfo.key]), sortInfo.sortReverse && (v2 = -v2), 0 !== v2) return v2;
  }
  return 0;
}

// node_modules/@visactor/vdataset/es/parser/dsv.js
var DEFAULT_DSV_PARSER_OPTIONS = {
  delimiter: ","
};
var dsvParser = (data, options = {}, dataView) => {
  dataView.type = DATAVIEW_TYPE.DSV;
  const mergeOptions = mergeDeepImmer(DEFAULT_DSV_PARSER_OPTIONS, options), { delimiter } = mergeOptions;
  if (!isString_default(delimiter)) throw new TypeError("Invalid delimiter: must be a string!");
  return dsv_default(delimiter).parse(data);
};
var csvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, csvParse(data));
var tsvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, tsvParse(data));

// node_modules/@visactor/vdataset/es/parser/geo/geobuf.js
var geobuf = __toESM(require_geobuf());
var import_pbf = __toESM(require_pbf());

// node_modules/@turf/clone/dist/es/index.js
function clone2(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature3) {
    return cloneFeature(feature3);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  var geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map(function(g3) {
      return cloneGeometry(g3);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
}
var es_default = clone2;

// node_modules/@turf/invariant/dist/es/index.js
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}

// node_modules/@turf/boolean-clockwise/dist/es/index.js
function booleanClockwise(line2) {
  var ring = getCoords(line2);
  var sum5 = 0;
  var i2 = 1;
  var prev;
  var cur;
  while (i2 < ring.length) {
    prev = cur || ring[0];
    cur = ring[i2];
    sum5 += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i2++;
  }
  return sum5 > 0;
}

// node_modules/@turf/meta/dist/es/index.js
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i2 = 0; i2 < geojson.features.length; i2++) {
      if (callback(geojson.features[i2], i2) === false) break;
    }
  }
}
function geomEach(geojson, callback) {
  var i2, j2, g3, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i2 = 0; i2 < stop; i2++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i2].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i2].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i2].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i2].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g3 = 0; g3 < stopG; g3++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g3] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j2 = 0; j2 < geometry.geometries.length; j2++) {
            if (callback(
              geometry.geometries[j2],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id2) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox, id: id2 }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}

// node_modules/@turf/rewind/dist/es/index.js
function rewind(geojson, options) {
  options = options || {};
  if (!isObject2(options)) throw new Error("options is invalid");
  var reverse2 = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson) throw new Error("<geojson> is required");
  if (typeof reverse2 !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false) geojson = es_default(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse2);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature3) {
        featureEach(rewindFeature(feature3, reverse2), function(result2) {
          results.push(result2);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse2);
}
function rewindFeature(geojson, reverse2) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse2);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse2);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse2);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse2);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse2);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse2) {
  if (booleanClockwise(coords) === reverse2) coords.reverse();
}
function rewindPolygon(coords, reverse2) {
  if (booleanClockwise(coords[0]) !== reverse2) {
    coords[0].reverse();
  }
  for (var i2 = 1; i2 < coords.length; i2++) {
    if (booleanClockwise(coords[i2]) === reverse2) {
      coords[i2].reverse();
    }
  }
}
var es_default2 = rewind;

// node_modules/@turf/flatten/dist/es/index.js
function flatten(geojson) {
  if (!geojson) throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature3) {
    results.push(feature3);
  });
  return featureCollection(results);
}
var es_default3 = flatten;

// node_modules/@visactor/vdataset/es/parser/geo/geojson.js
var geoPathInstance = path_default();
var DEFAULT_GEOJSON_OPTIONS = {
  centroid: false,
  name: false,
  bbox: false,
  rewind: false
};
var MultiToSingle = (feature3) => {
  if (feature3.geometry.type.startsWith("Multi")) {
    const f2 = es_default3(feature3).features[0];
    return Object.assign(Object.assign({}, f2), f2.properties);
  }
  return Object.assign(Object.assign({}, feature3), feature3.properties);
};
var flattenFeature = (data) => {
  const featuresArr = [];
  return data.forEach((item) => {
    "FeatureCollection" === item.type ? item.features.forEach((feature3) => {
      featuresArr.push(MultiToSingle(feature3));
    }) : featuresArr.push(MultiToSingle(item));
  }), featuresArr;
};
var geoJSONParser = (data, options = {}, dataView) => {
  dataView.type = DATAVIEW_TYPE.GEO;
  const mergeOptions = mergeDeepImmer(DEFAULT_GEOJSON_OPTIONS, options), { centroid, name, bbox, rewind: rewind2 } = mergeOptions;
  if (Array.isArray(data)) return flattenFeature(data);
  let features = data.features;
  return rewind2 && (features = es_default2(data, {
    reverse: !isObject_default(rewind2) || rewind2.reverse
  }).features), features.forEach((feature3) => {
    if (centroid) {
      const centroid2 = geoPathInstance.centroid(feature3);
      feature3.centroidX = centroid2[0], feature3.centroidY = centroid2[1];
    }
    if (name && (feature3.name = feature3.properties.name), bbox) {
      const bbox2 = geoPathInstance.bounds(feature3);
      feature3.bbox = bbox2;
    }
  }), data.features = features, data;
};

// node_modules/@visactor/vdataset/es/parser/geo/topojson.js
init_src2();
var DEFAULT_TOPOJSON_OPTIONS = {};
var topoJSONParser = (data, options, dataView) => {
  dataView.type = DATAVIEW_TYPE.GEO;
  const mergeOptions = mergeDeepImmer(DEFAULT_GEOJSON_OPTIONS, DEFAULT_TOPOJSON_OPTIONS, options), { object: object2 } = mergeOptions;
  if (!isString_default(object2)) throw new TypeError("Invalid object: must be a string!");
  const geoData = feature_default(data, data.objects[object2]);
  return geoJSONParser(geoData, mergeOptions, dataView);
};

// node_modules/@visactor/vdataset/es/parser/data-view.js
var dataViewParser = (data, options, dataView) => {
  const dependencyUpdate = !isBoolean_default(null == options ? void 0 : options.dependencyUpdate) || (null == options ? void 0 : options.dependencyUpdate);
  if (!data || !isArray_default(data)) throw new TypeError("Invalid data: must be DataView array!");
  return isArray_default(dataView.rawData) && dataView.rawData.forEach((rd) => {
    rd.target && (rd.target.removeListener("change", dataView.reRunAllTransform), rd.target.removeListener("markRunning", dataView.markRunning));
  }), dependencyUpdate && data.forEach((d2) => {
    d2.target.addListener("change", dataView.reRunAllTransform), d2.target.addListener("markRunning", dataView.markRunning);
  }), data;
};

// node_modules/@visactor/vdataset/es/utils/uuid.js
var idIndex = 0;
var maxId = 1e8;
function getUUID(prefix = "dataset") {
  return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
}

// node_modules/@visactor/vdataset/es/data-set.js
var DataSet = class {
  constructor(options) {
    var _a;
    let name;
    this.options = options, this.isDataSet = true, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new import_eventemitter3.default(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger.getInstance();
  }
  setLogger(logger) {
    this._logger = logger;
  }
  getDataView(name) {
    return this.dataViewMap[name];
  }
  setDataView(name, dataView) {
    var _a;
    this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} 之前已存在，请重新命名`)), this.dataViewMap[name] = dataView;
  }
  removeDataView(name) {
    this.dataViewMap[name] = null, delete this.dataViewMap[name];
  }
  registerParser(name, parser) {
    var _a;
    this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.parserMap[name] = parser;
  }
  removeParser(name) {
    this.parserMap[name] = null, delete this.parserMap[name];
  }
  getParser(name) {
    return this.parserMap[name] || this.parserMap.default;
  }
  registerTransform(name, transform29) {
    var _a;
    this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.transformMap[name] = transform29;
  }
  removeTransform(name) {
    this.transformMap[name] = null, delete this.transformMap[name];
  }
  getTransform(name) {
    return this.transformMap[name];
  }
  multipleDataViewAddListener(list, event, call) {
    this._callMap || (this._callMap = /* @__PURE__ */ new Map());
    let callAd = this._callMap.get(call);
    callAd || (callAd = () => {
      list.some((l2) => l2.isRunning) || call();
    }), list.forEach((l2) => {
      l2.target.addListener(event, callAd);
    }), this._callMap.set(call, callAd);
  }
  allDataViewAddListener(event, call) {
    this.multipleDataViewAddListener(Object.values(this.dataViewMap), event, call);
  }
  multipleDataViewRemoveListener(list, event, call) {
    if (this._callMap) {
      const callAd = this._callMap.get(call);
      callAd && list.forEach((l2) => {
        l2.target.removeListener(event, callAd);
      }), this._callMap.delete(call);
    }
  }
  multipleDataViewUpdateInParse(newData) {
    newData.forEach((d2) => {
      var _a;
      return null === (_a = this.getDataView(d2.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d2) => {
      var _a;
      return null === (_a = this.getDataView(d2.name)) || void 0 === _a ? void 0 : _a.parseNewData(d2.data, d2.options);
    });
  }
  multipleDataViewUpdateInRawData(newData) {
    newData.forEach((d2) => {
      var _a;
      return null === (_a = this.getDataView(d2.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d2) => {
      var _a;
      return null === (_a = this.getDataView(d2.name)) || void 0 === _a ? void 0 : _a.updateRawData(d2.data, d2.options);
    });
  }
  destroy() {
    this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
  }
};

// node_modules/@visactor/vdataset/es/data-view.js
var DataViewDiffRank = "_data-view-diff-rank";
var DataView = class _DataView {
  constructor(dataSet, options) {
    let name;
    this.dataSet = dataSet, this.options = options, this.isDataView = true, this.target = new import_eventemitter3.default(), this.parseOption = null, this.transformsArr = [], this.isRunning = false, this.rawData = {}, this.history = false, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = (opt = {
      pushHistory: true,
      emitMessage: true
    }) => (this.isRunning = true, this.resetTransformData(), this.transformsArr.forEach((t2) => {
      this.executeTransform(t2, {
        pushHistory: opt.pushHistory,
        emitMessage: false
      }), this.isLastTransform(t2) && this.diffLastData();
    }), this.isRunning = false, false !== opt.emitMessage && this.target.emit("change", []), this), this.markRunning = () => {
      this.isRunning = true, this.target.emit("markRunning", []);
    }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
  }
  parse(data, options, emit = false) {
    var _a;
    this.isRunning = true, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
    const cloneData = this.cloneParseData(data, options);
    if (null == options ? void 0 : options.type) {
      const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
      this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
    } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
    return this.isRunning = false, emit && this.target.emit("afterParse", []), this;
  }
  transform(options, execute = true) {
    if (this.isRunning = true, options && options.type) {
      let pushOption = true;
      if ("fields" === options.type) {
        this._fields = options.options.fields;
        const index = this.transformsArr.findIndex((_op) => _op.type === options.type);
        index >= 0 && (pushOption = false, this.transformsArr[index].options.fields = this._fields);
      }
      if (pushOption && this.transformsArr.push(options), execute) {
        const lastTag = this.isLastTransform(options);
        this.executeTransform(options), lastTag && this.diffLastData();
      }
    }
    return this.sortTransform(), this.isRunning = false, this;
  }
  isLastTransform(options) {
    return this.transformsArr[this.transformsArr.length - 1] === options;
  }
  sortTransform() {
    this.transformsArr.length >= 2 && this.transformsArr.sort((a4, b2) => {
      var _a, _b;
      return (null !== (_a = a4.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b2.level) && void 0 !== _b ? _b : 0);
    });
  }
  executeTransform(options, opt = {
    pushHistory: true,
    emitMessage: true
  }) {
    const { pushHistory, emitMessage } = opt, transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
    this.history && false !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, false !== emitMessage && this.target.emit("change", []);
  }
  resetTransformData() {
    this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
  }
  enableDiff(keys2) {
    this._diffData = true, this._diffKeys = keys2, this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  disableDiff() {
    this._diffData = false, this._diffMap = null, this._diffRank = null;
  }
  resetDiff() {
    this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  diffLastData() {
    var _a;
    if (!this._diffData) return;
    if (!this.latestData.forEach) return;
    if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length)) return;
    const next = this._diffRank + 1;
    if (0 === this._diffRank) this.latestData.forEach((d2) => {
      d2[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce((pre, k3) => pre + d2[k3], ""), d2);
    }), this.latestDataAUD = {
      add: Array.from(this.latestData),
      del: [],
      update: []
    };
    else {
      let tempKey;
      this.latestDataAUD = {
        add: [],
        del: [],
        update: []
      }, this.latestData.forEach((d2) => {
        d2[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce((pre, k3) => pre + d2[k3], ""), this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d2) : this.latestDataAUD.add.push(d2), this._diffMap.set(tempKey, d2);
      }), this._diffMap.forEach((v2, k3) => {
        v2[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v2), this._diffMap.delete(k3));
      });
    }
    this._diffRank = next;
  }
  cloneParseData(data, options) {
    let clone3 = false;
    return data instanceof _DataView || true !== (null == options ? void 0 : options.clone) || (clone3 = true), clone3 ? cloneDeep(data) : data;
  }
  parseNewData(data, options) {
    this.parse(data, options || this.parseOption), this.reRunAllTransform();
  }
  updateRawData(data, options) {
    const cloneData = this.cloneParseData(data, options);
    this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
  }
  getFields() {
    var _a;
    return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
  }
  setFields(f2, foreMerge = false) {
    this._fields = f2 && foreMerge ? merge({}, this._fields, f2) : f2;
    const fieldsOption = this.transformsArr.find((_op) => "fields" === _op.type);
    !isNil_default(this._fields) && isNil_default(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
      type: "fields",
      options: {
        fields: this._fields
      }
    }, false)) : fieldsOption && (fieldsOption.options.fields = this._fields);
  }
  destroy() {
    this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
  }
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/util/time.js
var TimeUtil = class _TimeUtil {
  static getInstance() {
    return _TimeUtil.instance || (_TimeUtil.instance = new _TimeUtil()), _TimeUtil.instance;
  }
  constructor() {
    this.locale_shortWeekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], this.locale_periods = ["AM", "PM"], this.locale_weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], this.locale_shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], this.numberRe = /^\s*\d+/, this.pads = {
      "-": "",
      _: " ",
      0: "0"
    }, this.requoteRe = /[\\^$*+?|[\]().{}]/g, this.locale_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], this.formatShortWeekday = (d2) => this.locale_shortWeekdays[d2.getDay()], this.formatWeekday = (d2) => this.locale_weekdays[d2.getDay()], this.formatShortMonth = (d2) => this.locale_shortMonths[d2.getMonth()], this.formatMonth = (d2) => this.locale_months[d2.getMonth()], this.formatDayOfMonth = (d2, p2) => this.pad(d2.getDate(), p2, 2), this.formatHour24 = (d2, p2) => this.pad(d2.getHours(), p2, 2), this.formatHour12 = (d2, p2) => this.pad(d2.getHours() % 12 || 12, p2, 2), this.formatMilliseconds = (d2, p2) => this.pad(d2.getMilliseconds(), p2, 3), this.formatMonthNumber = (d2, p2) => this.pad(d2.getMonth() + 1, p2, 2), this.formatMinutes = (d2, p2) => this.pad(d2.getMinutes(), p2, 2), this.formatPeriod = (d2) => this.locale_periods[+(d2.getHours() >= 12)], this.formatSeconds = (d2, p2) => this.pad(d2.getSeconds(), p2, 2), this.formatFullYear = (d2, p2) => this.pad(d2.getFullYear() % 1e4, p2, 4), this.formatUTCShortWeekday = (d2) => this.locale_shortWeekdays[d2.getUTCDay()], this.formatUTCWeekday = (d2) => this.locale_weekdays[d2.getUTCDay()], this.formatUTCShortMonth = (d2) => this.locale_shortMonths[d2.getUTCMonth()], this.formatUTCMonth = (d2) => this.locale_months[d2.getUTCMonth()], this.formatUTCDayOfMonth = (d2, p2) => this.pad(d2.getUTCDate(), p2, 2), this.formatUTCHour24 = (d2, p2) => this.pad(d2.getUTCHours(), p2, 2), this.formatUTCHour12 = (d2, p2) => this.pad(d2.getUTCHours() % 12 || 12, p2, 2), this.formatUTCMilliseconds = (d2, p2) => this.pad(d2.getUTCMilliseconds(), p2, 3), this.formatUTCMonthNumber = (d2, p2) => this.pad(d2.getUTCMonth() + 1, p2, 2), this.formatUTCMinutes = (d2, p2) => this.pad(d2.getUTCMinutes(), p2, 2), this.formatUTCPeriod = (d2) => this.locale_periods[+(d2.getUTCHours() >= 12)], this.formatUTCSeconds = (d2, p2) => this.pad(d2.getUTCSeconds(), p2, 2), this.formatUTCFullYear = (d2, p2) => this.pad(d2.getUTCFullYear() % 1e4, p2, 4), this.formats = {
      a: this.formatShortWeekday,
      A: this.formatWeekday,
      b: this.formatShortMonth,
      B: this.formatMonth,
      d: this.formatDayOfMonth,
      e: this.formatDayOfMonth,
      H: this.formatHour24,
      I: this.formatHour12,
      L: this.formatMilliseconds,
      m: this.formatMonthNumber,
      M: this.formatMinutes,
      p: this.formatPeriod,
      S: this.formatSeconds,
      Y: this.formatFullYear
    }, this.utcFormats = {
      a: this.formatUTCShortWeekday,
      A: this.formatUTCWeekday,
      b: this.formatUTCShortMonth,
      B: this.formatUTCMonth,
      d: this.formatUTCDayOfMonth,
      e: this.formatUTCDayOfMonth,
      H: this.formatUTCHour24,
      I: this.formatUTCHour12,
      L: this.formatUTCMilliseconds,
      m: this.formatUTCMonthNumber,
      M: this.formatUTCMinutes,
      p: this.formatUTCPeriod,
      S: this.formatUTCSeconds,
      Y: this.formatUTCFullYear
    }, this.parseShortWeekday = (d2, string, i2) => {
      const n2 = this.shortWeekdayRe.exec(string.slice(i2));
      return n2 ? (d2.w = this.shortWeekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseWeekday = (d2, string, i2) => {
      const n2 = this.weekdayRe.exec(string.slice(i2));
      return n2 ? (d2.w = this.weekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseShortMonth = (d2, string, i2) => {
      const n2 = this.shortMonthRe.exec(string.slice(i2));
      return n2 ? (d2.m = this.shortMonthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseMonth = (d2, string, i2) => {
      const n2 = this.monthRe.exec(string.slice(i2));
      return n2 ? (d2.m = this.monthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseDayOfMonth = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.d = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseHour24 = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.H = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseMilliseconds = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 3));
      return n2 ? (d2.L = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseMonthNumber = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.m = n2 - 1, i2 + n2[0].length) : -1;
    }, this.parseMinutes = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.M = +n2[0], i2 + n2[0].length) : -1;
    }, this.parsePeriod = (d2, string, i2) => {
      const n2 = this.periodRe.exec(string.slice(i2));
      return n2 ? (d2.p = this.periodLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
    }, this.parseSeconds = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 2));
      return n2 ? (d2.S = +n2[0], i2 + n2[0].length) : -1;
    }, this.parseFullYear = (d2, string, i2) => {
      const n2 = this.numberRe.exec(string.slice(i2, i2 + 4));
      return n2 ? (d2.y = +n2[0], i2 + n2[0].length) : -1;
    }, this.parses = {
      a: this.parseShortWeekday,
      A: this.parseWeekday,
      b: this.parseShortMonth,
      B: this.parseMonth,
      d: this.parseDayOfMonth,
      e: this.parseDayOfMonth,
      H: this.parseHour24,
      I: this.parseHour24,
      L: this.parseMilliseconds,
      m: this.parseMonthNumber,
      M: this.parseMinutes,
      p: this.parsePeriod,
      S: this.parseSeconds,
      Y: this.parseFullYear
    }, this.timeFormat = (specifier, timeText) => this.newFormat(specifier, this.formats)(new Date(this.getFullTimeStamp(timeText))), this.timeUTCFormat = (specifier, timeText) => this.newFormat(specifier, this.utcFormats)(new Date(this.getFullTimeStamp(timeText))), this.timeParse = (specifier, timeText) => this.newParse(specifier, false)(timeText + ""), this.requoteF = this.requote.bind(this), this.periodRe = this.formatRe(this.locale_periods), this.periodLookup = this.formatLookup(this.locale_periods), this.weekdayRe = this.formatRe(this.locale_weekdays), this.weekdayLookup = this.formatLookup(this.locale_weekdays), this.shortWeekdayRe = this.formatRe(this.locale_shortWeekdays), this.shortWeekdayLookup = this.formatLookup(this.locale_shortWeekdays), this.monthRe = this.formatRe(this.locale_months), this.monthLookup = this.formatLookup(this.locale_months), this.shortMonthRe = this.formatRe(this.locale_shortMonths), this.shortMonthLookup = this.formatLookup(this.locale_shortMonths);
  }
  requote(s3) {
    return s3.replace(this.requoteRe, "\\$&");
  }
  localDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      const date = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
      return date.setFullYear(d2.y), date;
    }
    return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
  }
  utcDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      const date = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
      return date.setUTCFullYear(d2.y), date;
    }
    return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
  }
  newDate(y3, m5, d2) {
    return {
      y: y3,
      m: m5,
      d: d2,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }
  formatRe(names) {
    return new RegExp("^(?:" + names.map(this.requoteF).join("|") + ")", "i");
  }
  formatLookup(names) {
    return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
  }
  pad(value, fill, width) {
    const sign4 = value < 0 ? "-" : "", string = (sign4 ? -value : value) + "", length2 = string.length;
    return sign4 + (length2 < width ? new Array(width - length2 + 1).join(fill) + string : string);
  }
  parseSpecifier(d2, specifier, string, j2) {
    let i2 = 0;
    const n2 = specifier.length, m5 = string.length;
    let c4, parse2;
    for (; i2 < n2; ) {
      if (j2 >= m5) return -1;
      if (c4 = specifier.charCodeAt(i2++), 37 === c4) {
        if (c4 = specifier.charAt(i2++), parse2 = this.parses[c4 in this.pads ? specifier.charAt(i2++) : c4], !parse2 || (j2 = parse2(d2, string, j2)) < 0) return -1;
      } else if (c4 !== string.charCodeAt(j2++)) return -1;
    }
    return j2;
  }
  newParse(specifier, Z3) {
    const that = this;
    return function(string) {
      const d2 = that.newDate(1900, void 0, 1);
      return that.parseSpecifier(d2, specifier, string += "", 0) !== string.length ? null : "Q" in d2 ? new Date(d2.Q) : "s" in d2 ? new Date(1e3 * d2.s + ("L" in d2 ? d2.L : 0)) : (Z3 && !("Z" in d2) && (d2.Z = 0), "p" in d2 && (d2.H = d2.H % 12 + 12 * d2.p), void 0 === d2.m && (d2.m = "q" in d2 ? d2.q : 0), "Z" in d2 ? (d2.H += d2.Z / 100 | 0, d2.M += d2.Z % 100, that.utcDate(d2)) : that.localDate(d2));
    };
  }
  newFormat(specifier, formats) {
    const that = this;
    return function(date) {
      const string = [];
      let i2 = -1, j2 = 0;
      const n2 = specifier.length;
      let c4, pad, format;
      for (date instanceof Date || (date = /* @__PURE__ */ new Date(+date)); ++i2 < n2; ) 37 === specifier.charCodeAt(i2) && (string.push(specifier.slice(j2, i2)), (pad = that.pads[c4 = specifier.charAt(++i2)]) ? c4 = specifier.charAt(++i2) : pad = "e" === c4 ? " " : "0", format = formats[c4], c4 = format(date, pad), string.push(c4), j2 = i2 + 1);
      return string.push(specifier.slice(j2, i2)), string.join("");
    };
  }
  getFullTimeStamp(timeText) {
    const timeOriStamp = parseInt(timeText + "", 10);
    return 10 === String(timeOriStamp).length ? 1e3 * timeOriStamp : timeOriStamp;
  }
};

// node_modules/@visactor/vchart/esm/util/debug.js
var warn = (msg, detail) => (isFunction_default(config.warnHandler) && config.warnHandler.call(null, msg, detail), detail ? Logger.getInstance().warn(`[VChart warn]: ${msg}`, detail) : Logger.getInstance().warn(`[VChart warn]: ${msg}`));
var error = (msg, detail, err) => {
  if (!config.silent) {
    if (!isFunction_default(config.errorHandler)) throw new Error(msg);
    config.errorHandler.call(null, msg, detail);
  }
};
var config = {
  silent: false,
  warnHandler: false,
  errorHandler: false
};

// node_modules/@visactor/vrender-core/es/common/generator.js
var Generator = class _Generator {
  static GenAutoIncrementId() {
    return _Generator.auto_increment_id++;
  }
};
Generator.auto_increment_id = 0;

// node_modules/@visactor/vrender-core/es/common/inversify/cotainer-module.js
var ContainerModule = class {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/metadata_keys.js
var NAMED_TAG = "named";
var INJECT_TAG = "inject";
var MULTI_INJECT_TAG = "multi_inject";
var TAGGED = "inversify:tagged";
var PARAM_TYPES = "inversify:paramtypes";
function getNonCustomTagKeys() {
  return ["inject", "multi_inject", "name", "unmanaged", "named", "optional"];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

// node_modules/@visactor/vrender-core/es/common/inversify/meta-data.js
var Metadata = class {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};

// node_modules/@visactor/vrender-core/es/common/Reflect-metadata.js
var Reflect_metadata_default = function(Reflect2) {
  var target, previous;
  return function(exporter) {
    const hasOwn = Object.prototype.hasOwnProperty, supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", supportsCreate = "function" == typeof Object.create, supportsProto = {
      __proto__: []
    } instanceof Array, downLevel = !supportsCreate && !supportsProto, HashMap = {
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({
          __proto__: null
        });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map4, key) {
        return hasOwn.call(map4, key);
      } : function(map4, key) {
        return key in map4;
      },
      get: downLevel ? function(map4, key) {
        return hasOwn.call(map4, key) ? map4[key] : void 0;
      } : function(map4, key) {
        return map4[key];
      }
    }, functionPrototype = Object.getPrototypeOf(Function), usePolyfill = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, _Map = usePolyfill || "function" != typeof Map || "function" != typeof Map.prototype.entries ? CreateMapPolyfill() : Map, Metadata2 = (usePolyfill || "function" != typeof Set || "function" != typeof Set.prototype.entries ? CreateSetPolyfill() : Set, new (usePolyfill || "function" != typeof WeakMap ? CreateWeakMapPolyfill() : WeakMap)());
    function defineMetadata(metadataKey, metadataValue, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
    }
    function hasMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target2, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target2, propertyKey);
    }
    function getMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target2, propertyKey);
    }
    function GetOrCreateMetadataMap(O2, P2, Create) {
      let targetMetadata = Metadata2.get(O2);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map(), Metadata2.set(O2, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P2);
      if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map(), targetMetadata.set(P2, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O2, P2) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O2, P2)) return true;
      const parent = OrdinaryGetPrototypeOf(O2);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P2);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
      const metadataMap = GetOrCreateMetadataMap(O2, P2, false);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O2, P2) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O2, P2)) return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
      const parent = OrdinaryGetPrototypeOf(O2);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P2);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
      const metadataMap = GetOrCreateMetadataMap(O2, P2, false);
      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
      GetOrCreateMetadataMap(O2, P2, true).set(MetadataKey, MetadataValue);
    }
    function Type(x3) {
      if (null === x3) return 1;
      switch (typeof x3) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x3 ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x3) {
      return void 0 === x3;
    }
    function IsNull(x3) {
      return null === x3;
    }
    function IsSymbol(x3) {
      return "symbol" == typeof x3;
    }
    function IsObject(x3) {
      return "object" == typeof x3 ? null !== x3 : "function" == typeof x3;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result2 = exoticToPrim.call(input, hint);
        if (IsObject(result2)) throw new TypeError();
        return result2;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O2, hint) {
      if ("string" === hint) {
        const toString_1 = O2.toString;
        if (IsCallable(toString_1)) {
          const result2 = toString_1.call(O2);
          if (!IsObject(result2)) return result2;
        }
        const valueOf = O2.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O2);
          if (!IsObject(result2)) return result2;
        }
      } else {
        const valueOf = O2.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O2);
          if (!IsObject(result2)) return result2;
        }
        const toString_2 = O2.toString;
        if (IsCallable(toString_2)) {
          const result2 = toString_2.call(O2);
          if (!IsObject(result2)) return result2;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V2, P2) {
      const func = V2[P2];
      if (null != func) {
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O2) {
      const proto = Object.getPrototypeOf(O2);
      if ("function" != typeof O2 || O2 === functionPrototype) return proto;
      if (proto !== functionPrototype) return proto;
      const prototype = O2.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O2 ? proto : constructor;
    }
    function CreateMapPolyfill() {
      const cacheSentinel = {}, arraySentinel = [], MapIterator = function() {
        function MapIterator2(keys2, values, selector) {
          this._index = 0, this._keys = keys2, this._values = values, this._selector = selector;
        }
        return MapIterator2.prototype["@@iterator"] = function() {
          return this;
        }, MapIterator2.prototype[iteratorSymbol] = function() {
          return this;
        }, MapIterator2.prototype.next = function() {
          const index = this._index;
          if (index >= 0 && index < this._keys.length) {
            const result2 = this._selector(this._keys[index], this._values[index]);
            return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel) : this._index++, {
              value: result2,
              done: false
            };
          }
          return {
            value: void 0,
            done: true
          };
        }, MapIterator2.prototype.throw = function(error3) {
          throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), error3;
        }, MapIterator2.prototype.return = function(value) {
          return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), {
            value,
            done: true
          };
        }, MapIterator2;
      }();
      return function() {
        function Map2() {
          this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }
        return Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        }), Map2.prototype.has = function(key) {
          return this._find(key, false) >= 0;
        }, Map2.prototype.get = function(key) {
          const index = this._find(key, false);
          return index >= 0 ? this._values[index] : void 0;
        }, Map2.prototype.set = function(key, value) {
          const index = this._find(key, true);
          return this._values[index] = value, this;
        }, Map2.prototype.delete = function(key) {
          const index = this._find(key, false);
          if (index >= 0) {
            const size = this._keys.length;
            for (let i2 = index + 1; i2 < size; i2++) this._keys[i2 - 1] = this._keys[i2], this._values[i2 - 1] = this._values[i2];
            return this._keys.length--, this._values.length--, key === this._cacheKey && (this._cacheKey = cacheSentinel, this._cacheIndex = -2), true;
          }
          return false;
        }, Map2.prototype.clear = function() {
          this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }, Map2.prototype.keys = function() {
          return new MapIterator(this._keys, this._values, getKey);
        }, Map2.prototype.values = function() {
          return new MapIterator(this._keys, this._values, getValue);
        }, Map2.prototype.entries = function() {
          return new MapIterator(this._keys, this._values, getEntry);
        }, Map2.prototype["@@iterator"] = function() {
          return this.entries();
        }, Map2.prototype[iteratorSymbol] = function() {
          return this.entries();
        }, Map2.prototype._find = function(key, insert) {
          return this._cacheKey !== key && (this._cacheIndex = this._keys.indexOf(this._cacheKey = key)), this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, this._keys.push(key), this._values.push(void 0)), this._cacheIndex;
        }, Map2;
      }();
      function getKey(key, _2) {
        return key;
      }
      function getValue(_2, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return function() {
        function Set2() {
          this._map = new _Map();
        }
        return Object.defineProperty(Set2.prototype, "size", {
          get: function() {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        }), Set2.prototype.has = function(value) {
          return this._map.has(value);
        }, Set2.prototype.add = function(value) {
          return this._map.set(value, value), this;
        }, Set2.prototype.delete = function(value) {
          return this._map.delete(value);
        }, Set2.prototype.clear = function() {
          this._map.clear();
        }, Set2.prototype.keys = function() {
          return this._map.keys();
        }, Set2.prototype.values = function() {
          return this._map.values();
        }, Set2.prototype.entries = function() {
          return this._map.entries();
        }, Set2.prototype["@@iterator"] = function() {
          return this.keys();
        }, Set2.prototype[iteratorSymbol] = function() {
          return this.keys();
        }, Set2;
      }();
    }
    function CreateWeakMapPolyfill() {
      const UUID_SIZE = 16, keys2 = HashMap.create(), rootKey = CreateUniqueKey();
      return function() {
        function WeakMap2() {
          this._key = CreateUniqueKey();
        }
        return WeakMap2.prototype.has = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table && HashMap.has(table, this._key);
        }, WeakMap2.prototype.get = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table ? HashMap.get(table, this._key) : void 0;
        }, WeakMap2.prototype.set = function(target2, value) {
          return GetOrCreateWeakMapTable(target2, true)[this._key] = value, this;
        }, WeakMap2.prototype.delete = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table && delete table[this._key];
        }, WeakMap2.prototype.clear = function() {
          this._key = CreateUniqueKey();
        }, WeakMap2;
      }();
      function CreateUniqueKey() {
        let key;
        do {
          key = "@@WeakMap@@" + CreateUUID();
        } while (HashMap.has(keys2, key));
        return keys2[key] = true, key;
      }
      function GetOrCreateWeakMapTable(target2, create3) {
        if (!hasOwn.call(target2, rootKey)) {
          if (!create3) return;
          Object.defineProperty(target2, rootKey, {
            value: HashMap.create()
          });
        }
        return target2[rootKey];
      }
      function FillRandomBytes(buffer2, size) {
        for (let i2 = 0; i2 < size; ++i2) buffer2[i2] = 255 * Math.random() | 0;
        return buffer2;
      }
      function GenRandomBytes(size) {
        return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(size)) : FillRandomBytes(new Uint8Array(size), size) : FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        const data = GenRandomBytes(UUID_SIZE);
        data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
        let result2 = "";
        for (let offset = 0; offset < UUID_SIZE; ++offset) {
          const byte = data[offset];
          4 !== offset && 6 !== offset && 8 !== offset || (result2 += "-"), byte < 16 && (result2 += "0"), result2 += byte.toString(16).toLowerCase();
        }
        return result2;
      }
    }
    function MakeDictionary(obj) {
      return obj.__ = void 0, delete obj.__, obj;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect2, function(key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: true,
      writable: true,
      value
    }), previous && previous(key, value);
  })), Reflect2;
}({});

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject_base.js
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect_metadata_default.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect_metadata_default.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect_metadata_default.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return (serviceIdentifier) => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/inject.js
var inject = injectBase(INJECT_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/multi_inject.js
var multiInject = injectBase(MULTI_INJECT_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/injectable.js
function injectable() {
  return function(target) {
    return Reflect_metadata_default.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

// node_modules/@visactor/vrender-core/es/common/inversify/annotation/named.js
function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

// node_modules/@visactor/vrender-core/es/common/inversify/literal_types.js
var BindingScopeEnum = {
  Singleton: "Singleton",
  Transient: "Transient"
};
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};

// node_modules/@visactor/vrender-core/es/common/inversify/binding.js
var Binding = class _Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = false, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = (request) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone3 = new _Binding(this.serviceIdentifier, this.scope);
    return clone3.activated = clone3.scope === BindingScopeEnum.Singleton && this.activated, clone3.implementationType = this.implementationType, clone3.dynamicValue = this.dynamicValue, clone3.scope = this.scope, clone3.type = this.type, clone3.provider = this.provider, clone3.constraint = this.constraint, clone3.cache = this.cache, clone3;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/metadata_reader.js
var MetadataReader = class {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect_metadata_default.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect_metadata_default.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("暂未实现");
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/constraint_helpers.js
var taggedConstraint = (key) => (value) => {
  const constraint = (request) => {
    if (null == request) return false;
    if (request.key === key && request.value === value) return true;
    if (null == request.constructorArgsMetadata) return false;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i2 = 0; i2 < constructorArgsMetadata.length; i2++) if (constructorArgsMetadata[i2].key === key && constructorArgsMetadata[i2].value === value) return true;
    return false;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
var namedConstraint = taggedConstraint(NAMED_TAG);

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_in_syntax.js
var BindingInSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("暂未实现");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/syntax/binding_to_syntax.js
var BindingToSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self = this._binding.serviceIdentifier;
    return this.to(self);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue((context) => context.container.get(service));
  }
};

// node_modules/@visactor/vrender-core/es/common/inversify/container.js
var Container = class {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = /* @__PURE__ */ new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named2) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named2);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope, binding = new Binding(serviceIdentifier, scope), list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
      bindingToSyntax._binding.moduleId = moduleId;
    }, getBindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.bind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    }, getUnbindFunction = () => (serviceIdentifier) => this.unbind(serviceIdentifier), getIsboundFunction = () => (serviceIdentifier) => this.isBound(serviceIdentifier), getRebindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.rebind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    };
    return (mId) => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: (serviceIdentifier) => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier
    };
  }
  _get(getArgs) {
    const result2 = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter((b2) => b2.constraint(getArgs)).forEach((binding) => {
      result2.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result2.length ? result2 : result2[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType, { userGeneratedMetadata } = this._metadataReader.getConstructorMetadata(constr), keys2 = Object.keys(userGeneratedMetadata), arr = [];
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const constructorArgsMetadata = userGeneratedMetadata[i2], targetMetadataMap = {};
      constructorArgsMetadata.forEach((md) => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
        inject: targetMetadataMap[INJECT_TAG],
        multiInject: targetMetadataMap[MULTI_INJECT_TAG]
      }, injectIdentifier = metadata.inject || metadata.multiInject, target = {
        serviceIdentifier: injectIdentifier,
        constructorArgsMetadata
      }, request = {
        injectIdentifier,
        metadata: constructorArgsMetadata,
        bindings: this._bindingDictionary.get(injectIdentifier).filter((b2) => b2.constraint(target))
      };
      arr.push(request);
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result2 = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result2), result2;
  }
  _getResolvedFromBinding(binding) {
    let result2;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result2 = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result2 = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result2 = binding.dynamicValue({
          container: this
        });
    }
    return result2;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated) return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map((request) => request.bindings.length > 1 ? request.bindings.map((binding) => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result2) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result2, binding.activated = true);
  }
};

// node_modules/@visactor/vrender-core/es/common/contribution-provider.js
var ContributionProvider = Symbol("ContributionProvider");
var ContributionProviderCache = class {
  constructor(serviceIdentifier, container2) {
    this.serviceIdentifier = serviceIdentifier, this.container = container2;
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
};
function bindContributionProvider(bind, id2) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id2, container2)).inSingletonScope().whenTargetNamed(id2);
}
function bindContributionProviderNoSingletonScope(bind, id2) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id2, container2)).whenTargetNamed(id2);
}

// node_modules/@visactor/vrender-core/es/tapable/Hook.js
var Hook = class {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter((tap) => tap.name !== name && (!fn || tap.fn === fn)));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options) _options = {
      name: options.trim()
    };
    else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
    return _options = Object.assign({
      type,
      fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = /* @__PURE__ */ new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i2 = this.taps.length;
    for (; i2 > 0; ) {
      i2--;
      const x3 = this.taps[i2];
      this.taps[i2 + 1] = x3;
      const xStage = x3.stage || 0;
      if (before) {
        if (before.has(x3.name)) {
          before.delete(x3.name);
          continue;
        }
        if (before.size > 0) continue;
      }
      if (!(xStage > stage)) {
        i2++;
        break;
      }
    }
    this.taps[i2] = item;
  }
};

// node_modules/@visactor/vrender-core/es/tapable/SyncHook.js
var SyncHook = class extends Hook {
  call(...args) {
    this.taps.map((t2) => t2.fn).forEach((cb) => cb(...args));
  }
};

// node_modules/@visactor/vrender-core/es/constants.js
var EnvContribution = Symbol.for("EnvContribution");
var VGlobal = Symbol.for("VGlobal");

// node_modules/@visactor/vrender-core/es/core/global.js
var __decorate = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGlobal = class {
  get env() {
    return this._env;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    this.contributions = contributions, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = false;
  }
  bindContribution(params2) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach((contribution) => {
      const data = contribution.configure(this, params2);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length) return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params2) {
    if (params2 && true === params2.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params2);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params2) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params2);
    if (data && data.then) return data.then(() => {
      this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
    });
    this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params2);
  }
  createOffscreenCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params2);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  addEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params2);
  }
  getElementTop(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
};
DefaultGlobal = __decorate([injectable(), __param(0, inject(ContributionProvider)), __param(0, named(EnvContribution)), __metadata("design:paramtypes", [Object])], DefaultGlobal);

// node_modules/@visactor/vrender-core/es/common/bounds-context.js
var circleThreshold = tau - 1e-8;
var BoundsContext = class {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r2, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r2, cy - r2), void this.bounds.add(cx + r2, cy + r2);
    let s3, i2, x3, y3, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;
    function update3(a4) {
      x3 = r2 * Math.cos(a4), y3 = r2 * Math.sin(a4), x3 < xmin && (xmin = x3), x3 > xmax && (xmax = x3), y3 < ymin && (ymin = y3), y3 > ymax && (ymax = y3);
    }
    if (update3(sa), update3(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s3 = sa, sa = ea, ea = s3), ccw) for (ea -= tau, s3 = sa - sa % halfPi, i2 = 0; i2 < 4 && s3 > ea; ++i2, s3 -= halfPi) update3(s3);
    else for (s3 = sa - sa % halfPi + halfPi, i2 = 0; i2 < 4 && s3 < ea; ++i2, s3 += halfPi) update3(s3);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x14, y14, x23, y23, radius) {
    throw new Error("不支持arcTo");
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x3, y3);
  }
  closePath() {
  }
  ellipse() {
    throw new Error("不支持ellipse");
  }
  lineTo(x3, y3) {
    this.bounds.add(x3, y3);
  }
  moveTo(x3, y3) {
    this.bounds.add(x3, y3);
  }
  quadraticCurveTo(cpx, cpy, x3, y3) {
    this.bounds.add(cpx, cpy), this.bounds.add(x3, y3);
  }
  rect(x3, y3, w2, h2) {
    this.bounds.add(x3, y3), this.bounds.add(x3 + w2, y3 + h2);
  }
  clear() {
    this.bounds.clear();
  }
  release(...params2) {
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/curve/path.js
var CurvePath = class {
  constructor() {
    this.curves = [], this.bounds = new AABBBounds();
  }
  getCurveLengths() {
    return this.curves.map((curve) => curve.getLength());
  }
  getPointAt(t2) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
};

// node_modules/@visactor/vrender-core/es/common/path-svg.js
var rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
var commandLengths = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7,
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7
};
var enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
var currPath;
var coordsStr;
var commandChar;
var coordStr;
var coordNumber;
var standardCommandLen;
function parseSvgPath(str) {
  if (!str) return [];
  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths) return [];
  let currCommandData, coordsStrArr;
  const result2 = [];
  for (let i2 = 0, len = paths.length; i2 < len; i2++) if (currPath = paths[i2], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
    for (let i3 = 0, len2 = coordsStrArr.length; i3 < len2; i3++) coordStr = coordsStrArr[i3], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
      let subCommand;
      for (let i3 = 1, len2 = currCommandData.length; i3 < len2; i3 += standardCommandLen) {
        subCommand = [commandChar];
        for (let j2 = i3, subLen = i3 + standardCommandLen; j2 < subLen; j2++) subCommand.push(currCommandData[j2]);
        result2.push(subCommand);
      }
    } else result2.push(currCommandData);
  } else result2.push(currCommandData);
  return result2;
}

// node_modules/@visactor/vrender-core/es/common/enums.js
var UpdateTag;
!function(UpdateTag2) {
  UpdateTag2[UpdateTag2.NONE = 0] = "NONE", UpdateTag2[UpdateTag2.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag2[UpdateTag2.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag2[UpdateTag2.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag2[UpdateTag2.INIT = 179] = "INIT", UpdateTag2[UpdateTag2.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag2[UpdateTag2.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function(IContainPointMode2) {
  IContainPointMode2[IContainPointMode2.GLOBAL = 1] = "GLOBAL", IContainPointMode2[IContainPointMode2.LOCAL = 16] = "LOCAL", IContainPointMode2[IContainPointMode2.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode2[IContainPointMode2.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function(AttributeUpdateType2) {
  AttributeUpdateType2[AttributeUpdateType2.INIT = 0] = "INIT", AttributeUpdateType2[AttributeUpdateType2.DEFAULT = 1] = "DEFAULT", AttributeUpdateType2[AttributeUpdateType2.STATE = 2] = "STATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType2[AttributeUpdateType2.SCALE = 22] = "SCALE", AttributeUpdateType2[AttributeUpdateType2.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType2[AttributeUpdateType2.ROTATE = 24] = "ROTATE", AttributeUpdateType2[AttributeUpdateType2.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var AnimateStatus;
!function(AnimateStatus2) {
  AnimateStatus2[AnimateStatus2.INITIAL = 0] = "INITIAL", AnimateStatus2[AnimateStatus2.RUNNING = 1] = "RUNNING", AnimateStatus2[AnimateStatus2.PAUSED = 2] = "PAUSED", AnimateStatus2[AnimateStatus2.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));
var AnimateMode;
!function(AnimateMode2) {
  AnimateMode2[AnimateMode2.NORMAL = 0] = "NORMAL", AnimateMode2[AnimateMode2.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));
var AnimateStepType;
!function(AnimateStepType2) {
  AnimateStepType2.wait = "wait", AnimateStepType2.from = "from", AnimateStepType2.to = "to", AnimateStepType2.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var Direction;
!function(Direction3) {
  Direction3[Direction3.ROW = 1] = "ROW", Direction3[Direction3.COLUMN = 2] = "COLUMN";
}(Direction || (Direction = {}));
var CurveTypeEnum;
!function(CurveTypeEnum2) {
  CurveTypeEnum2[CurveTypeEnum2.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum2[CurveTypeEnum2.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum2[CurveTypeEnum2.ArcCurve = 2] = "ArcCurve", CurveTypeEnum2[CurveTypeEnum2.LineCurve = 3] = "LineCurve", CurveTypeEnum2[CurveTypeEnum2.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum2[CurveTypeEnum2.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function(BaseRenderContributionTime2) {
  BaseRenderContributionTime2[BaseRenderContributionTime2.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime2[BaseRenderContributionTime2.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

// node_modules/@visactor/vrender-core/es/common/shape/arc.js
function segments(x3, y3, rx, ry, large, sweep, rotateX2, ox, oy) {
  const th = degreeToRadian(rotateX2), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x3) * 0.5 + sin_th * (oy - y3) * 0.5, py = cos_th * (oy - y3) * 0.5 - sin_th * (ox - x3) * 0.5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x05 = a00 * ox + a01 * oy, y05 = a10 * ox + a11 * oy, x14 = a00 * x3 + a01 * y3, y14 = a10 * x3 + a11 * y3;
  let sfactor_sq = 1 / ((x14 - x05) * (x14 - x05) + (y14 - y05) * (y14 - y05)) - 0.25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = 0.5 * (x05 + x14) - sfactor * (y14 - y05), yc = 0.5 * (y05 + y14) + sfactor * (x14 - x05), th0 = Math.atan2(y05 - yc, x05 - xc);
  let th_arc = Math.atan2(y14 - yc, x14 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi + 1e-3))), result2 = [];
  for (let i2 = 0; i2 < segs; ++i2) {
    const th2 = th0 + i2 * th_arc / segs, th3 = th0 + (i2 + 1) * th_arc / segs;
    result2[i2] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result2;
}
function bezier(params2) {
  const cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = 0.5 * (th1 - th0), sin_th_h2 = Math.sin(0.5 * th_half), t2 = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x14 = cx + cos_th0 - t2 * sin_th0, y14 = cy + sin_th0 + t2 * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x23 = x3 + t2 * sin_th1, y23 = y3 - t2 * cos_th1;
  return [a00 * x14 + a01 * y14, a10 * x14 + a11 * y14, a00 * x23 + a01 * y23, a10 * x23 + a11 * y23, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x3, y3, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x3, y3);
  for (let i2 = 0; i2 < seg.length; ++i2) {
    const bez = bezier(seg[i2]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
  const delta = Math.abs(endAngle - startAngle), len = 4 * Math.tan(delta / 4) / 3, dir = endAngle < startAngle ? -1 : 1, c1 = Math.cos(startAngle), s1 = Math.sin(startAngle), c22 = Math.cos(endAngle), s22 = Math.sin(endAngle), x14 = c1 * rx + cx, y14 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s22 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
  bezierPath.push(x14 - hx * s1, y14 + hy * c1, x4 + hx * s22, y4 - hy * c22, x4, y4);
};

// node_modules/@visactor/vrender-core/es/common/render-command-list.js
var commandFuncs = [(command, context, x3, y3, sx, sy, z2) => context.arc(command[1] * sx + x3, command[2] * sy + y3, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z2), (command, context, x3, y3, sx, sy, z2) => context.arcTo(command[1] * sx + x3, command[2] * sy + y3, command[3] * sx + x3, command[4] * sy + y3, command[5] * (sx + sy) / 2, z2), (command, context, x3, y3, sx, sy, z2) => context.bezierCurveTo(command[1] * sx + x3, command[2] * sy + y3, command[3] * sx + x3, command[4] * sy + y3, command[5] * sx + x3, command[6] * sy + y3, z2), (command, context, x3, y3) => context.closePath(), (command, context, x3, y3, sx, sy) => context.ellipse(command[1] * sx + x3, command[2] * sy + y3, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x3, y3, sx, sy, z2) => context.lineTo(command[1] * sx + x3, command[2] * sy + y3, z2), (command, context, x3, y3, sx, sy, z2) => context.moveTo(command[1] * sx + x3, command[2] * sy + y3, z2), (command, context, x3, y3, sx, sy, z2) => context.quadraticCurveTo(command[1] * sx + x3, command[2] * sy + y3, command[3] * sx + x3, command[4] * sy + y3, z2), (command, context, x3, y3, sx, sy, z2) => context.rect(command[1] * sx + x3, command[2] * sy + y3, command[3] * sx, command[4] * sy, z2)];
function renderCommandList(commandList, context, x3 = 0, y3 = 0, sx = 1, sy = 1, z2) {
  for (let i2 = 0; i2 < commandList.length; i2++) {
    const command = commandList[i2];
    commandFuncs[command[0]](command, context, x3, y3, sx, sy, z2);
  }
}

// node_modules/@visactor/vrender-core/es/common/segment/curve/base.js
var Curve = class {
  getLength(direction2) {
    return null != direction2 ? this.calcProjLength(direction2) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
};

// node_modules/@visactor/vrender-core/es/common/bezier-utils.js
function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i2 = 0; i2 < count; i2++) {
    const x3 = xArr[i2], y3 = yArr[i2], nextX = xArr[(i2 + 1) % count], nextY = yArr[(i2 + 1) % count];
    totalLength += PointService.distanceNN(x3, y3, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t2) {
  const one3 = 1 - t2;
  return one3 * one3 * one3 * p0 + 3 * p1 * t2 * one3 * one3 + 3 * p2 * t2 * t2 * one3 + p3 * t2 * t2 * t2;
}
function cubicPointAt(p0, p1, p2, p3, t2) {
  const x3 = cubicCalc(p0.x, p1.x, p2.x, p3.x, t2), y3 = cubicCalc(p0.y, p1.y, p2.y, p3.y, t2);
  return new Point(x3, y3);
}

// node_modules/@visactor/vrender-core/es/common/segment/curve/cubic-bezier.js
function divideCubic(curve, t2) {
  const { p0, p1, p2, p3 } = curve, pt = cubicPointAt(p0, p1, p2, p3, t2), c1 = PointService.pointAtPP(p0, p1, t2), c22 = PointService.pointAtPP(p1, p2, t2), c32 = PointService.pointAtPP(p2, p3, t2), c12 = PointService.pointAtPP(c1, c22, t2), c23 = PointService.pointAtPP(c22, c32, t2);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c32, p3)];
}
var CubicBezierCurve = class extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t2) {
    if (false !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t2);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3, 0) : 60;
  }
  calcProjLength(direction2) {
    return direction2 === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction2 === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t2) {
    const minT = max(t2 - 0.01, 0), maxT = min(t2 + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/curve/line.js
function divideLinear(curve, t2) {
  const { p0, p1 } = curve, c1 = PointService.pointAtPP(p0, p1, t2);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
var LineCurve = class extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t2) {
    if (false !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t2);
    throw new Error("defined为false的点不能getPointAt");
  }
  getAngleAt(t2) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction2) {
    return direction2 === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction2 === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
};

// node_modules/@visactor/vrender-core/es/common/seg-context.js
var SegContext = class {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction2) {
    this.init(curveType, direction2);
  }
  init(curveType, direction2) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction2, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3, defined, p2) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x3, y3));
    curve.originP1 = this._lastOriginP, curve.originP2 = p2, curve.defined = defined, this.curves.push(curve), this._lastX = x3, this._lastY = y3, this._lastOriginP = p2;
  }
  closePath() {
    if (this.curves.length < 2) return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext不支持调用ellipse");
  }
  lineTo(x3, y3, defined, p2) {
    const curve = this.addLinearCurve(x3, y3, defined, this._lastOriginP, p2);
    this.curves.push(curve), this._lastX = x3, this._lastY = y3, this._lastOriginP = p2;
  }
  moveTo(x3, y3, p2) {
    return this._lastX = this._startX = x3, this._lastY = this._startY = y3, this._lastOriginP = p2, this._startOriginP = p2, this;
  }
  quadraticCurveTo(cpx, cpy, x3, y3) {
    throw new Error("SegContext不支持调用quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction2) {
    return this.getLength(direction2);
  }
  addLinearCurve(x3, y3, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x3, y3));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t2) {
    throw new Error("暂未实现");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction2) {
    var _a, _b;
    if (direction2 === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction2 === Direction.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l2, c4) => l2 + c4.getLength(), 0)), this.length;
  }
};
var ReflectSegContext = class extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3, defined, p2) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y3, x3, defined, p2);
  }
  lineTo(x3, y3, defined, p2) {
    return super.lineTo(y3, x3, defined, p2);
  }
  moveTo(x3, y3, p2) {
    return super.moveTo(y3, x3, p2);
  }
  clear() {
    return super.clear();
  }
};

// node_modules/@visactor/vrender-core/es/common/segment/common.js
function genCurveSegments(path, points, step = 1) {
  let defined0 = false;
  for (let i2 = 0, n2 = points.length; i2 <= n2; i2++) i2 >= n2 === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i2]);
}
function genSegContext(curveType, direction2, points) {
  const curveDirection = null != direction2 ? direction2 : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

// node_modules/@visactor/vrender-core/es/common/segment/linear.js
var Linear = class {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p2) {
    const x3 = p2.x, y3 = p2.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x3, y3, false !== this._lastDefined && false !== p2.defined, p2) : this.context.moveTo(x3, y3, p2);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x3, y3, false !== this._lastDefined && false !== p2.defined, p2);
    }
    this._lastDefined = p2.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genLinearSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction2, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vrender-core/es/common/segment/basis.js
function point2(curveClass, x3, y3, defined, p2) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x3) / 6, (curveClass._y0 + 4 * curveClass._y1 + y3) / 6, defined, curveClass.lastPoint1);
}
var Basis = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point) point2(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p2) {
    const x3 = p2.x, y3 = p2.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x3, y3, false !== this._lastDefined1 && false !== this._lastDefined2, p2) : this.context.moveTo(x3, y3, p2);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point2(this, x3, y3, false !== this._lastDefined1 && false !== this._lastDefined2, p2);
    }
    this._x0 = this._x1, this._x1 = x3, this._y0 = this._y1, this._y1 = y3, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p2.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p2;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("basis", direction2, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vrender-core/es/common/segment/monotone.js
function sign3(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(curveClass, x23, y23) {
  const h0 = curveClass._x1 - curveClass._x0, h1 = x23 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y23 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign3(s0) + sign3(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(curveClass, t2) {
  const h2 = curveClass._x1 - curveClass._x0;
  return h2 ? (3 * (curveClass._y1 - curveClass._y0) / h2 - t2) / 2 : t2;
}
function point3(curveClass, t0, t1, defined, p2) {
  const x05 = curveClass._x0, y05 = curveClass._y0, x14 = curveClass._x1, y14 = curveClass._y1, dx = (x14 - x05) / 3;
  curveClass.context.bezierCurveTo(x05 + dx, y05 + dx * t0, x14 - dx, y14 - dx * t1, x14, y14, defined, curveClass.lastPoint1);
}
var MonotoneX = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point3(this, this._t0, slope2(this, this._t0), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p2) {
    let t1 = NaN;
    const x3 = p2.x, y3 = p2.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x3, y3, false !== this._lastDefined1 && false !== this._lastDefined2, p2) : this.context.moveTo(x3, y3, p2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point3(this, slope2(this, t1 = slope3(this, x3, y3)), t1, false !== this._lastDefined1 && false !== this._lastDefined2, p2);
        break;
      default:
        point3(this, this._t0, t1 = slope3(this, x3, y3), false !== this._lastDefined1 && false !== this._lastDefined2, p2);
    }
    this._x0 = this._x1, this._x1 = x3, this._y0 = this._y1, this._y1 = y3, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = false !== p2.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p2;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var MonotoneY = class extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p2) {
    return super.point({
      y: p2.x,
      x: p2.y,
      defined: p2.defined
    });
  }
};
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneX", direction2, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneY", direction2, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

// node_modules/@visactor/vrender-core/es/common/segment/step.js
var Step = class {
  constructor(context, t2 = 0.5, startPoint) {
    this.context = context, this._t = t2, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, false !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p2) {
    const x3 = p2.x, y3 = p2.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x3, y3, false !== this._lastDefined && false !== p2.defined, p2) : this.context.moveTo(x3, y3, p2);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0) this.context.lineTo(this._x, y3, false !== this._lastDefined && false !== p2.defined, this.lastPoint), this.context.lineTo(x3, y3, false !== this._lastDefined && false !== p2.defined, p2);
        else {
          const x14 = this._x * (1 - this._t) + x3 * this._t;
          this.context.lineTo(x14, this._y, false !== this._lastDefined && false !== p2.defined, this.lastPoint), this.context.lineTo(x14, y3, false !== this._lastDefined && false !== p2.defined, p2);
        }
    }
    this._lastDefined = p2.defined, this._x = x3, this._y = y3, this.lastPoint = p2;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genStepSegments(points, t2, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction2 ? direction2 : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new Step(segContext, t2, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vrender-core/es/common/segment/linear-closed.js
var LinearClosed = class extends Linear {
  lineEnd() {
    this.context.closePath();
  }
};
function genLinearClosedSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction2, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// node_modules/@visactor/vrender-core/es/common/segment/index.js
function calcLineCache(points, curveType, params2) {
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}

// node_modules/@visactor/vrender-core/es/common/custom-path2d.js
var CustomPath2D = class extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x3, y3) {
    return this.commandList.push([enumCommandMap.M, x3, y3]), this._ctx && this._ctx.moveTo(x3, y3), this;
  }
  lineTo(x3, y3) {
    return this.commandList.push([enumCommandMap.L, x3, y3]), this._ctx && this._ctx.lineTo(x3, y3), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x3, y3, w2, h2) {
    return this.commandList.push([enumCommandMap.R, x3, y3, w2, h2]), this._ctx && this._ctx.rect(x3, y3, w2, h2), this;
  }
  arc(x3, y3, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x3, y3, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x3, y3, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this.curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this.curves.length = 0;
  }
  toString() {
    if (!this.toStringCbList) {
      const list2 = [];
      list2[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list2[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list2[enumCommandMap.A] = (cmd) => {
        const bezierPathList = [];
        addArcToBezierPath(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
        let path2 = "";
        for (let i2 = 0; i2 < bezierPathList.length; i2 += 6) path2 += `C${bezierPathList[i2]} ${bezierPathList[i2 + 1]} ${bezierPathList[i2 + 2]} ${bezierPathList[i2 + 3]} ${bezierPathList[i2 + 4]} ${bezierPathList[i2 + 5]}`;
        return path2;
      }, list2[enumCommandMap.Z] = (cmd) => "Z", this.toStringCbList = list2;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach((c4) => {
      path += list[c4[0]](c4);
    }), path;
  }
  fromString(str, x3, y3, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str);
    return this._runCommandStrList(commandStrList, x3, y3, sX, sY), this._updateBounds(), this;
  }
  fromLine(line2) {
    const { points, curveType, clipRangeByDimension } = line2.attribute;
    if (!points) return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this.curves = cache.curves;
  }
  fromCustomPath2D(path, x3, y3, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x3, y3, sX, sY), this._updateBounds(), this;
  }
  transform(x3, y3, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach((cmd) => {
      this.transformCbList[cmd[0]](cmd, x3, y3, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3;
  }
  lineToTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3;
  }
  quadraticCurveToTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * sx + x3, cmd[4] = cmd[4] * sy + y3;
  }
  bezierCurveToTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * sx + x3, cmd[4] = cmd[4] * sy + y3, cmd[5] = cmd[5] * sx + x3, cmd[6] = cmd[6] * sy + y3;
  }
  arcToTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * sx + x3, cmd[4] = cmd[4] * sy + y3, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x3, y3, sx, sy) {
    cmd[1] = cmd[1] * sx + x3, cmd[2] = cmd[2] * sy + y3, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {
  }
  _runCommandStrList(commandStrList, l2 = 0, t2 = 0, sX = 1, sY = 1) {
    let current, tempX, tempY, tempControlX, tempControlY, previous = null, x3 = 0, y3 = 0, controlX = 0, controlY = 0;
    for (let i2 = 0, len = commandStrList.length; i2 < len; ++i2) {
      switch (current = commandStrList[i2], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), current[0]) {
        case "l":
          x3 += current[1], y3 += current[2], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "L":
          x3 = current[1], y3 = current[2], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "h":
          x3 += current[1], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "H":
          x3 = current[1], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "v":
          y3 += current[1], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "V":
          y3 = current[1], this.lineTo(x3 + l2, y3 + t2);
          break;
        case "m":
          x3 += current[1], y3 += current[2], this.moveTo(x3 + l2, y3 + t2);
          break;
        case "M":
          x3 = current[1], y3 = current[2], this.moveTo(x3 + l2, y3 + t2);
          break;
        case "c":
          tempX = x3 + current[5], tempY = y3 + current[6], controlX = x3 + current[3], controlY = y3 + current[4], this.bezierCurveTo(x3 + current[1] + l2, y3 + current[2] + t2, controlX + l2, controlY + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY;
          break;
        case "C":
          x3 = current[5], y3 = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l2, current[2] + t2, controlX + l2, controlY + t2, x3 + l2, y3 + t2);
          break;
        case "s":
          tempX = x3 + current[3], tempY = y3 + current[4], controlX = 2 * x3 - controlX, controlY = 2 * y3 - controlY, this.bezierCurveTo(controlX + l2, controlY + t2, x3 + current[1] + l2, y3 + current[2] + t2, tempX + l2, tempY + t2), controlX = x3 + current[1], controlY = y3 + current[2], x3 = tempX, y3 = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], controlX = 2 * x3 - controlX, controlY = 2 * y3 - controlY, this.bezierCurveTo(controlX + l2, controlY + t2, current[1] + l2, current[2] + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY, controlX = current[1], controlY = current[2];
          break;
        case "q":
          tempX = x3 + current[3], tempY = y3 + current[4], controlX = x3 + current[1], controlY = y3 + current[2], this.quadraticCurveTo(controlX + l2, controlY + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l2, current[2] + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x3 + current[1], tempY = y3 + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x3, controlY = y3) : "t" === previous[0] ? (controlX = 2 * x3 - tempControlX, controlY = 2 * y3 - tempControlY) : "q" === previous[0] && (controlX = 2 * x3 - controlX, controlY = 2 * y3 - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l2, controlY + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY, controlX = x3 + current[1], controlY = y3 + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x3 - controlX, controlY = 2 * y3 - controlY, this.quadraticCurveTo(controlX + l2, controlY + t2, tempX + l2, tempY + t2), x3 = tempX, y3 = tempY;
          break;
        case "a":
          drawArc(this, x3 + l2, y3 + t2, [current[1], current[2], current[3], current[4], current[5], current[6] + x3 + l2, current[7] + y3 + t2]), x3 += current[6], y3 += current[7];
          break;
        case "A":
          drawArc(this, x3 + l2, y3 + t2, [current[1], current[2], current[3], current[4], current[5], current[6] + l2, current[7] + t2]), x3 = current[6], y3 = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList, l2 = 0, t2 = 0, sX = 1, sY = 1) {
    if (0 !== l2 || 0 !== t2 || 1 !== sX || 1 !== sY) for (let i2 = 0, len = commandList.length; i2 < len; ++i2) {
      const current = commandList[i2].slice();
      switch (current[0]) {
        case enumCommandMap.L:
          this.lineToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.M:
          this.moveToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.C:
          this.bezierCurveToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.Q:
          this.quadraticCurveToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.A:
          this.arcToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.E:
          this.ellipseTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.R:
          this.rectTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.AT:
          this.arcToTransform(current, l2, t2, sX, sY);
          break;
        case enumCommandMap.Z:
          this.closePath();
      }
    }
    else this.commandList = commandList.map((entry) => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this.curves.reduce((l2, c4) => l2 + c4.getLength(), 0);
  }
  getAttrAt(distance2) {
    if (!this.curves) return {
      pos: {
        x: 0,
        y: 0
      },
      angle: 0
    };
    let curve, _dis = 0;
    for (let i2 = 0; i2 < this.curves.length; i2++) {
      curve = this.curves[i2];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance2) break;
      _dis += cl;
    }
    const t2 = (distance2 - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t2),
      angle: curve.getAngleAt(t2)
    };
  }
};
var temp2 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale(current, sX, sY) {
  const c4 = temp2[0] = current[0];
  if ("a" === c4 || "A" === c4) temp2[1] = sX * current[1], temp2[2] = sY * current[2], temp2[3] = current[3], temp2[4] = current[4], temp2[5] = current[5], temp2[6] = sX * current[6], temp2[7] = sY * current[7];
  else if ("h" === c4 || "H" === c4) temp2[1] = sX * current[1];
  else if ("v" === c4 || "V" === c4) temp2[1] = sY * current[1];
  else for (let i2 = 1, n2 = current.length; i2 < n2; ++i2) temp2[i2] = (i2 % 2 == 1 ? sX : sY) * current[i2];
  return temp2;
}

// node_modules/@visactor/vrender-core/es/graphic/config.js
var DefaultLayout = {
  alignSelf: "auto"
};
var DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
var DefaultFillStyle = {
  fillOpacity: 1,
  fill: false,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: false
};
var DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
var DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "…",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: false,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: false,
  verticalMode: 0,
  wrap: false,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  disableAutoClipedPoptip: void 0
};
var DefaultPickStyle = {
  pickStrokeBuffer: 0
};
var DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  opacity: 1,
  background: null,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: true,
  blur: 0,
  cursor: null,
  html: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
var DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
var DefaultDebugAttribute = {
  _debug_bounds: false
};
var DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  pickable: true,
  childrenPickable: true,
  fillPickable: true,
  strokePickable: true,
  visible: true,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: true,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden"
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
var DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: false,
  forceShowCap: false
});
var DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: false
});
var DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
var DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: false,
  visibleAll: true,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start"
});
var DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: false
});
var DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: false
});
var DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  customPath: () => {
    Logger.getInstance().warn("空函数");
  }
});
var DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: true
});
var DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0
});
var DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0
});
var DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: true
});
var DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: true
});
var DefaultRichTextAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 300,
  height: 300,
  ellipsis: true,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: false
});
var DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0
}, DefaultAttribute), {
  fill: true,
  cornerRadius: 0
});
var DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: false,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

// node_modules/@visactor/vrender-core/es/application.js
var Application = class {
};
var application = new Application();

// node_modules/@visactor/vrender-core/es/graphic/richtext/utils.js
var DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
var defaultFormatting = {
  fontSize: 16,
  fontFamily: "sans-serif",
  fill: true,
  stroke: false,
  fontWeight: "normal",
  lineHeight: "normal",
  fontStyle: "normal",
  textDecoration: "none",
  textAlign: "left",
  script: "normal"
};
var nbsp = String.fromCharCode(160);
var regLetter = /\w|\(|\)|-/;
var regPunctuation = /[.?!,;:/，。？！、；：]/;
var regFirstSpace = /\S/;
function applyFillStyle(ctx, character) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle) return void (ctx.globalAlpha = 0);
  ctx.globalAlpha = 1, ctx.fillStyle = fillStyle;
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily || "sans-serif"
  });
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle) return void (ctx.globalAlpha = 0);
  ctx.globalAlpha = 1, ctx.lineWidth = character && "number" == typeof character.lineHeight ? character.lineHeight : 1, ctx.strokeStyle = strokeStyle;
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily || "sans-serif"
  });
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (!width || width <= 0) return 0;
  const textMeasure = application.graphicUtil.textMeasure;
  let index = guessIndex, temp3 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp3, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width; ) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp3 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp3, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function testLetter(string, index) {
  let i2 = index;
  for (; regLetter.test(string[i2 - 1]) && regLetter.test(string[i2]) || regPunctuation.test(string[i2]); ) if (i2--, i2 <= 0) return index;
  return i2;
}
function measureTextCanvas(text2, character) {
  const measurement = application.graphicUtil.textMeasure.measureText(text2, character), result2 = {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  };
  return "number" != typeof measurement.actualBoundingBoxAscent || "number" != typeof measurement.actualBoundingBoxDescent ? (result2.width = Math.floor(measurement.width), result2.height = character.fontSize || 0, result2.ascent = result2.height, result2.descent = 0) : (result2.width = Math.floor(measurement.width), result2.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), result2.ascent = Math.floor(measurement.actualBoundingBoxAscent), result2.descent = result2.height - result2.ascent), result2;
}

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/AtextMeasure.js
var __decorate2 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  measureTextWidth(text2, options) {
    if (!this.context) return this.estimate(text2, options).width;
    this.context.setTextStyleWithoutAlignBaseline(options);
    return this.context.measureText(text2).width;
  }
  estimate(text2, { fontSize = DefaultTextAttribute.fontSize }) {
    let eCharLen = 0, cCharLen = 0;
    for (let i2 = 0; i2 < text2.length; i2++) text2.charCodeAt(i2) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextPixelHeight(text2, options) {
    var _a;
    if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(options);
    const textMeasure = this.context.measureText(text2);
    return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
  }
  measureTextBoundHieght(text2, options) {
    var _a;
    if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(options);
    const textMeasure = this.context.measureText(text2);
    return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
  }
  measureText(text2, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text2)) : this.estimate(text2, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const { fontSize = 12 } = options;
    verticalList.forEach((item) => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length2 = 0, i2 = 0;
    for (; i2 < verticalList.length && length2 + verticalList[i2].width < width; i2++) length2 += verticalList[i2].width, out.push(verticalList[i2]);
    if (verticalList[i2] && verticalList[i2].text.length > 1) {
      const clipedData = this._clipText(verticalList[i2].text, options, width - length2, 0, verticalList[i2].text.length - 1, "end", false);
      if (wordBreak && clipedData.str !== verticalList[i2].text) {
        let text2 = "", length3 = 0;
        for (let j2 = 0; j2 < i2; j2++) {
          const item = verticalList[j2];
          text2 += item.text, length3 += item.text.length;
        }
        text2 += verticalList[i2].text;
        const totalLength = length3 + clipedData.str.length;
        let index = testLetter(text2, totalLength);
        index -= length3, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i2]), {
        text: clipedData.str,
        width: clipedData.width
      })), length2 += clipedData.width;
    }
    return {
      verticalList: out,
      width: length2
    };
  }
  clipText(text2, options, width, wordBreak) {
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    let length2 = this.measureTextWidth(text2, options);
    if (length2 <= width) return {
      str: text2,
      width: length2
    };
    if (length2 = this.measureTextWidth(text2[0], options), length2 > width) return {
      str: "",
      width: 0
    };
    const data = this._clipText(text2, options, width, 0, text2.length - 1, "end", false);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.str = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text2, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position) data = this._clipTextStart(text2, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);
    else if ("middle" === position) {
      const d2 = this._clipTextMiddle(text2, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d2.width,
        result: d2.left + suffix + d2.right
      };
    } else data = this._clipTextEnd(text2, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text2.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text2.substring(0, middleIdx);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextEnd(text2, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text2.length - 1) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str = text2.substring(0, middleIdx + 2);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text2, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2), subText = text2.substring(middleIdx - 1, text2.length - 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text2.substring(middleIdx, text2.length - 1);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextStart(text2, options, width, middleIdx, text2.length - 1);
    }
    if (strWidth < width) {
      if (middleIdx <= 0) return {
        str: text2,
        width: this.measureTextWidth(text2, options)
      };
      const str = text2.substring(middleIdx - 2, text2.length - 1);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text2, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text2, options, width, left2, right2, leftW, rightW, buffer2) {
    const subLeftText = text2.substring(0, buffer2), strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width) return {
      left: left2,
      right: right2,
      width: leftW + rightW
    };
    const subRightText = text2.substring(text2.length - buffer2, text2.length), strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right: right2,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text2, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer2 + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length) return {
      verticalList,
      width: 0
    };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v2 = this.revertVerticalList(out.verticalList);
      v2.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v2;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak), nextVerticalList = this.revertVerticalList(verticalList), rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach((v2) => leftOut.verticalList.push(v2)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
      text: suffix,
      direction: 1,
      width: suffixWidth
    });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map((l2) => {
      const t2 = l2.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l2), {
        text: t2
      });
    });
  }
  clipTextWithSuffix(text2, options, width, suffix, wordBreak, position) {
    if ("" === suffix) return this.clipText(text2, options, width, wordBreak);
    if (0 === text2.length) return {
      str: "",
      width: 0
    };
    const length2 = this.measureTextWidth(text2, options);
    if (length2 <= width) return {
      str: text2,
      width: length2
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    width -= suffixWidth;
    const data = this._clipText(text2, options, width, 0, text2.length - 1, position, suffix);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.str = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate2([injectable()], ATextMeasure);

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/textMeasure-contribution.js
var __decorate3 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var TextMeasureContribution = Symbol.for("TextMeasureContribution");
var DefaultTextMeasureContribution = class extends ATextMeasure {
};
DefaultTextMeasureContribution = __decorate3([injectable()], DefaultTextMeasureContribution);

// node_modules/@visactor/vrender-core/es/container.js
var container = new Container();

// node_modules/@visactor/vrender-core/es/canvas/constants.js
var CanvasFactory = Symbol.for("CanvasFactory");
var Context2dFactory = Symbol.for("Context2dFactory");

// node_modules/@visactor/vrender-core/es/canvas/util.js
function wrapCanvas(params2) {
  return container.getNamed(CanvasFactory, application.global.env)(params2);
}
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = Math.sqrt(3);
var ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON2 && val < EPSILON2;
}
function isNotAroundZero(val) {
  return val > EPSILON2 || val < -EPSILON2;
}
function isNumber3(data) {
  return "number" == typeof data && Number.isFinite(data);
}
var _v0 = [0, 0];
var _v1 = [0, 0];
var _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t2) {
  const onet = 1 - t2;
  return onet * (onet * p0 + 2 * t2 * p1) + t2 * t2 * p2;
}
function cubicAt(p0, p1, p2, p3, t2) {
  const onet = 1 - t2;
  return onet * onet * (onet * p0 + 3 * t2 * p1) + t2 * t2 * (t2 * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a4 = p0 - 2 * p1 + p2, b2 = 2 * (p1 - p0), c4 = p0 - val;
  let n2 = 0;
  if (isAroundZero(a4)) {
    if (isNotAroundZero(b2)) {
      const t1 = -c4 / b2;
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1);
    }
  } else {
    const disc = b2 * b2 - 4 * a4 * c4;
    if (isAroundZero(disc)) {
      const t1 = -b2 / (2 * a4);
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b2 + discSqrt) / (2 * a4), t2 = (-b2 - discSqrt) / (2 * a4);
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n2++] = t2);
    }
  }
  return n2;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? 0.5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, out) {
  let t2 = 0, interval = 5e-3, d2 = 1 / 0;
  _v0[0] = x3, _v0[1] = y3;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x05, x14, x23, _t), _v1[1] = quadraticAt(y05, y14, y23, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d2 && (t2 = _t, d2 = d1);
  }
  d2 = 1 / 0;
  for (let i2 = 0; i2 < 32 && !(interval < EPSILON_NUMERIC); i2++) {
    const prev = t2 - interval, next = t2 + interval;
    _v1[0] = quadraticAt(x05, x14, x23, prev), _v1[1] = quadraticAt(y05, y14, y23, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d2) t2 = prev, d2 = d1;
    else {
      _v2[0] = quadraticAt(x05, x14, x23, next), _v2[1] = quadraticAt(y05, y14, y23, next);
      const d22 = distanceSquare(_v2, _v0);
      next <= 1 && d22 < d2 ? (t2 = next, d2 = d22) : interval *= 0.5;
    }
  }
  return out && (out[0] = quadraticAt(x05, x14, x23, t2), out[1] = quadraticAt(y05, y14, y23, t2)), Math.sqrt(d2);
}
function cubicProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, x4, y4, out) {
  let prev, next, d1, d2, t2 = 0, interval = 5e-3, d3 = 1 / 0;
  _v0[0] = x4, _v0[1] = y4;
  for (let _t = 0; _t < 1; _t += 0.05) _v1[0] = cubicAt(x05, x14, x23, x3, _t), _v1[1] = cubicAt(y05, y14, y23, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d3 && (t2 = _t, d3 = d1);
  d3 = 1 / 0;
  for (let i2 = 0; i2 < 32 && !(interval < EPSILON_NUMERIC); i2++) prev = t2 - interval, next = t2 + interval, _v1[0] = cubicAt(x05, x14, x23, x3, prev), _v1[1] = cubicAt(y05, y14, y23, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d3 ? (t2 = prev, d3 = d1) : (_v2[0] = cubicAt(x05, x14, x23, x3, next), _v2[1] = cubicAt(y05, y14, y23, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d3 ? (t2 = next, d3 = d2) : interval *= 0.5);
  return out && (out[0] = cubicAt(x05, x14, x23, x3, t2), out[1] = cubicAt(y05, y14, y23, y3, t2)), Math.sqrt(d3);
}
function normalizeRadian(angle2) {
  return (angle2 %= pi2) < 0 && (angle2 += pi2), angle2;
}
function windingLine(x05, y05, x14, y14, x3, y3) {
  if (y3 > y05 && y3 > y14 || y3 < y05 && y3 < y14) return 0;
  if (y14 === y05) return 0;
  const t2 = (y3 - y05) / (y14 - y05);
  let dir = y14 < y05 ? 1 : -1;
  1 !== t2 && 0 !== t2 || (dir = y14 < y05 ? 0.5 : -0.5);
  const x_ = t2 * (x14 - x05) + x05;
  return x_ === x3 ? 1 / 0 : x_ > x3 ? dir : 0;
}
function containQuadStroke(x05, y05, x14, y14, x23, y23, lineWidth, x3, y3) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y3 > y05 + _l && y3 > y14 + _l && y3 > y23 + _l || y3 < y05 - _l && y3 < y14 - _l && y3 < y23 - _l || x3 > x05 + _l && x3 > x14 + _l && x3 > x23 + _l || x3 < x05 - _l && x3 < x14 - _l && x3 < x23 - _l) return false;
  return quadraticProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, null) <= _l / 2;
}
function containCubicStroke(x05, y05, x14, y14, x23, y23, x3, y3, lineWidth, x4, y4) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  if (y4 > y05 + _l && y4 > y14 + _l && y4 > y23 + _l && y4 > y3 + _l || y4 < y05 - _l && y4 < y14 - _l && y4 < y23 - _l && y4 < y3 - _l || x4 > x05 + _l && x4 > x14 + _l && x4 > x23 + _l && x4 > x3 + _l || x4 < x05 - _l && x4 < x14 - _l && x4 < x23 - _l && x4 < x3 - _l) return false;
  return cubicProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, x4, y4, null) <= _l / 2;
}
function containArcStroke(cx, cy, r2, startAngle, endAngle, anticlockwise, lineWidth, x3, y3) {
  if (0 === lineWidth) return false;
  const _l = lineWidth;
  x3 -= cx, y3 -= cy;
  const d2 = Math.sqrt(x3 * x3 + y3 * y3);
  if (d2 - _l > r2 || d2 + _l < r2) return false;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return true;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle2 = Math.atan2(y3, x3);
  return angle2 < 0 && (angle2 += pi2), angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle;
}
function containLineStroke(x05, y05, x14, y14, lineWidth, x3, y3) {
  if (0 === lineWidth) return false;
  const _l = lineWidth, _halfL = lineWidth / 2;
  let _a = 0, _b = x05;
  if (y3 > y05 + _halfL && y3 > y14 + _halfL || y3 < y05 - _halfL && y3 < y14 - _halfL || x3 > x05 + _halfL && x3 > x14 + _halfL || x3 < x05 - _halfL && x3 < x14 - _halfL) return false;
  if (x05 === x14) return Math.abs(x3 - x05) <= _l / 2;
  _a = (y05 - y14) / (x05 - x14), _b = (x05 * y14 - x14 * y05) / (x05 - x14);
  const tmp = _a * x3 - y3 + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
var EPSILON2 = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a4 = p3 + 3 * (p1 - p2) - p0, b2 = 3 * (p2 - 2 * p1 + p0), c4 = 3 * (p1 - p0), d2 = p0 - val, A5 = b2 * b2 - 3 * a4 * c4, B2 = b2 * c4 - 9 * a4 * d2, C2 = c4 * c4 - 3 * b2 * d2;
  let n2 = 0;
  if (isAroundZero(A5) && isAroundZero(B2)) if (isAroundZero(b2)) roots2[0] = 0;
  else {
    const t1 = -c4 / b2;
    t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1);
  }
  else {
    const disc = B2 * B2 - 4 * A5 * C2;
    if (isAroundZero(disc)) {
      const K2 = B2 / A5, t1 = -b2 / a4 + K2, t2 = -K2 / 2;
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n2++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y12 = A5 * b2 + 1.5 * a4 * (-B2 + discSqrt), Y22 = A5 * b2 + 1.5 * a4 * (-B2 - discSqrt);
      Y12 = Y12 < 0 ? -Math.pow(-Y12, ONE_THIRD) : Math.pow(Y12, ONE_THIRD), Y22 = Y22 < 0 ? -Math.pow(-Y22, ONE_THIRD) : Math.pow(Y22, ONE_THIRD);
      const t1 = (-b2 - (Y12 + Y22)) / (3 * a4);
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1);
    } else {
      const T2 = (2 * A5 * b2 - 3 * a4 * B2) / (2 * Math.sqrt(A5 * A5 * A5)), theta = Math.acos(T2) / 3, ASqrt = Math.sqrt(A5), tmp = Math.cos(theta), t1 = (-b2 - 2 * ASqrt * tmp) / (3 * a4), t2 = (-b2 + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a4), t3 = (-b2 + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a4);
      t1 >= 0 && t1 <= 1 && (roots2[n2++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n2++] = t2), t3 >= 0 && t3 <= 1 && (roots2[n2++] = t3);
    }
  }
  return n2;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b2 = 6 * p2 - 12 * p1 + 6 * p0, a4 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c4 = 3 * p1 - 3 * p0;
  let n2 = 0;
  if (isAroundZero(a4)) {
    if (isNotAroundZero(b2)) {
      const t1 = -c4 / b2;
      t1 >= 0 && t1 <= 1 && (extrema2[n2++] = t1);
    }
  } else {
    const disc = b2 * b2 - 4 * a4 * c4;
    if (isAroundZero(disc)) extrema2[0] = -b2 / (2 * a4);
    else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b2 + discSqrt) / (2 * a4), t2 = (-b2 - discSqrt) / (2 * a4);
      t1 >= 0 && t1 <= 1 && (extrema2[n2++] = t1), t2 >= 0 && t2 <= 1 && (extrema2[n2++] = t2);
    }
  }
  return n2;
}
function isAroundEqual2(a4, b2) {
  return Math.abs(a4 - b2) < EPSILON2;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x05, y05, x14, y14, x23, y23, x3, y3, x4, y4) {
  if (y4 > y05 && y4 > y14 && y4 > y23 && y4 > y3 || y4 < y05 && y4 < y14 && y4 < y23 && y4 < y3) return 0;
  const nRoots = cubicRootAt(y05, y14, y23, y3, y4, roots);
  if (0 === nRoots) return 0;
  let w2 = 0, nExtrema = -1, y0_ = 0, y1_ = 0;
  for (let i2 = 0; i2 < nRoots; i2++) {
    const t2 = roots[i2], unit = 0 === t2 || 1 === t2 ? 0.5 : 1;
    cubicAt(x05, x14, x23, x3, t2) < x4 || (nExtrema < 0 && (nExtrema = cubicExtrema(y05, y14, y23, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y05, y14, y23, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y05, y14, y23, y3, extrema[1]))), 2 === nExtrema ? t2 < extrema[0] ? w2 += y0_ < y05 ? unit : -unit : t2 < extrema[1] ? w2 += y1_ < y0_ ? unit : -unit : w2 += y3 < y1_ ? unit : -unit : t2 < extrema[0] ? w2 += y0_ < y05 ? unit : -unit : w2 += y3 < y0_ ? unit : -unit);
  }
  return w2;
}
function windingQuadratic(x05, y05, x14, y14, x23, y23, x3, y3) {
  if (y3 > y05 && y3 > y14 && y3 > y23 || y3 < y05 && y3 < y14 && y3 < y23) return 0;
  const nRoots = quadraticRootAt(y05, y14, y23, y3, roots);
  if (0 === nRoots) return 0;
  const t2 = quadraticExtremum(y05, y14, y23);
  if (t2 >= 0 && t2 <= 1) {
    let w2 = 0;
    const y_ = quadraticAt(y05, y14, y23, t2);
    for (let i2 = 0; i2 < nRoots; i2++) {
      const unit2 = 0 === roots[i2] || 1 === roots[i2] ? 0.5 : 1;
      quadraticAt(x05, x14, x23, roots[i2]) < x3 || (roots[i2] < t2 ? w2 += y_ < y05 ? unit2 : -unit2 : w2 += y23 < y_ ? unit2 : -unit2);
    }
    return w2;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? 0.5 : 1;
  return quadraticAt(x05, x14, x23, roots[0]) < x3 ? 0 : y23 < y05 ? unit : -unit;
}
function windingArc(cx, cy, r2, startAngle, endAngle, anticlockwise, x3, y3) {
  if ((y3 -= cy) > r2 || y3 < -r2) return 0;
  const tmp = Math.sqrt(r2 * r2 - y3 * y3);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x3 >= roots[0] + cx && x3 <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle, endAngle = tmp2;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w2 = 0;
  for (let i2 = 0; i2 < 2; i2++) {
    const x_ = roots[i2];
    if (x_ + cx > x3) {
      let angle2 = Math.atan2(y3, x_), dir = anticlockwise ? 1 : -1;
      angle2 < 0 && (angle2 = pi2 + angle2), (angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle) && (angle2 > pi / 2 && angle2 < 1.5 * pi && (dir = -dir), w2 += dir);
    }
  }
  return w2;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles2, anticlockwise) {
  let newStartAngle = modpi2(angles2[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles2[0];
  let newEndAngle = angles2[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles2[0] = newStartAngle, angles2[1] = newEndAngle;
}
var tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x3, y3) {
  const data = commands, len = commands.length;
  let x14, y14, w2 = 0, xi = 0, yi = 0, x05 = 0, y05 = 0;
  for (let i2 = 0; i2 < len; i2++) {
    const command = data[i2], isFirst = 0 === i2;
    command[0] === enumCommandMap.M && i2 > 1 && (isStroke || (w2 += windingLine(xi, yi, x05, y05, x3, y3))), isFirst && (xi = command[1], yi = command[2], x05 = xi, y05 = yi);
    const c0 = command[0], c1 = command[1], c22 = command[2], c32 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];
    let startAngle = c4, endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x3 - c1) * c32 / c32 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x05 = c1, y05 = c22, xi = x05, yi = y05;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c22, lineWidth, x3, y3)) return true;
        } else w2 += windingLine(xi, yi, c1, c22, x3, y3) || 0;
        xi = c1, yi = c22;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c22, c32, c4, c5, c6, lineWidth, x3, y3)) return true;
        } else w2 += windingCubic(xi, yi, c1, c22, c32, c4, c5, c6, x3, y3) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c22, c32, c4, lineWidth, x3, y3)) return true;
        } else w2 += windingQuadratic(xi, yi, c1, c22, c32, c4, x3, y3) || 0;
        xi = c32, yi = c4;
        break;
      case enumCommandMap.A:
        if (x14 = Math.cos(theta) * c32 + c1, y14 = Math.sin(theta) * c32 + c22, isFirst ? (x05 = x14, y05 = y14) : w2 += windingLine(xi, yi, x14, y14, x3, y3), isStroke) {
          if (containArcStroke(c1, c22, c32, theta, theta + dTheta, anticlockwise, lineWidth, _x, y3)) return true;
        } else w2 += windingArc(c1, c22, c32, theta, theta + dTheta, anticlockwise, _x, y3);
        xi = Math.cos(theta + dTheta) * c32 + c1, yi = Math.sin(theta + dTheta) * c32 + c22;
        break;
      case enumCommandMap.R:
        if (x05 = xi = c1, y05 = yi = c22, x14 = x05 + c32, y14 = y05 + c4, isStroke) {
          if (containLineStroke(x05, y05, x14, y05, lineWidth, x3, y3) || containLineStroke(x14, y05, x14, y14, lineWidth, x3, y3) || containLineStroke(x14, y14, x05, y14, lineWidth, x3, y3) || containLineStroke(x05, y14, x05, y05, lineWidth, x3, y3)) return true;
        } else w2 += windingLine(x14, y05, x14, y14, x3, y3), w2 += windingLine(x05, y14, x05, y05, x3, y3);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x05, y05, lineWidth, x3, y3)) return true;
        } else w2 += windingLine(xi, yi, x05, y05, x3, y3);
        xi = x05, yi = y05;
    }
  }
  return isStroke || isAroundEqual2(yi, y05) || (w2 += windingLine(xi, yi, x05, y05, x3, y3) || 0), 0 !== w2;
}
function contain(commands, x3, y3) {
  return containPath(commands, 0, false, x3, y3);
}
function containStroke(commands, lineWidth, x3, y3) {
  return containPath(commands, lineWidth, true, x3, y3);
}

// node_modules/@visactor/vrender-core/es/allocator/canvas-allocate.js
var DefaultCanvasAllocate = class {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c4 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c4), c4;
    }
    const m5 = this.pools.pop();
    return m5.resize(data.width, data.height), m5.dpr = data.dpr, m5;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
        width: canvas.width / canvas.dpr,
        height: canvas.height / canvas.dpr,
        dpr: canvas.dpr
      }, c4 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c4), c4;
    }
    const m5 = this.pools.pop();
    return m5.width = canvas.width, m5.height = canvas.height, m5;
  }
  free(d2) {
    this.pools.push(d2);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var canvasAllocate = new DefaultCanvasAllocate();

// node_modules/@visactor/vrender-core/es/core/window.js
var __decorate4 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata2 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var VWindow = Symbol.for("VWindow");
var WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
var DefaultWindow = class {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", () => {
      this.active();
    }), this.active();
  }
  active() {
    const global = this.global;
    if (!global.env || this.actived) return;
    container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = true;
  }
  get style() {
    return this._handler.getStyle();
  }
  set style(style) {
    this._handler.setStyle(style);
  }
  create(params2) {
    this._handler.createWindow(params2);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, this.title = this._handler.getTitle(), this.resizable = true;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w2, h2) {
    return this._handler.resizeWindow(w2, h2);
  }
  configure() {
    throw new Error("暂不支持");
  }
  release() {
    return this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  addEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._handler.dispatchEvent(event);
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(viewBox, color) {
    this._handler.clearViewBox(viewBox, color);
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate4([injectable(), __metadata2("design:paramtypes", [])], DefaultWindow);

// node_modules/@visactor/vrender-core/es/core/graphic-utils.js
var __decorate5 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata3 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = false, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
      this.configured = false, this.configure(global, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global, env) {
    this.configured || (this.contributions.getContributions().forEach((contribution) => {
      contribution.configure(this, env);
    }), this.configured = true);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text2, tc, method = "native") {
    var _a;
    this.configure(this.global, this.global.env);
    const m5 = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text2, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m5, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer) return null;
    const window2 = container.get(VWindow), bounds = graphic.AABBBounds, width = bounds.width(), height = bounds.height();
    window2.create({
      width,
      height,
      canvas,
      dpr: stage.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    });
    const x3 = -bounds.x1, y3 = -bounds.y1, disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = true, stage.defaultLayer.getNativeHandler().drawTo(window2, [graphic], {
      x: x3,
      y: y3,
      width,
      height,
      stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: true,
      updateBounds: false
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c4 = window2.getNativeHandler();
    return c4.nativeCanvas ? c4.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate5([injectable(), __param2(0, inject(ContributionProvider)), __param2(0, named(TextMeasureContribution)), __metadata3("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function(TransformMode2) {
  TransformMode2[TransformMode2.transform = 0] = "transform", TransformMode2[TransformMode2.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
var _matrix = new Matrix();
var DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x: x3, y: y3 } = center2;
      this.outTargetMatrix.translate(x3, y3), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x3, -y3);
    } else this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle2, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x: x3, y: y3 } = center2;
      this.outTargetMatrix.translate(x3, y3), this.outTargetMatrix.rotate(angle2), this.outTargetMatrix.translate(-x3, -y3);
    } else this.outTargetMatrix.rotate(angle2);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center2) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center2) : this;
  }
  rotate(angle2, center2) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle2, center2) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate5([injectable(), __metadata3("design:paramtypes", [])], DefaultTransformUtil);

// node_modules/@visactor/vrender-core/es/graphic/theme.js
var defaultThemeObj = {
  arc: DefaultArcAttribute,
  area: DefaultAreaAttribute,
  circle: DefaultCircleAttribute,
  line: DefaultLineAttribute,
  path: DefaultPathAttribute,
  symbol: DefaultSymbolAttribute,
  text: DefaultTextAttribute,
  rect: DefaultRectAttribute,
  rect3d: DefaultRect3dAttribute,
  polygon: DefaultPolygonAttribute,
  richtext: DefaultRichTextAttribute,
  richtextIcon: DefaultRichTextIconAttribute,
  image: DefaultImageAttribute,
  group: DefaultGroupAttribute,
  glyph: DefaultGlyphAttribute
};
var themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    rect3d: Object.assign({}, defaultThemeObj.rect3d),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t2) {
  Object.keys(t2).forEach((k3) => {
    out[k3] = t2[k3];
  });
}
var globalThemeObj = newThemeObj();
var Theme = class {
  constructor() {
    this.initTheme(), this.dirty = false;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach((key) => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent; ) if ((group = group.parent).theme) return group;
    return null;
  }
  applyTheme(group, pt, force = false) {
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, true);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = false);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme, combinedTheme = this.combinedTheme;
    themeKeys.forEach((k3) => {
      const obj = Object.create(globalThemeObj[k3]);
      parentCombinedTheme && parentCombinedTheme[k3] && combine(obj, parentCombinedTheme[k3]), combinedTheme[k3] && combine(obj, combinedTheme[k3]), userTheme[k3] && combine(obj, userTheme[k3]), this.combinedTheme[k3] = obj;
    }), userTheme.common && themeKeys.forEach((k3) => {
      combine(this.combinedTheme[k3], userTheme.common);
    }), this.dirty = false;
  }
  setTheme(t2, g3) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t2).forEach((k3) => {
      userTheme[k3] ? Object.assign(userTheme[k3], t2[k3]) : userTheme[k3] = Object.assign({}, t2[k3]);
    }) : userTheme = t2, this.userTheme = userTheme, this.dirty = true, this.dirtyChildren(g3);
  }
  resetTheme(t2, g3) {
    this.userTheme = t2, this.dirty = true, this.dirtyChildren(g3);
  }
  dirtyChildren(g3) {
    g3.forEachChildren((item) => {
      item.isContainer && (item.theme && (item.theme.dirty = true), this.dirtyChildren(item));
    });
  }
};
var globalTheme = new Theme();
function getTheme(graphic, theme2) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme2 ? (graphic.isContainer, theme2) : getThemeFromGroup(graphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g3;
  if (g3 = graphic.isContainer ? graphic : graphic.parent, g3) {
    for (; g3 && !g3.theme; ) g3 = g3.parent;
    return g3 ? (g3.theme || g3.createTheme(), g3.theme.getTheme(g3)) : globalTheme.getTheme();
  }
  return null;
}

// node_modules/@visactor/vrender-core/es/graphic/node-tree.js
var __awaiter = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Node = class extends import_eventemitter3.default {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb, reverse2 = false) {
    if (reverse2) {
      let child = this._lastChild, i2 = 0;
      for (; child; ) {
        if (cb(child, i2++)) return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild, i2 = 0;
      for (; child; ) {
        if (cb(child, i2++)) return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb, reverse2 = false) {
    return __awaiter(this, void 0, void 0, function* () {
      if (reverse2) {
        let child = this._lastChild, i2 = 0;
        for (; child; ) {
          let breakTag = cb(child, i2++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild, i2 = 0;
        for (; child; ) {
          let breakTag = cb(child, i2++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node, highPerformance = true) {
    if (this._uid === node._uid) return null;
    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = true, node;
  }
  appendChildArrHighPerformance(nodes, replace = false) {
    return console.error("暂不支持该函数"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this._uid === newNode._uid) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this._uid === newNode._uid) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
    if (this._uid === newNode._uid) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;
    else {
      let child = this._firstChild;
      for (let i2 = 0; i2 < idx; i2++) {
        if (!child) return null;
        i2 > 0 && (child = child._next);
      }
      if (!child) return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
      const node2 = this._nodeList[idx];
      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node2);
    }
    let node;
    this._nodeList[idx] = newNode;
    for (let i2 = idx - 1; i2 >= 0 && (node = this._nodeList[i2], !node); i2--) ;
    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = true;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = false, data;
  }
  removeChild(child) {
    if (!this._idMap) return null;
    if (!this._idMap.has(child._uid)) return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx = this._nodeList.findIndex((n2) => n2 === child);
      idx > 0 && this._nodeList.splice(idx, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = true, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild() {
    if (!this._idMap) return;
    let child = this._firstChild;
    for (; child; ) child.parent = null, child._prev = null, child._next = null, child = child._next;
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = true, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("暂不支持");
  }
  find(callback, deep = false) {
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, true)), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const node = child.find(callback, true);
        if (node) return target = node, true;
      }
      return false;
    }), target;
  }
  findAll(callback, deep = false) {
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const targets = child.findAll(callback, true);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id2) {
    return this.find((node) => node.id === id2, true);
  }
  findChildById(id2) {
    return this.getElementById(id2);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll((node) => node.name === name, true);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll((node) => node.type === type, true);
  }
  getChildByName(name, deep = false) {
    return this.find((node) => node.name === name, deep);
  }
  getChildAt(idx) {
    let c4 = this._firstChild;
    if (!c4) return null;
    for (let i2 = 0; i2 < idx; i2++) {
      if (!c4._next) return null;
      c4 = c4._next;
    }
    return c4;
  }
  at(idx) {
    return this.getChildAt(idx);
  }
  containNode(node) {
    if (!this._idMap) return false;
    if (this._idMap.has(node._uid)) return true;
    let child = this._firstChild;
    for (; child; ) {
      if (child.containNode(node)) return true;
      child = child._next;
    }
    return false;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent; ) parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child; ) nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent) return false;
    do {
      if (parent._uid === node._uid) return true;
      parent = parent.parent;
    } while (null !== parent);
    return false;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx) {
    throw new Error("暂不支持");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent) do {
      parent._count += deltaCount, parent = parent.parent;
    } while (null !== parent);
  }
  clone() {
    throw new Error("暂不支持");
  }
  cloneTo(node) {
    throw new Error("暂不支持");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, once = isObject_default(options) && options.once, context = isFunction_default(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, context = isFunction_default(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent;
    const once = isObject_default(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject_default(options) ? (options.once = true, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: true
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event, ...args) {
    return super.emit(event.type, event, ...args), !event.defaultPrevented;
  }
  emit(event, data) {
    return this.dispatchEvent(event, data);
  }
  release() {
    this.removeAllListeners();
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/base-event.js
var FederatedEvent = class _FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = _FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
  }
  preventDefault() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation(), this.propagationStopped = true;
  }
  initEvent() {
  }
  initUIEvent() {
  }
  clone() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/mouse-event.js
var FederatedMouseEvent = class extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = {
      x: 0,
      y: 0
    }, this.movement = {
      x: 0,
      y: 0
    }, this.offset = {
      x: 0,
      y: 0
    }, this.global = {
      x: 0,
      y: 0
    }, this.screen = {
      x: 0,
      y: 0
    };
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/pointer-event.js
var FederatedPointerEvent = class _FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
  }
  getCoalescedEvents() {
    return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedPointerEvent(this.manager);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice(), event.type = this.type, event;
  }
};

// node_modules/@visactor/vrender-core/es/event/federated-event/wheel-event.js
var FederatedWheelEvent = class _FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedWheelEvent(this.manager);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice(), event.type = this.type, event;
  }
};
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

// node_modules/@visactor/vrender-core/es/event/federated-event/custom-event.js
var CustomEvent = class extends FederatedEvent {
  constructor(eventName, object2) {
    super(), this.type = eventName, this.detail = object2;
  }
};

// node_modules/@visactor/vrender-core/es/event/constant.js
var WILDCARD = "*";

// node_modules/@visactor/vrender-core/es/event/util.js
var clock = "object" == typeof performance && performance.now ? performance : Date;

// node_modules/@visactor/vrender-core/es/event/event-manager.js
function isMouseLike(pointerType) {
  return "mouse" === pointerType || "pen" === pointerType;
}
var EventManager = class {
  constructor(root, config2) {
    this.dispatch = new import_eventemitter3.default(), this.cursorTarget = null, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this.onPointerDown = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e3 = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e3, "pointerdown"), "touch" === e3.pointerType) this.dispatchEvent(e3, "touchstart");
      else if (isMouseLike(e3.pointerType)) {
        const isRightButton = 2 === e3.button;
        this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
      }
      this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e3.composedPath(), this.freeEvent(e3);
    }, this.onPointerMove = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e3 = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e3.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e3.target) {
        const outType = "mousemove" === from.type ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
        if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e3.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e3.composedPath().includes(leaveEvent.target); ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e3.target) {
        const overType = "mousemove" === from.type ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e3, overType);
        this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
        for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e3.target; ) overTargetAncestor = overTargetAncestor.parent;
        if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
          const enterEvent = this.clonePointerEvent(e3, "pointerenter");
          for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      this.dispatchEvent(e3, "pointermove"), "touch" === e3.pointerType && this.dispatchEvent(e3, "touchmove"), isMouse && (this.dispatchEvent(e3, "mousemove"), this.cursorTarget = e3.target, this.cursor = (null === (_b = null === (_a = e3.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e3.composedPath(), this.freeEvent(e3);
    }, this.onPointerOver = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), e3 = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e3.pointerType);
      this.dispatchEvent(e3, "pointerover"), isMouse && this.dispatchEvent(e3, "mouseover"), "mouse" === e3.pointerType && (this.cursorTarget = e3.target, this.cursor = (null === (_b = null === (_a = e3.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
      const enterEvent = this.clonePointerEvent(e3, "pointerenter");
      for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
      trackingData.overTargets = e3.composedPath(), this.freeEvent(e3), this.freeEvent(enterEvent);
    }, this.onPointerOut = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
        this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; ) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
      }
      this.cursorTarget = null, this.cursor = "";
    }, this.onPointerUp = (from, target) => {
      var _a;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const now = clock.now(), e3 = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e3, "pointerup"), "touch" === e3.pointerType) this.dispatchEvent(e3, "touchend");
      else if (isMouseLike(e3.pointerType)) {
        const isRightButton = 2 === e3.button;
        this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e3.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        for (; currentTarget && !e3.composedPath().includes(currentTarget); ) {
          if (e3.currentTarget = currentTarget, this.notifyTarget(e3, "pointerupoutside"), "touch" === e3.pointerType) this.notifyTarget(e3, "touchendoutside");
          else if (isMouseLike(e3.pointerType)) {
            const isRightButton = 2 === e3.button;
            this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e3, "click");
        clickEvent.target = clickTarget, clickEvent.path = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        });
        const clickHistory = trackingData.clicksByButton[from.button];
        clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
      }
      this.freeEvent(e3);
    }, this.onPointerUpOutside = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e3 = this.createPointerEvent(from, from.type, target);
      if (pressTarget) {
        let currentTarget = pressTarget;
        for (; currentTarget; ) e3.currentTarget = currentTarget, this.notifyTarget(e3, "pointerupoutside"), "touch" === e3.pointerType ? this.notifyTarget(e3, "touchendoutside") : isMouseLike(e3.pointerType) && this.notifyTarget(e3, 2 === e3.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e3);
    }, this.onWheel = (from, target) => {
      if (!(from instanceof FederatedWheelEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
      const wheelEvent = this.createWheelEvent(from, target);
      this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
    }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
      clickInterval: 200
    }, config2), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
  }
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn,
      priority: 0
    }), this.mappingTable[type].sort((a4, b2) => a4.priority - b2.priority);
  }
  dispatchEvent(e3, type) {
    e3.propagationStopped = false, e3.propagationImmediatelyStopped = false, this.propagate(e3, type), this.dispatch.emit(type || e3.type, e3);
  }
  mapEvent(e3) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.rootTarget) return;
    const mappers = this.mappingTable[e3.type];
    let target;
    const cacheKey = `${e3.canvasX}-${e3.canvasY}`;
    if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e3.canvasX, e3.canvasY, e3), e3.pickParams || (this._prePointTargetCache = {
      [cacheKey]: target,
      stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
    })), mappers) for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) mappers[i2].fn(e3, target);
    else Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e3.type}`);
  }
  propagate(e3, type) {
    if (!e3.target) return;
    const composedPath = e3.composedPath();
    e3.eventPhase = e3.CAPTURING_PHASE;
    for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) if (e3.currentTarget = composedPath[i2], this.notifyTarget(e3, type), e3.propagationStopped || e3.propagationImmediatelyStopped) return;
    if (e3.eventPhase = e3.AT_TARGET, e3.currentTarget = e3.target, this.notifyTarget(e3, type), !e3.propagationStopped && !e3.propagationImmediatelyStopped) {
      e3.eventPhase = e3.BUBBLING_PHASE;
      for (let i2 = composedPath.length - 2; i2 >= 0; i2--) if (e3.currentTarget = composedPath[i2], this.notifyTarget(e3, type), e3.propagationStopped || e3.propagationImmediatelyStopped) return;
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i2 = 0; i2 < 2048 && target !== this.rootTarget && target.parent; i2++) {
      if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  notifyTarget(e3, type) {
    type = null != type ? type : e3.type;
    const key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e3, key), e3.eventPhase === e3.AT_TARGET && this.notifyListeners(e3, type);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) return null;
    let currentTarget = propagationPath[0];
    for (let i2 = 1; i2 < propagationPath.length && propagationPath[i2].parent === currentTarget; i2++) currentTarget = propagationPath[i2];
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y, event), "string" == typeof type && (event.type = type), event;
  }
  createWheelEvent(from, target) {
    const event = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y, event), event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = null != type ? type : event.type, event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach((key) => {
      to[key].x = from[key].x, to[key].y = from[key].y;
    }));
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
  }
  trackingData(id2) {
    return this.mappingState.trackingData[id2] || (this.mappingState.trackingData[id2] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id2];
  }
  allocateEvent(constructor) {
    var _a;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event;
  }
  freeEvent(event) {
    var _a;
    if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
  }
  notifyListeners(e3, type) {
    const listeners = e3.currentTarget._events[type];
    if (listeners) if ("fn" in listeners) listeners.once && e3.currentTarget.removeEventListener(type, listeners.fn, {
      once: true
    }), listeners.fn.call(listeners.context, e3);
    else for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e3.propagationImmediatelyStopped; i2++) listeners[i2].once && e3.currentTarget.removeEventListener(type, listeners[i2].fn, {
      once: true
    }), listeners[i2].fn.call(listeners[i2].context, e3);
    this.emitDelegation(e3, type);
  }
  emitDelegation(e3, type) {
    const listeners = e3.currentTarget._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e3, type);
    else for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e3.propagationImmediatelyStopped; i2++) listeners[i2].fn.call(listeners[i2].context, e3, type);
  }
  pickTarget(x3, y3, e3) {
    let target;
    const pickResult = this.rootTarget.pick(x3, y3);
    return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x3, y3) ? this.rootTarget : null, e3 && (e3.pickParams = pickResult.params), target;
  }
};

// node_modules/@visactor/vrender-core/es/event/event-target.js
var EventTarget = {
  pickable: true,
  visible: true,
  dispatchEvent(e3) {
    var _a;
    if (!(e3 instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e3.defaultPrevented = false, e3.path = [], e3.target = this, null === (_a = null == e3 ? void 0 : e3.manager) || void 0 === _a || _a.dispatchEvent(e3), !e3.defaultPrevented;
  },
  emit(eventName, object2) {
    return this.dispatchEvent(new CustomEvent(eventName, object2));
  }
};

// node_modules/@visactor/vrender-core/es/event/event-system.js
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var EventSystem = class {
  constructor(params2) {
    this.resolution = 1, this.onPointerDown = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
      }
      for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
        const nativeEvent2 = events[i2], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
        this.manager.mapEvent(federatedEvent);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerMove = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerUp = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const outside = this.isEventOutsideOfTargetElement(nativeEvent) ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
        event.type += outside, this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerOverOut = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onWheel = (nativeEvent) => {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.manager.mapEvent(wheelEvent);
    };
    const { targetElement, resolution, rootNode, global, viewport, autoPreventDefault = false, clickInterval, supportsTouchEvents = global.supportsTouchEvents, supportsPointerEvents = global.supportsPointerEvents } = params2;
    this.manager = new EventManager(rootNode, {
      clickInterval
    }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = false, this.viewport = viewport, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.resolution = resolution, this.setTargetElement(targetElement);
  }
  release() {
    this.setTargetElement(null);
  }
  setCursor(mode2, target) {
    if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
    mode2 || (mode2 = "default");
    const { applyStyles, domElement } = this;
    if (this.currentCursor === mode2) return;
    this.currentCursor = mode2;
    const style = this.cursorStyles[mode2];
    style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode2) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString_default(mode2) && !has_default(this.cursorStyles, mode2) && (domElement.style.cursor = mode2);
  }
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, true), globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, true)) : (domElement.addEventListener("pointermove", this.onPointerMove, true), domElement.addEventListener("pointerup", this.onPointerUp, true)), domElement.addEventListener("pointerdown", this.onPointerDown, true), domElement.addEventListener("pointerleave", this.onPointerOverOut, true), domElement.addEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, true), globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, true)) : (domElement.addEventListener("mousemove", this.onPointerMove, true), domElement.addEventListener("mouseup", this.onPointerUp, true)), domElement.addEventListener("mousedown", this.onPointerDown, true), domElement.addEventListener("mouseout", this.onPointerOverOut, true), domElement.addEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, true), domElement.addEventListener("touchend", this.onPointerUp, true), domElement.addEventListener("touchmove", this.onPointerMove, true)), domElement.addEventListener("wheel", this.onWheel, {
      capture: true
    }), this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("pointermove", this.onPointerMove, true), globalObj.getDocument().removeEventListener("pointerup", this.onPointerUp, true)) : (domElement.removeEventListener("pointermove", this.onPointerMove, true), domElement.removeEventListener("pointerup", this.onPointerUp, true)), domElement.removeEventListener("pointerdown", this.onPointerDown, true), domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), domElement.removeEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("mousemove", this.onPointerMove, true), globalObj.getDocument().removeEventListener("mouseup", this.onPointerUp, true)) : (domElement.removeEventListener("mousemove", this.onPointerMove, true), domElement.removeEventListener("mouseup", this.onPointerUp, true)), domElement.removeEventListener("mousedown", this.onPointerDown, true), domElement.removeEventListener("mouseout", this.onPointerOverOut, true), domElement.removeEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, true), domElement.removeEventListener("touchend", this.onPointerUp, true), domElement.removeEventListener("touchmove", this.onPointerMove, true)), domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
  }
  mapToViewportPoint(event) {
    const viewport = this.viewport, { x: x3, y: y3 } = event;
    return {
      x: x3 - viewport.x,
      y: y3 - viewport.y
    };
  }
  mapToCanvasPoint(nativeEvent) {
    var _a;
    const point6 = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
    if (point6) return point6;
    const { clientX: x3, clientY: y3 } = nativeEvent, rect = this.domElement.getBoundingClientRect();
    return {
      x: x3 - rect.left,
      y: y3 - rect.top
    };
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
      const touch = event.changedTouches[i2];
      isUndefined_default(touch.button) && (touch.button = 0), isUndefined_default(touch.buttons) && (touch.buttons = 1), isUndefined_default(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined_default(touch.width) && (touch.width = touch.radiusX || 1), isUndefined_default(touch.height) && (touch.height = touch.radiusY || 1), isUndefined_default(touch.tiltX) && (touch.tiltX = 0), isUndefined_default(touch.tiltY) && (touch.tiltY = 0), isUndefined_default(touch.pointerType) && (touch.pointerType = "touch"), isUndefined_default(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined_default(touch.pressure) && (touch.pressure = touch.force || 0.5), isUndefined_default(touch.twist) && (touch.twist = 0), isUndefined_default(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined_default(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined_default(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = true, touch.type = event.type, normalizedEvents.push(touch);
    }
    else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event);
    else {
      const tempEvent = event;
      isUndefined_default(tempEvent.isPrimary) && (tempEvent.isPrimary = true), isUndefined_default(tempEvent.width) && (tempEvent.width = 1), isUndefined_default(tempEvent.height) && (tempEvent.height = 1), isUndefined_default(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined_default(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined_default(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined_default(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined_default(tempEvent.pressure) && (tempEvent.pressure = 0.5), isUndefined_default(tempEvent.twist) && (tempEvent.twist = 0), isUndefined_default(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
  }
  isEventOutsideOfTargetElement(nativeEvent) {
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
  }
};

// node_modules/@visactor/vrender-core/es/animate/Ticker/default-ticker.js
var ManualTickHandler = class _ManualTickHandler {
  constructor() {
    this.time = 0;
  }
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _ManualTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.time = Math.max(0, interval + this.time), cb(this, {
      once: true
    });
  }
  tickTo(t2, cb) {
    this.time = Math.max(0, t2), cb(this, {
      once: true
    });
  }
  release() {
    this.timerId > 0 && (this.timerId = -1);
  }
  getTime() {
    return this.time;
  }
};
var TimeOutTickHandler = class _TimeOutTickHandler {
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _TimeOutTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.timerId = setTimeout(() => {
      cb(this);
    }, interval);
  }
  release() {
    this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
  }
  getTime() {
    return Date.now();
  }
};
var RAFTickHandler = class _RAFTickHandler {
  static Avaliable() {
    return !!application.global.getRequestAnimationFrame();
  }
  avaliable() {
    return _RAFTickHandler.Avaliable();
  }
  tick(interval, cb) {
    application.global.getRequestAnimationFrame()(() => {
      this.released || cb(this);
    });
  }
  release() {
    this.released = true;
  }
  getTime() {
    return Date.now();
  }
};
var STATUS;
!function(STATUS3) {
  STATUS3[STATUS3.INITIAL = 0] = "INITIAL", STATUS3[STATUS3.RUNNING = 1] = "RUNNING", STATUS3[STATUS3.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));
var DefaultTicker = class {
  set mode(m5) {
    this._mode !== m5 && (this._mode = m5, this.setupTickHandler());
  }
  get mode() {
    return this._mode;
  }
  constructor(timelines = []) {
    this.handleTick = (handler, params2) => {
      const { once = false } = null != params2 ? params2 : {};
      this.ifCanStop() ? this.stop() : (this._handlerTick(handler), once || handler.tick(this.interval, this.handleTick));
    }, this._handlerTick = (handler) => {
      const time = this.tickerHandler.getTime();
      let delta = 0;
      this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t2) => {
        t2.tick(delta);
      }));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = true;
  }
  init() {
    this.interval = NaN, this.status = STATUS.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
      this.initHandler();
    }), application.global.env && this.initHandler();
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter((t2) => t2 !== timeline);
  }
  initHandler() {
    if (this._mode) return null;
    const ticks4 = [{
      mode: "raf",
      cons: RAFTickHandler
    }, {
      mode: "timeout",
      cons: TimeOutTickHandler
    }, {
      mode: "manual",
      cons: ManualTickHandler
    }];
    for (let i2 = 0; i2 < ticks4.length; i2++) if (ticks4[i2].cons.Avaliable()) {
      this.mode = ticks4[i2].mode;
      break;
    }
    return null;
  }
  setupTickHandler() {
    let handler;
    switch (this._mode) {
      case "raf":
        handler = new RAFTickHandler();
        break;
      case "timeout":
        handler = new TimeOutTickHandler();
        break;
      case "manual":
        handler = new ManualTickHandler();
        break;
      default:
        Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
    }
    return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, true);
  }
  setInterval(interval) {
    this.interval = interval;
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(1e3 / fps);
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  tickTo(t2) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t2, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  pause() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, true);
  }
  resume() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, true);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length) return true;
      if (0 === this.timelines.reduce((a4, b2) => a4 + b2.animateCount, 0)) return true;
    }
    return false;
  }
  start(force = false) {
    if (this.status === STATUS.RUNNING) return false;
    if (!this.tickerHandler) return false;
    if (!force) {
      if (this.status === STATUS.PAUSE) return false;
      if (!this.timelines.length) return false;
      if (0 === this.timelines.reduce((a4, b2) => a4 + b2.animateCount, 0)) return false;
    }
    return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), true;
  }
  stop() {
    this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
  }
};

// node_modules/@visactor/vrender-core/es/animate/easing.js
var Easing = class _Easing {
  constructor() {
  }
  static linear(t2) {
    return t2;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t2) {
      return 0 === amount ? t2 : amount < 0 ? t2 * (t2 * -amount + 1 + amount) : t2 * ((2 - t2) * amount + (1 - amount));
    };
  }
  static getPowIn(pow3) {
    return function(t2) {
      return Math.pow(t2, pow3);
    };
  }
  static getPowOut(pow3) {
    return function(t2) {
      return 1 - Math.pow(1 - t2, pow3);
    };
  }
  static getPowInOut(pow3) {
    return function(t2) {
      return (t2 *= 2) < 1 ? 0.5 * Math.pow(t2, pow3) : 1 - 0.5 * Math.abs(Math.pow(2 - t2, pow3));
    };
  }
  static getBackIn(amount) {
    return function(t2) {
      return t2 * t2 * ((amount + 1) * t2 - amount);
    };
  }
  static getBackOut(amount) {
    return function(t2) {
      return --t2 * t2 * ((amount + 1) * t2 + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function(t2) {
      return (t2 *= 2) < 1 ? t2 * t2 * ((amount + 1) * t2 - amount) * 0.5 : 0.5 * ((t2 -= 2) * t2 * ((amount + 1) * t2 + amount) + 2);
    };
  }
  static sineIn(t2) {
    return 1 - Math.cos(t2 * Math.PI / 2);
  }
  static sineOut(t2) {
    return Math.sin(t2 * Math.PI / 2);
  }
  static sineInOut(t2) {
    return -(Math.cos(Math.PI * t2) - 1) / 2;
  }
  static expoIn(t2) {
    return 0 === t2 ? 0 : Math.pow(2, 10 * t2 - 10);
  }
  static expoOut(t2) {
    return 1 === t2 ? 1 : 1 - Math.pow(2, -10 * t2);
  }
  static expoInOut(t2) {
    return 0 === t2 ? 0 : 1 === t2 ? 1 : t2 < 0.5 ? Math.pow(2, 20 * t2 - 10) / 2 : (2 - Math.pow(2, -20 * t2 + 10)) / 2;
  }
  static circIn(t2) {
    return -(Math.sqrt(1 - t2 * t2) - 1);
  }
  static circOut(t2) {
    return Math.sqrt(1 - --t2 * t2);
  }
  static circInOut(t2) {
    return (t2 *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
  }
  static bounceOut(t2) {
    return t2 < 1 / 2.75 ? 7.5625 * t2 * t2 : t2 < 2 / 2.75 ? 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75 : t2 < 2.5 / 2.75 ? 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375 : 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
  }
  static bounceIn(t2) {
    return 1 - _Easing.bounceOut(1 - t2);
  }
  static bounceInOut(t2) {
    return t2 < 0.5 ? 0.5 * _Easing.bounceIn(2 * t2) : 0.5 * _Easing.bounceOut(2 * t2 - 1) + 0.5;
  }
  static getElasticIn(amplitude, period) {
    return function(t2) {
      if (0 === t2 || 1 === t2) return t2;
      const s3 = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s3) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function(t2) {
      if (0 === t2 || 1 === t2) return t2;
      const s3 = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t2) * Math.sin((t2 - s3) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function(t2) {
      const s3 = period / pi2 * Math.asin(1 / amplitude);
      return (t2 *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s3) * pi2 / period) * -0.5 : amplitude * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 - s3) * pi2 / period) * 0.5 + 1;
    };
  }
};
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, 0.3), Easing.elasticOut = Easing.getElasticOut(1, 0.3), Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5);

// node_modules/@visactor/vrender-core/es/animate/timeline.js
var DefaultTimeline = class {
  constructor() {
    this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = false;
  }
  addAnimate(animate) {
    this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  tick(delta) {
    if (this.paused) return;
    let animate = this.animateHead;
    for (this.animateCount = 0; animate; ) animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
  }
  clear() {
    let animate = this.animateHead;
    for (; animate; ) animate.release(), animate = animate.nextAnimate;
    this.animateHead = null, this.animateTail = null, this.animateCount = 0;
  }
  removeAnimate(animate, release = true) {
    animate._onRemove && animate._onRemove.forEach((cb) => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
  }
};
var defaultTimeline = new DefaultTimeline();

// node_modules/@visactor/vrender-core/es/animate/animate.js
var ACustomAnimate = class {
  constructor(from, to, duration, easing, params2) {
    this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params2, this.updateCount = 0;
  }
  bind(target, subAni) {
    this.target = target, this.subAnimate = subAni, this.onBind();
  }
  onBind() {
  }
  onFirstRun() {
  }
  onStart() {
  }
  onEnd() {
  }
  getEndProps() {
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var _a;
    const thisEndProps = this.getEndProps();
    return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
  }
  update(end, ratio, out) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const props = this.step.getLastProps();
      Object.keys(props).forEach((k3) => {
        this.subAnimate.animate.validAttr(k3) && (out[k3] = props[k3]);
      });
    }
    this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
  }
};
var CbAnimate = class extends ACustomAnimate {
  constructor(cb) {
    super(null, null, 0, "linear"), this.cb = cb;
  }
  onUpdate(end, ratio, out) {
  }
  onStart() {
    this.cb();
  }
};
var Animate = class _Animate {
  constructor(id2 = Generator.GenAutoIncrementId(), timeline = defaultTimeline) {
    this.id = id2, this.timeline = timeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this);
  }
  setTimeline(timeline) {
    timeline !== this.timeline && (this.timeline.removeAnimate(this, false), timeline.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((t2, subAnimate) => t2 + subAnimate.totalDuration, 0);
  }
  after(animate) {
    const t2 = animate.getDuration();
    return this._startTime = t2, this;
  }
  afterAll(list) {
    let maxT = -1 / 0;
    return list.forEach((a4) => {
      maxT = max(a4.getDuration(), maxT);
    }), this._startTime = maxT, this;
  }
  parallel(animate) {
    return this._startTime = animate.getStartTime(), this;
  }
  static AddInterpolate(name, cb) {
    _Animate.interpolateMap.set(name, cb);
  }
  play(customAnimate) {
    if (this.tailAnimate.play(customAnimate), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return 1 === this.subAnimates.length && this.tailAnimate.duration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
  }
  trySetAttribute(attr, mode2 = _Animate.mode) {
    attr && mode2 & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, false, {
      type: AttributeUpdateType.ANIMATE_PLAY
    });
  }
  runCb(cb) {
    const customAnimate = new CbAnimate(() => {
      cb(this, customAnimate.step.prev);
    });
    return this.tailAnimate.play(customAnimate), this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    const func = _Animate.interpolateMap.get(key) || _Animate.interpolateMap.get("");
    return !!func && func(key, ratio, from, to, target, ret);
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  to(props, duration, easing, params2) {
    if (this.tailAnimate.to(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  from(props, duration, easing, params2) {
    if (this.tailAnimate.from(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  wait(duration) {
    if (this.tailAnimate.wait(duration), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  startAt(t2) {
    if (this.tailAnimate.startAt(t2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  loop(l2) {
    if (this.tailAnimate.loop = l2, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  reversed(r2) {
    if (this.tailAnimate.reversed = r2, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  bounce(b2) {
    if (this.tailAnimate.bounce = b2, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const sa = new SubAnimate(this, this.tailAnimate);
    return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(key) {
    this._preventAttrs && this._preventAttrs.delete(key);
  }
  preventAttr(key) {
    this._preventAttrs || (this._preventAttrs = /* @__PURE__ */ new Set()), this._preventAttrs.add(key);
  }
  preventAttrs(keys2) {
    keys2.forEach((key) => this.preventAttr(key));
  }
  validAttr(key) {
    return !this._preventAttrs || !this._preventAttrs.has(key);
  }
  bind(target) {
    return this.target = target, this.target.onAnimateBind && this.target.onAnimateBind(this), this.subAnimates.forEach((sa) => {
      sa.bind(target);
    }), this;
  }
  advance(delta) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
      delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
    }
    this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach((cb) => cb()));
    this.setPosition(this.rawPosition + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach((cb) => cb()));
  }
  setPosition(rawPosition) {
    let sa, d2 = 0;
    const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce((a4, b2) => a4 + b2.totalDuration, 0);
    rawPosition < 0 && (rawPosition = 0);
    const end = rawPosition >= maxRawPos;
    if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
    for (let i2 = 0; i2 < this.subAnimates.length && (sa = this.subAnimates[i2], !(d2 + sa.totalDuration >= rawPosition)); i2++) d2 += sa.totalDuration, sa = void 0;
    return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d2), end;
  }
  onStart(cb) {
    this._onStart || (this._onStart = []), this._onStart.push(cb);
  }
  onEnd(cb) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
  }
  onRemove(cb) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
  }
  onFrame(cb) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(nextVal) {
    nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
  }
};
Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = /* @__PURE__ */ new Map();
var SubAnimate = class {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(animate, lastSubAnimate) {
    this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step2(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = true, this._startAt = 0;
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(target) {
    return this.target = target, this;
  }
  play(customAnimate) {
    let duration = customAnimate.duration;
    (null == duration || duration < 0) && (duration = 0);
    const easing = customAnimate.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, false), this._appendCustomAnimate(customAnimate, step), this;
  }
  to(props, duration, easing, params2) {
    (null == duration || duration < 0) && (duration = 0);
    const easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.to, this._appendProps(props, step, !!params2 && params2.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params2 && params2.noPreventAttrs || this.target.animates.forEach((a4) => {
      a4.id !== this.animate.id && a4.preventAttrs(step.propKeys);
    }), this;
  }
  from(props, duration, easing, params2) {
    this.to(props, 0, easing, params2);
    const toProps = {};
    this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach((k3) => {
      toProps[k3] = this.getLastPropByName(k3, this.stepTail);
    }), this.to(toProps, duration, easing, params2), this.stepTail.type = AnimateStepType.from;
  }
  startAt(t2) {
    return t2 < 0 && (t2 = 0), this._startAt = t2, this;
  }
  getStartProps() {
    var _a;
    return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(duration) {
    if (duration > 0) {
      const step = this._addStep(+duration, null);
      step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
    }
    return this;
  }
  _addStep(duration, props, easingFunc) {
    const step = new Step2(this.duration, duration, props, easingFunc);
    return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
  }
  _appendProps(props, step, tempProps) {
    step.props = tempProps ? props : Object.assign({}, props);
    let lastStep = step.prev;
    const _props = step.props;
    for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k3) => {
      void 0 === step.props[k3] && (step.props[k3] = this.target.getDefaultAttribute(k3));
    }); lastStep.prev; ) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach((key) => {
      void 0 === _props[key] && (_props[key] = lastStep.props[key]);
    })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
    const initProps = this.stepHead.props;
    step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key) => {
      if (void 0 === initProps[key]) {
        const parentAnimateInitProps = this.animate.getStartProps();
        initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
      }
    }), this.target.onAddStep && this.target.onAddStep(step);
  }
  _appendCustomAnimate(customAnimate, step) {
    step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
  }
  setPosition(rawPosition) {
    var _a;
    const d2 = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
    let loop, position, end = false;
    const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
    if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, false;
    if (rawPosition -= startAt, d2 <= 0) return end = true, end;
    if (loop = Math.floor(rawPosition / d2), position = rawPosition - loop * d2, end = rawPosition >= loopCount * d2 + d2, end && (position = d2, loop = loopCount, rawPosition = position * loop + d2), rawPosition === prevRawPos) return end;
    const rev = !this.reversed != !(this.bounce && loop % 2);
    return rev && (position = d2 - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
  }
  updatePosition(end, rev) {
    if (!this.stepHead) return;
    let step = this.stepHead.next;
    const position = this.position, duration = this.duration;
    if (this.target && step) {
      let stepNext = step.next;
      for (; stepNext && stepNext.position <= position; ) step = stepNext, stepNext = step.next;
      let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
      step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb) => cb(step, ratio));
    }
  }
  tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
    if (step !== lastStep) if (rev) {
      let _step = lastStep.prev;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    } else {
      let _step = lastStep.next;
      for (; _step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    }
  }
  getLastPropByName(name, step) {
    let lastStep = step.prev;
    for (; lastStep; ) {
      if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
      if (lastStep.customAnimate) {
        const val = lastStep.customAnimate.getEndProps()[name];
        if (void 0 !== val) return val;
      }
      lastStep = lastStep.prev;
    }
    return Logger.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
  }
  updateTarget(step, ratio, end) {
    null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
  }
};
var Step2 = class {
  constructor(position, duration, props, easing) {
    this.duration = duration, this.position = position, this.props = props, this.easing = easing;
  }
  append(step) {
    step.prev = this, step.next = this.next, this.next = step;
  }
  getLastProps() {
    let step = this.prev;
    for (; step; ) {
      if (step.props) return step.props;
      if (step.customAnimate) return step.customAnimate.getMergedEndProps();
      step = step.prev;
    }
    return null;
  }
};

// node_modules/@visactor/vrender-core/es/animate/config.js
var DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};
var DefaultMorphingAnimateConfig = {
  duration: 1e3,
  easing: "quadInOut"
};

// node_modules/@visactor/vrender-core/es/common/utils.js
var Edge;
!function(Edge2) {
  Edge2[Edge2.Top = 1] = "Top", Edge2[Edge2.Right = 2] = "Right", Edge2[Edge2.Bottom = 4] = "Bottom", Edge2[Edge2.Left = 8] = "Left", Edge2[Edge2.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
var _strokeVec4 = [false, false, false, false];
var parseStroke = (stroke2) => {
  var _a;
  let isFullStroke = true;
  if (isBoolean_default(stroke2, true)) {
    for (let i2 = 0; i2 < 4; i2++) _strokeVec4[i2] = stroke2, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i2]) && void 0 !== _a && !_a));
    isFullStroke = stroke2;
  } else if (Array.isArray(stroke2)) for (let i2 = 0; i2 < 4; i2++) _strokeVec4[i2] = !!stroke2[i2], isFullStroke && (isFullStroke = !!_strokeVec4[i2]);
  else _strokeVec4[0] = false, _strokeVec4[1] = false, _strokeVec4[2] = false, _strokeVec4[3] = false;
  return {
    isFullStroke,
    stroke: _strokeVec4
  };
};
var _paddingVec4 = [0, 0, 0, 0];
var parsePadding = (padding) => padding ? isArray_default(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
var _coords = [{
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}];
var indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2; ) startAngle -= pi2;
  for (; startAngle < 0; ) startAngle += pi2;
  for (; startAngle > endAngle; ) endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi) % 4, endIdx = Math.ceil(endAngle / halfPi) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = false;
    for (let i2 = 0; i2 < indexList.length; i2++) if (match || startIdx !== indexList[i2]) {
      if (match && endIdx === indexList[i2]) break;
      if (match) {
        const p2 = _coords[indexList[i2]];
        bounds.add(p2.x, p2.y);
      }
    } else {
      match = true;
      const p2 = _coords[startIdx];
      bounds.add(p2.x, p2.y);
    }
  }
}
function pointInterpolation(pointA, pointB, ratio) {
  const { x: x3, y: y3 } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), { x: x14, y: y14 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point6 = new Point(x3, y3, x14, y14);
  return point6.defined = pointB.defined, point6;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB) return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map((point6) => {
      const p2 = new Point(point6.x, point6.y, point6.x1, point6.y1);
      return p2.defined = point6.defined, p2;
    });
    for (let i2 = 0; i2 < pointsB.length; i2++) points[i2] = pointInterpolation(pointsA[i2], pointsB[i2], ratio);
  } else {
    points = pointsB.map((point6) => {
      const p2 = new Point(point6.x, point6.y, point6.x1, point6.y1);
      return p2.defined = point6.defined, p2;
    });
    for (let i2 = 0; i2 < pointsA.length; i2++) points[i2] = pointInterpolation(pointsA[i2], pointsB[i2], ratio);
  }
  return points;
}
var transformKeys = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY"];
var isTransformKey = (key) => transformKeys.includes(key);
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray_default(attr)) {
    let val;
    for (let i2 = 0; i2 < attr.length && void 0 === val; i2++) val = attr[i2][key];
    return val;
  }
  return attr[key];
}
var RafBasedSTO = class _RafBasedSTO {
  constructor() {
    this.durations = [], this.timeout = _RafBasedSTO.TimeOut, this.lastDate = 0, this.durationsListThreshold = 30;
  }
  call(cb) {
    return this.lastDate = Date.now(), setTimeout(() => {
      this.appendDuration(Date.now() - this.lastDate), cb(0);
    }, this.timeout, true);
  }
  clear(h2) {
    clearTimeout(h2);
  }
  appendDuration(d2) {
    this.durations.push(d2), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a4, b2) => a4 + b2, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
  }
};
RafBasedSTO.TimeOut = 1e3 / 60;
var rafBasedSto = new RafBasedSTO();
var calculateLineHeight = (lineHeight, fontSize) => {
  if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};

// node_modules/@visactor/vrender-core/es/animate/custom-animate.js
var IncreaseCount = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2);
  }
  getEndProps() {
    return false === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.fromNumber = isNumber_default(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), this.toNumber = isNumber_default(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = false), false !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    false !== this.valid && (out.text = end ? this.toNumber : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
  }
};
var Direction2;
!function(Direction3) {
  Direction3[Direction3.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction3[Direction3.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction3[Direction3.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction3[Direction3.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction3[Direction3.STROKE = 4] = "STROKE";
}(Direction2 || (Direction2 = {}));
var TagPointsUpdate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this.newPointAnimateType = "appear" === (null == params2 ? void 0 : params2.newPointAnimateType) ? "appear" : "grow";
  }
  onBind() {
    var _a, _b;
    const originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
    this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [originFromPoints] : [], this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [originToPoints] : [];
    const tagMap = /* @__PURE__ */ new Map();
    this.fromPoints.forEach((point6) => {
      point6.context && tagMap.set(point6.context, point6);
    });
    let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
    for (let i2 = 0; i2 < this.toPoints.length; i2 += 1) if (tagMap.has(this.toPoints[i2].context)) {
      firstMatchedIndex = i2, firstMatchedPoint = tagMap.get(this.toPoints[i2].context);
      break;
    }
    for (let i2 = this.toPoints.length - 1; i2 >= 0; i2 -= 1) if (tagMap.has(this.toPoints[i2].context)) {
      lastMatchedIndex = i2, lastMatchedPoint = tagMap.get(this.toPoints[i2].context);
      break;
    }
    let prevMatchedPoint = this.toPoints[0];
    this.interpolatePoints = this.toPoints.map((point6, index) => {
      const matchedPoint = tagMap.get(point6.context);
      return matchedPoint ? (prevMatchedPoint = matchedPoint, [matchedPoint, point6]) : "appear" === this.newPointAnimateType ? [point6, point6] : index < firstMatchedIndex && firstMatchedPoint ? [firstMatchedPoint, point6] : index > lastMatchedIndex && lastMatchedPoint ? [lastMatchedPoint, point6] : [prevMatchedPoint, point6];
    }), this.points = this.interpolatePoints.map((interpolate2) => {
      const fromPoint = interpolate2[0], toPoint = interpolate2[1], newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
      return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
    });
  }
  onUpdate(end, ratio, out) {
    this.points = this.points.map((point6, index) => {
      const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return newPoint.context = point6.context, newPoint;
    }), out.points = this.points;
  }
};
var ClipGraphicAnimate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(null, null, duration, easing, params2), this.clipFromAttribute = from, this.clipToAttribute = to, this._group = null == params2 ? void 0 : params2.group, this._clipGraphic = null == params2 ? void 0 : params2.clipGraphic;
  }
  onBind() {
    this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, this._lastPath = this._group.attribute.path, this._group.setAttributes({
      clip: true,
      path: [this._clipGraphic]
    }, false, {
      type: AttributeUpdateType.ANIMATE_BIND
    }));
  }
  onEnd() {
    this._group && this._group.setAttributes({
      clip: this._lastClip,
      path: this._lastPath
    }, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onUpdate(end, ratio, out) {
    if (!this._clipGraphic) return;
    const res = {};
    Object.keys(this.clipFromAttribute).forEach((k3) => {
      res[k3] = this.clipFromAttribute[k3] + (this.clipToAttribute[k3] - this.clipFromAttribute[k3]) * ratio;
    }), this._clipGraphic.setAttributes(res, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end
      }
    });
  }
};
var ClipAngleAnimate = class extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const groupAttribute = null !== (_b = null === (_a = null == params2 ? void 0 : params2.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params2 ? void 0 : params2.animationType) && void 0 !== _e ? _e : "in", startAngle = null !== (_f = null == params2 ? void 0 : params2.startAngle) && void 0 !== _f ? _f : 0, orient = null !== (_g = null == params2 ? void 0 : params2.orient) && void 0 !== _g ? _g : "clockwise";
    let arcStartAngle = 0, arcEndAngle = 0;
    "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
    const arc = application.graphicService.creator.arc({
      x: null !== (_j = null === (_h = null == params2 ? void 0 : params2.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
      y: null !== (_l = null === (_k = null == params2 ? void 0 : params2.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
      outerRadius: null !== (_m = null == params2 ? void 0 : params2.radius) && void 0 !== _m ? _m : (width + height) / 2,
      innerRadius: 0,
      startAngle: arcStartAngle,
      endAngle: arcEndAngle,
      fill: true
    });
    let fromAttributes, toAttributes;
    "anticlockwise" === orient ? (fromAttributes = {
      startAngle: startAngle + 2 * Math.PI
    }, toAttributes = {
      startAngle
    }) : (fromAttributes = {
      endAngle: startAngle
    }, toAttributes = {
      endAngle: startAngle + 2 * Math.PI
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params2 ? void 0 : params2.group,
      clipGraphic: arc
    });
  }
};
var ClipDirectionAnimate = class extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const groupAttribute = null !== (_b = null === (_a = null == params2 ? void 0 : params2.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_d = null !== (_c = null == params2 ? void 0 : params2.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0, height = null !== (_f = null !== (_e = null == params2 ? void 0 : params2.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0, animationType = null !== (_g = null == params2 ? void 0 : params2.animationType) && void 0 !== _g ? _g : "in", direction2 = null !== (_h = null == params2 ? void 0 : params2.direction) && void 0 !== _h ? _h : "x", orient = null !== (_j = null == params2 ? void 0 : params2.orient) && void 0 !== _j ? _j : "positive", rect = application.graphicService.creator.rect({
      x: 0,
      y: 0,
      width: "in" === animationType && "x" === direction2 ? 0 : width,
      height: "in" === animationType && "y" === direction2 ? 0 : height,
      fill: true
    });
    let fromAttributes = {}, toAttributes = {};
    "y" === direction2 ? "negative" === orient ? (fromAttributes = {
      y: height,
      height: 0
    }, toAttributes = {
      y: 0,
      height
    }) : (fromAttributes = {
      height: 0
    }, toAttributes = {
      height
    }) : "negative" === orient ? (fromAttributes = {
      x: width,
      width: 0
    }, toAttributes = {
      x: 0,
      width
    }) : (fromAttributes = {
      width: 0
    }, toAttributes = {
      width
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params2 ? void 0 : params2.group,
      clipGraphic: rect
    });
  }
};
var RotateBySphereAnimate = class extends ACustomAnimate {
  onStart() {
    const { center: center2, r: r2 } = "function" == typeof this.params ? this.params() : this.params, startX = this.target.getComputedAttribute("x"), startY = this.target.getComputedAttribute("y"), startZ = this.target.getComputedAttribute("z"), phi = Math.acos((startY - center2.y) / r2);
    let theta = Math.acos((startX - center2.x) / r2 / Math.sin(phi));
    startZ - center2.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
  }
  onBind() {
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    if (null == this.phi || null == this.theta) return;
    const { center: center2, r: r2, cb } = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x3 = r2 * Math.sin(phi) * Math.cos(theta) + center2.x, y3 = r2 * Math.cos(phi) + center2.y, z2 = r2 * Math.sin(phi) * Math.sin(theta) + center2.z;
    for (out.x = x3, out.y = y3, out.z = z2, out.alpha = theta + pi / 2; out.alpha > pi2; ) out.alpha -= pi2;
    out.alpha = pi2 - out.alpha, out.zIndex = -1e4 * out.z, cb && cb(out);
  }
};
var GroupFadeOut = class extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: 1 - ratio
      }
    });
  }
};
var AnimateGroup = class extends ACustomAnimate {
  constructor(duration, customAnimates) {
    super(null, null, duration, "linear"), this.customAnimates = customAnimates;
  }
  initAnimates() {
    this.customAnimates.forEach((a4) => {
      a4.step = this.step, a4.subAnimate = this.subAnimate, a4.target = this.target;
    });
  }
  getEndProps() {
    const props = {};
    return this.customAnimates.forEach((a4) => {
      Object.assign(props, a4.getEndProps());
    }), props;
  }
  onBind() {
    this.initAnimates(), this.customAnimates.forEach((a4) => {
      a4.onBind();
    });
  }
  onEnd() {
    this.customAnimates.forEach((a4) => {
      a4.onEnd();
    });
  }
  onStart() {
    this.customAnimates.forEach((a4) => {
      a4.onStart();
    });
  }
  onUpdate(end, ratio, out) {
    this.updating || (this.updating = true, this.customAnimates.forEach((a4) => {
      const easing = a4.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing;
      ratio = easingFunc(ratio), a4.onUpdate(end, ratio, out);
    }), this.updating = false);
  }
};

// node_modules/@visactor/vrender-core/es/common/morphing-utils.js
function cubicSubdivide(p0, p1, p2, p3, t2, out) {
  const p01 = (p1 - p0) * t2 + p0, p12 = (p2 - p1) * t2 + p1, p23 = (p3 - p2) * t2 + p2, p012 = (p12 - p01) * t2 + p01, p123 = (p23 - p12) * t2 + p12, p0123 = (p123 - p012) * t2 + p012;
  out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, out[6] = p23, out[7] = p3;
}
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length, len2 = subpath2.length;
  if (len1 === len2) return [subpath1, subpath2];
  const tmpSegX = [], tmpSegY = [], shorterPath = len1 < len2 ? subpath1 : subpath2, shorterLen = Math.min(len1, len2), diff = Math.abs(len2 - len1) / 6, shorterBezierCount = (shorterLen - 2) / 6, eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount), newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i2 = 2; i2 < shorterLen; i2 += 6) {
    let x05 = shorterPath[i2 - 2], y05 = shorterPath[i2 - 1], x14 = shorterPath[i2], y14 = shorterPath[i2 + 1], x23 = shorterPath[i2 + 2], y23 = shorterPath[i2 + 3];
    const x3 = shorterPath[i2 + 4], y3 = shorterPath[i2 + 5];
    if (remained <= 0) {
      newSubpath.push(x14, y14, x23, y23, x3, y3);
      continue;
    }
    const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
    for (let k3 = 1; k3 <= actualSubDivCount; k3++) {
      const p2 = k3 / actualSubDivCount;
      cubicSubdivide(x05, x14, x23, x3, p2, tmpSegX), cubicSubdivide(y05, y14, y23, y3, p2, tmpSegY), x05 = tmpSegX[3], y05 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x05, y05), x14 = tmpSegX[5], y14 = tmpSegY[5], x23 = tmpSegX[6], y23 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpath, otherSubpath) {
  const prevSubPath = lastSubpath || otherSubpath, len = prevSubPath.length, lastX = prevSubPath[len - 2], lastY = prevSubPath[len - 1], newSubpath = [];
  for (let i2 = 0; i2 < otherSubpath.length; i2 += 2) newSubpath[i2] = lastX, newSubpath[i2 + 1] = lastY;
  return newSubpath;
}
function reverseSubpath(array2) {
  const newArr = [], len = array2.length;
  for (let i2 = 0; i2 < len; i2 += 2) newArr[i2] = array2[len - i2 - 2], newArr[i2 + 1] = array2[len - i2 - 1];
  return newArr;
}
function centroidOfSubpath(array2) {
  let signedArea = 0, cx = 0, cy = 0;
  const len = array2.length;
  for (let i2 = 0, j2 = len - 2; i2 < len; j2 = i2, i2 += 2) {
    const x05 = array2[j2], y05 = array2[j2 + 1], x14 = array2[i2], y14 = array2[i2 + 1], a4 = x05 * y14 - x14 * y05;
    signedArea += a4, cx += (x05 + x14) * a4, cy += (y05 + y14) * a4;
  }
  return 0 === signedArea ? [array2[0] || 0, array2[1] || 0, 0] : [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = 1 / 0, bestOffset = 0;
  const len = fromSubBeziers.length, len2 = len - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = 6 * offset;
    let score3 = 0;
    for (let k3 = 0; k3 < len; k3 += 2) {
      const idx = 0 === k3 ? cursorOffset : (cursorOffset + k3 - 2) % len2 + 2, x05 = fromSubBeziers[idx] - fromCp[0], y05 = fromSubBeziers[idx + 1] - fromCp[1], dx = toSubBeziers[k3] - toCp[0] - x05, dy = toSubBeziers[k3 + 1] - toCp[1] - y05;
      score3 += dx * dx + dy * dy;
    }
    score3 < bestScore && (bestScore = score3, bestOffset = offset);
  }
  return bestOffset;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
  const result2 = [];
  let fromNeedsReverse;
  for (let i2 = 0; i2 < fromArr.length; i2++) {
    let fromSubpathBezier = fromArr[i2];
    const toSubpathBezier = toArr[i2], fromCp = centroidOfSubpath(fromSubpathBezier), toCp = centroidOfSubpath(toSubpathBezier);
    null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
    const newFromSubpathBezier = [], newToSubpathBezier = [];
    let bestAngle = 0, bestScore = 1 / 0;
    const tmpArr = [], len = fromSubpathBezier.length;
    fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
    const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp), len2 = len - 2;
    for (let k3 = 0; k3 < len2; k3 += 2) {
      const idx = (offset + k3) % len2 + 2;
      newFromSubpathBezier[k3 + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k3 + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle2 = -searchAngleRange / 2; angle2 <= searchAngleRange / 2; angle2 += step) {
        const sa = Math.sin(angle2), ca = Math.cos(angle2);
        let score3 = 0;
        for (let k3 = 0; k3 < fromSubpathBezier.length; k3 += 2) {
          const x05 = newFromSubpathBezier[k3], y05 = newFromSubpathBezier[k3 + 1], x14 = toSubpathBezier[k3] - toCp[0], y14 = toSubpathBezier[k3 + 1] - toCp[1], newX1 = x14 * ca - y14 * sa, newY1 = x14 * sa + y14 * ca;
          tmpArr[k3] = newX1, tmpArr[k3 + 1] = newY1;
          const dx = newX1 - x05, dy = newY1 - y05;
          score3 += dx * dx + dy * dy;
        }
        if (score3 < bestScore) {
          bestScore = score3, bestAngle = angle2;
          for (let m5 = 0; m5 < tmpArr.length; m5++) newToSubpathBezier[m5] = tmpArr[m5];
        }
      }
    } else for (let i3 = 0; i3 < len; i3 += 2) newToSubpathBezier[i3] = toSubpathBezier[i3] - toCp[0], newToSubpathBezier[i3 + 1] = toSubpathBezier[i3 + 1] - toCp[1];
    result2.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result2;
}
function alignBezierCurves(array1, array2) {
  let lastSubpath1, lastSubpath2;
  const newArray1 = [], newArray2 = [];
  for (let i2 = 0; i2 < Math.max(array1.length, array2.length); i2++) {
    const subpath1 = array1[i2], subpath2 = array2[i2];
    let newSubpath1, newSubpath2;
    subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
var addLineToBezierPath = (bezierPath, x05, y05, x14, y14) => {
  isNumberClose(x05, x14) && isNumberClose(y05, y14) || bezierPath.push(x05, y05, x14, y14, x14, y14);
};
function pathToBezierCurves(path) {
  const commandList = path.commandList, bezierArrayGroups = [];
  let currentSubpath, xi = 0, yi = 0, x05 = 0, y05 = 0;
  const createNewSubpath = (x3, y3) => {
    currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), currentSubpath = [x3, y3];
  };
  let x14, y14, x23, y23;
  for (let i2 = 0, len = commandList.length; i2 < len; i2++) {
    const cmd = commandList[i2], isFirst = 0 === i2;
    switch (isFirst && (x05 = xi = cmd[1], y05 = yi = cmd[2], [enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0]) && (currentSubpath = [x05, y05])), cmd[0]) {
      case enumCommandMap.M:
        xi = x05 = cmd[1], yi = y05 = cmd[2], createNewSubpath(x05, y05);
        break;
      case enumCommandMap.L:
        x14 = cmd[1], y14 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xi = x14, yi = y14;
        break;
      case enumCommandMap.C:
        currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
        break;
      case enumCommandMap.Q:
        x14 = cmd[1], y14 = cmd[2], x23 = cmd[3], y23 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x14 - xi), yi + 2 / 3 * (y14 - yi), x23 + 2 / 3 * (x14 - x23), y23 + 2 / 3 * (y14 - y23), x23, y23), xi = x23, yi = y23;
        break;
      case enumCommandMap.A: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = rx, startAngle = cmd[4], endAngle = cmd[5], counterClockwise = !!cmd[6];
        x14 = Math.cos(startAngle) * rx + cx, y14 = Math.sin(startAngle) * rx + cy, isFirst ? (x05 = x14, y05 = y14, createNewSubpath(x05, y05)) : addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
        const step = (counterClockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; counterClockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = counterClockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry);
        }
        break;
      }
      case enumCommandMap.E: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = cmd[4], rotate3 = cmd[5], startAngle = cmd[6], endAngle = cmd[7] + startAngle, anticlockwise = !!cmd[8], hasRotate = !isNumberClose(rotate3, 0), rc = Math.cos(rotate3), rs = Math.sin(rotate3);
        let xTemp = Math.cos(startAngle) * rx, yTemp = Math.sin(startAngle) * ry;
        hasRotate ? (x14 = xTemp * rc - yTemp * rs + cx, y14 = xTemp * rs + yTemp * rc + cy) : (x14 = xTemp + cx, y14 = yTemp + cy), isFirst ? (x05 = x14, y05 = y14, createNewSubpath(x05, y05)) : addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);
        const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; anticlockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = anticlockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          if (addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry), hasRotate) {
            const curLen = currentSubpath.length;
            for (let j2 = curLen - 6; j2 <= curLen - 1; j2 += 2) xTemp = currentSubpath[j2], yTemp = currentSubpath[j2 + 1], currentSubpath[j2] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j2 + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
          }
        }
        break;
      }
      case enumCommandMap.R:
        x05 = xi = cmd[1], y05 = yi = cmd[2], x14 = x05 + cmd[3], y14 = y05 + cmd[4], createNewSubpath(x14, y05), addLineToBezierPath(currentSubpath, x14, y05, x14, y14), addLineToBezierPath(currentSubpath, x14, y14, x05, y14), addLineToBezierPath(currentSubpath, x05, y14, x05, y05), addLineToBezierPath(currentSubpath, x05, y05, x14, y05);
        break;
      case enumCommandMap.AT: {
        const tx1 = cmd[1], ty1 = cmd[2], tx2 = cmd[3], ty2 = cmd[4], r2 = cmd[5], dis1 = PointService.distancePP({
          x: xi,
          y: yi
        }, {
          x: tx1,
          y: ty1
        }), dis2 = PointService.distancePP({
          x: tx2,
          y: ty2
        }, {
          x: tx1,
          y: ty1
        }), theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2), dis = r2 / Math.sin(theta / 2), midX = (xi + tx2 - 2 * tx1) / 2, midY = (yi + ty2 - 2 * ty1) / 2, midLen = PointService.distancePP({
          x: midX,
          y: midY
        }, {
          x: 0,
          y: 0
        }), cx = tx1 + dis * midX / midLen, cy = tx2 + dis * midY / midLen, disP = Math.sqrt(dis * dis - r2 * r2);
        x05 = tx1 + disP * (xi - tx1) / dis1, y05 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x05, y05), xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
        const startAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: x05,
          y: y05
        }), endAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: xi,
          y: yi
        });
        addArcToBezierPath(currentSubpath, startAngle, endAngle, cx, cy, r2, r2);
        break;
      }
      case enumCommandMap.Z:
        currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x05, y05), xi = x05, yi = y05;
    }
  }
  return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), bezierArrayGroups;
}
function applyTransformOnBezierCurves(bezierCurves, martrix) {
  for (let i2 = 0; i2 < bezierCurves.length; i2++) {
    const subPath = bezierCurves[i2];
    for (let k3 = 0; k3 < subPath.length; k3 += 2) {
      const x3 = subPath[k3], y3 = subPath[k3 + 1], res = {
        x: x3,
        y: y3
      };
      martrix.transformPoint({
        x: x3,
        y: y3
      }, res), subPath[k3] = res.x, subPath[k3 + 1] = res.y;
    }
  }
}
function bezierCurversToPath(bezierCurves) {
  const path = new CustomPath2D();
  for (let i2 = 0; i2 < bezierCurves.length; i2++) {
    const subPath = bezierCurves[i2];
    if (subPath.length > 2) {
      path.moveTo(subPath[0], subPath[1]);
      for (let k3 = 2; k3 < subPath.length; k3 += 6) path.bezierCurveTo(subPath[k3], subPath[k3 + 1], subPath[k3 + 2], subPath[k3 + 3], subPath[k3 + 4], subPath[k3 + 5]);
    }
  }
  return path;
}

// node_modules/@visactor/vrender-core/es/common/rect-utils.js
var normalizeRectAttributes = (attribute) => {
  if (!attribute) return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  let width = isNil_default(attribute.width) ? attribute.x1 - attribute.x : attribute.width, height = isNil_default(attribute.height) ? attribute.y1 - attribute.y : attribute.height, x3 = 0, y3 = 0;
  return width < 0 ? (x3 = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y3 = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x: x3,
    y: y3,
    width,
    height
  };
};

// node_modules/@visactor/vrender-core/es/common/split-path.js
function splitToGrids(width, height, count) {
  const ratio = width / height;
  let rowCount, columnCount;
  width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, rowCount = count));
  const grids = [];
  for (let i2 = 0; i2 < rowCount; i2++) grids.push(columnCount);
  const remained = count - rowCount * columnCount;
  if (remained > 0) for (let i2 = 0; i2 < remained; i2 += columnCount) i2 + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i2);
  return grids;
}
var splitRect = (rect, count) => {
  const { width, height } = normalizeRectAttributes(rect.attribute), grids = splitToGrids(width, height, count), res = [], gridHeight = height / grids.length;
  for (let i2 = 0, rowCount = grids.length; i2 < rowCount; i2++) {
    const columnCount = grids[i2], gridWidth = width / columnCount;
    for (let j2 = 0; j2 < columnCount; j2++) res.push({
      x: 0 + j2 * gridWidth,
      y: 0 + i2 * gridHeight,
      width: gridWidth,
      height: gridHeight
    });
  }
  return res;
};
var splitArc = (arc, count) => {
  const angles2 = arc.getParsedAngle(), startAngle = angles2.startAngle, endAngle = angles2.endAngle, innerRadius = arc.getComputedAttribute("innerRadius"), outerRadius = arc.getComputedAttribute("outerRadius"), angleDelta = Math.abs(startAngle - endAngle), radiusDelta = Math.abs(outerRadius - innerRadius), grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count), res = [], gridRadius = radiusDelta / grids.length, radiusSign = outerRadius >= innerRadius ? 1 : -1, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i2 = 0, rowCount = grids.length; i2 < rowCount; i2++) {
    const columnCount = grids[i2], gridAngle = angleDelta / columnCount;
    for (let j2 = 0; j2 < columnCount; j2++) res.push({
      innerRadius: outerRadius - gridRadius * i2 * radiusSign,
      outerRadius: outerRadius - gridRadius * (i2 + 1) * radiusSign,
      startAngle: startAngle + gridAngle * j2 * angleSign,
      endAngle: startAngle + gridAngle * (j2 + 1) * angleSign
    });
  }
  return res;
};
var splitCircle = (arc, count) => {
  const startAngle = arc.getComputedAttribute("startAngle"), endAngle = arc.getComputedAttribute("endAngle"), radius = arc.getComputedAttribute("radius"), angleDelta = Math.abs(startAngle - endAngle), grids = splitToGrids(angleDelta * radius, radius, count), res = [], gridAngle = angleDelta / grids[0], gridRadius = radius / grids.length, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i2 = 0, rowCount = grids.length; i2 < rowCount; i2++) for (let j2 = 0, columnCount = grids[i2]; j2 < columnCount; j2++) res.push({
    innerRadius: gridRadius * i2,
    outerRadius: gridRadius * (i2 + 1),
    startAngle: startAngle + gridAngle * j2 * angleSign,
    endAngle: startAngle + gridAngle * (j2 + 1) * angleSign
  });
  return res;
};
var samplingPoints = (points, count) => {
  const validatePoints = points.filter((point6) => false !== point6.defined && isNumber_default(point6.x) && isNumber_default(point6.y));
  if (0 === validatePoints.length) return [];
  if (1 === validatePoints.length) return new Array(count).fill(0).map((i2) => validatePoints[0]);
  const res = [];
  if (count <= validatePoints.length) {
    const step = validatePoints.length / count;
    let i2 = 0, cur = 0;
    for (; i2 < count; ) res.push(validatePoints[Math.floor(cur)]), cur += step, i2++;
    return res;
  }
  const insertCount = count - validatePoints.length, insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
  let curCount = 0;
  for (let i2 = 0, len = points.length; i2 < len; i2++) if (res.push(points[i2]), i2 < len - 1) {
    let cur = insetRatio;
    const xCur = points[i2].x, yCur = points[i2].y, xNext = points[i2 + 1].x, yNext = points[i2 + 1].y;
    for (; cur < 1 && curCount < insertCount; ) res.push({
      x: xCur + (xNext - xCur) * cur,
      y: yCur + (yNext - yCur) * cur
    }), cur += insetRatio, curCount += 1;
  }
  return res;
};
var splitArea = (area2, count) => {
  var _a, _b;
  const attribute = area2.attribute;
  let points = attribute.points;
  const segements = attribute.segments;
  points || (points = segements.reduce((res2, seg) => {
    var _a2;
    return res2.concat(null !== (_a2 = seg.points) && void 0 !== _a2 ? _a2 : []);
  }, []));
  const validatePoints = points.filter((point6) => false !== point6.defined && isNumber_default(point6.x) && isNumber_default(point6.y));
  if (!validatePoints.length) return [];
  const allPoints = [];
  validatePoints.forEach((point6) => {
    allPoints.push({
      x: point6.x,
      y: point6.y
    });
  });
  for (let i2 = validatePoints.length - 1; i2 >= 0; i2--) {
    const point6 = validatePoints[i2];
    allPoints.push({
      x: null !== (_a = point6.x1) && void 0 !== _a ? _a : point6.x,
      y: null !== (_b = point6.y1) && void 0 !== _b ? _b : point6.y
    });
  }
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitLine = (line2, count) => {
  const attribute = line2.attribute, points = attribute.points;
  if (points) return samplingPoints(points, count);
  if (attribute.segments) {
    const allPoints = attribute.segments.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, []);
    return samplingPoints(allPoints, count);
  }
  return [];
};
function crossProduct2(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
var clonePoints = (points) => points.map((p2) => ({
  x: p2.x,
  y: p2.y
}));
var splitPolygonByLine = (points, p0, p1) => {
  const len = points.length, intersections = [];
  for (let i2 = 0; i2 < len; i2++) {
    const cur = points[i2], next = i2 === len - 1 ? points[0] : points[i2 + 1], res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
    res && "boolean" != typeof res && intersections.push({
      dot: crossProduct2([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
      point: {
        x: res[0],
        y: res[1]
      },
      edgeIndex: i2
    });
  }
  if (intersections.length < 2) return [clonePoints(points), clonePoints(points)];
  intersections.sort((a4, b2) => a4.dot - b2.dot);
  let is0 = intersections[0], is1 = intersections[intersections.length - 1];
  is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [is1, is0]);
  const newP0 = is0.point, newP1 = is1.point, newPointsA = [{
    x: newP0.x,
    y: newP0.y
  }];
  for (let i2 = is0.edgeIndex + 1; i2 <= is1.edgeIndex; i2++) newPointsA.push({
    x: points[i2].x,
    y: points[i2].y
  });
  newPointsA.push({
    x: newP1.x,
    y: newP1.y
  });
  const newPointsB = [{
    x: newP1.x,
    y: newP1.y
  }];
  for (let i2 = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i2 <= maxIndex; i2++) {
    const p2 = points[i2 % len];
    newPointsB.push({
      x: p2.x,
      y: p2.y
    });
  }
  return newPointsB.push({
    x: newP0.x,
    y: newP0.y
  }), [newPointsA, newPointsB];
};
var binarySplitPolygon = (points) => {
  const box = new Bounds();
  points.forEach((point6) => {
    box.add(point6.x, point6.y);
  });
  const width = box.width(), height = box.height();
  if (width >= height) {
    const midX = box.x1 + width / 2;
    return splitPolygonByLine(points, {
      x: midX,
      y: box.y1
    }, {
      x: midX,
      y: box.y2
    });
  }
  const midY = box.y1 + height / 2;
  return splitPolygonByLine(points, {
    x: box.x1,
    y: midY
  }, {
    x: box.x2,
    y: midY
  });
};
var recursiveCallBinarySplit = (points, count, out) => {
  if (1 === count) out.push({
    points
  });
  else {
    const half = Math.floor(count / 2), res = binarySplitPolygon(points);
    recursiveCallBinarySplit(res[0], half, out), recursiveCallBinarySplit(res[1], count - half, out);
  }
};
var splitPolygon = (polygon, count) => {
  const points = polygon.attribute.points;
  if (!points || !points.length) return [];
  if (1 === count) return [{
    points: clonePoints(points)
  }];
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitPath = (path, count) => {
  const pathShape = path.getParsedPathShape(), bezierCurves = pathToBezierCurves(pathShape);
  if (!bezierCurves.length || count < 0) return [];
  const subPathCnt = bezierCurves.length;
  if (bezierCurves.length >= count) {
    const res2 = [], stepCount2 = Math.floor(bezierCurves.length / count);
    for (let i2 = 0; i2 < count; i2++) {
      const curves = bezierCurves.slice(i2 * stepCount2, i2 === count - 1 ? subPathCnt : (i2 + 1) * stepCount2);
      res2.push({
        path: bezierCurversToPath(curves)
      });
    }
    return res2;
  }
  const res = [], stepCount = Math.floor(count / subPathCnt);
  let remain = count;
  for (let c4 = 0; c4 < subPathCnt; c4++) {
    const points = [];
    for (let i2 = 2, len = bezierCurves[c4].length; i2 < len; i2 += 2) points.push({
      x: bezierCurves[0][i2],
      y: bezierCurves[0][i2 + 1]
    });
    recursiveCallBinarySplit(points, c4 === subPathCnt - 1 ? remain : stepCount, res), remain -= stepCount;
  }
  return res;
};

// node_modules/@visactor/vrender-core/es/color-string/store.js
var ColorType;
!function(ColorType2) {
  ColorType2[ColorType2.Color255 = 0] = "Color255", ColorType2[ColorType2.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
var ColorStore = class _ColorStore {
  static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
    if (size === ColorType.Color1) {
      const color2 = _ColorStore.store1[str];
      if (color2) return arr[0] = color2[0], arr[1] = color2[1], arr[2] = color2[2], arr[3] = color2[3], arr;
      const c5 = Color.parseColorString(str);
      if (c5) {
        const data = [c5.r / 255, c5.g / 255, c5.b / 255, c5.opacity];
        _ColorStore.store1[str] = data, _ColorStore.store255[str] = [c5.r, c5.g, c5.b, c5.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = _ColorStore.store255[str];
    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c4 = Color.parseColorString(str);
    return c4 && (_ColorStore.store1[str] = [c4.r / 255, c4.g / 255, c4.b / 255, c4.opacity], _ColorStore.store255[str] = [c4.r, c4.g, c4.b, c4.opacity], arr[0] = c4.r, arr[1] = c4.g, arr[2] = c4.b, arr[3] = c4.opacity), arr;
  }
  static Set(str, size, arr) {
    if (size === ColorType.Color1) {
      if (_ColorStore.store1[str]) return;
      _ColorStore.store1[str] = arr, _ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (_ColorStore.store255[str]) return;
      _ColorStore.store255[str] = arr, _ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
};
ColorStore.store255 = {}, ColorStore.store1 = {};

// node_modules/@visactor/vrender-core/es/color-string/interpolate.js
function colorArrayToString(color, alphaChannel = false) {
  return Array.isArray(color) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || false;
  let fromArray, toArray, fromGradient = false, toGradient = false;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = true, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = true, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
      stops: gradient.stops.map((v2) => Object.assign(Object.assign({}, v2), {
        color: colorArrayToString(pure)
      }))
    });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
      if (fromStops.length !== toStops.length) return false;
      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return false;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_2, i2) => ({
      color: colorStringInterpolationToStr(fStops[i2].color, tStops[i2].color, ratio),
      offset: fStops[i2].offset + (tStops[i2].offset - fStops[i2].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_2, i2) => ({
      color: colorStringInterpolationToStr(fStops[i2].color, tStops[i2].color, ratio),
      offset: fStops[i2].offset + (tStops[i2].offset - fStops[i2].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_2, i2) => ({
      color: colorStringInterpolationToStr(fStops[i2].color, tStops[i2].color, ratio),
      offset: fStops[i2].offset + (tStops[i2].offset - fStops[i2].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
var _fromColorRGB = [0, 0, 0, 0];
var _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

// node_modules/@visactor/vrender-core/es/color-string/colorName.js
var parsedColors = {};
Object.keys(DEFAULT_COLORS).forEach((k3) => {
  const c4 = DEFAULT_COLORS[k3];
  parsedColors[k3] = [c4 >> 16 & 255, c4 >> 8 & 255, 255 & c4];
});

// node_modules/@visactor/vrender-core/es/animate/morphing.js
var interpolateOtherAttrs = (attrs, out, ratio) => {
  attrs.forEach((entry) => {
    if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio;
    else if ("fill" === entry.key || "stroke" === entry.key) {
      const color = interpolateColor(entry.from, entry.to, ratio, false);
      color && (out[entry.key] = color);
    }
  });
};
var interpolateMorphingData = (morphingData, path, ratio) => {
  const tmpArr = [], newCp = [];
  path.clear();
  for (let i2 = 0; i2 < morphingData.length; i2++) {
    const item = morphingData[i2], from = item.from, to = item.to, angle2 = item.rotation * ratio, fromCp = item.fromCp, toCp = item.toCp, sa = Math.sin(angle2), ca = Math.cos(angle2);
    newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
    for (let m5 = 0; m5 < from.length; m5 += 2) {
      const x06 = from[m5], y06 = from[m5 + 1], x3 = x06 * (1 - ratio) + to[m5] * ratio, y3 = y06 * (1 - ratio) + to[m5 + 1] * ratio;
      tmpArr[m5] = x3 * ca - y3 * sa + newCp[0], tmpArr[m5 + 1] = x3 * sa + y3 * ca + newCp[1];
    }
    let x05 = tmpArr[0], y05 = tmpArr[1];
    path.moveTo(x05, y05);
    for (let m5 = 2; m5 < from.length; m5 += 6) {
      const x14 = tmpArr[m5], y14 = tmpArr[m5 + 1], x23 = tmpArr[m5 + 2], y23 = tmpArr[m5 + 3], x3 = tmpArr[m5 + 4], y3 = tmpArr[m5 + 5];
      x05 === x14 && y05 === y14 && x23 === x3 && y23 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x14, y14, x23, y23, x3, y3), x05 = x3, y05 = y3;
    }
  }
};
var parseMorphingData = (fromPath, toPath, config2) => {
  const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [], toBezier = pathToBezierCurves(toPath);
  config2 && fromBezier && (config2.fromTransform && applyTransformOnBezierCurves(fromBezier, config2.fromTransform.clone().getInverse()), applyTransformOnBezierCurves(fromBezier, config2.toTransfrom));
  const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
  return fromPath ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map((to, index) => ({
    from: fromBezierCurves[index],
    to,
    fromCp: [0, 0],
    toCp: [0, 0],
    rotation: 0
  }));
};
var validateOtherAttrs = ["fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset"];
var parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
  if (!fromAttrs || !toAttrs) return null;
  const res = [];
  let hasAttr = false;
  return Object.keys(fromAttrs).forEach((fromKey) => {
    if (!validateOtherAttrs.includes(fromKey)) return;
    const toValue = toAttrs[fromKey];
    isNil_default(toValue) || isNil_default(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
      from: "string" == typeof fromAttrs[fromKey] ? ColorStore.Get(fromAttrs[fromKey], ColorType.Color255) : fromAttrs[fromKey],
      to: "string" == typeof toValue ? ColorStore.Get(toValue, ColorType.Color255) : toValue,
      key: fromKey
    }) : res.push({
      from: fromAttrs[fromKey],
      to: toValue,
      key: fromKey
    }), hasAttr = true);
  }), hasAttr ? res : null;
};
var MorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs, this.saveOnEnd = config2.saveOnEnd;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.createPathProxy(), this.onUpdate(false, 0, this.target.attribute);
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    const target = this.target, pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
    interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), end && !this.saveOnEnd && (this.target.pathProxy = null);
  }
};
var morphPath = (fromGraphic, toGraphic, animationConfig2, fromGraphicTransform) => {
  var _a, _b, _c;
  if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, " is not validate"), null;
  if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, " is not validate"), null;
  let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
  fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
  const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
    fromTransform,
    toTransfrom: toGraphic.globalTransMatrix
  }), attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute), animate = toGraphic.animate(animationConfig2);
  return (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MorphingPath({
    morphingData,
    otherAttrs: attrs
  }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing)), animate;
};
var oneToMultiMorph = (fromGraphic, toGraphics, animationConfig2) => {
  var _a;
  const validateToGraphics = toGraphics.filter((graphic) => graphic && graphic.toCustomPath && graphic.valid);
  validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, false), oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd;
  let count = validateToGraphics.length;
  const onEachEnd = () => {
    count--, 0 === count && oldOnEnd && oldOnEnd();
  };
  validateToGraphics.forEach((toChild, index) => {
    var _a2;
    const fromChild = childGraphics[index], delay = (null !== (_a2 = null == animationConfig2 ? void 0 : animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + ((null == animationConfig2 ? void 0 : animationConfig2.individualDelay) ? animationConfig2.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
    morphPath(fromChild, toChild, Object.assign({}, animationConfig2, {
      onEnd: onEachEnd,
      delay
    }), fromGraphic.globalTransMatrix);
  });
};
var MultiToOneMorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.addPathProxy();
  }
  addPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.createPathProxy();
    }), this.onUpdate(false, 0, this.target.attribute);
  }
  clearPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.pathProxy = null;
    });
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    this.target.shadowRoot.forEachChildren((child, index) => {
      var _a;
      interpolateMorphingData(this.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
    }), end && (this.clearPathProxy(), this.morphingData = null);
  }
};
var parseShadowChildAttrs = (graphicAttrs) => {
  const attrs = {};
  return Object.keys(graphicAttrs).forEach((key) => {
    isTransformKey(key) || (attrs[key] = graphicAttrs[key]);
  }), attrs;
};
var appendShadowChildrenToGraphic = (graphic, children, count) => {
  const childAttrs = parseShadowChildAttrs(graphic.attribute), shadowRoot = graphic.attachShadow();
  if (children.length) shadowRoot.setTheme({
    [children[0].type]: childAttrs
  }), children.forEach((element) => {
    shadowRoot.appendChild(element);
  });
  else {
    const box = graphic.AABBBounds, width = box.width(), height = box.height();
    shadowRoot.setTheme({
      rect: childAttrs
    }), new Array(count).fill(0).forEach((el) => {
      const child = application.graphicService.creator.rect({
        x: 0,
        y: 0,
        width,
        height
      });
      shadowRoot.appendChild(child), children.push(child);
    });
  }
};
var cloneGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute), path = graphic.toCustomPath();
  for (let i2 = 0; i2 < count; i2++) {
    const element = {
      path: new CustomPath2D().fromCustomPath2D(path)
    };
    children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var splitGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
  if ("rect" === graphic.type) {
    splitRect(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("arc" === graphic.type) {
    splitArc(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("circle" === graphic.type) {
    splitCircle(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("line" === graphic.type) {
    const childrenAttrs = splitLine(graphic, count), defaultSymbol = {
      size: 10,
      symbolType: "circle"
    };
    childrenAttrs.forEach((element) => {
      children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
    });
  } else if ("polygon" === graphic.type) {
    splitPolygon(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("area" === graphic.type) {
    splitArea(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("path" === graphic.type) {
    splitPath(graphic, count).forEach((element) => {
      "path" in element ? children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var multiToOneMorph = (fromGraphics, toGraphic, animationConfig2) => {
  var _a, _b, _c;
  const validateFromGraphics = fromGraphics.filter((graphic) => graphic.toCustomPath && graphic.valid);
  validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, true), toAttrs = toGraphic.attribute;
  toGraphic.setAttribute("visible", false);
  const morphingData = validateFromGraphics.map((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
    fromTransform: graphic.globalTransMatrix,
    toTransfrom: childGraphics[index].globalTransMatrix
  })), otherAttrs = validateFromGraphics.map((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs));
  if (null == animationConfig2 ? void 0 : animationConfig2.individualDelay) {
    const oldOnEnd = animationConfig2.onEnd;
    let count = validateFromGraphics.length;
    const onEachEnd = () => {
      count--, 0 === count && (toGraphic.setAttributes({
        visible: true,
        ratio: null
      }, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
    };
    childGraphics.forEach((to, index) => {
      var _a2, _b2, _c2;
      const delay = (null !== (_a2 = animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + animationConfig2.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to), animate = to.animate(Object.assign({}, animationConfig2, {
        onEnd: onEachEnd
      }));
      animate.wait(delay), animate.play(new MorphingPath({
        morphingData: morphingData[index],
        saveOnEnd: true,
        otherAttrs: otherAttrs[index]
      }, null !== (_b2 = animationConfig2.duration) && void 0 !== _b2 ? _b2 : DefaultMorphingAnimateConfig.duration, null !== (_c2 = animationConfig2.easing) && void 0 !== _c2 ? _c2 : DefaultMorphingAnimateConfig.easing));
    });
  } else {
    const oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd, config2 = animationConfig2 ? Object.assign({}, animationConfig2) : {};
    config2.onEnd = () => {
      toGraphic.setAttribute("visible", true, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();
    };
    const animate = toGraphic.animate(config2);
    (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MultiToOneMorphingPath({
      morphingData,
      otherAttrs
    }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
  }
};

// node_modules/@visactor/vrender-core/es/resource-loader/loader.js
var ResourceLoader = class _ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    let data = _ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, _ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then((res) => {
      var _a2;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a2 = data.waitingMark) || void 0 === _a2 || _a2.map((mark2, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark2.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark2.imageLoadFail(url));
      });
    })) : (data.loadState = "fail", mark.imageLoadFail(url)));
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = _ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadSuccess(svgStr, data.data);
    }) : (data = {
      type: "image",
      loadState: "init"
    }, _ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then((res) => {
      var _a2;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a2 = data.waitingMark) || void 0 === _a2 || _a2.map((mark2, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark2.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark2.imageLoadFail(svgStr));
      });
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = _ResourceLoader.cache.get(url);
    return data ? "init" === data.loadState || "fail" === data.loadState ? Promise.reject() : "loading" === data.loadState ? data.dataPromise.then((data2) => data2.data) : Promise.resolve(data.data) : (data = {
      type,
      loadState: "init"
    }, _ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then((data2) => data2.data));
  }
};
ResourceLoader.cache = /* @__PURE__ */ new Map();

// node_modules/@visactor/vrender-core/es/graphic/graphic.js
var tempMatrix = new Matrix();
var tempBounds = new AABBBounds();
var GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
var tempConstantXYKey = ["x", "y"];
var tempConstantScaleXYKey = ["scaleX", "scaleY"];
var tempConstantAngleKey = ["angle"];
var point4 = new Point();
var NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
var Graphic = class _Graphic extends Node {
  static mixin(source) {
    const keys2 = Object.keys(source);
    for (let i2 = 0; i2 < keys2.length; ++i2) {
      const propertyName = keys2[i2];
      Object.defineProperty(_Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(true);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(true);
  }
  constructor(params2 = {}) {
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params2, this.valid = this.isValid(), params2.background && this.loadImage(null !== (_a = params2.background.background) && void 0 !== _a ? _a : params2.background, true);
  }
  setMode(mode2) {
    "3d" === mode2 ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  getOffsetXY(attr, includeScroll = false) {
    var _a, _b;
    const { dx = attr.dx, dy = attr.dy } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point4.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point4.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else point4.x = dx, point4.y = dy;
    return point4;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds(full) {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true), bounds;
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b2 = this.shadowRoot.AABBBounds.clone();
      bounds.union(b2);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this.AABBBounds.clone(), this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m5 = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f);
      }
    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return true;
  }
  tryUpdateLocalTransMatrix(clearTag = true) {
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x3, y3, mode2, picker) {
    if (!picker) return false;
    if (mode2 === IContainPointMode.GLOBAL) {
      const point6 = new Point(x3, y3);
      this.parent && this.parent.globalTransMatrix.transformPoint(point6, point6), x3 = point6.x, y3 = point6.y;
    }
    return picker.containsPoint(this, {
      x: x3,
      y: y3
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    (params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2).background && this.loadImage(params2.background, true), this._setAttributes(params2, forceUpdateTag, context);
  }
  _setAttributes(params2, forceUpdateTag = false, context) {
    const keys2 = Object.keys(params2);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      this.attribute[key] = params2[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params2 ? this._setAttributes(params2, forceUpdateTag, context) : isNil_default(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key && this.loadImage(value, true);
  }
  needUpdateTags(keys2, k3 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i2 = 0; i2 < k3.length; i2++) {
      const attrKey = k3[i2];
      if (-1 !== keys2.indexOf(attrKey)) return true;
    }
    return false;
  }
  needUpdateTag(key, k3 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i2 = 0; i2 < k3.length; i2++) {
      if (key === k3[i2]) return true;
    }
    return false;
  }
  initAttributes(params2) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this.attribute = params2, params2.background && this.loadImage(params2.background, true), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x3, y3) {
    var _a, _b;
    if (0 === x3 && 0 === y3) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x: x3,
      y: y3
    }, this.attribute, tempConstantXYKey, context);
    params2 && (x3 = params2.x, y3 = params2.y, delete params2.x, delete params2.y, this._setAttributes(params2));
    const attribute = this.attribute, postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x3, y3) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x3, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y3), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x3, y3) {
    const attribute = this.attribute;
    if (attribute.x === x3 && attribute.y === y3) return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x: x3,
      y: y3
    }, this.attribute, tempConstantXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.x = x3, attribute.y = y3, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY,
      scaleCenter
    }, this.attribute, tempConstantScaleXYKey, context);
    params2 && (scaleX = params2.scaleX, scaleY = params2.scaleY, delete params2.scaleX, delete params2.scaleY, this._setAttributes(params2));
    const attribute = this.attribute;
    if (scaleCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
    const context = {
      type: AttributeUpdateType.SCALE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY
    }, this.attribute, tempConstantScaleXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle2, rotateCenter) {
    var _a;
    if (0 === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      angle: angle2,
      rotateCenter
    }, this.attribute, tempConstantAngleKey, context);
    params2 && (delete params2.angle, this._setAttributes(params2, false, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle2, rotateCenter);
    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle2;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle2) {
    const attribute = this.attribute;
    if (attribute.angle === angle2) return this;
    const context = {
      type: AttributeUpdateType.ROTATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle2, this.attribute, tempConstantAngleKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.angle = angle2, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b2, c4) {
    return this;
  }
  animate(params2) {
    this.animates || (this.animates = /* @__PURE__ */ new Map());
    const animate = new Animate(null == params2 ? void 0 : params2.id).bind(this);
    if (params2) {
      const { onStart, onFrame, onEnd, onRemove } = params2;
      null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params2.interpolate;
    }
    return this.animates.set(animate.id, animate), animate.onRemove(() => {
      this.animates.delete(animate.id);
    }), animate;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d2) {
    d2 ? (d2.bounds && this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), d2.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil_default(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b, _c, _d;
    if (hasAnimation) {
      const keys2 = Object.keys(attrs), noWorkAAttr = this.getNoWorkAnimateAttr(), animateAttrs = {};
      let noAnimateAttrs;
      isClear ? keys2.forEach((key) => {
        noWorkAAttr[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      }) : keys2.forEach((key) => {
        noWorkAAttr[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = attrs[key];
      });
      const animate = this.animate();
      animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, false, {
        type: AttributeUpdateType.STATE
      });
    } else this.setAttributes(attrs, false, {
      type: AttributeUpdateType.STATE
    });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach((key) => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach((key) => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach((key) => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  getNormalAttribute(key) {
    let value = this.attribute[key];
    return this.animates && this.animates.forEach((animate) => {
      if (animate.stateNames) {
        const endProps = animate.getEndProps();
        has_default(endProps, key) && (value = endProps[key]);
      }
    }), value;
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) >= 0) {
      const currentStates = this.currentStates.filter((state) => state !== stateName);
      this.useStates(currentStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);
    else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {};
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a2 = this.states) || void 0 === _a2 ? void 0 : _a2[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params2) {
    const _anchor = [0, 0], getBounds = () => {
      if (params2.b) return params2.b;
      const { scaleX, scaleY, angle: angle2 } = this.attribute;
      return tempBounds.copy(this._AABBBounds), this.setAttributes({
        scaleX: 1,
        scaleY: 1,
        angle: 0
      }), params2.b = this.AABBBounds.clone(), this._AABBBounds.copy(tempBounds), this.setAttributes({
        scaleX,
        scaleY,
        angle: angle2
      }), params2.b;
    };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100, bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100, bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const { x: x3 = DefaultTransform.x, y: y3 = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, scaleCenter, anchor, postMatrix } = this.attribute;
    let _anchor = [0, 0];
    const params2 = {};
    if (anchor && (_anchor = this.getAnchor(anchor, params2)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x3, y3, scaleX, scaleY, angle2, anchor && _anchor);
    else {
      const m5 = this._transMatrix;
      m5.reset(), m5.translate(_anchor[0], _anchor[1]), m5.rotate(angle2), m5.translate(-_anchor[0], -_anchor[1]), m5.translate(x3, y3), _anchor = this.getAnchor(scaleCenter, params2), application.transformUtil.fromMatrix(m5, m5).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p2 = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p2.x, this._transMatrix.f += p2.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m22 = this._transMatrix;
      m1.multiply(m22.a, m22.b, m22.c, m22.d, m22.e, m22.f), m22.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach((a4) => {
          a4.setTimeline(timeline);
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {
  }
  onStop(props) {
    props && this.setAttributes(props, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onStep(subAnimate, animate, step, ratio, end) {
    const nextAttributes = {};
    if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);
    else {
      const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;
      this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
    }
    this.setAttributes(nextAttributes, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end,
        step,
        isFirstFrameOfStep: subAnimate.getLastStep() !== step
      }
    }), this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
    propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key) => {
      animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
    }) : propKeys.forEach((key) => {
      var _a;
      if (!animate.validAttr(key)) return;
      const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
      if (null == nextStepVal || null == lastStepVal) return void (nextAttributes[key] = nextStepVal);
      let match;
      match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
    }), step.parsedProps = nextParsedProps;
  }
  defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
    if (Number.isFinite(nextStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, true;
    if ("fill" === key) {
      nextParsedProps || (nextParsedProps = {});
      const fillColorArray = nextParsedProps.fillColorArray, color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.fillColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("stroke" === key) {
      nextParsedProps || (nextParsedProps = {});
      const strokeColorArray = nextParsedProps.strokeColorArray, color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.strokeColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("shadowColor" === key) {
      nextParsedProps || (nextParsedProps = {});
      const shadowColorArray = nextParsedProps.shadowColorArray, color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, true, (fArray, tArray) => {
        nextParsedProps.shadowColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    return false;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
  }
  getDefaultAttribute(name) {
    return getTheme(this)[this.type][name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb, immediate = false) {
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((item) => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString_default(path, true) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image, background = false) {
    if (!image || background && backgroundNotImage(image)) return;
    const url = image;
    this.resources || (this.resources = /* @__PURE__ */ new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl_default(image) || image.includes("/") || isBase64_default(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background);
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach((animate) => {
      animate.stop();
    });
  }
  stopAnimates(stopChildren = false) {
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(true), this.isContainer && stopChildren && this.forEachChildren((c4) => {
      c4.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = false, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
};
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.mixin(EventTarget);

// node_modules/@visactor/vrender-core/es/common/xml/utils.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match; ) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

// node_modules/@visactor/vrender-core/es/common/xml/OrderedObjParser.js
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
};
function findClosingIndex(xmlData, str, i2, errMsg) {
  const closingIndex = xmlData.indexOf(str, i2);
  if (-1 === closingIndex) throw new Error(errMsg);
  return closingIndex + str.length - 1;
}
function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
  let attrBoundary, tagExp = "";
  for (let index = i2; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");
    else if ('"' === ch || "'" === ch) attrBoundary = ch;
    else if (ch === closingChar[0]) {
      if (!closingChar[1]) return {
        data: tagExp,
        index
      };
      if (xmlData[index + 1] === closingChar[1]) return {
        data: tagExp,
        index
      };
    } else "	" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
  const result2 = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
  if (!result2) return;
  let tagExp = result2.data;
  const closeIndex = result2.index, separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp, attrExpPresent = true;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result2.data.substr(colonIndex + 1));
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
var OrderedObjParser = class {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result2 = childNode.tagname;
    "string" == typeof result2 ? (childNode.tagname = result2, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr) return;
    const matches = getAllMatches(attrStr, attrsRegx), len = matches.length;
    for (let i2 = 0; i2 < len; i2++) {
      const attrName = matches[i2][1], oldVal = matches[i2][4], aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj, textData = "", jPath = "";
    for (let i2 = 0; i2 < xmlData.length; i2++) {
      if ("<" === xmlData[i2]) if ("/" === xmlData[i2 + 1]) {
        const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed."), propIndex = jPath.lastIndexOf(".");
        jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i2 = closeIndex;
      } else if ("?" === xmlData[i2 + 1]) {
        i2 = readTagExp(xmlData, i2, false, "?>").closeIndex + 1;
      } else if ("!--" === xmlData.substr(i2 + 1, 3)) {
        i2 = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
      } else {
        const result2 = readTagExp(xmlData, i2, false);
        let tagName = result2.tagName, tagExp = result2.tagExp;
        const attrExpPresent = result2.attrExpPresent, closeIndex = result2.closeIndex;
        if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
          "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
          const childNode = new XmlNode(tagName);
          tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
        } else {
          const childNode = new XmlNode(tagName);
          this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
        }
        textData = "", i2 = closeIndex;
      }
      else textData += xmlData[i2];
    }
    return xmlObj.child;
  }
};

// node_modules/@visactor/vrender-core/es/common/xml/node2json.js
function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i2 = 0; i2 < arr.length; i2++) {
    const tagObj = arr[i2], property = propName(tagObj);
    let newJpath = "";
    if (newJpath = void 0 === jPath ? property : jPath + "." + property, void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property], newJpath);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"], newJpath), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj) {
  const keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    if (":@" !== key) return key;
  }
}
function assignAttributes(obj, attrMap, jpath) {
  if (attrMap) {
    const keys2 = Object.keys(attrMap), len = keys2.length;
    for (let i2 = 0; i2 < len; i2++) {
      const atrrName = keys2[i2];
      obj[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj) {
  return 0 === Object.keys(obj).length;
}

// node_modules/@visactor/vrender-core/es/common/xml/parser.js
var XMLParser = class _XMLParser {
  constructor(options) {
    this.options = Object.assign({}, _XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid) return false;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
};
XMLParser.defaultOptions = {};
function isSvg(str) {
  return str.startsWith("<svg") || str.startsWith("<?xml");
}

// node_modules/@visactor/vrender-core/es/graphic/tools.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function waitForAllSubLayers(stage) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promiseList = [], layers = stage.getChildren();
    yield new Promise((resolve) => {
      application.global.getRequestAnimationFrame()(() => {
        resolve(null);
      });
    }), layers.forEach((l2) => {
      l2.subLayers.size && l2.subLayers.forEach((sl) => {
        sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise((resolve) => {
          sl.drawContribution.hooks.completeDraw.tap("outWait", () => {
            sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter((i2) => "outWait" !== i2.name), resolve(null);
          });
        }));
      });
    }), yield Promise.all(promiseList);
  });
}
function boundStroke(bounds, halfW, miter, pad = 0) {
  return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
var NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function(TextDirection2) {
  TextDirection2[TextDirection2.HORIZONTAL = 0] = "HORIZONTAL", TextDirection2[TextDirection2.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text2) {
  const nextCharacter = [];
  let flag = 0, currStr = "";
  for (let i2 = 0; i2 < text2.length; i2++) rotateText(text2[i2]) ? flag ? currStr += text2[i2] : (flag = 1, currStr = text2[i2]) : (flag && (nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), currStr = "", flag = 0), nextCharacter.push({
    text: text2[i2],
    direction: TextDirection.HORIZONTAL
  }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
var rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"];
var rotateCharMap = /* @__PURE__ */ new Map();
rotateCharList.forEach((c4) => rotateCharMap.set(c4, true));
var noRotateCharList = [""];
var noRotateCharMap = /* @__PURE__ */ new Map();
function rotateText(c4) {
  if (rotateCharMap.has(c4)) return true;
  if (noRotateCharMap.has(c4)) return false;
  let rotate3 = false;
  return c4.codePointAt(0) < 256 && (rotate3 = true), rotate3;
}
noRotateCharList.forEach((c4) => noRotateCharMap.set(c4, true));

// node_modules/@visactor/vrender-core/es/graphic/constants.js
var ARC_NUMBER_TYPE = genNumberType();
var ARC3D_NUMBER_TYPE = genNumberType();
var AREA_NUMBER_TYPE = genNumberType();
var CIRCLE_NUMBER_TYPE = genNumberType();
var GLYPH_NUMBER_TYPE = genNumberType();
var GROUP_NUMBER_TYPE = genNumberType();
var IMAGE_NUMBER_TYPE = genNumberType();
var LINE_NUMBER_TYPE = genNumberType();
var PATH_NUMBER_TYPE = genNumberType();
var POLYGON_NUMBER_TYPE = genNumberType();
var PYRAMID3D_NUMBER_TYPE = genNumberType();
var RECT_NUMBER_TYPE = genNumberType();
var RECT3D_NUMBER_TYPE = genNumberType();
var RICHTEXT_NUMBER_TYPE = genNumberType();
var SYMBOL_NUMBER_TYPE = genNumberType();
var TEXT_NUMBER_TYPE = genNumberType();
var GraphicService = Symbol.for("GraphicService");
var GraphicCreator = Symbol.for("GraphicCreator");
var SVG_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity"
};
var SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
var SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
var SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

// node_modules/@visactor/vrender-core/es/graphic/group.js
var GroupUpdateAABBBoundsMode;
!function(GroupUpdateAABBBoundsMode2) {
  GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
var Group = class _Group extends Graphic {
  constructor(params2) {
    super(params2), this.type = "group", this.parent = null, this.isContainer = true, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode2) {
    "3d" === mode2 ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  setTheme(t2) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t2, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  hideAll() {
    this.setAttribute("visible", false), this.forEachChildren((item) => {
      item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute("visible", false);
    });
  }
  showAll() {
    this.setAttribute("visible", true), this.forEachChildren((item) => {
      item.isContainer && item.showAll ? item.showAll() : item.setAttribute("visible", true);
    });
  }
  containsPoint(x3, y3, mode2) {
    if (mode2 === IContainPointMode.GLOBAL) {
      const point6 = new Point(x3, y3);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point6, point6), this.AABBBounds.contains(point6.x, point6.y);
    }
    return this.AABBBounds.contains(x3, y3);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), bounds;
  }
  doUpdateLocalMatrix() {
    const { x: x3 = DefaultTransform.x, y: y3 = DefaultTransform.y, dx = DefaultTransform.dx, dy = DefaultTransform.dy, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, postMatrix } = this.attribute;
    if (0 !== x3 || 0 !== y3 || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle2 || postMatrix) return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  doUpdateAABBBounds() {
    const attribute = this.attribute, groupTheme = getTheme(this).group;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const bounds = application.graphicService.updateGroupAABBBounds(attribute, groupTheme, this._AABBBounds, this), { boundsPadding = groupTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
  }
  appendChild(node, addStage = true) {
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    const data = super.insertBefore(newNode, referenceNode);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertAfter(newNode, referenceNode) {
    const data = super.insertAfter(newNode, referenceNode);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertInto(newNode, idx) {
    const data = super.insertInto(newNode, idx);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
  }
  removeAllChild() {
    this.forEachChildren((child) => {
      application.graphicService.onRemove(child);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren((item) => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren((g3) => {
      g3.isContainer && g3.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren((g3) => {
      g3.isContainer && g3.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m5 = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find((node) => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new _Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Group.NOWORK_ANIMATE_ATTR;
  }
};
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

// node_modules/@visactor/vrender-core/es/core/layer.js
var Layer = class extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("暂不支持");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global, window2, params2) {
    var _a;
    super({}), this.stage = stage, this.global = global, this.window = window2, this.main = params2.main, this.layerHandler = params2.layerHandler, this.layerHandler.init(this, window2, {
      main: params2.main,
      canvasId: params2.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params2.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = /* @__PURE__ */ new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer(removeIncrementalKey = true) {
    const subLayers = Array.from(this.subLayers.values()).sort((a4, b2) => a4.zIndex - b2.zIndex);
    this.layerHandler.merge(subLayers.map((l2) => (l2.layer.subLayers.size && l2.layer.combineSubLayer(removeIncrementalKey), l2.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach((l2) => {
      l2.group && (l2.group.incremental = 0);
    }), subLayers.forEach((l2) => {
      application.layerService.releaseLayer(this.stage, l2.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x3, y3) {
    throw new Error("暂不支持");
  }
  tryRenderSecondaryLayer(params2, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach((h2) => {
      h2.layer.renderCount = this.renderCount, h2.layer.render(params2, userParams);
    });
  }
  render(params2, userParams) {
    var _a;
    const stage = this.stage;
    this.layerHandler.render([this], {
      renderService: params2.renderService,
      x: stage.x,
      y: stage.y,
      width: this.viewWidth,
      height: this.viewHeight,
      stage: this.stage,
      layer: this,
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params2.updateBounds
    }, userParams), this.afterDrawCbs.forEach((c4) => c4(this)), this.tryRenderSecondaryLayer(params2, userParams);
  }
  resize(w2, h2) {
    this.layerHandler.resize(w2, h2);
  }
  resizeView(w2, h2) {
    this.layerHandler.resizeView(w2, h2);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t2) {
    throw new Error("暂不支持");
  }
  setToFrame(t2) {
    throw new Error("暂不支持");
  }
  prepare(dirtyBounds, params2) {
  }
  combineTo(target, params2) {
    var _a, _b, _c;
    this.offscreen && (this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      renderService: params2.renderService,
      x: null !== (_b = params2.x) && void 0 !== _b ? _b : this.stage.x,
      y: null !== (_c = params2.y) && void 0 !== _c ? _c : this.stage.y,
      width: this.viewWidth,
      height: this.viewHeight,
      stage: this.stage,
      layer: this
    }, params2)), this.afterDrawCbs.forEach((c4) => c4(this)));
  }
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l2) => {
      application.layerService.releaseLayer(this.stage, l2.layer);
    });
  }
  drawTo(target, params2) {
    var _a, _b, _c;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      renderService: params2.renderService,
      x: null !== (_b = params2.x) && void 0 !== _b ? _b : this.stage.x,
      y: null !== (_c = params2.y) && void 0 !== _c ? _c : this.stage.y,
      width: this.viewWidth,
      height: this.viewHeight,
      stage: this.stage,
      layer: this
    }, params2)), this.afterDrawCbs.forEach((c4) => c4(this));
  }
};

// node_modules/@visactor/vrender-core/es/core/constants.js
var TransformUtil = Symbol.for("TransformUtil");
var GraphicUtil = Symbol.for("GraphicUtil");
var LayerService = Symbol.for("LayerService");
var StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
var DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
var VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

// node_modules/@visactor/vrender-core/es/core/layer-service.js
var DefaultLayerService_1;
var __decorate6 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata4 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = /* @__PURE__ */ new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = true);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage, options = {
    main: false
  }) {
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode), layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
      main: false
    }, options), {
      layerMode,
      canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
      layerHandler
    })), stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren((l2) => {
      const handler = l2.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter((l2) => l2 !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate6([injectable(), __metadata4("design:paramtypes", [])], DefaultLayerService);

// node_modules/@visactor/vrender-core/es/core/core-modules.js
var core_modules_default = new ContainerModule((bind) => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/utils.js
function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke2, lineWidth) {
  let s3;
  return s3 = isArray_default(stroke2) ? stroke2.some((item) => item || void 0 === item) : !!stroke2, s3 && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height) {
  return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function drawPathProxy(graphic, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
  if (!graphic.pathProxy) return false;
  const themeAttributes = getTheme(graphic, null == params2 ? void 0 : params2.theme)[graphic.type], { fill = themeAttributes.fill, stroke: stroke2 = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
  if (!visible) return true;
  if (!doFill && !doStroke) return true;
  if (!(fVisible || sVisible || fillCb || strokeCb)) return true;
  context.beginPath();
  const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
  return renderCommandList(path.commandList, context, x3, y3), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x3, y3, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x3, y3, themeAttributes), context.fill())), true;
}
function intersect(x05, y05, x14, y14, x23, y23, x3, y3) {
  const x10 = x14 - x05, y10 = y14 - y05, x32 = x3 - x23, y32 = y3 - y23;
  let t2 = y32 * x10 - x32 * y10;
  return t2 * t2 < epsilon ? [] : (t2 = (x32 * (y05 - y23) - y32 * (x05 - x23)) / t2, [x05 + t2 * x10, y05 + t2 * y10]);
}
function cornerTangents(x05, y05, x14, y14, r1, rc, clockwise) {
  const x01 = x05 - x14, y01 = y05 - y14, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x112 = x05 + ox, y112 = y05 + oy, x10 = x14 + ox, y10 = y14 + oy, x004 = (x112 + x10) / 2, y004 = (y112 + y10) / 2, dx = x10 - x112, dy = y10 - y112, d2 = dx * dx + dy * dy, r2 = r1 - rc, D2 = x112 * y10 - x10 * y112, d3 = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r2 * r2 * d2 - D2 * D2));
  let cx0 = (D2 * dy - dx * d3) / d2, cy0 = (-D2 * dx - dy * d3) / d2;
  const cx1 = (D2 * dy + dx * d3) / d2, cy1 = (-D2 * dx + dy * d3) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp3 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp3;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));
  else {
    const cornerRadius = arc.getParsedCornerRadius(), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    let xore, yore, xirs, yirs;
    if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
      const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
      if (oc) {
        const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
      }
    }
    if (outerDeltaAngle < 1e-3) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = true;
    else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

// node_modules/@visactor/vrender-core/es/canvas/conical-gradient.js
var ConicalCanvas = class _ConicalCanvas {
  static GetCanvas() {
    try {
      return _ConicalCanvas.canvas || (_ConicalCanvas.canvas = application.global.createCanvas({})), _ConicalCanvas.canvas;
    } catch (err) {
      return null;
    }
  }
  static GetCtx() {
    if (!_ConicalCanvas.ctx) {
      const conicalCanvas = _ConicalCanvas.GetCanvas();
      _ConicalCanvas.ctx = conicalCanvas.getContext("2d");
    }
    return _ConicalCanvas.ctx;
  }
};
var ColorInterpolate = class _ColorInterpolate extends LRU {
  static getInstance() {
    return _ColorInterpolate._instance || (_ColorInterpolate._instance = new _ColorInterpolate()), _ColorInterpolate._instance;
  }
  constructor(stops = [], precision = 100) {
    super(), this.cacheParams = {
      CLEAN_THRESHOLD: 100,
      L_TIME: 1e3
    }, this.dataMap = /* @__PURE__ */ new Map();
    const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
    if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;
    if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
    const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
    stops.forEach((stop) => {
      gradient.addColorStop(stop[0], stop[1]);
    }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
  }
  getColor(offset) {
    const rgba2 = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
    return `rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, ${rgba2[3] / 255})`;
  }
  GetOrCreate(x3, y3, w2, h2, stops = [], precision = 100) {
    let str = `${x3}${y3}${w2}${h2}`;
    stops.forEach((item) => str += item.join()), str += precision;
    let colorInter = this.dataMap.get(str);
    if (!colorInter) {
      colorInter = {
        data: new _ColorInterpolate(stops, precision),
        timestamp: []
      }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
    }
    return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
  }
};
var ConicalPatternStore = class _ConicalPatternStore {
  static GetSize(minSize) {
    for (let i2 = 0; i2 < _ConicalPatternStore.ImageSize.length; i2++) if (_ConicalPatternStore.ImageSize[i2] >= minSize) return _ConicalPatternStore.ImageSize[i2];
    return minSize;
  }
  static Get(stops, x3, y3, startAngle, endAngle, w2, h2) {
    const key = _ConicalPatternStore.GenKey(stops, x3, y3, startAngle, endAngle), data = _ConicalPatternStore.cache[key];
    if (!data || 0 === data.length) return null;
    for (let i2 = 0; i2 < data.length; i2++) if (data[i2].width >= w2 && data[i2].height >= h2) return data[i2].pattern;
    return null;
  }
  static Set(stops, x3, y3, startAngle, endAngle, pattern, w2, h2) {
    const key = _ConicalPatternStore.GenKey(stops, x3, y3, startAngle, endAngle);
    _ConicalPatternStore.cache[key] ? _ConicalPatternStore.cache[key].push({
      width: w2,
      height: h2,
      pattern
    }) : _ConicalPatternStore.cache[key] = [{
      width: w2,
      height: h2,
      pattern
    }];
  }
  static GenKey(stops, x3, y3, startAngle, endAngle) {
    return `${x3},${y3},${startAngle},${endAngle},${stops.join()}`;
  }
};
ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x3, y3, angle2, color) {
  const { stops, startAngle, endAngle } = color;
  for (; angle2 < 0; ) angle2 += pi2;
  for (; angle2 > pi2; ) angle2 -= pi2;
  if (angle2 < startAngle) return stops[0].color;
  if (angle2 > endAngle) return stops[0].color;
  let startStop, endStop, percent = (angle2 - startAngle) / (endAngle - startAngle);
  for (let i2 = 0; i2 < stops.length; i2++) if (stops[i2].offset >= percent) {
    startStop = stops[i2 - 1], endStop = stops[i2];
    break;
  }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, false);
}
function createConicalGradient(context, stops, x3, y3, deltaAngle, startAngle, endAngle, minW, minH) {
  const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
  if (!conicalCtx) return null;
  const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);
  let pattern = ConicalPatternStore.Get(stops, x3, y3, startAngle, endAngle, width, height);
  if (pattern) return pattern;
  const r2 = Math.sqrt(Math.max(Math.max(Math.pow(x3, 2) + Math.pow(y3, 2), Math.pow(width - x3, 2) + Math.pow(y3, 2)), Math.max(Math.pow(width - x3, 2) + Math.pow(height - y3, 2), Math.pow(x3, 2) + Math.pow(height - y3, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.getInstance().GetOrCreate(x3, y3, width, height, stops, stepNum), lineWidth = 2 * Math.PI * r2 / 360;
  conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x3, y3), conicalCtx.rotate(startAngle);
  for (let i2 = 0, len = stepNum - 1; i2 < len && !(startAngle + i2 * step > endAngle); i2++) {
    const color = colorInter.getColor(i2);
    conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r2, -2 * lineWidth), conicalCtx.lineTo(r2, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
  }
  const imageData = conicalCtx.getImageData(0, 0, width, height);
  return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x3, y3, startAngle, endAngle, pattern, width, height), pattern;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/constants.js
var ArcRenderContribution = Symbol.for("ArcRenderContribution");
var AreaRenderContribution = Symbol.for("AreaRenderContribution");
var CircleRenderContribution = Symbol.for("CircleRenderContribution");
var GroupRenderContribution = Symbol.for("GroupRenderContribution");
var ImageRenderContribution = Symbol.for("ImageRenderContribution");
var PathRenderContribution = Symbol.for("PathRenderContribution");
var PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
var RectRenderContribution = Symbol.for("RectRenderContribution");
var SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
var TextRenderContribution = Symbol.for("TextRenderContribution");
var CommonRenderContribution = Symbol.for("CommonRenderContribution");
var InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

// node_modules/@visactor/vrender-core/es/graphic/circle.js
var CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
var Circle = class _Circle extends Graphic {
  constructor(params2 = {
    radius: 1
  }) {
    super(params2), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, radius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  doUpdateAABBBounds(full) {
    const circleTheme = getTheme(this).circle;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateCircleAABBBounds(attribute, getTheme(this).circle, this._AABBBounds, full, this), { boundsPadding = circleTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).circle[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"), path = new CustomPath2D();
    return path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new _Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Circle.NOWORK_ANIMATE_ATTR;
  }
};
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

// node_modules/@visactor/vrender-core/es/common/text.js
function getContextFont2(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}
function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - 0.79 * fontSize);
}

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/layout.js
var CanvasTextLayout = class {
  constructor(fontFamily, options, textMeasure) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
  }
  LayoutBBox(bbox, textAlign, textBaseline) {
    if ("left" === textAlign || "start" === textAlign) bbox.xOffset = 0;
    else if ("center" === textAlign) bbox.xOffset = bbox.width / -2;
    else {
      if ("right" !== textAlign && "end" !== textAlign) throw new Error("非法的textAlign");
      bbox.xOffset = -bbox.width;
    }
    return bbox.yOffset = "top" === textBaseline ? 0 : "middle" === textBaseline ? bbox.height / -2 : "alphabetic" === textBaseline ? -0.79 * bbox.height : -bbox.height, bbox;
  }
  GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, wordBreak, suffixPosition) {
    const linesLayout = [], bboxWH = [width, height], bboxOffset = [0, 0];
    for (; str.length > 0; ) {
      const { str: clipText } = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix, wordBreak, suffixPosition);
      linesLayout.push({
        str: clipText,
        width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
      }), str = str.substring(clipText.length);
    }
    "left" === textAlign || "start" === textAlign || ("center" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : "right" !== textAlign && "end" !== textAlign || (bboxOffset[0] = -bboxWH[0])), "top" === textBaseline || ("middle" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : "bottom" === textBaseline && (bboxOffset[1] = -bboxWH[1]));
    const bbox = {
      xOffset: bboxOffset[0],
      yOffset: bboxOffset[1],
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, lineWidth, suffixPosition = "end") {
    lines = lines.map((l2) => l2.toString());
    const linesLayout = [], bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i2 = 0, len = lines.length; i2 < len; i2++) width = Math.min(this.textMeasure.measureTextWidth(lines[i2], this.textOptions), lineWidth), linesLayout.push({
        str: this.textMeasure.clipTextWithSuffix(lines[i2], this.textOptions, width, suffix, wordBreak, suffixPosition).str,
        width
      });
      bboxWH[0] = lineWidth;
    } else {
      let width, text2;
      lineWidth = 0;
      for (let i2 = 0, len = lines.length; i2 < len; i2++) text2 = lines[i2], width = this.textMeasure.measureTextWidth(text2, this.textOptions), lineWidth = Math.max(lineWidth, width), linesLayout.push({
        str: text2,
        width
      });
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a4, b2) => Math.max(a4, b2.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0], totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i2 = 0; i2 < lines.length; i2++) this.lineOffset(bbox, lines[i2], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox,
      lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight,
      textAlign,
      textBaseline
    };
  }
  lineOffset(bbox, line2, textAlign, textBaseline, lineHeight, origin) {
    return "left" === textAlign || "start" === textAlign ? line2.leftOffset = 0 : "center" === textAlign ? line2.leftOffset = (bbox.width - line2.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line2.leftOffset = bbox.width - line2.width), line2.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + 0.79 * this.textOptions.fontSize + origin[1], origin[1] += lineHeight, line2;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/text.js
var TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
var Text = class _Text extends Graphic {
  get font() {
    const textTheme = getTheme(this).text;
    return this._font || (this._font = getContextFont2(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute, textTheme = getTheme(this).text;
    if (!this.isSimplify()) return;
    const { maxLineWidth = textTheme.maxLineWidth } = attribute;
    return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    if (this.isSimplify()) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    const textTheme = getTheme(this).text, attribute = this.attribute;
    if (this.isMultiLine) return;
    const { maxLineWidth = textTheme.maxLineWidth } = attribute;
    return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map((item) => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString());
  }
  get multilineLayout() {
    if (this.isMultiLine) return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  isSimplify() {
    return !this.isMultiLine && "vertical" !== this.attribute.direction;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor(params2 = {
    text: "",
    fontSize: 16
  }) {
    super(params2), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t2) => null == t2 || "" === t2) : null != text2 && "" !== text2;
  }
  doUpdateAABBBounds() {
    const textTheme = getTheme(this).text;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this), { boundsPadding = textTheme.boundsPadding } = this.attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updateWrapAABBBounds(text2) {
    var _a, _b, _c, _d;
    const textTheme = getTheme(this).text, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, suffixPosition = textTheme.suffixPosition, heightLimit = 0, lineClamp } = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure), lines = isArray_default(text2) ? text2.map((l2) => l2.toString()) : [text2.toString()], linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i2 = 0; i2 < lines.length; i2++) {
        const str = lines[i2];
        let needCut = true;
        if (i2 === lineCountLimit - 1) {
          const clip2 = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width
        }), clip.str.length === str.length) ;
        else if (needCut) {
          const newStr = str.substring(clip.str.length);
          lines.splice(i2 + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout2) => {
        maxWidth = Math.max(maxWidth, layout2.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i2 = 0, len = lines.length; i2 < len; i2++) {
        if (i2 === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i2], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i2], width = layoutObj.textMeasure.measureTextWidth(text3, layoutObj.textOptions, "break-word" === wordBreak), lineWidth2 = Math.max(lineWidth2, width), linesLayout.push({
          str: text3,
          width
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateSingallineAABBBounds(text2) {
    const textTheme = getTheme(this).text, { direction: direction2 = textTheme.direction } = this.attribute;
    return "horizontal" === direction2 ? this.updateHorizontalSinglelineAABBBounds(text2) : this.updateVerticalSinglelineAABBBounds(text2);
  }
  updateMultilineAABBBounds(text2) {
    const textTheme = getTheme(this).text, { direction: direction2 = textTheme.direction } = this.attribute;
    return "horizontal" === direction2 ? this.updateHorizontalMultilineAABBBounds(text2) : this.updateVerticalMultilineAABBBounds(text2);
  }
  updateHorizontalSinglelineAABBBounds(text2) {
    var _a, _b;
    const textTheme = getTheme(this).text, { wrap = textTheme.wrap } = this.attribute;
    if (wrap) return this.updateWrapAABBBounds([text2]);
    const textMeasure = application.graphicUtil.textMeasure;
    let width, str;
    const attribute = this.attribute, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, ignoreBuf = textTheme.ignoreBuf, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition } = attribute;
    if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text2);
    const buf = ignoreBuf ? 0 : Math.max(2, 0.075 * fontSize), textFontSize = attribute.fontSize || textTheme.fontSize, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, textFontSize)) && void 0 !== _a ? _a : textFontSize + buf;
    if (!this.shouldUpdateShape() && this.cache) {
      width = null !== (_b = this.cache.clipedWidth) && void 0 !== _b ? _b : 0;
      const dx2 = textDrawOffsetX(textAlign, width), dy2 = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
      return this._AABBBounds.set(dx2, dy2, dx2 + width, dy2 + lineHeight), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    if (Number.isFinite(maxLineWidth)) {
      if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffix(text2.toString(), {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        str = data.str, width = data.width;
      } else {
        const data = textMeasure.clipText(text2.toString(), {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        str = data.str, width = data.width;
      }
      this.cache.clipedText = str, this.cache.clipedWidth = width;
    } else width = textMeasure.measureTextWidth(text2.toString(), {
      fontSize,
      fontWeight,
      fontFamily
    }), this.cache.clipedText = text2.toString(), this.cache.clipedWidth = width;
    this.clearUpdateShapeTag();
    const dx = textDrawOffsetX(textAlign, width);
    let lh = lineHeight;
    application.global && application.global.isSafari() && (lh += 0.2 * fontSize);
    const dy = textLayoutOffsetY(textBaseline, lh, fontSize, buf);
    return this._AABBBounds.set(dx, dy, dx + width, dy + lh), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getBaselineMapAlign() {
    return _Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return _Text.alignMapBaseline;
  }
  updateVerticalSinglelineAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { ignoreBuf = textTheme.ignoreBuf } = attribute, buf = ignoreBuf ? 0 : 2, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, fontFamily = textTheme.fontFamily, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t2 = textAlign;
      textAlign = null !== (_b = _Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = _Text.alignMapBaseline[t2]) && void 0 !== _c ? _c : "top";
    }
    if (!this.shouldUpdateShape() && this.cache) {
      width = this.cache.clipedWidth;
      const dx2 = textDrawOffsetX(textAlign, width), dy2 = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + lineHeight, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    let verticalList = [verticalLayout(text2.toString())];
    if (Number.isFinite(maxLineWidth)) {
      if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalList[0], {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        verticalList = [data.verticalList], width = data.width;
      } else {
        const data = textMeasure.clipTextVertical(verticalList[0], {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        verticalList = [data.verticalList], width = data.width;
      }
      this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
    } else width = 0, verticalList[0].forEach((t2) => {
      const w2 = t2.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t2.text, {
        fontSize,
        fontWeight,
        fontFamily
      });
      width += w2, t2.width = w2;
    }), this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
    this.clearUpdateShapeTag();
    const dx = textDrawOffsetX(textAlign, width), dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
    return this._AABBBounds.set(dy, dx, dy + lineHeight, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateHorizontalMultilineAABBBounds(text2) {
    var _a, _b;
    const textTheme = getTheme(this).text, { wrap = textTheme.wrap } = this.attribute;
    if (wrap) return this.updateWrapAABBBounds(text2);
    const attribute = this.attribute, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : attribute.fontSize || textTheme.fontSize;
    if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text2);
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutData = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure).GetLayoutByLines(text2, textAlign, textBaseline, lineHeight, true === ellipsis ? textTheme.ellipsis : ellipsis || void 0, false, maxLineWidth, suffixPosition), { bbox } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { ignoreBuf = textTheme.ignoreBuf } = attribute, buf = ignoreBuf ? 0 : 2, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t2 = textAlign;
      textAlign = null !== (_b = _Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = _Text.alignMapBaseline[t2]) && void 0 !== _c ? _c : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach((item) => {
        const w2 = item.reduce((a4, b2) => a4 + b2.width, 0);
        width = max(w2, width);
      });
      const dx2 = textDrawOffsetX(textAlign, width), height2 = this.cache.verticalList.length * lineHeight, dy2 = textLayoutOffsetY(textBaseline, height2, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + height2, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text2.map((str) => verticalLayout(str.toString()));
    verticalLists.forEach((verticalData, i2) => {
      if (Number.isFinite(maxLineWidth)) if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        verticalLists[i2] = data.verticalList, width = data.width;
      } else {
        const data = textMeasure.clipTextVertical(verticalData, {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        verticalLists[i2] = data.verticalList, width = data.width;
      }
      else width = 0, verticalData.forEach((t2) => {
        const w2 = t2.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t2.text, {
          fontSize,
          fontWeight,
          fontFamily
        });
        width += w2, t2.width = w2;
      });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach((item) => {
      const w2 = item.reduce((a4, b2) => a4 + b2.width, 0);
      width = max(w2, width);
    });
    const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).text[name];
  }
  needUpdateTags(keys2, k3 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(keys2, k3);
  }
  needUpdateTag(key, k3 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(key, k3);
  }
  clone() {
    return new _Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Text.NOWORK_ANIMATE_ATTR;
  }
};
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/wrap-text.js
var WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
var WrapText = class _WrapText extends Text {
  constructor(params2) {
    super(Object.assign(Object.assign({}, params2), {
      wrap: true
    }));
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t2) => null == t2 || "" === t2) : null != text2 && "" !== text2;
  }
  updateMultilineAABBBounds(text2) {
    var _a, _b, _c, _d;
    const textTheme = getTheme(this).text, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, heightLimit = 0, suffixPosition = textTheme.suffixPosition, lineClamp } = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure), lines = text2.map((l2) => l2.toString()), linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i2 = 0; i2 < lines.length; i2++) {
        const str = lines[i2];
        let needCut = true;
        if (i2 === lineCountLimit - 1) {
          const clip2 = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip2.str,
            width: clip2.width
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = false;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width
        }), clip.str.length === str.length) ;
        else if (needCut) {
          const newStr = str.substring(clip.str.length);
          lines.splice(i2 + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach((layout2) => {
        maxWidth = Math.max(maxWidth, layout2.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i2 = 0, len = lines.length; i2 < len; i2++) {
        if (i2 === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i2], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i2], width = layoutObj.textMeasure.measureTextWidth(text3, layoutObj.textOptions, "break-word" === wordBreak), lineWidth2 = Math.max(lineWidth2, width), linesLayout.push({
          str: text3,
          width
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  needUpdateTags(keys2) {
    for (let i2 = 0; i2 < WRAP_TEXT_UPDATE_TAG_KEY.length; i2++) {
      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i2];
      if (-1 !== keys2.indexOf(attrKey)) return true;
    }
    return super.needUpdateTags(keys2);
  }
  needUpdateTag(key) {
    for (let i2 = 0; i2 < WRAP_TEXT_UPDATE_TAG_KEY.length; i2++) {
      if (key === WRAP_TEXT_UPDATE_TAG_KEY[i2]) return true;
    }
    return super.needUpdateTag(key);
  }
  getNoWorkAnimateAttr() {
    return _WrapText.NOWORK_ANIMATE_ATTR;
  }
};
function createWrapText(attributes) {
  return new WrapText(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/base.js
var BaseSymbol = class {
  bounds(size, bounds) {
    if (isNumber_default(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/circle.js
function circle2(ctx, r2, x3, y3, z2) {
  return z2 ? ctx.arc(x3, y3, r2, 0, tau, false, z2) : ctx.arc(x3, y3, r2, 0, tau), false;
}
var CircleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x3, y3, z2) {
    return circle2(ctx, size / 2, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return circle2(ctx, size / 2 + offset, x3, y3, z2);
  }
  drawToSvgPath(size, x3, y3, z2) {
    const r2 = size / 2;
    return `M ${x3 - r2}, ${y3} a ${r2},${r2} 0 1,0 ${2 * r2},0 a ${r2},${r2} 0 1,0 -${2 * r2},0`;
  }
};
var circle_default3 = new CircleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/cross.js
function cross(ctx, r2, x3, y3, z2) {
  return ctx.moveTo(-3 * r2 + x3, -r2 + y3, z2), ctx.lineTo(-r2 + x3, -r2 + y3, z2), ctx.lineTo(-r2 + x3, -3 * r2 + y3, z2), ctx.lineTo(r2 + x3, -3 * r2 + y3, z2), ctx.lineTo(r2 + x3, -r2 + y3, z2), ctx.lineTo(3 * r2 + x3, -r2 + y3, z2), ctx.lineTo(3 * r2 + x3, r2 + y3, z2), ctx.lineTo(r2 + x3, r2 + y3, z2), ctx.lineTo(r2 + x3, 3 * r2 + y3, z2), ctx.lineTo(-r2 + x3, 3 * r2 + y3, z2), ctx.lineTo(-r2 + x3, r2 + y3, z2), ctx.lineTo(-3 * r2 + x3, r2 + y3, z2), ctx.closePath(), true;
}
function crossOffset(ctx, r2, x3, y3, offset, z2) {
  return ctx.moveTo(-3 * r2 + x3 - offset, -r2 + y3 - offset, z2), ctx.lineTo(-r2 + x3 - offset, -r2 + y3 - offset, z2), ctx.lineTo(-r2 + x3 - offset, -3 * r2 + y3 - offset, z2), ctx.lineTo(r2 + x3 + offset, -3 * r2 + y3 - offset, z2), ctx.lineTo(r2 + x3 + offset, -r2 + y3 - offset, z2), ctx.lineTo(3 * r2 + x3 + offset, -r2 + y3 - offset, z2), ctx.lineTo(3 * r2 + x3 + offset, r2 + y3 + offset, z2), ctx.lineTo(r2 + x3 + offset, r2 + y3 + offset, z2), ctx.lineTo(r2 + x3 + offset, 3 * r2 + y3 + offset, z2), ctx.lineTo(-r2 + x3 - offset, 3 * r2 + y3 + offset, z2), ctx.lineTo(-r2 + x3 - offset, r2 + y3 + offset, z2), ctx.lineTo(-3 * r2 + x3 - offset, r2 + y3 + offset, z2), ctx.closePath(), true;
}
var CrossSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x3, y3, z2) {
    return cross(ctx, size / 6, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return crossOffset(ctx, size / 6, x3, y3, offset, z2);
  }
};
var cross_default = new CrossSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/diamond.js
function diamond(ctx, r2, x3, y3, z2) {
  return ctx.moveTo(x3, y3 - r2, z2), ctx.lineTo(r2 + x3, y3, z2), ctx.lineTo(x3, y3 + r2, z2), ctx.lineTo(x3 - r2, y3, z2), ctx.closePath(), true;
}
var DiamondSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x3, y3, z2) {
    return diamond(ctx, size / 2, x3, y3, z2);
  }
  drawFitDir(ctx, size, x3, y3, z2) {
    return diamond(ctx, size / 2, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return diamond(ctx, size / 2 + offset, x3, y3, z2);
  }
};
var diamond_default = new DiamondSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/square.js
function square(ctx, r2, x3, y3) {
  const wh = 2 * r2;
  return ctx.rect(x3 - r2, y3 - r2, wh, wh), false;
}
var SquareSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x3, y3) {
    return square(ctx, size / 2, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return square(ctx, size / 2 + offset, x3, y3);
  }
};
var square_default = new SquareSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-up.js
function trianglUp(ctx, r2, x3, y3) {
  return ctx.moveTo(x3 + r2, r2 + y3), ctx.lineTo(x3 - r2, r2 + y3), ctx.lineTo(x3, y3 - r2), ctx.closePath(), true;
}
function trianglUpOffset(ctx, r2, x3, y3, offset) {
  return ctx.moveTo(x3 + r2 + 2 * offset, r2 + y3 + offset), ctx.lineTo(x3 - r2 - 2 * offset, r2 + y3 + offset), ctx.lineTo(x3, y3 - r2 - 2 * offset), ctx.closePath(), true;
}
var TriangleUpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x3, y3) {
    return trianglUp(ctx, size / 2, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return trianglUpOffset(ctx, size / 2, x3, y3, offset);
  }
};
var triangle_up_default = new TriangleUpSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle.js
var TriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
};
var triangle_default = new TriangleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/star.js
var kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;
function star(ctx, r2, transX, transY) {
  const x3 = kx * r2, y3 = ky * r2;
  ctx.moveTo(transX, -r2 + transY), ctx.lineTo(x3 + transX, y3 + transY);
  for (let i2 = 1; i2 < 5; ++i2) {
    const a4 = tau * i2 / 5, c4 = Math.cos(a4), s3 = Math.sin(a4);
    ctx.lineTo(s3 * r2 + transX, -c4 * r2 + transY), ctx.lineTo(c4 * x3 - s3 * y3 + transX, s3 * x3 + c4 * y3 + transY);
  }
  return ctx.closePath(), true;
}
var StarSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, size / 2 + offset, transX, transY);
  }
};
var star_default = new StarSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow.js
var sqrt3 = sqrt(3);
function arrow(ctx, r2, transX, transY) {
  const triangleH = r2, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r2;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), true;
}
var ArrowSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, size / 2 + offset, transX, transY);
  }
};
var arrow_default = new ArrowSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wedge.js
function wedge(ctx, r2, transX, transY) {
  const h2 = 2 * r2;
  return ctx.moveTo(transX, -r2 + transY), ctx.lineTo(h2 / 3 / 2 + transX, r2 + transY), ctx.lineTo(-h2 / 3 / 2 + transX, r2 + transY), ctx.closePath(), true;
}
var WedgeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, size / 2 + offset, transX, transY);
  }
};
var wedge_default = new WedgeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/stroke.js
function stroke(ctx, r2, transX, transY) {
  return ctx.moveTo(-r2 + transX, transY), ctx.lineTo(transX, r2 + transY), false;
}
var StrokeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, size / 2 + offset, transX, transY);
  }
};
var stroke_default = new StrokeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/wye.js
var c = -0.5;
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = 3 * (k / 2 + 1);
function wye(ctx, r2, transX, transY) {
  const x05 = r2 / 2, y05 = r2 * k, x14 = x05, y14 = r2 * k + r2, x23 = -x14, y23 = y14;
  return ctx.moveTo(x05 + transX, y05 + transY), ctx.lineTo(x14 + transX, y14 + transY), ctx.lineTo(x23 + transX, y23 + transY), ctx.lineTo(c * x05 - s * y05 + transX, s * x05 + c * y05 + transY), ctx.lineTo(c * x14 - s * y14 + transX, s * x14 + c * y14 + transY), ctx.lineTo(c * x23 - s * y23 + transX, s * x23 + c * y23 + transY), ctx.lineTo(c * x05 + s * y05 + transX, c * y05 - s * x05 + transY), ctx.lineTo(c * x14 + s * y14 + transX, c * y14 - s * x14 + transY), ctx.lineTo(c * x23 + s * y23 + transX, c * y23 - s * x23 + transY), ctx.closePath(), false;
}
var WyeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, size / 2 + offset, transX, transY);
  }
};
var wye_default = new WyeSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-left.js
function trianglLeft(ctx, r2, x3, y3) {
  return ctx.moveTo(-r2 + x3, y3), ctx.lineTo(r2 + x3, r2 + y3), ctx.lineTo(r2 + x3, y3 - r2), ctx.closePath(), true;
}
function trianglLeftOffset(ctx, r2, x3, y3, offset) {
  return ctx.moveTo(-r2 + x3 - 2 * offset, y3), ctx.lineTo(r2 + x3 + offset, r2 + y3 + 2 * offset), ctx.lineTo(r2 + x3 + offset, y3 - r2 - 2 * offset), ctx.closePath(), true;
}
var TriangleLeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x3, y3) {
    return trianglLeft(ctx, size / 2, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return trianglLeftOffset(ctx, size / 2, x3, y3, offset);
  }
};
var triangle_left_default = new TriangleLeftSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-right.js
function trianglRight(ctx, r2, x3, y3) {
  return ctx.moveTo(x3 - r2, r2 + y3), ctx.lineTo(r2 + x3, y3), ctx.lineTo(x3 - r2, y3 - r2), ctx.closePath(), true;
}
function trianglRightOffset(ctx, r2, x3, y3, offset) {
  return ctx.moveTo(x3 - r2 - offset, r2 + y3 + 2 * offset), ctx.lineTo(r2 + x3 + 2 * offset, y3), ctx.lineTo(x3 - r2 - offset, y3 - r2 - 2 * offset), ctx.closePath(), true;
}
var TriangleRightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x3, y3) {
    return trianglRight(ctx, size / 2, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return trianglRightOffset(ctx, size / 2, x3, y3, offset);
  }
};
var triangle_right_default = new TriangleRightSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/triangle-down.js
function trianglDown(ctx, r2, x3, y3) {
  return ctx.moveTo(x3 - r2, y3 - r2), ctx.lineTo(x3 + r2, y3 - r2), ctx.lineTo(x3, y3 + r2), ctx.closePath(), true;
}
function trianglDownOffset(ctx, r2, x3, y3, offset) {
  return ctx.moveTo(x3 - r2 - 2 * offset, y3 - r2 - offset), ctx.lineTo(x3 + r2 + 2 * offset, y3 - r2 - offset), ctx.lineTo(x3, y3 + r2 + 2 * offset), ctx.closePath(), true;
}
var TriangleDownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x3, y3) {
    return trianglDown(ctx, size / 2, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return trianglDownOffset(ctx, size / 2, x3, y3, offset);
  }
};
var triangle_down_default = new TriangleDownSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/thin-triangle.js
var sqrt32 = sqrt(3);
function thinTriangle(ctx, r2, x3, y3) {
  const h2 = r2 * sqrt32;
  return ctx.moveTo(x3, y3 + -h2 / 3 * 2), ctx.lineTo(r2 + x3, y3 + h2), ctx.lineTo(x3 - r2, y3 + h2), ctx.closePath(), true;
}
var ThinTriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x3, y3) {
    return thinTriangle(ctx, size / 2 / sqrt32, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return thinTriangle(ctx, size / 2 / sqrt32 + offset, x3, y3);
  }
};
var thin_triangle_default = new ThinTriangleSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-left.js
function arrow2Left(ctx, r2, transX, transY) {
  const r22 = 2 * r2;
  return ctx.moveTo(r2 + transX, transY - r22), ctx.lineTo(transX - r2, transY), ctx.lineTo(r2 + transX, r22 + transY), true;
}
var Arrow2LeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_left_default = new Arrow2LeftSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-right.js
function arrow2Right(ctx, r2, transX, transY) {
  const r22 = 2 * r2;
  return ctx.moveTo(transX - r2, transY - r22), ctx.lineTo(transX + r2, transY), ctx.lineTo(transX - r2, r22 + transY), true;
}
var Arrow2RightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_right_default = new Arrow2RightSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-up.js
function arrow2Up(ctx, r2, transX, transY) {
  const r22 = 2 * r2;
  return ctx.moveTo(transX - r22, transY + r2), ctx.lineTo(transX, transY - r2), ctx.lineTo(transX + r22, transY + r2), true;
}
var Arrow2UpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_up_default = new Arrow2UpSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/arrow2-down.js
function arrow2Down(ctx, r2, transX, transY) {
  const r22 = 2 * r2;
  return ctx.moveTo(transX - r22, transY - r2), ctx.lineTo(transX, transY + r2), ctx.lineTo(transX + r22, transY - r2), true;
}
var Arrow2DownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_down_default = new Arrow2DownSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-v.js
function lineV(ctx, r2, x3, y3, z2) {
  return ctx.moveTo(x3, y3 - r2), ctx.lineTo(x3, y3 + r2), true;
}
var LineVSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x3, y3, z2) {
    return lineV(ctx, size / 2, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return lineV(ctx, size / 2 + offset, x3, y3, z2);
  }
  drawToSvgPath(size, x3, y3, z2) {
    const r2 = size / 2;
    return `M ${x3}, ${y3 - r2} L ${x3},${y3 + r2}`;
  }
};
var line_v_default = new LineVSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/line-h.js
function lineH(ctx, r2, x3, y3, z2) {
  return ctx.moveTo(x3 - r2, y3), ctx.lineTo(x3 + r2, y3), true;
}
var LineHSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x3, y3, z2) {
    return lineH(ctx, size / 2, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return lineH(ctx, size / 2 + offset, x3, y3, z2);
  }
  drawToSvgPath(size, x3, y3, z2) {
    const r2 = size / 2;
    return `M ${x3 - r2}, ${y3} L ${x3 + r2},${y3}`;
  }
};
var line_h_default = new LineHSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/close.js
function close(ctx, r2, x3, y3, z2) {
  return ctx.moveTo(x3 - r2, y3 - r2), ctx.lineTo(x3 + r2, y3 + r2), ctx.moveTo(x3 + r2, y3 - r2), ctx.lineTo(x3 - r2, y3 + r2), true;
}
var CloseSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x3, y3, z2) {
    return close(ctx, size / 2, x3, y3, z2);
  }
  drawOffset(ctx, size, x3, y3, offset, z2) {
    return close(ctx, size / 2 + offset, x3, y3, z2);
  }
  drawToSvgPath(size, x3, y3, z2) {
    const r2 = size / 2;
    return `M ${x3 - r2}, ${y3 - r2} L ${x3 + r2},${y3 + r2} M ${x3 + r2}, ${y3 - r2} L ${x3 - r2},${y3 + r2}`;
  }
};
var close_default = new CloseSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/rect.js
function rectSizeArray(ctx, size, x3, y3) {
  return ctx.rect(x3 - size[0] / 2, y3 - size[1] / 2, size[0], size[1]), false;
}
function rectSize(ctx, size, x3, y3) {
  const w2 = size, h2 = size / 2;
  return ctx.rect(x3 - w2 / 2, y3 - h2 / 2, w2, h2), false;
}
var RectSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x3, y3) {
    return isNumber_default(size) ? rectSize(ctx, size, x3, y3) : rectSizeArray(ctx, size, x3, y3);
  }
  drawOffset(ctx, size, x3, y3, offset) {
    return isNumber_default(size) ? rectSize(ctx, size + 2 * offset, x3, y3) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x3, y3);
  }
};
var rect_default = new RectSymbol();

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/utils.js
var tempBounds2 = new AABBBounds();
var CustomSymbolClass = class {
  constructor(type, path, isSvg2 = false) {
    this.pathStr = "", this.type = type, isArray_default(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg2;
  }
  drawOffset(ctx, size, x3, y3, offset, z2, cb) {
    return this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x3, y3, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x3, y3, size + offset, size + offset), false);
  }
  draw(ctx, size, x3, y3, z2, cb) {
    return this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x3, y3, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x3, y3, size, size), false);
  }
  bounds(size, bounds) {
    if (this.isSvg) {
      if (!this.svgCache) return;
      return bounds.clear(), void this.svgCache.forEach(({ path }) => {
        tempBounds2.x1 = path.bounds.x1 * size, tempBounds2.y1 = path.bounds.y1 * size, tempBounds2.x2 = path.bounds.x2 * size, tempBounds2.y2 = path.bounds.y2 * size, bounds.union(tempBounds2);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
};

// node_modules/@visactor/vrender-core/es/graphic/builtin-symbol/index.js
var builtinSymbols = [circle_default3, cross_default, diamond_default, square_default, thin_triangle_default, triangle_default, star_default, arrow_default, wedge_default, stroke_default, wye_default, triangle_left_default, triangle_right_default, triangle_up_default, triangle_down_default, arrow2_left_default, arrow2_right_default, arrow2_up_default, arrow2_down_default, rect_default, line_v_default, line_h_default, close_default];
var builtinSymbolsMap = {};
builtinSymbols.forEach((symbol) => {
  builtinSymbolsMap[symbol.type] = symbol;
});
var builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

// node_modules/@visactor/vrender-core/es/graphic/symbol.js
var _tempBounds = new AABBBounds();
var SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
var Symbol2 = class _Symbol extends Graphic {
  constructor(params2 = {
    symbolType: "circle"
  }) {
    super(params2), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { size } = this.attribute;
    return isArray_default(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const symbolTheme = getTheme(this).symbol;
    let { symbolType = symbolTheme.symbolType } = this.attribute, path = builtinSymbolsMap[symbolType];
    if (path) return this._parsedPath = path, path;
    if (path = _Symbol.userSymbolMap[symbolType], path) return this._parsedPath = path, path;
    symbolType = builtInSymbolStrMap[symbolType] || symbolType;
    if (true === isSvg(symbolType)) {
      const parser = new XMLParser(), { svg } = parser.parse(symbolType);
      if (!svg) return null;
      const path2 = isArray_default(svg.path) ? svg.path : [svg.path];
      _tempBounds.clear();
      const cacheList = [];
      path2.forEach((item) => {
        const cache2 = new CustomPath2D().fromString(item.d), attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((k3) => {
          item[k3] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k3]] = item[k3]);
        }), cacheList.push({
          path: cache2,
          attribute
        }), _tempBounds.union(cache2.bounds);
      });
      const width2 = _tempBounds.width(), height2 = _tempBounds.height(), scale5 = 1 / max(width2, height2);
      return cacheList.forEach((cache2) => cache2.path.transform(0, 0, scale5, scale5)), this._parsedPath = new CustomSymbolClass(symbolType, cacheList, true), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
    }
    const cache = new CustomPath2D().fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale4 = 1 / max(width, height);
    return cache.transform(0, 0, scale4, scale4), this._parsedPath = new CustomSymbolClass(symbolType, cache), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
  }
  doUpdateAABBBounds(full) {
    const symbolTheme = getTheme(this).symbol;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateSymbolAABBBounds(attribute, getTheme(this).symbol, this._AABBBounds, full, this), { boundsPadding = symbolTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).symbol[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = isArray_default(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new _Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol2.userSymbolMap = {}, Symbol2.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol2(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/line.js
var LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", ...GRAPHIC_UPDATE_TAG_KEY];
var Line = class _Line extends Graphic {
  constructor(params2 = {}) {
    super(params2), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  doUpdateAABBBounds() {
    const lineTheme = getTheme(this).line;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateLineAABBBounds(attribute, getTheme(this).line, this._AABBBounds, this), { boundsPadding = lineTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).line[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, path = new CustomPath2D(), segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        points.forEach((point6) => {
          false !== point6.defined && (isFirst ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y), isFirst = false);
        });
      }
    };
    return segments2 && segments2.length ? segments2.forEach((seg) => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new _Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Line.NOWORK_ANIMATE_ATTR;
  }
};
Line.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/rect.js
var RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Rect = class _Rect extends Graphic {
  constructor(params2) {
    super(params2), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return true;
  }
  doUpdateAABBBounds() {
    const rectTheme = getTheme(this).rect;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateRectAABBBounds(attribute, getTheme(this).rect, this._AABBBounds, this), { boundsPadding = rectTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).rect[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, { x: x3, y: y3, width, height } = normalizeRectAttributes(attribute), path = new CustomPath2D();
    return path.moveTo(x3, y3), path.rect(x3, y3, width, height), path;
  }
  clone() {
    return new _Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Rect.NOWORK_ANIMATE_ATTR;
  }
};
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/rect3d.js
var CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
var Rect3d = class _Rect3d extends Rect {
  constructor(params2) {
    super(params2), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  findFace() {
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    }, rectTheme = getTheme(this).rect3d, { x1: x14, y1: y14, x: x3, y: y3, length: length2 = min(rectTheme.width, rectTheme.height) } = this.attribute;
    let { width, height } = this.attribute;
    width = null != width ? width : x14 - x3, height = null != height ? height : y14 - y3;
    for (let i2 = 0; i2 < CUBE_VERTICES.length; i2++) {
      const v2 = CUBE_VERTICES[i2];
      faces.vertices.push([v2[0] * width, v2[1] * height, v2[2] * length2]);
    }
    return faces.polygons.push({
      polygon: [0, 1, 5, 4],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [2, 3, 7, 6],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [4, 7, 3, 0],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 2, 6, 5],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  getNoWorkAnimateAttr() {
    return _Rect3d.NOWORK_ANIMATE_ATTR;
  }
};
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect3d(attributes) {
  return new Rect3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/glyph.js
var Glyph = class _Glyph extends Graphic {
  constructor(params2) {
    super(params2), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
  }
  setSubGraphic(subGraphic) {
    this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g3) => {
      g3.glyphHost = this, Object.setPrototypeOf(g3.attribute, this.attribute);
    }), this.valid = this.isValid(), this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach((g3) => {
      g3.glyphHost = null, Object.setPrototypeOf(g3.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(cb) {
    this._onInit = cb;
  }
  onUpdate(cb) {
    this._onUpdate = cb;
  }
  isValid() {
    return true;
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g3) => {
      g3.addUpdateShapeAndBoundsTag(), g3.addUpdatePositionTag();
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    super.setAttributes(params2, forceUpdateTag, context), this.subGraphic.forEach((g3) => {
      g3.addUpdateShapeAndBoundsTag(), g3.addUpdatePositionTag();
    });
  }
  translate(x3, y3) {
    return super.translate(x3, y3), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  translateTo(x3, y3) {
    return super.translateTo(x3, y3), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  scale(scaleX, scaleY, scaleCenter) {
    return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  scaleTo(scaleX, scaleY) {
    return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  rotate(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  rotateTo(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g3) => {
      g3.addUpdatePositionTag(), g3.addUpdateBoundTag();
    }), this;
  }
  doUpdateAABBBounds() {
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const bounds = application.graphicService.updateGlyphAABBBounds(this.attribute, getTheme(this).glyph, this._AABBBounds, this);
    return this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  needUpdateTags(keys2) {
    return false;
  }
  needUpdateTag(key) {
    return false;
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {}, subAttrs = this.subGraphic.map(() => ({}));
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
      attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a2 = attrs.subAttributes) || void 0 === _a2 ? void 0 : _a2.length) && subAttrs.forEach((subAttrs2, index) => {
        Object.assign(subAttrs2, attrs.subAttributes[index]);
      }));
    }), this.subGraphic.forEach((graphic, index) => {
      graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs && (this.subGraphic.forEach((graphic) => {
      graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, true), graphic.normalAttrs = null;
    }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true), this.normalAttrs = null, this.currentStates = []);
  }
  clone() {
    const glyph = new _Glyph(Object.assign({}, this.attribute));
    return glyph.setSubGraphic(this.subGraphic.map((g3) => g3.clone())), glyph;
  }
  getNoWorkAnimateAttr() {
    return _Glyph.NOWORK_ANIMATE_ATTR;
  }
};
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGlyph(attributes) {
  return new Glyph(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/richtext/frame.js
var Frame = class {
  constructor(left2, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
    this.left = left2, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left2 + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = /* @__PURE__ */ new Map();
  }
  draw(ctx, drawIcon) {
    const { width: actualWidth, height: actualHeight } = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    switch (this.globalAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -width / 2;
        break;
      case "right":
        deltaX = -width;
    }
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = false;
    if ("middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i2 = 0; i2 < this.lines.length; i2++) {
      const { top, height: height2 } = this.lines[i2];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
      let lastLine = false;
      this.ellipsis && this.lines[i2 + 1] && this.lines[i2 + 1].top + this.lines[i2 + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i2].draw(ctx, lastLine, this.lines[i2][this.directionKey.left] + deltaX, this.lines[i2][this.directionKey.top] + deltaY, drawIcon);
    }
    else {
      const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
      "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
      for (let i2 = 0; i2 < this.lines.length; i2++) this.lines[i2].draw(ctx, false, this.lines[i2][this.directionKey.left] + deltaX, this.lines[i2][this.directionKey.top] + deltaY, drawIcon);
    }
    else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i2 = 0; i2 < this.lines.length; i2++) {
      const { top, height: height2 } = this.lines[i2], y3 = frameHeight - this.lines[i2].top - this.lines[i2].height;
      if (0 === frameHeight) this.lines[i2].draw(ctx, false, deltaX, y3 + deltaY, drawIcon);
      else {
        if (y3 + height2 > this[this.directionKey.top] + frameHeight || y3 < this[this.directionKey.top]) return lastLineTag;
        {
          let lastLine = false;
          this.ellipsis && this.lines[i2 + 1] && y3 - this.lines[i2 + 1].height < this[this.directionKey.top] && (lastLine = true, lastLineTag = true), this.lines[i2].draw(ctx, lastLine, deltaX, y3 + deltaY, drawIcon);
        }
      }
    }
    else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i2 = 0; i2 < this.lines.length; i2++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i2].height + this.lines[i2].top);
        const { top, height: height2 } = this.lines[i2];
        if (0 === frameHeight) this.lines[i2].draw(ctx, false, this.lines[i2][this.directionKey.left] + deltaX, this.lines[i2][this.directionKey.top] + deltaY, drawIcon);
        else {
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) return lastLineTag;
          {
            let lastLine = false;
            this.ellipsis && this.lines[i2 + 1] && this.lines[i2 + 1].top + this.lines[i2 + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i2].draw(ctx, lastLine, this.lines[i2][this.directionKey.left] + deltaX, this.lines[i2][this.directionKey.top] + deltaY, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0, height = 0;
    for (let i2 = 0; i2 < this.lines.length; i2++) {
      const line2 = this.lines[i2];
      line2.actualWidth > width && (width = line2.actualWidth), height += line2.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0, heightBound = 0;
    const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
    this.width;
    let height = this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i2 = 0; i2 < this.lines.length; i2++) {
      const { top, height: height2 } = this.lines[i2];
      if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else if (this.ellipsis && this.lines[i2 + 1] && this.lines[i2 + 1].top + this.lines[i2 + 1].height > this[this.directionKey.top] + frameHeight) {
        const lineWidth = this.lines[i2].getWidthWithEllips();
        lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i2].height;
      } else this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
    }
    else {
      Math.floor((frameHeight - this.actualHeight) / 2);
      for (let i2 = 0; i2 < this.lines.length; i2++) this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
    }
    else if ("bottom" === this.verticalDirection) for (let i2 = 0; i2 < this.lines.length; i2++) {
      const { top, height: height2 } = this.lines[i2], y3 = frameHeight - this.lines[i2].top - this.lines[i2].height;
      if (0 === frameHeight) this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
      else if (y3 + height2 > this[this.directionKey.top] + frameHeight || y3 < this[this.directionKey.top]) ;
      else {
        if (this.ellipsis && this.lines[i2 + 1] && y3 - this.lines[i2 + 1].height < this[this.directionKey.top]) {
          const lineWidth = this.lines[i2].getWidthWithEllips();
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i2].height;
        } else this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
      }
    }
    else for (let i2 = 0; i2 < this.lines.length; i2++) {
      const { top, height: height2 } = this.lines[i2];
      if (0 === frameHeight) this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
      else if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight) ;
      else {
        if (this.ellipsis && this.lines[i2 + 1] && this.lines[i2 + 1].top + this.lines[i2 + 1].height > this[this.directionKey.top] + frameHeight) {
          const lineWidth = this.lines[i2].getWidthWithEllips();
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i2].height;
        } else this.lines[i2].actualWidth > widthBound && (widthBound = this.lines[i2].actualWidth), heightBound += this.lines[i2].height;
      }
    }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/paragraph.js
var Paragraph = class {
  constructor(text2, newLine, character) {
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic";
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const { ascent, height, descent, width } = measureTextCanvas(text2, character);
    let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text2.length, this.width = width || 0, this.text = text2 || "", this.newLine = newLine || false, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height);
  }
  updateWidth() {
    const { width } = measureTextCanvas(this.text, this.character);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
    let text2 = this.text, left2 = this.left + deltaLeft;
    baseline += this.top;
    let direction2 = this.direction;
    if (this.verticalEllipsis) text2 = "...", direction2 = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text2 += "...", "right" === textAlign && (left2 -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction2 ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += "...", "right" === textAlign) {
          const { width } = measureTextCanvas(this.text.slice(index), this.character);
          "vertical" === direction2 || (left2 -= this.ellipsisWidth - width);
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction2 && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left2, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left2, baseline), left2 = 0, baseline = 0), this.character.stroke && (applyStrokeStyle(ctx, this.character), ctx.strokeText(text2, left2, baseline)), applyFillStyle(ctx, this.character), this.character.fill && ctx.fillText(text2, left2, baseline), this.character.fill && ("boolean" == typeof this.character.lineThrough || "boolean" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left2, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), this.character.lineThrough && ctx.fillRect(left2, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : "underline" === this.character.textDecoration ? ctx.fillRect(left2, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : "line-through" === this.character.textDecoration && ctx.fillRect(left2, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), "vertical" === direction2 && ctx.restore();
  }
  getWidthWithEllips(direction2) {
    let text2 = this.text;
    const width = "vertical" === direction2 ? this.height : this.width;
    if ("hide" === this.ellipsis) return width;
    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text2, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
      text2 = text2.slice(0, index), text2 += "...";
      const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
};
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, true, paragraph.character)];
}

// node_modules/@visactor/vrender-core/es/graphic/image.js
var IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
var Image = class _Image extends Graphic {
  constructor(params2) {
    super(params2), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;
  }
  set width(width) {
    this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;
  }
  set height(height) {
    this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    });
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.image && this.loadImage(params2.image), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  doUpdateAABBBounds() {
    const imageTheme = getTheme(this).image;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateImageAABBBounds(attribute, getTheme(this).image, this._AABBBounds, this), { boundsPadding = imageTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new _Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Image.NOWORK_ANIMATE_ATTR;
  }
};
Image.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/richtext/icon.js
var RichTextIcon = class extends Image {
  constructor(params2) {
    if (super(params2), this._x = 0, this._y = 0, this._hovered = false, this._marginArray = [0, 0, 0, 0], "always" === params2.backgroundShowMode && (this._hovered = true), params2.margin) {
      const marginArray = parsePadding(params2.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray_default(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
        const marginArray = parsePadding(attributes.margin);
        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute, { backgroundWidth = width, backgroundHeight = height } = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/line.js
var Line2 = class {
  constructor(left2, width, baseline, ascent, descent, lineBuffer, direction2, isWidthMax) {
    this.left = left2, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p2) => p2), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction2, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result2 = regFirstSpace.exec(word.text);
        0 !== (null == result2 ? void 0 : result2.index) && (word.text = word.text.slice(null == result2 ? void 0 : result2.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey, maxHeight = this.height;
    let x3 = this.left, spacing = 0;
    if (this.actualWidth < width && !isWidthMax) switch (this.textAlign) {
      case "right":
        x3 = width - this.actualWidth;
        break;
      case "center":
        x3 = (width - this.actualWidth) / 2;
        break;
      case "justify":
        this.paragraphs.length < 2 ? x3 = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);
    }
    this.paragraphs.map(function(paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x3, x3 += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x3, x3 += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x3, y3, drawIcon) {
    if (lastLine) {
      let otherParagraphWidth = 0;
      for (let i2 = this.paragraphs.length - 1; i2 >= 0; i2--) {
        const paragraph = this.paragraphs[i2];
        if (paragraph instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = true;
          break;
        }
        const { width } = measureTextCanvas("...", paragraph.character), ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          paragraph.ellipsis = "add";
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    this.paragraphs.map((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
        x: x3 + paragraph._x,
        y: y3 + paragraph._y
      }), void drawIcon(paragraph, ctx, x3 + paragraph._x, y3 + paragraph._y, this.ascent);
      paragraph.draw(ctx, y3 + this.ascent, x3, 0 === index, this.textAlign);
    });
  }
  getWidthWithEllips() {
    let otherParagraphWidth = 0;
    for (let i2 = this.paragraphs.length - 1; i2 >= 0; i2--) {
      const paragraph = this.paragraphs[i2];
      if (paragraph instanceof RichTextIcon) break;
      const { width: width2 } = measureTextCanvas("...", paragraph.character), ellipsisWidth = width2 || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.map((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext/wrapper.js
var Wrapper = class {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0, iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line2 = new Line2(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line2), this.frame.actualHeight += line2.height, this.y += line2.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph) {
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), 0 !== paragraph.text.length && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph)));
  }
  cut(paragraph) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), this.deal(p2);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
};

// node_modules/@visactor/vrender-core/es/graphic/richtext.js
var RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", ...GRAPHIC_UPDATE_TAG_KEY];
var RichText = class _RichText extends Graphic {
  constructor(params2) {
    super(params2), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w2) {
    this.attribute.width !== w2 && (this.attribute.width = w2, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h2) {
    this.attribute.height !== h2 && (this.attribute.height = h2, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e3) {
    this.attribute.ellipsis !== e3 && (this.attribute.ellipsis = e3, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config2) {
    this.attribute.textConfig = config2, this.addUpdateShapeAndBoundsTag();
  }
  doUpdateAABBBounds() {
    const richTextTheme = getTheme(this).richtext;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateRichTextAABBBounds(attribute, getTheme(this).richtext, this._AABBBounds, this), { boundsPadding = richTextTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return DefaultRichTextAttribute[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  doUpdateFrameCache() {
    var _a;
    const { textConfig = [], maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine } = this.attribute, paragraphs = [];
    for (let i2 = 0; i2 < textConfig.length; i2++) if ("image" in textConfig[i2]) {
      const config2 = textConfig[i2], iconCache = config2.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config2.id);
      if (iconCache) paragraphs.push(iconCache);
      else {
        const icon = new RichTextIcon(config2);
        icon.successCallback = () => {
          var _a2;
          this.addUpdateBoundTag(), null === (_a2 = this.stage) || void 0 === _a2 || _a2.renderNextFrame();
        }, icon.richtextId = config2.id, paragraphs.push(icon);
      }
    } else if (textConfig[i2].text.includes("\n")) {
      const textParts = textConfig[i2].text.split("\n");
      for (let j2 = 0; j2 < textParts.length; j2++) paragraphs.push(new Paragraph(textParts[j2], 0 !== j2, textConfig[i2]));
    } else paragraphs.push(new Paragraph(textConfig[i2].text, false, textConfig[i2]));
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0, maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0, richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth), richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight), frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || false, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new Wrapper(frame);
    for (let i2 = 0; i2 < paragraphs.length; i2++) wrapper.deal(paragraphs[i2]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function(l2) {
        l2.calcOffset(offsetSize, false);
      });
    }
    this._frameCache = frame;
  }
  clone() {
    return new _RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach((icon) => {
      icon.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", (e3) => {
      var _a, _b, _c, _d, _e;
      const pickedIcon = this.pickIcon(e3.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(false), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(true), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && this._currentHoverIcon && (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame()));
    }), this.addEventListener("pointerleave", (e3) => {
      var _a, _b;
      this._currentHoverIcon && (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_a = this.stage) || void 0 === _a || _a.setCursor(), null === (_b = this.stage) || void 0 === _b || _b.renderNextFrame());
    });
  }
  pickIcon(point6) {
    const frameCache = this.getFrameCache(), { e: x3, f: y3 } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon) => {
      var _a, _b;
      icon.AABBBounds.containsPoint({
        x: point6.x - x3,
        y: point6.y - y3
      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x3, pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y3);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return _RichText.NOWORK_ANIMATE_ATTR;
  }
};
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/path.js
var PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
var Path = class _Path extends Graphic {
  constructor(params2) {
    super(params2), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { path } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = getTheme(this).path;
    if (!this.valid) return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil_default(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  doUpdateAABBBounds() {
    const pathTheme = getTheme(this).path;
    this.doUpdatePathShape(), this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updatePathAABBBounds(attribute, getTheme(this).path, this._AABBBounds, this), { boundsPadding = pathTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString_default(attribute.path, true) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  getDefaultAttribute(name) {
    return getTheme(this).path[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new _Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Path.NOWORK_ANIMATE_ATTR;
  }
};
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/area.js
var AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", ...GRAPHIC_UPDATE_TAG_KEY];
var Area = class _Area extends Graphic {
  constructor(params2) {
    super(params2), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && 0 !== points.length;
  }
  doUpdateAABBBounds() {
    const areaTheme = getTheme(this).area;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateAreaAABBBounds(attribute, getTheme(this).area, this._AABBBounds, this), { boundsPadding = areaTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getDefaultAttribute(name) {
    return getTheme(this).area[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const path = new CustomPath2D(), attribute = this.attribute, segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        const basePoints = [];
        if (points.forEach((point6) => {
          var _a, _b;
          false !== point6.defined && (isFirst ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y), basePoints.push({
            x: null !== (_a = point6.x1) && void 0 !== _a ? _a : point6.x,
            y: null !== (_b = point6.y1) && void 0 !== _b ? _b : point6.y
          }), isFirst = false);
        }), basePoints.length) {
          for (let i2 = basePoints.length - 1; i2 >= 0; i2--) path.lineTo(basePoints[i2].x, basePoints[i2].y);
          path.closePath();
        }
      }
    };
    return attribute.points ? parsePoints(attribute.points) : segments2 && segments2.length && segments2.forEach((seg) => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new _Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Area.NOWORK_ANIMATE_ATTR;
  }
};
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/arc.js
var ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
var Arc = class _Arc extends Graphic {
  constructor(params2) {
    super(params2), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = getTheme(this).arc, { cornerRadius = arcTheme.cornerRadius, outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    if (0 === cornerRadius || "0%" === cornerRadius) return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius);
    return Math.min(isNumber_default(cornerRadius, true) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
  }
  getParsedAngle() {
    const arcTheme = getTheme(this).arc;
    let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
    const { cap = arcTheme.cap } = this.attribute, sign4 = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1, endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      const { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute, capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon) return {
        startAngle: startAngle - sign4 * capAngle * startCap,
        endAngle: endAngle + sign4 * capAngle * endCap,
        sc: sign4 * capAngle * startCap,
        ec: sign4 * capAngle * endCap
      };
    }
    return {
      startAngle,
      endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = getTheme(this).arc, { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius, padAngle = arcTheme.padAngle } = this.attribute, { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute, deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign4 = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)), p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign4, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign4, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle,
        outerEndAngle,
        innerStartAngle,
        innerEndAngle,
        innerDeltaAngle,
        outerDeltaAngle
      };
    }
    return {
      outerStartAngle,
      outerEndAngle,
      innerStartAngle,
      innerEndAngle,
      innerDeltaAngle,
      outerDeltaAngle
    };
  }
  doUpdateAABBBounds(full) {
    const arcTheme = getTheme(this).arc;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateArcAABBBounds(attribute, getTheme(this).arc, this._AABBBounds, full, this), { boundsPadding = arcTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  getDefaultAttribute(name) {
    return getTheme(this).arc[name];
  }
  toCustomPath() {
    const attribute = this.attribute, { startAngle, endAngle } = this.getParsedAngle();
    let innerRadius = attribute.innerRadius, outerRadius = attribute.outerRadius;
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    const path = new CustomPath2D();
    if (outerRadius <= epsilon) path.moveTo(0, 0);
    else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));
    else {
      const xors = outerRadius * cos(startAngle), yors = outerRadius * sin(startAngle), xire = innerRadius * cos(endAngle), yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new _Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Arc.NOWORK_ANIMATE_ATTR;
  }
};
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/arc3d.js
var Arc3d = class _Arc3d extends Arc {
  constructor(params2) {
    super(params2), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).arc;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updateArc3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  getNoWorkAnimateAttr() {
    return _Arc3d.NOWORK_ANIMATE_ATTR;
  }
};
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc3d(attributes) {
  return new Arc3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/polygon.js
var POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Polygon = class _Polygon extends Graphic {
  constructor(params2) {
    super(params2), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { points } = this.attribute;
    return points && points.length >= 2;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).polygon;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updatePolygonAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("暂不支持");
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getDefaultAttribute(name) {
    return getTheme(this).polygon[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const points = this.attribute.points, path = new CustomPath2D();
    return points.forEach((point6, index) => {
      0 === index ? path.moveTo(point6.x, point6.y) : path.lineTo(point6.x, point6.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Polygon.NOWORK_ANIMATE_ATTR;
  }
};
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/pyramid3d.js
var Pyramid3d = class _Pyramid3d extends Polygon {
  constructor(params2) {
    super(params2), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).polygon;
    this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    const attribute = this.attribute, bounds = application.graphicService.updatePyramid3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  findFace() {
    const { points } = this.attribute, kList = points.map((p2, i2) => {
      const p1 = 3 === i2 ? points[0] : points[i2 + 1], dx = p2.x - p1.x;
      return 0 === dx ? 0 : (p2.y - p1.y) / dx;
    }), pointsMap = points.map((p2) => ({
      p: p2,
      d: 0
    }));
    let find = false, maxD = 0;
    for (let i2 = 0; i2 < kList.length - 1; i2++) {
      for (let j2 = i2 + 1; j2 < kList.length; j2++) {
        if (kList[i2] === kList[j2]) {
          find = true;
          const d1 = PointService.distancePP(pointsMap[i2].p, pointsMap[i2 + 1].p);
          pointsMap[i2].d = d1, pointsMap[i2 + 1].d = d1, maxD = max(maxD, d1);
          const d2 = PointService.distancePP(pointsMap[j2].p, pointsMap[j2 + 1].p);
          pointsMap[j2].d = d2, pointsMap[j2 + 1].d = d2, maxD = max(maxD, d2);
        }
        if (find) break;
      }
      if (find) break;
    }
    for (let i2 = points.length - 1; i2 >= 0; i2--) {
      const p2 = points[i2];
      pointsMap.unshift({
        p: p2,
        d: 0
      });
    }
    for (let i2 = 0; i2 < points.length; i2++) {
      const delta = (maxD - pointsMap[i2 + points.length].d) / 2;
      pointsMap[i2].d += delta, pointsMap[i2 + points.length].d += delta;
    }
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    };
    return pointsMap.forEach((p2) => {
      faces.vertices.push([p2.p.x, p2.p.y, p2.d]);
    }), faces.polygons.push({
      polygon: [0, 4, 5, 1],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [7, 6, 2, 3],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [0, 4, 7, 3],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 5, 6, 2],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return _Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
};
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPyramid3d(attributes) {
  return new Pyramid3d(attributes);
}

// node_modules/@visactor/vrender-core/es/graphic/shadow-root.js
var ShadowRoot = class extends Group {
  constructor(graphic) {
    super({
      x: 0,
      y: 0
    }), this.type = "shadowroot", this.shadowHost = graphic;
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      const m5 = this.transMatrix;
      this._globalTransMatrix ? this._globalTransMatrix.setValue(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f) : this._globalTransMatrix = m5.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const parentMatrix = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
  }
};
function createShadowRoot(graphic) {
  return new ShadowRoot(graphic);
}

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/common-contribution.js
var DefaultOuterBorderBoundsContribution = class {
  updateBounds(attribute, theme2, aabbBounds, graphic) {
    const { outerBorder, shadowBlur = theme2.shadowBlur } = attribute;
    if (outerBorder) {
      const defaultOuterBorder = theme2.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
      aabbBounds.expand(distance2 + (shadowBlur + lineWidth) / 2);
    }
    return aabbBounds;
  }
};

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/symbol-contribution.js
var DefaultSymbolOuterBorderBoundsContribution = class extends DefaultOuterBorderBoundsContribution {
  updateBounds(attribute, symbolTheme, aabbBounds, graphic) {
    const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
    if (outerBorder) {
      const defaultOuterBorder = symbolTheme.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
      boundStroke(aabbBounds, distance2 + (shadowBlur + lineWidth) / 2, true, strokeBoundsBuffer);
    }
    return aabbBounds;
  }
};

// node_modules/@visactor/vrender-core/es/allocator/matrix-allocate.js
var MatrixAllocate = Symbol.for("MatrixAllocate");
var Mat4Allocate = Symbol.for("Mat4Allocate");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
var DefaultMatrixAllocate = class {
  constructor() {
    this.pools = [];
  }
  allocate(a4, b2, c4, d2, e3, f2) {
    if (!this.pools.length) return new Matrix(a4, b2, c4, d2, e3, f2);
    const m5 = this.pools.pop();
    return m5.a = a4, m5.b = b2, m5.c = c4, m5.d = d2, m5.e = e3, m5.f = f2, m5;
  }
  allocateByObj(matrix) {
    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m5 = this.pools.pop();
    return m5.a = matrix.a, m5.b = matrix.b, m5.c = matrix.c, m5.d = matrix.d, m5.e = matrix.e, m5.f = matrix.f, m5;
  }
  free(d2) {
    this.pools.push(d2);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultMat4Allocate = class _DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const m5 = this.pools.pop();
    return _DefaultMat4Allocate.identity(m5), m5;
  }
  allocateByObj(d2) {
    let m5;
    m5 = this.pools.length ? this.pools.pop() : createMat4();
    for (let i2 = 0; i2 < m5.length; i2++) m5[i2] = d2[i2];
    return m5;
  }
  free(m5) {
    m5 && this.pools.push(m5);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var matrixAllocate = new DefaultMatrixAllocate();
var mat4Allocate = new DefaultMat4Allocate();

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-service.js
var __decorate7 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata5 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function identity(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a4, rad) {
  const s3 = Math.sin(rad), c4 = Math.cos(rad), a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  return a4 !== out && (out[0] = a4[0], out[1] = a4[1], out[2] = a4[2], out[3] = a4[3], out[12] = a4[12], out[13] = a4[13], out[14] = a4[14], out[15] = a4[15]), out[4] = a10 * c4 + a20 * s3, out[5] = a11 * c4 + a21 * s3, out[6] = a12 * c4 + a22 * s3, out[7] = a13 * c4 + a23 * s3, out[8] = a20 * c4 - a10 * s3, out[9] = a21 * c4 - a11 * s3, out[10] = a22 * c4 - a12 * s3, out[11] = a23 * c4 - a13 * s3, out;
}
function rotateY(out, a4, rad) {
  const s3 = Math.sin(rad), c4 = Math.cos(rad), a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  return a4 !== out && (out[4] = a4[4], out[5] = a4[5], out[6] = a4[6], out[7] = a4[7], out[12] = a4[12], out[13] = a4[13], out[14] = a4[14], out[15] = a4[15]), out[0] = a00 * c4 - a20 * s3, out[1] = a01 * c4 - a21 * s3, out[2] = a02 * c4 - a22 * s3, out[3] = a03 * c4 - a23 * s3, out[8] = a00 * s3 + a20 * c4, out[9] = a01 * s3 + a21 * c4, out[10] = a02 * s3 + a22 * c4, out[11] = a03 * s3 + a23 * c4, out;
}
function rotateZ(out, a4, rad) {
  const s3 = Math.sin(rad), c4 = Math.cos(rad), a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  return a4 !== out && (out[8] = a4[8], out[9] = a4[9], out[10] = a4[10], out[11] = a4[11], out[12] = a4[12], out[13] = a4[13], out[14] = a4[14], out[15] = a4[15]), out[0] = a00 * c4 + a10 * s3, out[1] = a01 * c4 + a11 * s3, out[2] = a02 * c4 + a12 * s3, out[3] = a03 * c4 + a13 * s3, out[4] = a10 * c4 - a00 * s3, out[5] = a11 * c4 - a01 * s3, out[6] = a12 * c4 - a02 * s3, out[7] = a13 * c4 - a03 * s3, out;
}
function translate(out, a4, v2) {
  const x3 = v2[0], y3 = v2[1], z2 = v2[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a4 === out ? (out[12] = a4[0] * x3 + a4[4] * y3 + a4[8] * z2 + a4[12], out[13] = a4[1] * x3 + a4[5] * y3 + a4[9] * z2 + a4[13], out[14] = a4[2] * x3 + a4[6] * y3 + a4[10] * z2 + a4[14], out[15] = a4[3] * x3 + a4[7] * y3 + a4[11] * z2 + a4[15]) : (a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a4[12], out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a4[13], out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a4[14], out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a4[15]), out;
}
function mat3Tomat4(out, b2) {
  out[0] = b2.a, out[1] = b2.b, out[2] = 0, out[3] = 0, out[4] = b2.c, out[5] = b2.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b2.e, out[13] = b2.f, out[14] = 0, out[15] = 1;
}
function scale2(out, a4, v2) {
  const x3 = v2[0], y3 = v2[1], z2 = v2[2];
  return out[0] = a4[0] * x3, out[1] = a4[1] * x3, out[2] = a4[2] * x3, out[3] = a4[3] * x3, out[4] = a4[4] * y3, out[5] = a4[5] * y3, out[6] = a4[6] * y3, out[7] = a4[7] * y3, out[8] = a4[8] * z2, out[9] = a4[9] * z2, out[10] = a4[10] * z2, out[11] = a4[11] * z2, out[12] = a4[12], out[13] = a4[13], out[14] = a4[14], out[15] = a4[15], out;
}
function multiplyMat4Mat4(out, a4, b2) {
  const a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11], a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  let b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  return out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[4], b1 = b2[5], b22 = b2[6], b3 = b2[7], out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[8], b1 = b2[9], b22 = b2[10], b3 = b2[11], out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[12], b1 = b2[13], b22 = b2[14], b3 = b2[15], out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, out;
}
function getModelMatrix(out, graphic, theme2) {
  var _a;
  const { x: x3 = theme2.x, y: y3 = theme2.y, z: z2 = theme2.z, dx = theme2.dx, dy = theme2.dy, dz = theme2.dz, scaleX = theme2.scaleX, scaleY = theme2.scaleY, scaleZ = theme2.scaleZ, alpha = theme2.alpha, beta = theme2.beta, angle: angle2 = theme2.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute, _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identity(out), translate(out, out, [x3 + dx, y3 + dy, z2 + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scale2(out, out, [scaleX, scaleY, scaleZ]), angle2) {
    const m5 = mat4Allocate.allocate(), _anchor2 = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
        _anchor2[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
        _anchor2[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor2[1] = anchor3d[1];
    }
    translate(m5, m5, [_anchor2[0], _anchor2[1], 0]), rotateZ(m5, m5, angle2), translate(m5, m5, [-_anchor2[0], -_anchor2[1], 0]), multiplyMat4Mat4(out, out, m5);
  }
}
function shouldUseMat4(graphic) {
  const { alpha, beta } = graphic.attribute;
  return alpha || beta;
}
var DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds(), this._rectBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._symbolBoundsContribitions = [new DefaultSymbolOuterBorderBoundsContribution()], this._circleBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._arcBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._pathBoundsContribitions = [new DefaultOuterBorderBoundsContribution()];
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params2, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params2, selfChange);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path) return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, rectTheme, aabbBounds, graphic)) return aabbBounds;
    if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
      let { width, height } = attribute;
      const { x1: x14, y1: y14, x: x3, y: y3 } = attribute;
      width = null != width ? width : x14 - x3, height = null != height ? height : y14 - y3, aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach((c4) => {
      c4.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }), this.transformAABBBounds(attribute, aabbBounds, rectTheme, false, graphic), aabbBounds;
  }
  updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
    const { width, height, path, clip = groupTheme.clip } = attribute;
    path && path.length ? path.forEach((g3) => {
      aabbBounds.union(g3.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, width, height), clip || graphic.forEachChildren((node) => {
      aabbBounds.union(node.AABBBounds);
    });
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, false, graphic), aabbBounds;
  }
  updateGlyphAABBBounds(attribute, theme2, aabbBounds, graphic) {
    return this._validCheck(attribute, theme2, aabbBounds, graphic) ? (graphic.getSubGraphic().forEach((node) => {
      aabbBounds.union(node.AABBBounds);
    }), aabbBounds) : aabbBounds;
  }
  updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, richtextTheme, aabbBounds, graphic)) return aabbBounds;
    if (!graphic) return aabbBounds;
    const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = richtextTheme.textBaseline } = attribute;
    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);
    else {
      const frameCache = graphic.getFrameCache(), { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    let deltaY = 0;
    switch (textBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    aabbBounds.translate(deltaX, deltaY);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, graphic), aabbBounds;
  }
  updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, textTheme, aabbBounds, graphic)) return aabbBounds;
    if (!graphic) return aabbBounds;
    const { text: text2 = textTheme.text } = graphic.attribute;
    Array.isArray(text2) ? graphic.updateMultilineAABBBounds(text2) : graphic.updateSingallineAABBBounds(text2);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { scaleX = textTheme.scaleX, scaleY = textTheme.scaleY, shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer = textTheme.strokeBoundsBuffer } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, true, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return this.combindShadowAABBBounds(aabbBounds, graphic), transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix), aabbBounds;
  }
  updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, pathTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach((c4) => {
      c4.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = pathTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
    if (!graphic) return aabbBounds;
    const pathShape = graphic.getParsedPathShape();
    return aabbBounds.union(pathShape.getBounds()), aabbBounds;
  }
  updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
    if (!graphic) return aabbBounds;
    const stage = graphic.stage;
    if (!stage || !stage.camera) return aabbBounds;
    graphic.findFace().vertices.forEach((v2) => {
      const x3 = v2[0], y3 = v2[1];
      aabbBounds.add(x3, y3);
    });
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, graphic), aabbBounds;
  }
  updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
    if (!graphic) return aabbBounds;
    const stage = graphic.stage;
    if (!stage || !stage.camera) return aabbBounds;
    const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute, r2 = outerRadius + height;
    aabbBounds.setValue(-r2, -r2, r2, r2);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, false, graphic), aabbBounds;
  }
  updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, polygonTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = polygonTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
    const { points = polygonTheme.points } = attribute;
    return points.forEach((p2) => {
      aabbBounds.add(p2.x, p2.y);
    }), aabbBounds;
  }
  updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, lineTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = lineTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const { points = lineTheme.points } = attribute, b2 = aabbBounds;
    return points.forEach((p2) => {
      b2.add(p2.x, p2.y);
    }), b2;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const { segments: segments2 = lineTheme.segments } = attribute, b2 = aabbBounds;
    return segments2.forEach((s3) => {
      s3.points.forEach((p2) => {
        b2.add(p2.x, p2.y);
      });
    }), b2;
  }
  updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, areaTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = areaTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const { points = areaTheme.points } = attribute, b2 = aabbBounds;
    return points.forEach((p2) => {
      var _a, _b;
      b2.add(p2.x, p2.y), b2.add(null !== (_a = p2.x1) && void 0 !== _a ? _a : p2.x, null !== (_b = p2.y1) && void 0 !== _b ? _b : p2.y);
    }), b2;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const { segments: segments2 = areaTheme.segments } = attribute, b2 = aabbBounds;
    return segments2.forEach((s3) => {
      s3.points.forEach((p2) => {
        var _a, _b;
        b2.add(p2.x, p2.y), b2.add(null !== (_a = p2.x1) && void 0 !== _a ? _a : p2.x, null !== (_b = p2.y1) && void 0 !== _b ? _b : p2.y);
      });
    }), b2;
  }
  updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, circleTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach((c4) => {
      c4.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }), this.transformAABBBounds(attribute, aabbBounds, circleTheme, false, graphic), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
    const { radius = circleTheme.radius } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
    const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, arcTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach((c4) => {
      c4.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = arcTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
    const { innerRadius = arcTheme.innerRadius } = attribute;
    let { outerRadius = arcTheme.outerRadius } = attribute;
    return outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    if (outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
    if (startAngle > endAngle) {
      const temp3 = startAngle;
      startAngle = endAngle, endAngle = temp3;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, symbolTheme, aabbBounds, graphic)) return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach((c4) => {
      c4.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = symbolTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
    const { size = symbolTheme.size } = attribute;
    if (isArray_default(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
    else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
    if (!graphic) return aabbBounds;
    const { size = symbolTheme.size } = attribute;
    return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, imageTheme, aabbBounds, graphic)) return aabbBounds;
    if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
      const { width = imageTheme.width, height = imageTheme.height } = attribute;
      aabbBounds.set(0, 0, width, height);
    }
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, imageTheme, false, graphic), aabbBounds;
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b2 = graphic.shadowRoot.AABBBounds;
      bounds.union(b2);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme2, miter, graphic) {
    const { scaleX = theme2.scaleX, scaleY = theme2.scaleY, stroke: stroke2 = theme2.stroke, shadowBlur = theme2.shadowBlur, lineWidth = theme2.lineWidth, pickStrokeBuffer = theme2.pickStrokeBuffer, strokeBoundsBuffer = theme2.strokeBoundsBuffer } = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    if (stroke2 && lineWidth) {
      const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
      boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }
    if (shadowBlur) {
      const { shadowOffsetX = theme2.shadowOffsetX, shadowOffsetY = theme2.shadowOffsetY } = attribute, shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
      boundStroke(tb1, shadowBlurWidth, false, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
    }
    this.combindShadowAABBBounds(aabbBounds, graphic);
    let updateMatrix = true;
    const m5 = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m5.a && 0 === m5.b && 0 === m5.c && 1 === m5.d && 0 === m5.e && 0 === m5.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m5);
  }
  _validCheck(attribute, theme2, aabbBounds, graphic) {
    if (!graphic) return true;
    if (!graphic.valid) return aabbBounds.clear(), false;
    const { visible = theme2.visible } = attribute;
    return !!visible || (aabbBounds.clear(), false);
  }
};
DefaultGraphicService = __decorate7([injectable(), __param3(0, inject(GraphicCreator)), __metadata5("design:paramtypes", [Object])], DefaultGraphicService);

// node_modules/@visactor/vrender-core/es/graphic/graphic-creator.js
var GraphicCreator2 = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params2) {
    const cb = this.store.get(name);
    return cb ? cb(params2) : null;
  }
};
var graphicCreator = new GraphicCreator2();

// node_modules/@visactor/vrender-core/es/graphic/bounds.js
var text;
var richText;
function getTextBounds(params2) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params2), text.AABBBounds;
}
function getRichTextBounds(params2) {
  return richText || (richText = graphicCreator.CreateGraphic("richtext", {})), richText.setAttributes(params2), richText.AABBBounds;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/base-render.js
var result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
var BaseRender = class {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions && this.builtinContributions.forEach((item) => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a4, b2) => b2.order - a4.order), this._beforeRenderContribitions = this._renderContribitions.filter((c4) => c4.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter((c4) => c4.time === BaseRenderContributionTime.afterFillStroke));
  }
  beforeRenderStep(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach((c4) => {
      c4.drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  afterRenderStep(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach((c4) => {
      c4.drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const { fill = defaultAttribute.fill, background, stroke: stroke2 = defaultAttribute.stroke, opacity = defaultAttribute.opacity, fillOpacity = defaultAttribute.fillOpacity, lineWidth = defaultAttribute.lineWidth, strokeOpacity = defaultAttribute.strokeOpacity, visible = defaultAttribute.visible } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    return !(!graphic.valid || !visible) && (!(!doFill && !doStroke) && (!!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible,
      sVisible,
      doFill,
      doStroke
    }));
  }
  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
    const { x: x3 = graphicAttribute.x, y: y3 = graphicAttribute.y, z: z2 = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle: angle2 = graphicAttribute.angle, postMatrix } = graphic.attribute, lastModelMatrix = context.modelMatrix, camera = context.camera;
    result.x = x3, result.y = y3, result.z = z2, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)), onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle2 && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, true), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point6 = graphic.getOffsetXY(graphicAttribute);
      result.x += point6.x, result.y += point6.y, result.z = z2, context.setTransformForCurrent();
    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, true);
    else if (camera && context.project) {
      const point6 = graphic.getOffsetXY(graphicAttribute);
      result.x += point6.x, result.y += point6.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle2);
    } else context.transformFromMatrix(graphic.transMatrix, true), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z2, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z2), p2 = context.project(width, 0, z2), p3 = context.project(width, height, z2), _p1 = {
        x: 0,
        y: 0
      }, _p2 = {
        x: width,
        y: 0
      }, _p3 = {
        x: width,
        y: height
      };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, true);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z2, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x3, y3, z2, scaleX, scaleY, angle2) {
    const p2 = context.project(x3, y3, z2);
    context.translate(p2.x, p2.y, false), context.scale(scaleX, scaleY, false), context.rotate(angle2, false), context.translate(-p2.x, -p2.y, false), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    this.z = z2, drawPathProxy(graphic, context, x3, y3, drawContext, params2) || (this.drawShape(graphic, context, x3, y3, drawContext, params2), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
};

// node_modules/@visactor/vrender-core/es/common/color-utils.js
var parse = /* @__PURE__ */ function() {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error3(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error3("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function(pattern2, callback) {
      const captures = scan(pattern2);
      if (captures) {
        scan(tokens.startCall) || error3("Missing (");
        const result2 = callback(captures);
        return scan(tokens.endCall) || error3("Missing )"), result2;
      }
    }(pattern, function(captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error3("Missing comma before color stops")), {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations, lookaheadCache, radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function() {
      const circle4 = match("shape", /^(circle)/i, 0);
      circle4 && (circle4.style = matchLength() || matchExtentKeyword());
      return circle4;
    }() || function() {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType) radialType.at = matchAtPosition();
    else {
      const extent5 = matchExtentKeyword();
      if (extent5) {
        radialType = extent5;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error3("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y) return {
      type: "position",
      value: location
    };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result2 = [];
    if (captures) for (result2.push(captures); scan(tokens.comma); ) captures = matcher(), captures ? result2.push(captures) : error3("One extra comma");
    return result2;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error3("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) return {
      type,
      value: captures[captureIndex]
    };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    return input = code.toString(), getAST();
  };
}();
var GradientParser = class _GradientParser {
  static IsGradient(c4) {
    return !("string" == typeof c4 && c4.length < 10);
  }
  static IsGradientStr(c4) {
    return "string" == typeof c4 && c4.length > 10;
  }
  static Parse(c4) {
    if (_GradientParser.IsGradientStr(c4)) try {
      const datum = parse(c4)[0];
      if (datum) {
        if ("linear" === datum.type) return _GradientParser.ParseLinear(datum);
        if ("radial" === datum.type) return _GradientParser.ParseRadial(datum);
        if ("conic" === datum.type) return _GradientParser.ParseConic(datum);
      }
    } catch (err) {
      return c4;
    }
    return c4;
  }
  static ParseConic(datum) {
    const { orientation, colorStops = [] } = datum, halfPi4 = pi / 2, sa = parseFloat(orientation.value) / 180 * pi - halfPi4;
    return {
      gradient: "conical",
      x: 0.5,
      y: 0.5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseRadial(datum) {
    const { colorStops = [] } = datum;
    return {
      gradient: "radial",
      x0: 0.5,
      y0: 0.5,
      x1: 0.5,
      y1: 0.5,
      r0: 0,
      r1: 1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseLinear(datum) {
    const { orientation, colorStops = [] } = datum, halfPi4 = pi / 2;
    let angle2 = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle2 < 0; ) angle2 += pi2;
    for (; angle2 > pi2; ) angle2 -= pi2;
    let x05 = 0, y05 = 0, x14 = 0, y14 = 0;
    return angle2 < halfPi4 ? (x05 = 0, y05 = 1, x14 = Math.sin(angle2), y14 = Math.cos(angle2)) : angle2 < pi ? (x05 = 0, y05 = 0, x14 = Math.cos(angle2 - halfPi4), y14 = Math.sin(angle2 - halfPi4)) : angle2 < pi + halfPi4 ? (x05 = 1, y05 = 0, x14 = x05 - Math.sin(angle2 - pi), y14 = Math.cos(angle2 - pi)) : (x05 = 1, x14 = x05 - Math.cos(angle2 - halfPi4 - pi), y14 -= Math.sin(angle2 - halfPi4 - pi)), {
      gradient: "linear",
      x0: x05,
      y0: y05,
      x1: x14,
      y1: y14,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
};

// node_modules/@visactor/vrender-core/es/common/canvas-utils.js
function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const { a: a4, b: b2, c: c4, d: d2 } = context.currentMatrix, scaleX = Math.sign(a4) * Math.sqrt(a4 * a4 + b2 * b2), scaleY = Math.sign(d2) * Math.sqrt(c4 * c4 + d2 * d2);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c4, params2, offsetX, offsetY) {
  if (!c4 || true === c4) return "black";
  let result2, color;
  if (isArray_default(c4)) for (let i2 = 0; i2 < c4.length && (color = c4[i2], !color); i2++) ;
  else color = c4;
  return color = GradientParser.Parse(color), "string" == typeof color ? color : ("linear" === color.gradient ? result2 = createLinearGradient(context, color, params2, offsetX, offsetY) : "conical" === color.gradient ? result2 = createConicGradient(context, color, params2, offsetX, offsetY) : "radial" === color.gradient && (result2 = createRadialGradient(context, color, params2, offsetX, offsetY)), result2 || "orange");
}
function createLinearGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d;
  const bounds = params2.AABBBounds;
  if (!bounds) return;
  let w2 = bounds.x2 - bounds.x1, h2 = bounds.y2 - bounds.y1, x3 = bounds.x1 - offsetX, y3 = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0) return;
    w2 /= scaleX, h2 /= scaleY, x3 /= scaleX, y3 /= scaleY;
  }
  const canvasGradient = context.createLinearGradient(x3 + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w2, y3 + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h2, x3 + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w2, y3 + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h2);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d, _e, _f;
  const bounds = params2.AABBBounds;
  if (!bounds) return;
  let w2 = bounds.x2 - bounds.x1, h2 = bounds.y2 - bounds.y1, x3 = bounds.x1 - offsetX, y3 = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0) return;
    x3 /= scaleX, y3 /= scaleY, w2 /= scaleX, h2 /= scaleY;
  }
  const canvasGradient = context.createRadialGradient(x3 + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0.5) * w2, y3 + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0.5) * h2, Math.max(w2, h2) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x3 + (null !== (_d = color.x1) && void 0 !== _d ? _d : 0.5) * w2, y3 + (null !== (_e = color.y1) && void 0 !== _e ? _e : 0.5) * h2, Math.max(w2, h2) * (null !== (_f = color.r1) && void 0 !== _f ? _f : 0.5));
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b;
  const bounds = params2.AABBBounds;
  if (!bounds) return;
  let w2 = bounds.x2 - bounds.x1, h2 = bounds.y2 - bounds.y1, x3 = bounds.x1 - offsetX, y3 = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0) return;
    w2 /= scaleX, h2 /= scaleY, x3 /= scaleX, y3 /= scaleY;
  }
  const canvasGradient = context.createConicGradient(x3 + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w2, y3 + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h2, color.startAngle, color.endAngle);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern(w2 + x3, h2 + y3, void 0);
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-contribution-render.js
var __decorate8 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata6 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultBaseBackgroundRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
      }
      context.clip();
      const b2 = graphic.AABBBounds;
      context.setCommonStyle(graphic, graphic.attribute, x3, y3, graphicAttribute), this.doDrawImage(context, res.data, b2, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x3, y3, graphicAttribute), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b2, backgroundMode, backgroundFit) {
    if ("no-repeat" === backgroundMode) context.drawImage(data, b2.x1, b2.y1, b2.width(), b2.height());
    else {
      const targetW = b2.width(), targetH = b2.height();
      let w2 = targetW, h2 = targetH;
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width, resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w2 = resW * (targetH / resH), h2 = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h2 = resH * (targetW / resW), w2 = targetW;
        }
        const dpr2 = context.dpr, canvas = canvasAllocate.allocate({
          width: w2,
          height: h2,
          dpr: dpr2
        }), ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, w2, h2), ctx.drawImage(data, 0, 0, w2, h2), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr, pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b2.x1, b2.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b2.x1, -b2.y1);
    }
  }
};
var defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
var DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach((c4) => {
      c4.render(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate8([injectable(), __param4(0, inject(ContributionProvider)), __param4(0, named(InteractiveSubRenderContribution)), __metadata6("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/base-texture-contribution-render.js
var DefaultBaseTextureRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 10;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r2 = (size - 2 * padding) / 2, dpr = targetContext.dpr, canvas = canvasAllocate.allocate({
      width: size,
      height: size,
      dpr
    }), ctx = canvas.getContext("2d");
    if (!ctx) return null;
    ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, size, size), cb(r2, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      ctx.fillStyle = color, ctx.arc(r2, r2, r2, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      const x3 = size / 2, y3 = x3;
      ctx.fillStyle = color, ctx.moveTo(x3, y3 - r2), ctx.lineTo(r2 + x3, y3), ctx.lineTo(x3, y3 + r2), ctx.lineTo(x3 - r2, y3), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      const x3 = padding, y3 = x3;
      ctx.fillStyle = color, ctx.fillRect(x3, y3, 2 * r2, 2 * r2);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      const x3 = padding;
      ctx.fillStyle = color, ctx.fillRect(x3, 0, 2 * r2, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      const y3 = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y3, size, 2 * r2);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r2, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2, dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r2, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2, dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r2, ctx) => {
      const x3 = padding, y3 = x3;
      ctx.fillStyle = color, ctx.fillRect(x3, y3, r2, r2), ctx.fillRect(x3 + r2, y3 + r2, r2, r2);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = /* @__PURE__ */ new Map();
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x3, y3, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x3, y3, graphicAttribute, textureColor, textureSize, texturePadding) {
    let pattern = this.textureMap.get(texture);
    if (!pattern) switch (texture) {
      case "circle":
        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "diamond":
        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "rect":
        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "vertical-line":
        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "horizontal-line":
        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-lr":
        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-rl":
        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "grid":
        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
    }
    pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x3, y3, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
  }
};
var defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/arc-contribution-render.js
var DefaultArcRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(arc, context, x3, y3, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = arc.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, x: originX = arcAttribute.x, y: originY = arcAttribute.y, scaleX = arcAttribute.scaleX, scaleY = arcAttribute.scaleY } = arc.attribute, doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = arcAttribute.outerBorder.distance } = outerBorder, d2 = getScaledStroke(context, distance2, context.dpr), deltaAngle = distance2 / outerRadius;
      if (arc.setAttributes({
        outerRadius: outerRadius + d2,
        innerRadius: innerRadius - d2,
        startAngle: startAngle - deltaAngle,
        endAngle: endAngle + deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x3, y3, outerRadius + d2, innerRadius - d2), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, outerBorder, arcAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = arcAttribute.outerBorder.opacity;
        arcAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(arc, outerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, arcAttribute.outerBorder), arcAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = arcAttribute.innerBorder.distance } = innerBorder, d2 = getScaledStroke(context, distance2, context.dpr), deltaAngle = distance2 / outerRadius;
      if (arc.setAttributes({
        outerRadius: outerRadius - d2,
        innerRadius: innerRadius + d2,
        startAngle: startAngle + deltaAngle,
        endAngle: endAngle - deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x3, y3, outerRadius - d2, innerRadius + d2), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, innerBorder, arcAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = arcAttribute.innerBorder.opacity;
        arcAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(arc, innerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, arcAttribute.innerBorder), arcAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    arc.setAttributes({
      outerRadius,
      innerRadius,
      startAngle,
      endAngle
    });
  }
};
var defaultArcRenderContribution = new DefaultArcRenderContribution();
var defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/circle-contribution-render.js
var DefaultCircleRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(circle4, context, x3, y3, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = circle4.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, x: originX = circleAttribute.x, y: originY = circleAttribute.y, scaleX = circleAttribute.scaleX, scaleY = circleAttribute.scaleY } = circle4.attribute, doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = circleAttribute.outerBorder.distance } = outerBorder, dw = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), context.arc(x3, y3, radius + dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle4, circle4.attribute, circleAttribute), strokeCb) strokeCb(context, outerBorder, circleAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = circleAttribute.outerBorder.opacity;
        circleAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(circle4, outerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, circleAttribute.outerBorder), circleAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = circleAttribute.innerBorder.distance } = innerBorder, dw = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), context.arc(x3, y3, radius - dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle4, circle4.attribute, circleAttribute), strokeCb) strokeCb(context, innerBorder, circleAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = circleAttribute.innerBorder.opacity;
        circleAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(circle4, innerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, circleAttribute.innerBorder), circleAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var defaultCircleRenderContribution = new DefaultCircleRenderContribution();
var defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/group-contribution-render.js
var DefaultGroupBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
      const b2 = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b2, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
};
var defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

// node_modules/@visactor/vrender-core/es/common/shape/rect.js
var halfPi3 = pi / 2;
function createRectPath(path, x3, y3, width, height, rectCornerRadius) {
  let cornerRadius;
  if (width < 0 && (x3 += width, width = -width), height < 0 && (y3 += height, height = -height), isNumber_default(rectCornerRadius, true)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];
  else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x3, y3, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x3, y3], [x3 + width, y3], [x3 + width, y3 + height], [x3, y3 + height]], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])], leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]], leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]], rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]], rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]], rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]], rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]], leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]], leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
    const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];
    path.arc(centerX, centerY, _cornerRadius[1], -halfPi3, 0, false);
  }
  if (path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
    const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];
    path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi3, false);
  }
  if (path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
    const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];
    path.arc(centerX, centerY, _cornerRadius[3], halfPi3, pi, false);
  }
  if (path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
    const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];
    path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi3, false);
  }
  return path.closePath(), path;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/image-contribution-render.js
var DefaultImageBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background) if (graphic.backgroundImg) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
      }
      const b2 = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b2, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else if (isObject_default(background)) {
      const { stroke: stroke2, fill, lineWidth = 1, cornerRadius = 0, expandX = 0, expandY = 0 } = background;
      if (!stroke2 && !fill) return;
      context.beginPath();
      const { x: x4, y: y4, width, height } = getActualPosition(graphic);
      cornerRadius ? createRectPath(context, x4 - expandX, y4 - expandY, width + 2 * expandX, height + 2 * expandY, cornerRadius) : context.rect(x4 - expandX, y4 - expandY, width + 2 * expandX, height + 2 * expandY), context.globalAlpha = 1, fill && (context.fillStyle = fill, context.fill()), stroke2 && lineWidth > 0 && (context.lineWidth = lineWidth, context.strokeStyle = stroke2, context.stroke());
    } else {
      context.beginPath();
      const b2 = graphic.AABBBounds;
      context.rect(x3, y3, b2.width(), b2.height()), context.fillStyle = background, context.globalAlpha = 1, context.fill();
    }
  }
};
function getActualPosition(graphic) {
  const boundsPadding = parsePadding(graphic.attribute.boundsPadding), bounds = graphic.AABBBounds;
  let x3 = bounds.x1, y3 = bounds.y1, width = bounds.width(), height = bounds.height();
  return isNumber_default(boundsPadding) ? (x3 += boundsPadding, y3 += boundsPadding, width -= 2 * boundsPadding, height -= 2 * boundsPadding) : (x3 += boundsPadding[3], y3 += boundsPadding[0], width -= boundsPadding[1] + boundsPadding[3], height -= boundsPadding[0] + boundsPadding[2]), {
    x: x3,
    y: y3,
    width,
    height
  };
}
var defaultImageBackgroundRenderContribution = new DefaultImageBackgroundRenderContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/rect-contribution-render.js
var __decorate9 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultRectRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x3, y3, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = rect.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, x: originX = rectAttribute.x, y: originY = rectAttribute.y, scaleX = rectAttribute.scaleX, scaleY = rectAttribute.scaleY, x1: x14, y1: y14 } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - x3) || 0, height = (null != height ? height : y14 - y3) || 0;
    const doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = rectAttribute.outerBorder.distance } = outerBorder, d2 = getScaledStroke(context, distance2, context.dpr), nextX = x3 - d2, nextY = y3 - d2, dw = 2 * d2;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width + dw, height + dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width + dw, height + dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, outerBorder, rectAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = rectAttribute.outerBorder.opacity;
        rectAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(rect, outerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, rectAttribute.outerBorder), rectAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = rectAttribute.innerBorder.distance } = innerBorder, d2 = getScaledStroke(context, distance2, context.dpr), nextX = x3 + d2, nextY = y3 + d2, dw = 2 * d2;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - dw, height - dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - dw, height - dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, innerBorder, rectAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = rectAttribute.innerBorder.opacity;
        rectAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(rect, innerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, rectAttribute.innerBorder), rectAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x3, y3, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = groupAttribute.stroke } = group.attribute;
    Array.isArray(stroke2) && stroke2.some((s3) => false === s3) && (doFillOrStroke.doStroke = false);
  }
};
SplitRectBeforeRenderContribution = __decorate9([injectable()], SplitRectBeforeRenderContribution);
var SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x3, y3, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const { width = groupAttribute.width, height = groupAttribute.height, stroke: stroke2 = groupAttribute.stroke } = rect.attribute;
    if (Array.isArray(stroke2) && stroke2.some((s3) => false === s3)) {
      if (context.setStrokeStyle(rect, rect.attribute, x3, y3, groupAttribute), context.beginPath(), context.moveTo(x3, y3), stroke2[0] ? context.lineTo(x3 + width, y3) : context.moveTo(x3 + width, y3), stroke2[1] ? context.lineTo(x3 + width, y3 + height) : context.moveTo(x3 + width, y3 + height), stroke2[2] ? context.lineTo(x3, y3 + height) : context.moveTo(x3, y3 + height), stroke2[3]) {
        const adjustY = stroke2[0] ? y3 - context.lineWidth / 2 : y3;
        context.lineTo(x3, adjustY);
      } else context.moveTo(x3, y3);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate9([injectable()], SplitRectAfterRenderContribution);
var defaultRectRenderContribution = new DefaultRectRenderContribution();
var defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/symbol-contribution-render.js
var DefaultSymbolRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(symbol, context, x3, y3, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { outerBorder, innerBorder } = symbol.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY } = symbol.attribute, doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = symbolAttribute.outerBorder.distance } = outerBorder, d2 = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x3, y3, d2) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, outerBorder, symbolAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = symbolAttribute.outerBorder.opacity;
        symbolAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(symbol, outerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, symbolAttribute.outerBorder), symbolAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = symbolAttribute.innerBorder.distance } = innerBorder, d2 = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x3, y3, -d2) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, innerBorder, symbolAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = symbolAttribute.innerBorder.opacity;
        symbolAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(symbol, innerBorder, (originX - x3) / scaleX, (originY - y3) / scaleY, symbolAttribute.innerBorder), symbolAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
var defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-texture-contribution-render.js
var DefaultAreaTextureRenderContribution = class extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { attribute = graphic.attribute } = options || {}, { texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"), textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"), textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"), texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding") } = attribute;
    texture && this.drawTexture(texture, graphic, context, x3, y3, graphicAttribute, textureColor, textureSize, texturePadding);
  }
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc-render.js
var __decorate10 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata7 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcRender = class extends BaseRender {
  constructor(arcRenderContribitions) {
    super(), this.arcRenderContribitions = arcRenderContribitions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(arcRenderContribitions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    const cornerRadius = arc.getParsedCornerRadius(), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    let xore, yore, xirs, yirs;
    if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
      const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
      if (oc) {
        const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
      }
    }
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
      else {
        const a1 = endAngle - capAngle - 0.03, a22 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a22, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3) context.lineTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11), a22 = endAngle - capAngle - 0.03;
        context.arc(cx, cy, innerRadius, a1, a22, clockwise);
      }
    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, x: originX = arcAttribute.x, y: originY = arcAttribute.y } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean_default(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const { sc, startAngle, endAngle } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = false;
    const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke2);
    if ((doFill || isFullStroke) && (context.beginPath(), drawArcPath(arc, context, x3, y3, outerRadius, innerRadius), beforeRenderContribitionsRuned = true, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x3, y3, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x3, originY - y3, arcAttribute), context.fill())), doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x3, originY - y3, arcAttribute), context.stroke()))), !isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath(arc, context, x3, y3, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x3, y3, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x3, y3, arcAttribute), context.stroke());
    }
    if ((isBoolean_default(cap) && cap || cap[1]) && forceShowCap) {
      const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, { endAngle = arcAttribute.endAngle, fill: fill2 = arcAttribute.fill } = arc.attribute, startAngle = endAngle;
        if (this.drawArcTailCapPath(arc, context, x3, y3, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x3, y3, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill) {
          const color = fill2;
          if ("conical" === color.gradient) {
            const lastColor = getConicGradientAt(0, 0, endAngle, color);
            fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x3, y3, arcAttribute), context.fillStyle = lastColor, context.fill());
          }
        }
        doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x3, y3, arcAttribute), context.stroke()));
      }
    }
    this.afterRenderStep(arc, context, x3, y3, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArcRender = __decorate10([injectable(), __param5(0, inject(ContributionProvider)), __param5(0, named(ArcRenderContribution)), __metadata7("design:paramtypes", [Object])], DefaultCanvasArcRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/circle-render.js
var __decorate11 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata8 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCircleRender = class extends BaseRender {
  constructor(circleRenderContribitions) {
    super(), this.circleRenderContribitions = circleRenderContribitions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(circleRenderContribitions);
  }
  drawShape(circle4, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle4, null == params2 ? void 0 : params2.theme).circle, { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, x: originX = circleAttribute.x, y: originY = circleAttribute.y } = circle4.attribute, data = this.valid(circle4, circleAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), context.arc(x3, y3, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle4, circle4.attribute, circleAttribute), this.beforeRenderStep(circle4, context, x3, y3, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, circle4.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle4, circle4.attribute, originX - x3, originY - y3, circleAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, circle4.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle4, circle4.attribute, originX - x3, originY - y3, circleAttribute), context.stroke())), this.afterRenderStep(circle4, context, x3, y3, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle4, renderService, drawContext, params2) {
    const circleAttribute = getTheme(circle4, null == params2 ? void 0 : params2.theme).circle;
    this._draw(circle4, circleAttribute, false, drawContext, params2);
  }
};
DefaultCanvasCircleRender = __decorate11([injectable(), __param6(0, inject(ContributionProvider)), __param6(0, named(CircleRenderContribution)), __metadata8("design:paramtypes", [Object])], DefaultCanvasCircleRender);

// node_modules/@visactor/vrender-core/es/common/render-utils.js
function drawSegItem(ctx, curve, endPercent, params2) {
  if (!curve.p1) return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
  else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p2 = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p2.x, offsetY + p2.y, offsetZ);
  }
}

// node_modules/@visactor/vrender-core/es/common/render-curve.js
function drawSegments(path, segPath, percent, clipRangeByDimension, params2) {
  var _a;
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode: mode2 = "none", drawConnect = false, zeroX = 0, zeroY = 0 } = params2 || {};
  if (drawConnect && "none" === mode2) return;
  if (!segPath) return;
  let needMoveTo = true;
  const { curves } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve2, defined02 = true;
      curves.forEach((curve, i2) => {
        var _a2;
        let p0 = curve.p0;
        if (curve.originP1 !== curve.originP2) {
          if (lastCurve2 && lastCurve2.originP1 === lastCurve2.originP2 && (p0 = lastCurve2.p0), curve.defined) defined02 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), defined02 = !defined02);
          else {
            const { originP1, originP2 } = curve;
            let validP;
            if (originP1 && false !== originP1.defined ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a2 = curve.p3) && void 0 !== _a2 ? _a2 : curve.p1), defined02) {
              defined02 = !defined02;
              const x3 = validP ? validP.x : curve.p0.x, y3 = validP ? validP.y : curve.p0.y;
              path.moveTo(x3 + offsetX, y3 + offsetY, offsetZ);
            } else validP && (defined02 = !defined02, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
          }
          lastCurve2 = curve;
        } else lastCurve2 = curve;
      });
    } else curves.forEach((curve) => {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
    });
    return;
  }
  if (percent <= 0) return;
  let direction2;
  "x" === clipRangeByDimension ? direction2 = Direction.ROW : "y" === clipRangeByDimension ? direction2 = Direction.COLUMN : "auto" === clipRangeByDimension && (direction2 = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction2);
  let drawedLengthUntilLast = 0, defined0 = true, lastCurve = null;
  for (let i2 = 0, n2 = curves.length; i2 < n2; i2++) {
    const curve = curves[i2], curCurveLength = curve.getLength(direction2), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
    if (drawConnect) {
      let p0 = curve.p0;
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), defined0 = !defined0);
      else {
        const { originP1, originP2 } = curve;
        let validP;
        if (originP1 && false !== originP1.defined ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
          defined0 = !defined0;
          const x3 = validP ? validP.x : curve.p0.x, y3 = validP ? validP.y : curve.p0.y;
          path.moveTo(x3 + offsetX, y3 + offsetY, offsetZ);
        } else validP && (defined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
      }
      lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = true;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params2), needMoveTo = false;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments2.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments2.points.forEach((p2) => {
    false !== p2.defined ? path.lineTo(p2.x + offsetX, p2.y + offsetY) : path.moveTo(p2.x + offsetX, p2.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, { points } = segments2, definedPointsList = [];
  let lastIdx = 0;
  for (let i2 = 0; i2 < points.length; i2++) false === points[i2].defined && (lastIdx + 1 !== i2 && definedPointsList.slice(lastIdx, i2), lastIdx = i2);
  definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach((points2, i2) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i2 ? lastSeg.points[lastSeg.points.length - 1] : points2[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points2.forEach((p2) => {
      false !== p2.defined ? path.lineTo(p2.x + offsetX, p2.y + offsetY) : path.moveTo(p2.x + offsetX, p2.y + offsetY);
    });
    for (let i3 = points2.length - 1; i3 >= 0; i3--) {
      const p2 = points2[i3];
      path.lineTo(null !== (_a = p2.x1) && void 0 !== _a ? _a : p2.x, null !== (_b = p2.y1) && void 0 !== _b ? _b : p2.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/line-render.js
var __decorate12 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line2, renderService, drawContext, params2) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line;
    this._draw(line2, lineAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e;
    if (!cache) return;
    context.beginPath();
    const z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY,
      offsetZ: z2
    }), line2.cache && !isArray_default(line2.cache) && line2.cache.curves.every((c4) => c4.defined) && line2.attribute.curveType && line2.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke()));
    let { connectedType, connectedX, connectedY, connectedStyle } = attribute;
    if (isArray_default(defaultAttribute) ? (connectedType = null !== (_b = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _b ? _b : defaultAttribute[1].connectedType, connectedX = null !== (_c = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _c ? _c : defaultAttribute[1].connectedX, connectedY = null !== (_d = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _d ? _d : defaultAttribute[1].connectedY, connectedStyle = null !== (_e = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _e ? _e : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), "none" !== connectedType) {
      context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
        offsetX,
        offsetY,
        offsetZ: z2,
        drawConnect: true,
        mode: connectedType,
        zeroX: connectedX,
        zeroY: connectedY
      });
      const da = [];
      isArray_default(defaultAttribute) ? defaultAttribute.forEach((i2) => da.push(i2)) : da.push(defaultAttribute), da.push(attribute), false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line2, connectedStyle, originX - offsetX, originY - offsetY, da), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line2, connectedStyle, originX - offsetX, originY - offsetY, da), context.stroke()));
    }
    return false;
  }
  drawLinearLineHighPerformance(line2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { points } = line2.attribute, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z2);
    for (let i2 = 1; i2 < points.length; i2++) {
      const p2 = points[i2];
      context.lineTo(p2.x + offsetX, p2.y + offsetY, z2);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line2, line2.attribute, lineAttribute);
    const { x: originX = 0, x: originY = 0 } = line2.attribute;
    false !== fill && (fillCb ? fillCb(context, line2.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, line2.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line2, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, segments: segments2, points, closePath } = line2.attribute;
    if (!this.valid(line2, lineAttribute, fillCb, strokeCb)) return;
    let { curveType = lineAttribute.curveType } = line2.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line2.attribute;
    if (1 === clipRange && !segments2 && !points.some((p2) => false === p2.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line2, context, !!fill, !!stroke2, fillOpacity, strokeOpacity, x3, y3, lineAttribute, drawContext, params2, fillCb, strokeCb);
    if (line2.shouldUpdateShape()) {
      const { points: points2, segments: segments3 } = line2.attribute, _points = points2;
      if (segments3 && segments3.length) {
        let startPoint, lastSeg;
        if (line2.cache = segments3.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y,
            curves: [{
              defined: false !== seg.points[0].defined
            }]
          }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(seg.points, curveType, {
            startPoint
          });
          return lastSeg = data, data;
        }).filter((item) => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i2 = 0; i2 < line2.cache.length; i2++) {
            const cacheItem = line2.cache[i2];
            for (let i3 = 0; i3 < cacheItem.curves.length; i3++) if (cacheItem.curves[i3].defined) {
              startP = cacheItem.curves[i3].p0;
              break;
            }
            if (startP) break;
          }
          line2.cache[line2.cache.length - 1] && line2.cache[line2.cache.length - 1].lineTo(startP.x, startP.y, true);
        }
      } else {
        if (!points2 || !points2.length) return line2.cache = null, void line2.clearUpdateShapeTag();
        line2.cache = calcLineCache(_points, curveType);
      }
      line2.clearUpdateShapeTag();
    }
    if (Array.isArray(line2.cache)) {
      const segments3 = line2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        line2.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], clipRange, clipRangeByDimension, x3, y3, line2, fillCb, strokeCb));
        });
      } else {
        const totalLength = line2.cache.reduce((l2, c4) => l2 + c4.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        line2.cache.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], min(_cr, 1), clipRangeByDimension, x3, y3, line2, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, line2.cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, line2.attribute, lineAttribute, clipRange, clipRangeByDimension, x3, y3, line2, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate12([injectable()], DefaultCanvasLineRender);

// node_modules/@visactor/vrender-core/es/common/render-area.js
function drawAreaSegments(path, segPath, percent, params2) {
  var _a;
  const { drawConnect = false, mode: mode2 = "none" } = params2 || {};
  if (drawConnect && "none" === mode2) return;
  const { top, bottom } = segPath;
  if (top.curves.length !== bottom.curves.length) return;
  if (percent >= 1) {
    const topList2 = [], bottomList2 = [];
    let lastDefined2 = true;
    if (drawConnect) {
      let lastCurve, lastBottomCurve2, defined02 = true;
      const n2 = top.curves.length;
      top.curves.forEach((curve, i2) => {
        const bototmCurve = bottom.curves[n2 - i2 - 1];
        let currentTopCurve = curve, currentBottomCurve = bototmCurve;
        if (curve.originP1 === curve.originP2) return lastCurve = curve, void (lastBottomCurve2 = bototmCurve);
        if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (currentTopCurve = lastCurve, currentBottomCurve = lastBottomCurve2), curve.defined) defined02 || (topList2.push(currentTopCurve), bottomList2.push(currentBottomCurve), drawAreaConnectBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0, defined02 = !defined02);
        else {
          const { originP1, originP2 } = curve;
          let validTopCurve, validBottomCurve;
          originP1 && false !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && false !== originP2.defined && (validTopCurve = curve, validBottomCurve = bototmCurve), defined02 ? (defined02 = !defined02, topList2.push(validTopCurve || curve), bottomList2.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined02 = !defined02, topList2.push(validTopCurve || curve), bottomList2.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0);
        }
        lastCurve = curve;
      }), drawAreaConnectBlock(path, topList2, bottomList2, params2);
    } else {
      for (let i2 = 0, n2 = top.curves.length; i2 < n2; i2++) {
        const topCurve = top.curves[i2];
        lastDefined2 !== topCurve.defined ? (lastDefined2 ? (drawAreaBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0) : (topList2.push(topCurve), bottomList2.push(bottom.curves[n2 - i2 - 1])), lastDefined2 = !lastDefined2) : lastDefined2 && (topList2.push(topCurve), bottomList2.push(bottom.curves[n2 - i2 - 1]));
      }
      drawAreaBlock(path, topList2, bottomList2, params2);
    }
    return;
  }
  if (percent <= 0) return;
  let { direction: direction2 } = params2 || {};
  const { curves: topCurves } = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = abs(endP.x - topCurves[0].p0.x), yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction2 = null != direction2 ? direction2 : xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN, Number.isFinite(xTotalLength) || (direction2 = Direction.COLUMN), Number.isFinite(yTotalLength) || (direction2 = Direction.ROW);
  const totalDrawLength = percent * (direction2 === Direction.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0, lastDefined = true;
  const topList = [], bottomList = [];
  let lastTopCurve, lastBottomCurve, defined0 = true;
  for (let i2 = 0, n2 = top.curves.length; i2 < n2; i2++) {
    const topCurve = top.curves[i2], curCurveLength = topCurve.getLength(direction2), percent2 = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent2 < 0) break;
    if (drawedLengthUntilLast += curCurveLength, drawConnect) {
      const bototmCurve = bottom.curves[n2 - i2 - 1];
      let currentTopCurve = topCurve, currentBottomCurve = bototmCurve;
      if (topCurve.originP1 === topCurve.originP2) {
        lastTopCurve = topCurve, lastBottomCurve = bototmCurve;
        continue;
      }
      if (lastTopCurve && lastTopCurve.originP1 === lastTopCurve.originP2 && (currentTopCurve = lastTopCurve, currentBottomCurve = lastBottomCurve), topCurve.defined) defined0 || (topList.push(currentTopCurve), bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0, defined0 = !defined0);
      else {
        const { originP1, originP2 } = topCurve;
        let validTopCurve, validBottomCurve;
        originP1 && false !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && false !== originP2.defined && (validTopCurve = topCurve, validBottomCurve = bototmCurve), defined0 ? (defined0 = !defined0, topList.push(validTopCurve || topCurve), bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined0 = !defined0, topList.push(validTopCurve || topCurve), bottomList.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0);
      }
      lastTopCurve = topCurve;
    } else {
      let tc = null, bc = null;
      lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n2 - i2 - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n2 - i2 - 1]), tc && bc && (percent2 < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent2)[0] : divideLinear(tc, percent2)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent2)[1] : divideLinear(bc, 1 - percent2)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
    }
  }
  drawConnect ? drawAreaConnectBlock(path, topList, bottomList, params2) : drawAreaBlock(path, topList, bottomList, params2);
}
function drawAreaConnectBlock(path, topList, bottomList, params2) {
  if (topList.length < 2) return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode: mode2 } = params2 || {};
  let curve = topList[0];
  path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = topList[topList.length - 1];
  let end = curve.p3 || curve.p1;
  path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), curve = bottomList[bottomList.length - 1], path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = bottomList[0], end = curve.p3 || curve.p1, path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), path.closePath();
}
function drawAreaBlock(path, topList, bottomList, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  let needMoveTo = true;
  topList.forEach((curve) => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }), needMoveTo = true;
  for (let i2 = bottomList.length - 1; i2 >= 0; i2--) {
    const curve = bottomList[i2];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }
  path.closePath();
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/area-contribution-render.js
var defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
var defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/area-render.js
var __decorate13 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata9 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function calcLineCache2(points, curveType, params2) {
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}
var DefaultCanvasAreaRender = class extends BaseRender {
  constructor(areaRenderContribitions) {
    super(), this.areaRenderContribitions = areaRenderContribitions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(areaRenderContribitions);
  }
  drawLinearAreaHighPerformance(area2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e;
    context.beginPath();
    const z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { points } = area2.attribute, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z2);
    for (let i2 = 1; i2 < points.length; i2++) {
      const p2 = points[i2];
      context.lineTo(p2.x + offsetX, p2.y + offsetY, z2);
    }
    for (let i2 = points.length - 1; i2 >= 0; i2--) {
      const p2 = points[i2];
      context.lineTo((null !== (_b = p2.x1) && void 0 !== _b ? _b : p2.x) + offsetX, (null !== (_c = p2.y1) && void 0 !== _c ? _c : p2.y) + offsetY, z2);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, area2.attribute, areaAttribute), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    });
    const { x: originX = 0, x: originY = 0 } = area2.attribute;
    if (false !== fill && (fillCb ? fillCb(context, area2.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    }), stroke2) {
      const { stroke: stroke3 = areaAttribute && areaAttribute.stroke } = area2.attribute;
      if (isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1]) {
        if (context.beginPath(), stroke3[0]) {
          context.moveTo(startP.x + offsetX, startP.y + offsetY, z2);
          for (let i2 = 1; i2 < points.length; i2++) {
            const p2 = points[i2];
            context.lineTo(p2.x + offsetX, p2.y + offsetY, z2);
          }
        } else if (stroke3[2]) {
          const endP = points[points.length - 1];
          context.moveTo(endP.x + offsetX, endP.y + offsetY, z2);
          for (let i2 = points.length - 2; i2 >= 0; i2--) {
            const p2 = points[i2];
            context.lineTo((null !== (_d = p2.x1) && void 0 !== _d ? _d : p2.x) + offsetX, (null !== (_e = p2.y1) && void 0 !== _e ? _e : p2.y) + offsetY, z2);
          }
        }
      }
      strokeCb ? strokeCb(context, area2.attribute, areaAttribute) : (context.setStrokeStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
    }
  }
  drawShape(area2, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area, { fill = areaAttribute.fill, stroke: stroke2 = areaAttribute.stroke, fillOpacity = areaAttribute.fillOpacity, z: z2 = areaAttribute.z, strokeOpacity = areaAttribute.strokeOpacity } = area2.attribute, data = this.valid(area2, areaAttribute, fillCb, strokeCb);
    if (!data) return;
    const { doFill, doStroke } = data, { clipRange = areaAttribute.clipRange, closePath, points, segments: segments2 } = area2.attribute;
    let { curveType = areaAttribute.curveType } = area2.attribute;
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments2 && !points.some((p2) => false === p2.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area2, context, !!fill, doStroke, fillOpacity, strokeOpacity, x3, y3, areaAttribute, drawContext, params2, fillCb, strokeCb);
    if (area2.shouldUpdateShape()) {
      if (segments2 && segments2.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments2.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y
          }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data2 = calcLineCache2(seg.points, curveType, {
            startPoint
          });
          return lastTopSeg = data2, data2;
        }).filter((item) => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i2 = segments2.length - 1; i2 >= 0; i2--) {
          const points2 = segments2[i2].points, bottomPoints = [];
          for (let i3 = points2.length - 1; i3 >= 0; i3--) bottomPoints.push({
            x: null !== (_a = points2[i3].x1) && void 0 !== _a ? _a : points2[i3].x,
            y: null !== (_b = points2[i3].y1) && void 0 !== _b ? _b : points2[i3].y
          });
          if (0 !== i2) {
            const lastSegmentPoints = segments2[i2 - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache2(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType), bottomCaches.unshift(lastBottomSeg));
        }
        area2.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length) return area2.cacheArea = null, void area2.clearUpdateShapeTag();
        {
          const topPoints = points, bottomPoints = [];
          for (let i2 = points.length - 1; i2 >= 0; i2--) bottomPoints.push({
            x: null !== (_e = points[i2].x1) && void 0 !== _e ? _e : points[i2].x,
            y: null !== (_f = points[i2].y1) && void 0 !== _f ? _f : points[i2].y
          });
          const topCache = calcLineCache2(topPoints, curveType), bottomCache = calcLineCache2(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType);
          area2.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area2.clearUpdateShapeTag();
    }
    if (Array.isArray(area2.cacheArea)) {
      const segments3 = area2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        area2.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], clipRange, x3, y3, z2, area2, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area2.cacheArea.reduce((l2, c4) => l2 + c4.top.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        area2.cacheArea.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], min(_cr, 1), x3, y3, z2, area2, drawContext, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, area2.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area2.attribute, areaAttribute, clipRange, x3, y3, z2, area2, drawContext, fillCb, strokeCb);
  }
  draw(area2, renderService, drawContext, params2) {
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area;
    this._draw(area2, areaAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb, strokeCb) {
    let ret = false;
    return ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, false, fillCb, strokeCb), ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, true, fillCb, strokeCb), ret;
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, connect, fillCb, strokeCb) {
    var _a, _b, _c, _d;
    let { connectedType, connectedX, connectedY, connectedStyle } = attribute;
    const da = [];
    if (connect && (isArray_default(defaultAttribute) ? (connectedType = null !== (_a = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _a ? _a : defaultAttribute[1].connectedType, connectedX = null !== (_b = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _b ? _b : defaultAttribute[1].connectedX, connectedY = null !== (_c = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _c ? _c : defaultAttribute[1].connectedY, connectedStyle = null !== (_d = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _d ? _d : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), isArray_default(defaultAttribute) ? defaultAttribute.forEach((i2) => da.push(i2)) : da.push(defaultAttribute), da.push(attribute)), connect && "none" === connectedType) return false;
    if (!cache) return;
    context.beginPath();
    const { points, segments: segments2 } = area2.attribute;
    let endP, startP, direction2 = Direction.ROW;
    if (segments2) {
      const endSeg = segments2[segments2.length - 1];
      startP = segments2[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else startP = points[0], endP = points[points.length - 1];
    direction2 = abs(endP.x - startP.x) > abs(endP.y - startP.y) ? Direction.ROW : Direction.COLUMN, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
      offsetX,
      offsetY,
      offsetZ,
      direction: direction2,
      drawConnect: connect,
      mode: connectedType,
      zeroX: connectedX,
      zeroY: connectedY
    }), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    if (false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area2, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), false !== stroke2) if (strokeCb) strokeCb(context, attribute, defaultAttribute);
    else {
      const { stroke: stroke3 = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;
      isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke3[0] ? cache.top : cache.bottom, clipRange, direction2 === Direction.ROW ? "x" : "y", {
        offsetX,
        offsetY,
        offsetZ,
        drawConnect: connect,
        mode: connectedType,
        zeroX: connectedX,
        zeroY: connectedY
      })), context.setStrokeStyle(area2, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.stroke();
    }
    return false;
  }
};
DefaultCanvasAreaRender = __decorate13([injectable(), __param7(0, inject(ContributionProvider)), __param7(0, named(AreaRenderContribution)), __metadata9("design:paramtypes", [Object])], DefaultCanvasAreaRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/path-contribution-render.js
var defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/path-render.js
var __decorate14 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata10 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathRender = class extends BaseRender {
  constructor(pathRenderContribitions) {
    super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(pathRenderContribitions);
  }
  drawShape(path, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params2 ? void 0 : params2.theme).path, { x: originX = pathAttribute.x, y: originY = pathAttribute.y } = path.attribute, z2 = null !== (_b = this.z) && void 0 !== _b ? _b : 0, data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x3, y3, 1, 1, z2);
    else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x3, y3, 1, 1, z2);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x3, y3, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x3, originY - y3, pathAttribute), context.stroke())), doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x3, originY - y3, pathAttribute), context.fill())), this.afterRenderStep(path, context, x3, y3, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params2) {
    const pathAttribute = getTheme(path, null == params2 ? void 0 : params2.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate14([injectable(), __param8(0, inject(ContributionProvider)), __param8(0, named(PathRenderContribution)), __metadata10("design:paramtypes", [Object])], DefaultCanvasPathRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect-render.js
var __decorate15 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata11 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectRender = class extends BaseRender {
  constructor(rectRenderContribitions) {
    super(), this.rectRenderContribitions = rectRenderContribitions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(rectRenderContribitions);
  }
  drawShape(rect, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, background, stroke: stroke2 = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x1: x14, y1: y14, x: originX = rectAttribute.x, y: originY = rectAttribute.y } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - originX) || 0, height = (null != height ? height : y14 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x3, y3, width, height)) : (context.beginPath(), createRectPath(context, x3, y3, width, height, cornerRadius));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x3, y3, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke), doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x3, originY - y3, rectAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x3, originY - y3, rectAttribute), context.stroke())), this.afterRenderStep(rect, context, x3, y3, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  draw(rect, renderService, drawContext, params2) {
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect;
    this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasRectRender = __decorate15([injectable(), __param9(0, inject(ContributionProvider)), __param9(0, named(RectRenderContribution)), __metadata11("design:paramtypes", [Object])], DefaultCanvasRectRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-render.js
var __decorate16 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata12 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(symbolRenderContribitions) {
    super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution], this.init(symbolRenderContribitions);
  }
  drawShape(symbol, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol, { size = symbolAttribute.size, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY } = symbol.attribute, data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute, z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (context.beginPath(), keepDirIn3d && context.camera && context.project) {
      const p2 = context.project(x3, y3, z2), camera = context.camera;
      context.camera = null, false === parsedPath.draw(context, isArray_default(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, p2.x, p2.y, void 0, (p3, a4) => {
        var _a2, _b, _c;
        if (symbol._parsedPath.svgCache) {
          const obj = Object.assign({}, a4);
          obj.fill = null !== (_a2 = a4.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj.opacity = null !== (_b = a4.fill) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a4.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a4 = obj;
        }
        a4.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a4, originX - x3, originY - y3, symbolAttribute), context.fill())), a4.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a4, (originX - x3) / scaleX, (originY - y3) / scaleY, symbolAttribute), context.stroke()));
      }) && context.closePath(), context.camera = camera;
    } else false === parsedPath.draw(context, size, x3, y3, z2, (p2, a4) => {
      var _a2, _b, _c;
      if (symbol._parsedPath.svgCache) {
        const obj = Object.assign({}, a4);
        obj.fill = null !== (_a2 = a4.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj.opacity = null !== (_b = a4.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a4.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a4 = obj;
      }
      a4.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a4, originX - x3, originY - y3, symbolAttribute), context.fill())), a4.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a4, (originX - x3) / scaleX, (originY - y3) / scaleY, symbolAttribute), context.stroke()));
    }) && context.closePath();
    context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x3, y3, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb), doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x3, originY - y3, symbolAttribute), context.fill())), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x3) / scaleX, (originY - y3) / scaleY, symbolAttribute), context.stroke())), this.afterRenderStep(symbol, context, x3, y3, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  draw(symbol, renderService, drawContext, params2) {
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol;
    this._draw(symbol, symbolAttribute, false, drawContext, params2);
  }
};
DefaultCanvasSymbolRender = __decorate16([injectable(), __param10(0, inject(ContributionProvider)), __param10(0, named(SymbolRenderContribution)), __metadata12("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

// node_modules/@visactor/vrender-core/es/allocator/bounds-allocate.js
var BoundsAllocate = Symbol.for("BoundsAllocate");
var DefaultBoundsAllocate = class {
  constructor() {
    this.pools = [];
    for (let i2 = 0; i2 < 10; i2++) this.pools.push(new AABBBounds());
  }
  allocate(x14, y14, x23, y23) {
    if (!this.pools.length) return new AABBBounds().setValue(x14, y14, x23, y23);
    const b2 = this.pools.pop();
    return b2.x1 = x14, b2.y1 = y14, b2.x2 = x23, b2.y2 = y23, b2;
  }
  allocateByObj(b2) {
    if (!this.pools.length) return new AABBBounds(b2);
    const _b = this.pools.pop();
    return _b.x1 = b2.x1, _b.y1 = b2.y1, _b.x2 = b2.x2, _b.y2 = b2.y2, _b;
  }
  free(b2) {
    this.pools.push(b2);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var boundsAllocate = new DefaultBoundsAllocate();

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/text-contribution-render.js
var DefaultTextBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    let b2, { background } = graphic.attribute;
    if (!background) return;
    const shouldReCalBounds = isObject_default(background) && background.background, onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds, x4 = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0), y4 = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0), w2 = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(), h2 = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b2 = boundsAllocate.allocate(x4, y4, x4 + w2, y4 + h2), background = background.background, !onlyTranslate) {
        const w3 = b2.width(), h3 = b2.height();
        b2.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w3, h3);
      }
    } else b2 = graphic.AABBBounds, onlyTranslate || b2.set(0, 0, b2.width(), b2.height());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.setCommonStyle(graphic, graphic.attribute, x3, y3, graphicAttribute), this.doDrawImage(context, res.data, b2, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x3, y3, graphicAttribute), context.fillStyle = background, context.fillRect(b2.x1, b2.y1, b2.width(), b2.height()), context.highPerformanceRestore();
    shouldReCalBounds && boundsAllocate.free(b2);
  }
};
var defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

// node_modules/@visactor/vrender-core/es/render/contributions/render/text-render.js
var __decorate17 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata13 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextRender = class extends BaseRender {
  constructor(textRenderContribitions) {
    super(), this.textRenderContribitions = textRenderContribitions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(textRenderContribitions);
  }
  drawShape(text2, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { text: str, underline = textAttribute2.underline, lineThrough = textAttribute2.lineThrough, keepDirIn3d = textAttribute2.keepDirIn3d, direction: direction2 = textAttribute2.direction, whiteSpace = textAttribute2.whiteSpace, fontSize = textAttribute2.fontSize, verticalMode = textAttribute2.verticalMode, x: originX = textAttribute2.x, y: originY = textAttribute2.y } = text2.attribute;
    let { textAlign = textAttribute2.textAlign, textBaseline = textAttribute2.textBaseline } = text2.attribute;
    if (!verticalMode && "vertical" === direction2) {
      const t2 = textAlign;
      textAlign = null !== (_a = text2.getBaselineMapAlign()[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = text2.getAlignMapBaseline()[t2]) && void 0 !== _b ? _b : "top";
    }
    const lineHeight = null !== (_c = calculateLineHeight(text2.attribute.lineHeight, fontSize)) && void 0 !== _c ? _c : fontSize, data = this.valid(text2, textAttribute2, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, transform3dMatrixToContextMatrix = !keepDirIn3d, z2 = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text2, text2.attribute, textAttribute2), this.beforeRenderStep(text2, context, x3, y3, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text2, textAttribute2, z2, context);
    const drawText = (t2, offsetX, offsetY, direction3) => {
      let _x = x3 + offsetX;
      const _y = y3 + offsetY;
      if (direction3) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, true), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x3, originY - y3, textAttribute2), context.strokeText(t2, _x, _y, z2))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x3, originY - y3, textAttribute2), context.fillText(t2, _x, _y, z2), this.drawUnderLine(underline, lineThrough, text2, _x, _y, z2, textAttribute2, context))), direction3 && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (text2.isMultiLine) if (context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute2, z2), "horizontal" === direction2) {
      const { multilineLayout } = text2;
      if (!multilineLayout) return void context.highPerformanceRestore();
      const { xOffset, yOffset } = multilineLayout.bbox;
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x3, originY - y3, textAttribute2), multilineLayout.lines.forEach((line2) => {
        context.strokeText(line2.str, (line2.leftOffset || 0) + xOffset + x3, (line2.topOffset || 0) + yOffset + y3, z2);
      }))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x3, originY - y3, textAttribute2), multilineLayout.lines.forEach((line2) => {
        context.fillText(line2.str, (line2.leftOffset || 0) + xOffset + x3, (line2.topOffset || 0) + yOffset + y3, z2), this.drawMultiUnderLine(underline, lineThrough, text2, (line2.leftOffset || 0) + x3, (line2.topOffset || 0) + yOffset + y3, z2, line2.width, textAttribute2, context);
      })));
    } else {
      text2.tryUpdateAABBBounds();
      const cache = text2.cache, { verticalList } = cache;
      context.textAlign = "left", context.textBaseline = "top";
      const totalHeight = lineHeight * verticalList.length;
      let totalW = 0;
      verticalList.forEach((verticalData) => {
        const _w = verticalData.reduce((a4, b2) => a4 + (b2.width || 0), 0);
        totalW = max(_w, totalW);
      });
      let offsetY = 0, offsetX = 0;
      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i2) => {
        const currentW = verticalData.reduce((a4, b2) => a4 + (b2.width || 0), 0), dw = totalW - currentW;
        let currentOffsetY = offsetY;
        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach((item) => {
          const { text: text3, width, direction: direction3 } = item;
          drawText(text3, totalHeight - (i2 + 1) * lineHeight + offsetX, currentOffsetY, direction3), currentOffsetY += width;
        });
      });
    }
    else if ("horizontal" === direction2) {
      context.setTextStyle(text2.attribute, textAttribute2, z2);
      const t2 = text2.clipedText;
      let dy = 0;
      lineHeight !== fontSize && ("top" === textBaseline ? dy = (lineHeight - fontSize) / 2 : "middle" === textBaseline || "bottom" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), drawText(t2, 0, dy, 0);
    } else {
      text2.tryUpdateAABBBounds();
      const cache = text2.cache;
      if (cache) {
        context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute2, z2);
        const { verticalList } = cache;
        let offsetY = 0;
        const totalW = verticalList[0].reduce((a4, b2) => a4 + (b2.width || 0), 0);
        let offsetX = 0;
        "bottom" === textBaseline ? offsetX = -lineHeight : "middle" === textBaseline && (offsetX = -lineHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), context.textAlign = "left", context.textBaseline = "top", verticalList[0].forEach((item) => {
          const { text: text3, width, direction: direction3 } = item;
          drawText(text3, offsetX, offsetY, direction3), offsetY += width;
        });
      }
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text2, textAttribute2, z2, context), this.afterRenderStep(text2, context, x3, y3, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb);
  }
  draw(text2, renderService, drawContext, params2) {
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d;
    this._draw(text2, textAttribute2, computed3dMatrix, drawContext, params2);
  }
  drawUnderLine(underline, lineThrough, text2, x3, y3, z2, textAttribute2, context) {
    if (lineThrough + underline <= 0) return;
    const { textAlign = textAttribute2.textAlign, textBaseline = textAttribute2.textBaseline, fontSize = textAttribute2.fontSize, fill = textAttribute2.fill, opacity = textAttribute2.opacity, fillOpacity = textAttribute2.fillOpacity } = text2.attribute, w2 = text2.clipedWidth, offsetX = textDrawOffsetX(textAlign, w2), offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, x3, y3, textAttribute2), context.beginPath();
      const dy = y3 + offsetY + fontSize;
      context.moveTo(x3 + offsetX, dy, z2), context.lineTo(x3 + offsetX + w2, dy, z2), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, x3, y3, textAttribute2), context.beginPath();
      const dy = y3 + offsetY + fontSize / 2;
      context.moveTo(x3 + offsetX, dy, z2), context.lineTo(x3 + offsetX + w2, dy, z2), context.stroke();
    }
  }
  drawMultiUnderLine(underline, lineThrough, text2, x3, y3, z2, w2, textAttribute2, context) {
    if (lineThrough + underline <= 0) return;
    const { textAlign = textAttribute2.textAlign, fontSize = textAttribute2.fontSize, fill = textAttribute2.fill, opacity = textAttribute2.opacity, fillOpacity = textAttribute2.fillOpacity } = text2.attribute, offsetX = textDrawOffsetX(textAlign, w2), offsetY = textLayoutOffsetY("alphabetic", fontSize, fontSize), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    let deltaY = -3;
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, x3, y3, textAttribute2), context.beginPath();
      const dy = y3 + offsetY + fontSize + deltaY;
      context.moveTo(x3 + offsetX, dy, z2), context.lineTo(x3 + offsetX + w2, dy, z2), context.stroke();
    }
    if (deltaY = -1, lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, x3, y3, textAttribute2), context.beginPath();
      const dy = y3 + offsetY + fontSize / 2 + deltaY;
      context.moveTo(x3 + offsetX, dy, z2), context.lineTo(x3 + offsetX + w2, dy, z2), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate17([injectable(), __param11(0, inject(ContributionProvider)), __param11(0, named(TextRenderContribution)), __metadata13("design:paramtypes", [Object])], DefaultCanvasTextRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/graphic-render.js
var __decorate18 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var AbstractGraphicRender = class {
};
AbstractGraphicRender = __decorate18([injectable()], AbstractGraphicRender);

// node_modules/@visactor/vrender-core/es/common/polygon.js
function drawPolygon(path, points, x3, y3) {
  path.moveTo(points[0].x + x3, points[0].y + y3);
  for (let i2 = 1; i2 < points.length; i2++) path.lineTo(points[i2].x + x3, points[i2].y + y3);
}
function drawRoundedPolygon(path, points, x3, y3, cornerRadius, closePath = true) {
  var _a;
  if (points.length < 3) return void drawPolygon(path, points, x3, y3);
  let startI = 0, endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x3, points[0].y + y3));
  for (let i2 = startI; i2 <= endI; i2++) {
    const p1 = points[0 === i2 ? endI : (i2 - 1) % points.length], angularPoint = points[i2 % points.length], p2 = points[(i2 + 1) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle2 = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan2 = Math.abs(Math.tan(angle2));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i2 % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan2;
    const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length3 = Math.min(length1, length2);
    segment > length3 && (segment = length3, radius = length3 * tan2);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L2 = getLength(dx, dy), circlePoint2 = getProportionPoint(angularPoint, getLength(segment, radius), L2, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint2.y, p1Cross.x - circlePoint2.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint2.y, p2Cross.x - circlePoint2.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i2 ? path.moveTo(p1Cross.x + x3, p1Cross.y + y3) : path.lineTo(p1Cross.x + x3, p1Cross.y + y3), sweepAngle && path.arcTo(angularPoint.x + x3, angularPoint.y + y3, p2Cross.x + x3, p2Cross.y + y3, radius), path.lineTo(p2Cross.x + x3, p2Cross.y + y3);
  }
  closePath || path.lineTo(points[endI + 1].x + x3, points[endI + 1].y + y3);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point6, segment, length2, dx, dy) {
  const factor = segment / length2;
  return {
    x: point6.x - dx * factor,
    y: point6.y - dy * factor
  };
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/contributions/polygon-contribution-render.js
var defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-render.js
var __decorate19 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata14 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(polygonRenderContribitions) {
    super(), this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(polygonRenderContribitions);
  }
  drawShape(polygon, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon, { points = polygonAttribute.points, cornerRadius = polygonAttribute.cornerRadius, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y, closePath = polygonAttribute.closePath } = polygon.attribute, data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), cornerRadius <= 0 || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x3, y3) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x3, y3, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x3, y3, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x3, originY - y3, polygonAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x3, originY - y3, polygonAttribute), context.stroke())), this.afterRenderStep(polygon, context, x3, y3, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params2) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon;
    this._draw(polygon, polygonAttribute, false, drawContext, params2);
  }
};
DefaultCanvasPolygonRender = __decorate19([injectable(), __param12(0, inject(ContributionProvider)), __param12(0, named(PolygonRenderContribution)), __metadata14("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/image-render.js
var __decorate20 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata15 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
var DefaultCanvasImageRender = class extends BaseRender {
  constructor(imageRenderContribitions) {
    super(), this.imageRenderContribitions = imageRenderContribitions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageBackgroundRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x3, y3, drawContext, params2, fillCb) {
    const imageAttribute = getTheme(image).image, { width = imageAttribute.width, height = imageAttribute.height, repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, cornerRadius = imageAttribute.cornerRadius, image: url } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.setShadowBlendStyle && context.setShadowBlendStyle(image, imageAttribute), this.beforeRenderStep(image, context, x3, y3, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), doFill) {
      if (fillCb) fillCb(context, image.attribute, imageAttribute);
      else if (fVisible) {
        if (!url || !image.resources) return;
        const res = image.resources.get(url);
        if ("success" !== res.state) return;
        let needRestore = false;
        0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) || (context.beginPath(), createRectPath(context, x3, y3, width, height, cornerRadius), context.save(), context.clip(), needRestore = true), context.setCommonStyle(image, image.attribute, x3, y3, imageAttribute);
        let repeat = 0;
        if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
          const pattern = context.createPattern(res.data, repeatStr[repeat]);
          context.fillStyle = pattern, context.translate(x3, y3, true), context.fillRect(0, 0, width, height), context.translate(-x3, -y3, true);
        } else context.drawImage(res.data, x3, y3, width, height);
        needRestore && context.restore();
      }
    }
    this.afterRenderStep(image, context, x3, y3, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { image: url } = image.attribute;
    if (!url || !image.resources) return;
    if ("success" !== image.resources.get(url).state) return;
    const { context } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasImageRender = __decorate20([injectable(), __param13(0, inject(ContributionProvider)), __param13(0, named(ImageRenderContribution)), __metadata15("design:paramtypes", [Object])], DefaultCanvasImageRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol.js
var IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
var ArcRender = Symbol.for("ArcRender");
var Arc3dRender = Symbol.for("Arc3dRender");
var AreaRender = Symbol.for("AreaRender");
var CircleRender = Symbol.for("CircleRender");
var GraphicRender = Symbol.for("GraphicRender");
var GroupRender = Symbol.for("GroupRender");
var LineRender = Symbol.for("LineRender");
var PathRender = Symbol.for("PathRender");
var PolygonRender = Symbol.for("PolygonRender");
var RectRender = Symbol.for("RectRender");
var Rect3DRender = Symbol.for("Rect3DRender");
var SymbolRender = Symbol.for("SymbolRender");
var TextRender = Symbol.for("TextRender");
var RichTextRender = Symbol.for("RichTextRender");
var Pyramid3dRender = Symbol.for("Pyramid3dRender");
var GlyphRender = Symbol.for("GlyphRender");
var ImageRender = Symbol.for("ImageRender");
var RenderSelector = Symbol.for("RenderSelector");
var DrawContribution = Symbol.for("DrawContribution");

// node_modules/@visactor/vrender-core/es/render/render-service.js
var __decorate21 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata16 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenderService = Symbol.for("RenderService");
var BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");
var DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach((g3) => {
      this._prepare(g3, updateBounds);
    });
  }
  _prepare(g3, updateBounds) {
    g3.forEachChildren((g4) => {
      this._prepare(g4, updateBounds);
    }), g3.update({
      bounds: updateBounds,
      trans: true
    });
  }
  prepareRenderList() {
  }
  beforeDraw(params2) {
  }
  draw(params2) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params2) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  render(groups2, params2) {
    this.renderTreeRoots = groups2, this.drawParams = params2;
    const updateBounds = params2.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params2), this.draw(params2), this.afterDraw(params2);
  }
};
DefaultRenderService = __decorate21([injectable(), __param14(0, inject(DrawContribution)), __metadata16("design:paramtypes", [Object])], DefaultRenderService);

// node_modules/@visactor/vrender-core/es/render/render-modules.js
var render_modules_default = new ContainerModule((bind) => {
  bind(RenderService).to(DefaultRenderService).inSingletonScope();
});

// node_modules/@visactor/vrender-core/es/picker/constants.js
var GraphicPicker = Symbol.for("GraphicPicker");
var PickerService = Symbol.for("PickerService");
var BoundsPicker = Symbol.for("BoundsPicker");
var GlobalPickerService = Symbol.for("GlobalPickerService");

// node_modules/@visactor/vrender-core/es/picker/pick-interceptor.js
var __decorate22 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var PickItemInterceptor = Symbol.for("PickItemInterceptor");
var ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point6, pickParams, params2) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point6, pickParams, params2) : null;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point6, pickParams, params2) : null;
  }
  _pickItem(graphic, pickerService, point6, pickParams, params2) {
    if (!graphic.shadowRoot) return null;
    const { parentMatrix } = params2 || {};
    if (!parentMatrix) return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const g3 = graphic.shadowRoot, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(currentGroupMatrix.a * point6.x + currentGroupMatrix.c * point6.y + currentGroupMatrix.e, currentGroupMatrix.b * point6.x + currentGroupMatrix.d * point6.y + currentGroupMatrix.f), result2 = pickerService.pickGroup(g3, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), result2;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate22([injectable()], ShadowRootPickItemInterceptorContribution);
var InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point6.x, point6.y), context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result2 = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result2;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate22([injectable()], InteractivePickItemInterceptorContribution);
var Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point6, pickParams, params2) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
    const context = pickerService.pickContext, stage = graphic.stage;
    if (!context || !stage) return null;
    if (pickParams.in3dInterceptor = true, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      let result2, isPie = false, is3d = false;
      if (graphic.forEachChildren((c4) => (isPie = c4.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c4) => (is3d = !!c4.findFace, !is3d)), isPie) {
        const children = graphic.getChildren(), sortedChildren = [...children];
        sortedChildren.sort((a4, b2) => {
          var _a, _b, _c, _d;
          let angle1 = (null !== (_b = null !== (_a = a4.attribute.startAngle) && void 0 !== _a ? _a : 0 + a4.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b2.attribute.startAngle) && void 0 !== _c ? _c : 0 + b2.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
          for (; angle1 < 0; ) angle1 += pi2;
          for (; angle2 < 0; ) angle2 += pi2;
          return angle2 - angle1;
        }), sortedChildren.forEach((c4) => {
          c4._next = null, c4._prev = null;
        }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c4) => {
          graphic.appendChild(c4);
        }), pickParams.hack_pieFace = "outside", result2 = pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams), result2.graphic || (pickParams.hack_pieFace = "inside", result2 = pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams)), result2.graphic || (pickParams.hack_pieFace = "top", result2 = pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams)), graphic.removeAllChild(), children.forEach((c4) => {
          c4._next = null, c4._prev = null;
        }), children.forEach((c4) => {
          graphic.appendChild(c4);
        });
      } else if (is3d) {
        const children = graphic.getChildren(), zChildren = children.map((g3) => ({
          ave_z: g3.findFace().vertices.map((v2) => {
            var _a;
            return context.view(v2[0], v2[1], null !== (_a = v2[2] + g3.attribute.z) && void 0 !== _a ? _a : 0)[2];
          }).reduce((a4, b2) => a4 + b2, 0),
          g: g3
        }));
        zChildren.sort((a4, b2) => b2.ave_z - a4.ave_z), graphic.removeAllChild(), zChildren.forEach((i2) => {
          i2.g._next = null, i2.g._prev = null;
        }), graphic.update(), zChildren.forEach((i2) => {
          graphic.add(i2.g);
        }), result2 = pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams), graphic.removeAllChild(), children.forEach((g3) => {
          g3._next = null, g3._prev = null;
        }), graphic.update(), children.forEach((g3) => {
          graphic.add(g3);
        });
      } else result2 = pickerService.pickGroup(graphic, point6, params2.parentMatrix, pickParams);
      return context.camera = null, pickParams.in3dInterceptor = false, context.restore(), result2;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate22([injectable()], Canvas3DPickItemInterceptor);

// node_modules/@visactor/vrender-core/es/picker/pick-modules.js
var pick_modules_default = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor);
});

// node_modules/@visactor/vrender-core/es/graphic/graphic-service/graphic-module.js
var graphic_module_default = new ContainerModule((bind) => {
  bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator).toConstantValue(graphicCreator);
});

// node_modules/@visactor/vrender-core/es/plugins/constants.js
var AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
var PluginService = Symbol.for("PluginService");

// node_modules/@visactor/vrender-core/es/plugins/plugin-service.js
var __decorate23 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata17 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = false;
  }
  active(stage, params2) {
    this.stage = stage, this.actived = true;
    const { pluginList } = params2;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach((p2) => {
      pluginList.includes(p2.name) && this.register(p2);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release(...params2) {
    this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate23([injectable(), __param15(0, inject(ContributionProvider)), __param15(0, named(AutoEnablePlugins)), __metadata17("design:paramtypes", [Object])], DefaultPluginService);

// node_modules/@visactor/vrender-core/es/plugins/plugin-modules.js
var plugin_modules_default = new ContainerModule((bind) => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

// node_modules/@visactor/vrender-core/es/core/contributions/env/modules.js
var modules_default = new ContainerModule((bind) => {
  bindContributionProvider(bind, EnvContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/textMeasure/modules.js
var modules_default2 = new ContainerModule((bind) => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/canvas2d-contribution.js
var __decorate24 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata18 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = false, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main) this.main = true, this.context = window2.getContext(), this.canvas = this.context.getCanvas();
    else {
      let nativeCanvas;
      this.main = false, params2.canvasId && (nativeCanvas = this.global.getElementById(params2.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window2.width,
        height: window2.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window2.getContext().getCanvas().nativeCanvas, canvas = wrapCanvas({
        nativeCanvas,
        width: window2.width,
        height: window2.height,
        dpr: window2.dpr,
        id: params2.canvasId,
        canvasControled: true,
        container: window2.getContainer(),
        x: windowCanvas.offsetLeft,
        y: windowCanvas.offsetTop
      });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w2, h2) {
    this.canvas.resize(w2, h2);
  }
  resizeView(w2, h2) {
  }
  render(group, params2, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }, params2), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach((l2) => {
      const canvas = l2.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate24([injectable(), __metadata18("design:paramtypes", [])], CanvasLayerHandlerContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/empty-contribution.js
var __decorate25 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata19 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var EmptyLayerHandlerContribution = class {
  constructor() {
    this.offscreen = false, this.type = "virtual", this.global = application.global;
  }
  setDpr(dpr) {
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main) throw new Error("virtual layer不能作为main layer");
    this.main = false, this.canvas = null, this.context = null;
  }
  resize(w2, h2) {
  }
  resizeView(w2, h2) {
  }
  render(group, params2, userParams) {
    this.mainHandler.render(group, params2, Object.assign(Object.assign({}, userParams), {
      clear: false
    }));
  }
  merge(layerHandlers) {
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return null;
  }
  release() {
  }
};
EmptyLayerHandlerContribution = __decorate25([injectable(), __metadata19("design:paramtypes", [])], EmptyLayerHandlerContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/offscreen2d-contribution.js
var __decorate26 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata20 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var OffscreenLayerHandlerContribution = class {
  constructor() {
    this.offscreen = true, this.type = "dynamic", this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    this.layer = layer;
    const nativeCanvas = this.global.createOffscreenCanvas({
      width: params2.width,
      height: params2.height,
      dpr: window2.dpr
    }), canvas = wrapCanvas({
      nativeCanvas,
      width: params2.width,
      height: params2.height,
      dpr: window2.dpr,
      canvasControled: true
    });
    this.canvas = canvas, this.context = canvas.getContext();
  }
  resize(w2, h2) {
    this.canvas.resize(w2, h2);
  }
  resizeView(w2, h2) {
    this.canvas.resize(w2, h2);
  }
  render(group, params2) {
    var _a;
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context
    }, params2), {
      x: 0,
      y: 0,
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }));
  }
  prepare(dirtyBounds, params2) {
  }
  release() {
    this.canvas.release();
  }
  getContext() {
    return this.context;
  }
  drawTo(target, group, params2) {
    const context = target.getContext(), targetDpr = target.dpr, { x: x3 = 0, y: y3 = 0, width = this.layer.viewWidth, height = this.layer.viewHeight } = params2;
    context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), params2.clear && context.clearRect(x3, y3, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x3, y3, width, height), context.nativeContext.restore();
  }
  merge(layerHandlers) {
  }
};
OffscreenLayerHandlerContribution = __decorate26([injectable(), __metadata20("design:paramtypes", [])], OffscreenLayerHandlerContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/layerHandler/modules.js
var modules_default3 = new ContainerModule((bind) => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(OffscreenLayerHandlerContribution).toSelf(), bind(EmptyLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution), bind(DynamicLayerHandlerContribution).toService(OffscreenLayerHandlerContribution), bind(VirtualLayerHandlerContribution).toService(EmptyLayerHandlerContribution);
});

// node_modules/@visactor/vrender-core/es/core/contributions/modules.js
function load(container2) {
  container2.load(modules_default), container2.load(modules_default2), container2.load(modules_default3);
}

// node_modules/@visactor/vrender-core/es/common/sort.js
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function foreach(graphic, defaultZIndex, cb, reverse2 = false, sort3d = false) {
  const childMap = {}, zIdxArray = [];
  let needSort = false;
  if (sort3d) needSort = true;
  else {
    let lastZIndex;
    graphic.forEachChildren((item, i2) => {
      const { zIndex = defaultZIndex } = item.attribute;
      if (0 === i2) lastZIndex = zIndex;
      else if (lastZIndex !== zIndex) return needSort = true, true;
      return false;
    }, reverse2);
  }
  if (needSort) {
    graphic.forEachChildren((item) => {
      const { zIndex = defaultZIndex } = item.attribute;
      childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
    }, reverse2), zIdxArray.sort((a4, b2) => reverse2 ? b2 - a4 : a4 - b2);
    let skip = false;
    for (let i2 = 0; i2 < zIdxArray.length && !skip; i2++) {
      const idx = zIdxArray[i2], children = childMap[idx];
      sort3d && children.sort((a4, b2) => {
        var _a, _b;
        return (reverse2 ? -1 : 1) * ((null !== (_a = b2.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a4.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i3 = 0; i3 < children.length; i3++) if (cb(children[i3], i3)) {
        skip = true;
        break;
      }
    }
  } else graphic.forEachChildren(cb, reverse2);
}
function foreachAsync(graphic, defaultZIndex, cb, reverse2 = false) {
  return __awaiter3(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse2);
  });
}
function findNextGraphic(graphic, id2, defaultZIndex, reverse2 = false) {
  const childMap = {}, zIdxArray = [];
  let needSort = false;
  graphic.forEachChildren((item, i2) => {
    const { zIndex = defaultZIndex } = item.attribute;
    if (0 === i2) ;
    else if (void 0 !== zIndex) return needSort = true, true;
    return false;
  }, reverse2);
  let result2 = null, next = false;
  if (needSort) {
    graphic.forEachChildren((item) => {
      const { zIndex = defaultZIndex } = item.attribute;
      childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
    }, reverse2), zIdxArray.sort((a4, b2) => reverse2 ? b2 - a4 : a4 - b2);
    let skip = false;
    for (let i2 = 0; i2 < zIdxArray.length && !skip; i2++) {
      const idx = zIdxArray[i2], children = childMap[idx];
      for (let i3 = 0; i3 < children.length; i3++) {
        if (next) {
          skip = true, result2 = children[i3];
          break;
        }
        children[i3]._uid !== id2 || (next = true);
      }
    }
  } else graphic.forEachChildren((item) => next ? (result2 = item, true) : (item._uid === id2 && (next = true), false), reverse2);
  return result2;
}

// node_modules/@visactor/vrender-core/es/render/contributions/render/draw-interceptor.js
var __decorate27 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata21 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
var tempDirtyBounds = new AABBBounds();
var ShadowRootDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute.shadowRootIdx < 0 && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.shadowRoot) return false;
    const { context } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, true), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds);
      const m5 = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m5);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, graphic.parent.globalTransMatrix), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), true;
  }
};
var DebugDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.attribute._debug_bounds) return false;
    const { context } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
    const b2 = graphic.AABBBounds;
    return true !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b2.x1, b2.y1, b2.width(), b2.height()), context.highPerformanceRestore(), true;
  }
};
var CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    for (let i2 = 0; i2 < this.interceptors.length; i2++) if (this.interceptors[i2].afterDrawItem && this.interceptors[i2].afterDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return false;
    for (let i2 = 0; i2 < this.interceptors.length; i2++) if (this.interceptors[i2].beforeDrawItem && this.interceptors[i2].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2)) return true;
    return false;
  }
};
CommonDrawItemInterceptorContribution = __decorate27([injectable(), __metadata21("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
var InteractiveDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, false, {
        skipUpdateCallback: true
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return true;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return false;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    const baseGraphic = graphic.baseGraphic;
    if (baseGraphic) {
      this.processing = true;
      const { context } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, true), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = false, true;
    }
    return false;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
};
var Canvas3DDrawItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor) return false;
    drawContext.in3dInterceptor = true;
    const { context, stage } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m5 = context.currentMatrix;
    m5.a /= context.dpr, m5.b /= context.dpr, m5.c /= context.dpr, m5.d /= context.dpr, m5.e /= context.dpr, m5.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m5);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m6 = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m6, lastModelMatrix, matrix);
      }
    } else context.modelMatrix = matrix;
    if (context.setTransform(1, 0, 0, 1, 0, 0, true), graphic.isContainer) {
      let isPie = false, is3d = false;
      if (graphic.forEachChildren((c4) => (isPie = c4.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c4) => (is3d = !!c4.findFace, !is3d)), isPie) {
        const children = graphic.getChildren(), sortedChildren = [...children];
        sortedChildren.sort((a4, b2) => {
          var _a, _b, _c, _d;
          let angle1 = ((null !== (_a = a4.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a4.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2, angle2 = ((null !== (_c = b2.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b2.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;
          for (; angle1 < 0; ) angle1 += pi2;
          for (; angle2 < 0; ) angle2 += pi2;
          return angle2 - angle1;
        }), sortedChildren.forEach((c4) => {
          c4._next = null, c4._prev = null;
        }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c4) => {
          graphic.appendChild(c4);
        });
        const m6 = graphic.parent.globalTransMatrix;
        drawContext.hack_pieFace = "outside", drawContribution.renderGroup(graphic, drawContext, m6), drawContext.hack_pieFace = "inside", drawContribution.renderGroup(graphic, drawContext, m6), drawContext.hack_pieFace = "top", drawContribution.renderGroup(graphic, drawContext, m6), graphic.removeAllChild(), children.forEach((c4) => {
          c4._next = null, c4._prev = null;
        }), children.forEach((c4) => {
          graphic.appendChild(c4);
        });
      } else if (is3d) {
        const children = graphic.getChildren(), zChildren = children.map((g3) => ({
          ave_z: g3.findFace().vertices.map((v2) => {
            var _a;
            return context.view(v2[0], v2[1], null !== (_a = v2[2] + g3.attribute.z) && void 0 !== _a ? _a : 0)[2];
          }).reduce((a4, b2) => a4 + b2, 0),
          g: g3
        }));
        zChildren.sort((a4, b2) => b2.ave_z - a4.ave_z), graphic.removeAllChild(), zChildren.forEach((i2) => {
          i2.g._next = null, i2.g._prev = null;
        }), graphic.update(), zChildren.forEach((i2) => {
          graphic.add(i2.g);
        }), drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, true), graphic.removeAllChild(), children.forEach((g3) => {
          g3._next = null, g3._prev = null;
        }), graphic.update(), children.forEach((g3) => {
          graphic.add(g3);
        });
      } else drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix);
    } else drawContribution.renderItem(graphic, drawContext);
    return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = false, true;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};

// node_modules/@visactor/vrender-core/es/render/contributions/render/draw-contribution.js
var __decorate28 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata22 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = /* @__PURE__ */ new Map(), this.defaultRenderMap = /* @__PURE__ */ new Map(), this.styleRenderMap = /* @__PURE__ */ new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, this.init();
  }
  init() {
    this.contributions.forEach((item) => {
      if (item.style) {
        const map4 = this.styleRenderMap.get(item.style) || /* @__PURE__ */ new Map();
        map4.set(item.numberType, item), this.styleRenderMap.set(item.style, map4);
      } else this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a4, b2) => a4.order - b2.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = true : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const { context, stage, x: x3 = 0, y: y3 = 0, width, height } = drawContext;
    if (!context) return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, width, height);
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b2 = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
      dirtyBounds.x1 = Math.floor(b2.x1), dirtyBounds.y1 = Math.floor(b2.y1), dirtyBounds.x2 = Math.ceil(b2.x2), dirtyBounds.y2 = Math.ceil(b2.y2);
    }
    const d2 = context.dpr % 1;
    (d2 || 0.5 !== d2) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = true, context.clearMatrix(), context.setTransformForCurrent(true);
    const drawInArea = dirtyBounds.width() * context.dpr < context.canvas.width || dirtyBounds.height() * context.dpr < context.canvas.height;
    context.save(), context.translate(x3, y3, true), drawInArea && (context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip()), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a4, b2) => {
      var _a, _b;
      return (null !== (_a = a4.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b2.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.restore(), context.draw(), context.inuse = false;
  }
  doRegister() {
    throw new Error("暂不支持");
  }
  _findNextGraphic(group) {
    let parent = group.parent, id2 = group._uid;
    for (; parent; ) {
      const g3 = findNextGraphic(parent, id2, DefaultAttribute.zIndex);
      if (g3) return g3;
      id2 = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || false === group.attribute.visibleAll) return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = true, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, false)) return;
    let tempBounds3, nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds3 = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    this.renderItem(group, drawContext, {
      drawingCb: () => {
        var _a;
        skipSort ? group.forEachChildren((item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }) : foreach(group, DefaultAttribute.zIndex, (item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }, false, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
      }
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds3), boundsAllocate.free(tempBounds3), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const { layer, stage } = drawContext, { subLayers } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: false
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);
    else {
      let afterLayer = subLayers.get(nextGraphic._uid);
      afterLayer || (afterLayer = {
        layer: this.layerService.createLayer(stage),
        zIndex: subLayers.size
      }, subLayers.set(nextGraphic._uid, afterLayer));
      const afterContext = afterLayer.layer.getNativeHandler().getContext();
      this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
        drawContribution: idc,
        clear: "transparent",
        layer: afterLayer.layer,
        context: afterContext,
        startAtId: nextGraphic._uid,
        break: false
      }));
    }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params2) {
    if (this.InterceptorContributions.length) for (let i2 = 0; i2 < this.InterceptorContributions.length; i2++) {
      const drawContribution = this.InterceptorContributions[i2];
      if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params2)) return;
    }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer) return;
    let tempBounds3, retrans = false;
    if (graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      if (retrans = !(!scrollX && !scrollY), retrans) {
        tempBounds3 = this.dirtyBounds.clone();
        const m5 = graphic.globalTransMatrix.getInverse();
        this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m5), this.dirtyBounds.translate(-scrollX, -scrollY);
      }
    }
    if (this.useDirtyBounds && !graphic.isContainer && !isRectIntersect(graphic.AABBBounds, this.dirtyBounds, false)) return void (retrans && this.dirtyBounds.copy(tempBounds3));
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params2 && (params2.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params2) : renderer.draw(graphic, this.currentRenderService, drawContext, params2), retrans && this.dirtyBounds.copy(tempBounds3), this.InterceptorContributions.length) for (let i2 = 0; i2 < this.InterceptorContributions.length; i2++) {
      const drawContribution = this.InterceptorContributions[i2];
      if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
    }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
  }
  selectRenderByNumberType(type) {
    return this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b;
    const { clear } = drawContext;
    if (clear) {
      const canvas = context.getCanvas(), { width = canvas.width, height = canvas.height } = drawContext, x3 = 0, y3 = 0;
      context.clearRect(x3, y3, width, height);
      const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
      if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear);
        res && "success" === res.state && res.data && context.drawImage(res.data, x3, y3, width, height);
      } else context.fillStyle = createColor(context, clear, {
        AABBBounds: {
          x1: x3,
          y1: y3,
          x2: x3 + width,
          y2: y3 + height
        }
      }, 0, 0), context.fillRect(x3, y3, width, height);
    }
  }
  afterDraw(renderService, drawParams) {
  }
};
DefaultDrawContribution = __decorate28([injectable(), __param16(0, multiInject(GraphicRender)), __param16(1, inject(ContributionProvider)), __param16(1, named(DrawItemInterceptor)), __metadata22("design:paramtypes", [Array, Object])], DefaultDrawContribution);

// node_modules/@visactor/vrender-core/es/render/contributions/render/group-render.js
var __decorate29 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata23 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  drawShape(group, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, { fill = groupAttribute.fill, background, stroke: stroke2 = groupAttribute.stroke, opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, clip = groupAttribute.clip, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible } = group.attribute, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!group.valid || !visible) return;
    if (!clip) {
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;
      context.disableFill = true, context.disableStroke = true, context.disableBeginPath = true, path.forEach((g3) => {
        drawContext.drawContribution.getRenderContribution(g3).draw(g3, drawContext.renderService, drawContext, params2);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else 0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x3, y3, width, height)) : (context.beginPath(), createRectPath(context, x3, y3, width, height, cornerRadius));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    this._groupRenderContribitions.forEach((c4) => {
      c4.time === BaseRenderContributionTime.beforeFillStroke && c4.drawShape(group, context, x3, y3, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip(), context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, x3, y3, groupAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, x3, y3, groupAttribute), context.stroke())), this._groupRenderContribitions.forEach((c4) => {
      c4.time === BaseRenderContributionTime.afterFillStroke && c4.drawShape(group, context, x3, y3, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const { clip } = group.attribute;
    clip ? context.save() : context.highPerformanceSave();
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, true);
    } else context.transformFromMatrix(group.transMatrix, true);
    context.beginPath(), params2.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params2, () => false, () => false) : this.drawShape(group, context, 0, 0, drawContext);
    const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = group.attribute;
    let p2;
    (scrollX || scrollY) && context.translate(scrollX, scrollY), params2 && params2.drawingCb && (p2 = params2.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, p2 && p2.then ? p2.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate29([injectable(), __param17(0, inject(ContributionProvider)), __param17(0, named(GroupRenderContribution)), __metadata23("design:paramtypes", [Object])], DefaultCanvasGroupRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-line-render.js
var __decorate30 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line2, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (line2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = line2.attribute;
      if (startAtIdx > segments2.length) return;
      const lineAttribute = getTheme(line2).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
      if (!line2.valid || !visible) return;
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
      const { context: context2 } = drawContext;
      for (let i2 = startAtIdx; i2 < startAtIdx + length2; i2++) this.drawIncreaseSegment(line2, context2, segments2[i2 - 1], segments2[i2], line2.attribute.segments[i2], [lineAttribute, line2.attribute], x3, y3);
    } else super.drawShape(line2, context, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
  drawIncreaseSegment(line2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute), context.setStrokeStyle(line2, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate30([injectable()], DefaultIncrementalCanvasLineRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-area-render.js
var __decorate31 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area2, context, x3, y3, drawContext, params2, fillCb) {
    if (area2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = area2.attribute;
      if (startAtIdx > segments2.length) return;
      const areaAttribute = getTheme(area2).area, { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), doFill = runFill(fill);
      if (!area2.valid || !visible) return;
      if (!doFill) return;
      if (!fVisible && !fillCb) return;
      for (let i2 = startAtIdx; i2 < startAtIdx + length2; i2++) this.drawIncreaseSegment(area2, context, segments2[i2 - 1], segments2[i2], area2.attribute.segments[i2], [areaAttribute, area2.attribute], x3, y3);
    } else super.drawShape(area2, context, x3, y3, drawContext, params2, fillCb);
  }
  drawIncreaseSegment(area2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute), context.setCommonStyle(area2, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate31([injectable()], DefaultIncrementalCanvasAreaRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/incremental-draw-contribution.js
var STATUS2;
var __decorate32 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata24 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
!function(STATUS3) {
  STATUS3[STATUS3.NORMAL = 0] = "NORMAL", STATUS3[STATUS3.STOP = 1] = "STOP";
}(STATUS2 || (STATUS2 = {}));
var DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = false, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS2.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw) return;
      this.currentRenderService = renderService;
      const { context, x: x3 = 0, y: y3 = 0 } = drawContext;
      context && (context.inuse = true, context.clearMatrix(), context.setTransformForCurrent(true), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(x3, y3, true), context.save(), renderService.renderTreeRoots.sort((a4, b2) => {
        var _a, _b;
        return (null !== (_a = a4.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b2.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach((group) => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = false, this.rendering = false;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering = true, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
            if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i2) => {
              if (this.status === STATUS2.STOP) return true;
              if (item.isContainer) return false;
              if (i2 < this.currentIdx) return false;
              const frameTail = this.currFrameStartAt + group.incremental;
              return i2 < frameTail && (this.currentIdx = i2 + 1, this.renderItem(item, drawContext)), i2 === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
            }), resolve(false);
            else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {
                startAtIdx: graphic.incrementalAt,
                length: graphic.incremental
              }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();
              else this.renderItem(graphic, drawContext);
              resolve(false);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter4(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(false);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = false, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS2.STOP, yield new Promise((resolve) => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS2.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item) => "stopCb" !== item.name), resolve(false);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!drawContext.break && false !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = true)) : void (yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
            yield foreachAsync(group, DefaultAttribute.zIndex, (item) => __awaiter4(this, void 0, void 0, function* () {
              drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
            })), resolve(false);
          })
        });
      }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate32([injectable(), __param18(0, multiInject(GraphicRender)), __param18(1, inject(DefaultIncrementalCanvasLineRender)), __param18(2, inject(DefaultIncrementalCanvasAreaRender)), __param18(3, inject(ContributionProvider)), __param18(3, named(DrawItemInterceptor)), __metadata24("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

// node_modules/@visactor/vrender-core/es/render/contributions/render/module.js
var module_default = new ContainerModule((bind) => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

// node_modules/@visactor/vrender-core/es/render/contributions/modules.js
function load2(container2) {
  container2.load(module_default);
}

// node_modules/@visactor/vrender-core/es/modules.js
function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = true, container.load(core_modules_default), container.load(graphic_module_default), container.load(render_modules_default), container.load(pick_modules_default), container.load(plugin_modules_default), load(container), load2(container));
}
preLoadAllModule.__loaded = false, preLoadAllModule();
var vglobal = container.get(VGlobal);
application.global = vglobal;
var graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
var transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
var graphicService = container.get(GraphicService);
application.graphicService = graphicService;
var layerService = container.get(LayerService);
application.layerService = layerService;

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/auto-render-plugin.js
var AutoRenderPlugin = class {
  constructor() {
    this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    }), application.graphicService.hooks.onSetStage.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter((item) => item.name !== this.key);
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/3dview-transform-plugin.js
var ViewTransform3dPlugin = class {
  constructor() {
    this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = (e3) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = true, this.pageX = e3.page.x, this.pageY = e3.page.y);
    }, this.onMouseUp = (e3) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = false);
    }, this.onMouseMove = (e3) => {
      var _a, _b;
      const stage = this.pluginService.stage;
      if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {
        const deltaX = e3.page.x - this.pageX, deltaY = e3.page.y - this.pageY;
        this.pageX = e3.page.x, this.pageY = e3.page.y;
        const angle1 = deltaX / 100, angle2 = deltaY / 100;
        this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(this.option3d), stage.renderNextFrame();
      } else this.pageX = e3.page.x, this.pageY = e3.page.y;
    };
  }
  activate(context) {
    this.pluginService = context;
    const stage = context.stage;
    this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
  }
  deactivate(context) {
    const stage = context.stage;
    stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/incremental-auto-render-plugin.js
var IncrementalAutoRenderPlugin = class {
  constructor() {
    this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
    }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
      group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = true, this.renderNextFrame(group));
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter((item) => item.name !== this.key);
  }
  renderNextFrame(group) {
    this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = true, application.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    const stage = this.pluginService.stage;
    this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group) => {
      const layer = group.layer;
      if (!layer || !group.layer.subLayers) return;
      const subLayer = group.layer.subLayers.get(group._uid);
      subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
        x: stage.x,
        y: stage.y,
        width: layer.viewWidth,
        height: layer.viewHeight,
        stage,
        layer,
        clear: "transparent",
        renderService: stage.renderService,
        updateBounds: false,
        startAtId: group._uid,
        context: subLayer.layer.getNativeHandler().getContext()
      }, this.nextUserParams));
    }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/html-attribute-plugin.js
var HtmlAttributePlugin = class {
  constructor() {
    this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && this.drawHTML(context.stage.renderService);
    }), application.graphicService.hooks.onRelease.tap(this.key, (graphic) => {
      this.removeDom(graphic);
    });
  }
  deactivate(context) {
    context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key);
  }
  drawHTML(renderService) {
    "browser" === application.global.env && renderService.renderTreeRoots.sort((a4, b2) => {
      var _a, _b;
      return (null !== (_a = a4.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b2.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      this.renderGroupHTML(group);
    });
  }
  renderGroupHTML(group) {
    this.renderGraphicHTML(group), group.forEachChildren((g3) => {
      g3.isContainer ? this.renderGroupHTML(g3) : this.renderGraphicHTML(g3);
    });
  }
  removeDom(graphic) {
    graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach((item) => {
      item.dom && item.dom.parentElement.removeChild(item.dom);
    }), graphic.bindDom.clear());
  }
  renderGraphicHTML(graphic) {
    const { html } = graphic.attribute;
    if (!html) return void (graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach((item) => {
      item.dom && item.dom.parentElement.removeChild(item.dom);
    }), graphic.bindDom.clear()));
    const stage = graphic.stage;
    if (!stage) return;
    const { dom, container: container2, width, height, style, anchorType = "boundsLeftTop" } = html;
    graphic.bindDom || (graphic.bindDom = /* @__PURE__ */ new Map());
    const lastDom = graphic.bindDom.get(dom);
    if (lastDom && (!container2 || container2 === lastDom.container)) return;
    let nativeDom, nativeContainer;
    graphic.bindDom.forEach(({ wrapGroup: wrapGroup2 }) => {
      application.global.removeDom(wrapGroup2);
    }), "string" == typeof dom ? (nativeDom = new DOMParser().parseFromString(dom, "text/html").firstChild, nativeDom.lastChild && (nativeDom = nativeDom.lastChild.firstChild)) : nativeDom = dom;
    const _container = container2 || (true === stage.params.enableHtmlAttribute ? null : stage.params.enableHtmlAttribute);
    nativeContainer = _container ? "string" == typeof _container ? application.global.getElementById(_container) : _container : graphic.stage.window.getContainer();
    const wrapGroup = application.global.createDom({
      tagName: "div",
      width,
      height,
      style,
      parent: nativeContainer
    });
    wrapGroup && (wrapGroup.appendChild(nativeDom), graphic.bindDom.set(dom, {
      dom: nativeDom,
      container: container2,
      wrapGroup
    })), wrapGroup.style.pointerEvents = "none", wrapGroup.style.position || (wrapGroup.style.position = "absolute", nativeContainer.style.position = "relative");
    let left2 = 0, top = 0;
    const b2 = graphic.globalAABBBounds;
    if ("position" === anchorType || b2.empty()) {
      const matrix = graphic.globalTransMatrix;
      left2 = matrix.e, top = matrix.f;
    } else left2 = b2.x1, top = b2.y1;
    const containerTL = application.global.getElementTopLeft(nativeContainer, false), windowTL = stage.window.getTopLeft(false), offsetX = left2 + windowTL.left - containerTL.left, offsetTop = top + windowTL.top - containerTL.top;
    wrapGroup.style.left = `${offsetX}px`, wrapGroup.style.top = `${offsetTop}px`;
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/dirty-bounds-plugin.js
var globalBounds = new AABBBounds();
var DirtyBoundsPlugin = class {
  constructor() {
    this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params2.globalAABBBounds));
    }), application.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
      const stage = graphic.stage;
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter((item) => item.name !== this.key);
  }
};

// node_modules/@visactor/vrender-core/es/plugins/builtin-plugin/flex-layout-plugin.js
var _tempBounds2 = new AABBBounds();
var FlexLayoutPlugin = class {
  constructor() {
    this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds();
  }
  tryLayout(graphic) {
    if (this.layouting) return;
    this.layouting = true;
    const p2 = graphic.parent;
    if (!p2 || !graphic.needUpdateLayout()) return;
    const theme2 = getTheme(p2).group, { display = theme2.display } = p2.attribute;
    if ("flex" !== display) return;
    const { flexDirection = theme2.flexDirection, flexWrap = theme2.flexWrap, justifyContent = theme2.justifyContent, alignItems = theme2.alignItems, alignContent = theme2.alignContent, clip = theme2.clip } = p2.attribute;
    let childrenWidth = 0, childrenHeight = 0, boundsLegal = 0;
    if (p2.forEachChildren((child) => {
      const bounds = child.AABBBounds;
      "column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2;
    }), !isFinite(boundsLegal)) return;
    const width = p2.attribute.width || childrenWidth, height = p2.attribute.height || childrenHeight;
    p2.attribute.width || (p2.attribute.width = 0), p2.attribute.height || (p2.attribute.height = 0), this.tempBounds.copy(p2._AABBBounds);
    const result2 = {
      main: {
        len: width,
        field: "x"
      },
      cross: {
        len: height,
        field: "y"
      },
      dir: 1
    }, main = result2.main, cross2 = result2.cross;
    "row-reverse" === flexDirection ? result2.dir = -1 : "column" === flexDirection ? (main.len = height, cross2.len = width, main.field = "y", cross2.field = "x") : "column-reverse" === flexDirection && (main.len = height, cross2.len = width, main.field = "y", cross2.field = "x", result2.dir = -1);
    let mainLen = 0, crossLen = 0;
    const mianLenArray = [];
    p2.forEachChildren((c4) => {
      const b2 = c4.AABBBounds, ml = "x" === main.field ? b2.width() : b2.height(), cl = "x" === cross2.field ? b2.width() : b2.height();
      mianLenArray.push({
        mainLen: ml,
        crossLen: cl
      }), mainLen += ml, crossLen = Math.max(crossLen, cl);
    });
    const mainList = [];
    if (mainLen > main.len && "wrap" === flexWrap) {
      let tempMainL = 0, tempCrossL = 0;
      mianLenArray.forEach(({ mainLen: mainLen2, crossLen: crossLen2 }, i2) => {
        tempMainL + mainLen2 > main.len ? 0 === tempMainL ? (mainList.push({
          idx: i2,
          mainLen: tempMainL + mainLen2,
          crossLen: crossLen2
        }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
          idx: i2 - 1,
          mainLen: tempMainL,
          crossLen: crossLen2
        }), tempMainL = mainLen2, tempCrossL = crossLen2) : (tempMainL += mainLen2, tempCrossL = Math.max(tempCrossL, crossLen2));
      }), mainList.push({
        idx: mianLenArray.length - 1,
        mainLen: tempMainL,
        crossLen: tempCrossL
      });
    } else mainList.push({
      idx: mianLenArray.length - 1,
      mainLen,
      crossLen
    });
    const children = p2.getChildren();
    let lastIdx = 0;
    if (mainList.forEach((s3) => {
      this.layoutMain(p2, children, justifyContent, main, mianLenArray, lastIdx, s3), lastIdx = s3.idx + 1;
    }), crossLen = mainList.reduce((a4, b2) => a4 + b2.crossLen, 0), 1 === mainList.length) if ("flex-end" === alignItems) {
      const anchorPos = cross2.len;
      this.layoutCross(children, alignItems, cross2, anchorPos, mianLenArray, mainList[0], 0);
    } else if ("center" === alignItems) {
      const anchorPos = cross2.len / 2;
      this.layoutCross(children, alignItems, cross2, anchorPos, mianLenArray, mainList[0], 0);
    } else children.forEach((child) => {
      child.attribute[cross2.field] = getPadding(child, cross2.field);
    });
    else if ("flex-start" === alignContent) {
      lastIdx = 0;
      let anchorPos = 0;
      mainList.forEach((s3, i2) => {
        this.layoutCross(children, "flex-start", cross2, anchorPos, mianLenArray, mainList[i2], lastIdx), lastIdx = s3.idx + 1, anchorPos += s3.crossLen;
      });
    } else if ("center" === alignContent) {
      lastIdx = 0;
      let anchorPos = Math.max(0, (cross2.len - crossLen) / 2);
      mainList.forEach((s3, i2) => {
        this.layoutCross(children, "center", cross2, anchorPos + s3.crossLen / 2, mianLenArray, mainList[i2], lastIdx), lastIdx = s3.idx + 1, anchorPos += s3.crossLen;
      });
    } else if ("space-around" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / mainList.length / 2);
      let anchorPos = padding;
      mainList.forEach((s3, i2) => {
        this.layoutCross(children, "flex-start", cross2, anchorPos, mianLenArray, mainList[i2], lastIdx), lastIdx = s3.idx + 1, anchorPos += s3.crossLen + 2 * padding;
      });
    } else if ("space-between" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / (2 * mainList.length - 2));
      let anchorPos = 0;
      mainList.forEach((s3, i2) => {
        this.layoutCross(children, "flex-start", cross2, anchorPos, mianLenArray, mainList[i2], lastIdx), lastIdx = s3.idx + 1, anchorPos += s3.crossLen + 2 * padding;
      });
    }
    children.forEach((child, idx) => {
      child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
    }), p2.addUpdateLayoutTag(), clip || this.tempBounds.equals(p2.AABBBounds) || (this.tryLayout(p2), this.layouting = false);
  }
  layoutMain(p2, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
    if ("flex-start" === justifyContent) {
      let pos = 0;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen;
    } else if ("flex-end" === justifyContent) {
      let pos = main.len;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) pos -= mianLenArray[i2].mainLen, children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field);
    } else if ("space-around" === justifyContent) if (currSeg.mainLen >= main.len) {
      let pos = 0;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen;
    } else {
      const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / size / 2;
      let pos = padding;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen + 2 * padding;
    }
    else if ("space-between" === justifyContent) if (currSeg.mainLen >= main.len) {
      let pos = 0;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen;
    } else {
      const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / (2 * size - 2);
      let pos = 0;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen + 2 * padding;
    }
    else if ("center" === justifyContent) {
      let pos = (main.len - currSeg.mainLen) / 2;
      for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[main.field] = pos + getPadding(children[i2], main.field), pos += mianLenArray[i2].mainLen;
    }
  }
  layoutCross(children, alignItem, cross2, anchorPos, lenArray, currSeg, lastIdx) {
    if ("flex-end" === alignItem) for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[cross2.field] = anchorPos - lenArray[i2].crossLen + getPadding(children[i2], cross2.field);
    else if ("center" === alignItem) for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[cross2.field] = anchorPos - lenArray[i2].crossLen / 2 + getPadding(children[i2], cross2.field);
    else for (let i2 = lastIdx; i2 <= currSeg.idx; i2++) children[i2].attribute[cross2.field] = anchorPos + getPadding(children[i2], cross2.field);
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic), this.layouting = false;
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && _tempBounds2.copy(bounds);
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && graphic.isContainer && (_tempBounds2.equals(bounds) || (this.tryLayout(graphic), this.layouting = false));
    }), application.graphicService.hooks.onSetStage.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic), this.layouting = false;
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter((item) => item.name !== this.key);
  }
};
function getPadding(graphic, field5) {
  if (!graphic.attribute.boundsPadding) return 0;
  if (isNumber3(graphic.attribute.boundsPadding)) return graphic.attribute.boundsPadding;
  if (isArray_default(graphic.attribute.boundsPadding) && 1 === graphic.attribute.boundsPadding.length) return graphic.attribute.boundsPadding[0];
  const paddingArray = parsePadding(graphic.attribute.boundsPadding);
  return "x" === field5 ? paddingArray[3] : "y" === field5 ? paddingArray[0] : 0;
}

// node_modules/@visactor/vrender-core/es/animate/default-ticker.js
var defaultTicker = new DefaultTicker();
defaultTicker.addTimeline(defaultTimeline);
defaultTicker.setFPS(60);

// node_modules/@visactor/vrender-core/es/core/light.js
var DirectionalLight = class {
  constructor(dir, color, ambient = 0.8) {
    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
    const length2 = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    this.formatedDir = [dir[0] / length2, dir[1] / length2, dir[2] / length2];
  }
  computeColor(normal, color) {
    const lightDir = this.formatedDir, brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
    let colorArray;
    colorArray = isString_default(color) ? ColorStore.Get(color, ColorType.Color1) : color;
    const lightColorArray = this.colorRgb;
    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
  }
};

// node_modules/@visactor/vrender-core/es/common/matrix.js
function lookAt(out, eye, center2, up) {
  let x05, x14, x23, y05, y14, y23, z0, z1, z2, len;
  const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center2[0], centery = center2[1], centerz = center2[2];
  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? DefaultMat4Allocate.identity(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x05 = upy * z2 - upz * z1, x14 = upz * z0 - upx * z2, x23 = upx * z1 - upy * z0, len = Math.hypot(x05, x14, x23), len ? (len = 1 / len, x05 *= len, x14 *= len, x23 *= len) : (x05 = 0, x14 = 0, x23 = 0), y05 = z1 * x23 - z2 * x14, y14 = z2 * x05 - z0 * x23, y23 = z0 * x14 - z1 * x05, len = Math.hypot(y05, y14, y23), len ? (len = 1 / len, y05 *= len, y14 *= len, y23 *= len) : (y05 = 0, y14 = 0, y23 = 0), out[0] = x05, out[1] = y05, out[2] = z0, out[3] = 0, out[4] = x14, out[5] = y14, out[6] = z1, out[7] = 0, out[8] = x23, out[9] = y23, out[10] = z2, out[11] = 0, out[12] = -(x05 * eyex + x14 * eyey + x23 * eyez), out[13] = -(y05 * eyex + y14 * eyey + y23 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}
function ortho(out, left2, right2, bottom, top, near, far) {
  const lr = 1 / (left2 - right2), bt = 1 / (bottom - top), nf = 1 / (near - far);
  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left2 + right2) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}
function multiply(out, a4, b2) {
  const a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3], a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7], a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11], a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  let b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  return out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[4], b1 = b2[5], b22 = b2[6], b3 = b2[7], out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[8], b1 = b2[9], b22 = b2[10], b3 = b2[11], out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, b0 = b2[12], b1 = b2[13], b22 = b2[14], b3 = b2[15], out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33, out;
}
function transformMat4(out, a4, m5) {
  const x3 = a4[0], y3 = a4[1], z2 = a4[2];
  let w2 = m5[3] * x3 + m5[7] * y3 + m5[11] * z2 + m5[15];
  return w2 = w2 || 1, out[0] = (m5[0] * x3 + m5[4] * y3 + m5[8] * z2 + m5[12]) / w2, out[1] = (m5[1] * x3 + m5[5] * y3 + m5[9] * z2 + m5[13]) / w2, out[2] = (m5[2] * x3 + m5[6] * y3 + m5[10] * z2 + m5[14]) / w2, out;
}

// node_modules/@visactor/vrender-core/es/core/camera.js
var OrthoCamera = class {
  set params(params2) {
    this._params = Object.assign({}, params2), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
  }
  get params() {
    return Object.assign({}, this._params);
  }
  constructor(params2) {
    this.params = params2;
  }
  getViewMatrix() {
    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
  }
  forceGetViewMatrix() {
    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
    const { pos, center: center2, up } = this.params.viewParams;
    return lookAt(this._viewMatrixCached, pos, center2, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
  }
  getProjectionMatrix() {
    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
  }
  forceGetProjectionMatrix() {
    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
    const { left: left2, top, right: right2, bottom } = this._params;
    return ortho(this._projectionMatrixCached, left2, right2, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
  }
  getField() {
    const { fieldRatio = 0.8, fieldDepth, left: left2, right: right2 } = this._params;
    return (null != fieldDepth ? fieldDepth : right2 - left2) * fieldRatio;
  }
  getProjectionScale(z2) {
    const field5 = this.getField();
    return field5 / (field5 + z2);
  }
  view(x3, y3, z2) {
    const outP2 = [0, 0, 0];
    return transformMat4(outP2, [x3, y3, z2], this._viewMatrixCached), outP2;
  }
  vp(x3, y3, z2) {
    const outP2 = [0, 0, 0], { pos } = this._params.viewParams;
    transformMat4(outP2, [x3, y3, z2], this._viewMatrixCached), x3 = outP2[0], y3 = outP2[1], z2 = outP2[2];
    const sizeProjection = this.getProjectionScale(z2);
    return {
      x: x3 * sizeProjection + pos[0],
      y: y3 * sizeProjection + pos[1]
    };
  }
};

// node_modules/@visactor/vrender-core/es/env-check.js
var _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv) try {
    _isBrowserEnv = globalThis === window, _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
  } catch (err) {
    _isBrowserEnv = false;
  }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}

// node_modules/@visactor/vrender-core/es/core/stage.js
var DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  X: 0,
  Y: 0,
  BACKGROUND: "white"
};
var Stage = class extends Group {
  set viewBox(b2) {
    this._viewBox.setValue(b2.x1, b2.y1, b2.x2, b2.y2);
  }
  get viewBox() {
    return this._viewBox;
  }
  get x() {
    return this._viewBox.x1;
  }
  set x(x3) {
    this._viewBox.translate(x3 - this._viewBox.x1, 0);
  }
  get y() {
    return this._viewBox.y1;
  }
  set y(y3) {
    this._viewBox.translate(0, y3 - this._viewBox.y1);
  }
  get width() {
    return this.window.width;
  }
  set width(w2) {
    this.resize(w2, this.height);
  }
  get viewWidth() {
    return this._viewBox.width();
  }
  set viewWidth(w2) {
    this.resizeView(w2, this.viewHeight);
  }
  get viewHeight() {
    return this._viewBox.height();
  }
  set viewHeight(h2) {
    this.resizeView(this.viewWidth, h2);
  }
  get height() {
    return this.window.height;
  }
  set height(h2) {
    this.resize(this.width, h2);
  }
  get dpr() {
    return this.window.dpr;
  }
  set dpr(r2) {
    this.setDpr(r2);
  }
  get background() {
    var _a;
    return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
  }
  set background(b2) {
    this._background = b2;
  }
  get defaultLayer() {
    return this.at(0);
  }
  get eventSystem() {
    return this._eventSystem;
  }
  constructor(params2 = {}) {
    var _a;
    super({}), this._onVisibleChange = (visible) => {
      this._skipRender < 0 || (visible ? (this.dirtyBounds && this.dirtyBounds.setValue(0, 0, this._viewBox.width(), this._viewBox.height()), this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0) : this._skipRender = 1);
    }, this.beforeRender = (stage) => {
      this._beforeRender && this._beforeRender(stage);
    }, this.afterRender = (stage) => {
      this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb) => cb(stage)), this._afterNextRenderCbs = null;
    }, this.params = params2, this.theme = new Theme(), this.hooks = {
      beforeRender: new SyncHook(["stage"]),
      afterRender: new SyncHook(["stage"])
    }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params2), this.window.create({
      width: params2.width,
      height: params2.height,
      container: params2.container,
      dpr: params2.dpr || this.global.devicePixelRatio,
      canvasControled: false !== params2.canvasControled,
      title: params2.title || "",
      canvas: params2.canvas
    }), this._viewBox = new AABBBounds(), params2.viewBox ? this._viewBox.setValue(params2.viewBox.x1, params2.viewBox.y1, params2.viewBox.x2, params2.viewBox.y2) : this._viewBox.setValue(0, 0, this.width, this.height), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height), this._background = null !== (_a = params2.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
      main: true
    })), this.nextFrameRenderLayerSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.stage = this, this.renderStyle = params2.renderStyle, params2.autoRender && this.enableAutoRender(), false === params2.disableDirtyBounds && this.enableDirtyBounds(), params2.enableHtmlAttribute && this.enableHtmlAttribute(params2.enableHtmlAttribute), params2.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params2.beforeRender, this._afterRender = params2.afterRender, this.ticker = params2.ticker || defaultTicker, this.supportInteractiveLayer = false !== params2.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params2.optimize || (params2.optimize = {}), this.optmize(params2.optimize), params2.background && isString_default(this._background) && this._background.includes("/") && this.setAttributes({
      background: this._background
    });
  }
  tryInitEventSystem() {
    this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
      targetElement: this.window,
      resolution: this.window.dpr || this.global.devicePixelRatio,
      rootNode: this,
      global: this.global,
      supportsPointerEvents: this.params.supportsPointerEvents,
      supportsTouchEvents: this.params.supportsTouchEvents,
      viewport: {
        viewBox: this._viewBox,
        get x() {
          return this.viewBox.x1;
        },
        get y() {
          return this.viewBox.y1;
        },
        get width() {
          return this.viewBox.width();
        },
        get height() {
          return this.viewBox.height();
        }
      }
    }, this.params.event)));
  }
  preventRender(prevent2) {
    prevent2 ? this._skipRender = -1 / 0 : false !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
  }
  optmize(params2) {
    this.optmizeRender(params2.skipRenderWithOutRange), this.params.optimize = params2;
  }
  optmizeRender(skipRenderWithOutRange = false) {
    skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
  }
  getTimeline() {
    return this.timeline;
  }
  get3dOptions(options) {
    const { center: center2 = {
      x: this.width / 2,
      y: this.height / 2,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0
    }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
    return Object.assign(Object.assign({}, options), {
      center: center2,
      light,
      alpha,
      beta,
      camera,
      fieldRatio,
      fieldDepth
    });
  }
  set3dOptions(options) {
    var _a, _b, _c, _d, _e, _f;
    this.option3d = options;
    const options3d = this.get3dOptions(options), { light, center: center2, camera, alpha, beta, fieldRatio, fieldDepth } = options3d, { dir = [1, 1, -1], color = "white", ambient } = light, centerX = (null !== (_a = center2.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center2.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_c = center2.y) && void 0 !== _c ? _c : this.height / 2) + (null !== (_d = center2.dy) && void 0 !== _d ? _d : 0), centerVec3 = [centerX, centerY, (null !== (_e = center2.z) && void 0 !== _e ? _e : 0) + (null !== (_f = center2.dz) && void 0 !== _f ? _f : 0)];
    let cameraX = 0, cameraY = 0, cameraZ = 0;
    camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new DirectionalLight(dir, color, ambient);
    const cameraParams = {
      left: 0,
      right: this.width,
      top: 0,
      bottom: this.height,
      fieldRatio,
      fieldDepth,
      viewParams: {
        pos: [cameraX, cameraY, cameraZ],
        center: centerVec3,
        up: [0, 1, 0]
      }
    };
    this.camera ? this.camera.params = cameraParams : this.camera = new OrthoCamera(cameraParams), options.enableView3dTransform && this.enableView3dTransform();
  }
  setBeforeRender(cb) {
    this._beforeRender = cb;
  }
  setAfterRender(cb) {
    this._afterRender = cb;
  }
  afterNextRender(cb) {
    this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
  }
  enableView3dTransform() {
    this.view3dTranform || (this.view3dTranform = true, this.pluginService.register(new ViewTransform3dPlugin()));
  }
  disableView3dTranform() {
    this.view3dTranform && (this.view3dTranform = false, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRender() {
    this.autoRender || (this.autoRender = true, this.pluginService.register(new AutoRenderPlugin()));
  }
  disableAutoRender() {
    this.autoRender && (this.autoRender = false, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableIncrementalAutoRender() {
    this.increaseAutoRender || (this.increaseAutoRender = true, this.pluginService.register(new IncrementalAutoRenderPlugin()));
  }
  disableIncrementalAutoRender() {
    this.increaseAutoRender && (this.increaseAutoRender = false, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableDirtyBounds() {
    if (this.dirtyBounds) return;
    this.dirtyBounds = new Bounds();
    let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
    plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
  }
  disableDirtyBounds() {
    this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableLayout() {
    this._enableLayout || (this._enableLayout = true, this.pluginService.register(new FlexLayoutPlugin()));
  }
  disableLayout() {
    this._enableLayout && (this._enableLayout = false, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableHtmlAttribute(container2) {
    this.htmlAttribute || (this.htmlAttribute = container2, this.pluginService.register(new HtmlAttributePlugin()));
  }
  disableHtmlAttribute() {
    this.htmlAttribute && (this.htmlAttribute = false, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  tryUpdateAABBBounds() {
    const viewBox = this._viewBox;
    return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
  }
  combineLayer(ILayer1, ILayer2) {
    throw new Error("暂不支持");
  }
  createLayer(canvasId, layerMode) {
    const layer = this.layerService.createLayer(this, {
      main: false,
      layerMode,
      canvasId
    });
    return this.appendChild(layer), layer;
  }
  sortLayer(cb) {
    const children = this.children;
    children.sort(cb), this.removeAllChild(), children.forEach((c4) => {
      this.appendChild(c4);
    });
  }
  removeLayer(ILayerId) {
    return this.removeChild(this.findChildByUid(ILayerId));
  }
  tryInitInteractiveLayer() {
    this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = false, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
  }
  clearViewBox(color) {
    this.window.clearViewBox(this._viewBox, color);
  }
  render(layers, params2) {
    this.ticker.start(), this.timeline.resume();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params2, this.hooks.beforeRender.call(this), this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear(), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  combineLayersToWindow() {
  }
  renderNextFrame(layers, force) {
    this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer) => {
      this.nextFrameRenderLayerSet.add(layer);
    }), this.willNextFrameRender || (this.willNextFrameRender = true, this.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    this.timeline.resume(), this.ticker.start();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.hooks.afterRender.call(this), this.nextFrameRenderLayerSet.clear()), this.state = state, this._skipRender && this._skipRender++;
  }
  renderLayerList(layerList, params2) {
    const list = [];
    for (let i2 = 0; i2 < layerList.length; i2++) {
      let l2 = layerList[i2];
      "virtual" === l2.layerMode && (l2 = l2.getNativeHandler().mainHandler.layer), list.includes(l2) || list.push(l2);
    }
    list.forEach((layer) => {
      layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer.render({
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      }, Object.assign({
        renderStyle: this.renderStyle
      }, params2)));
    }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && this.interactiveLayer.render({
      renderService: this.renderService,
      updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
    }, Object.assign({
      renderStyle: this.renderStyle
    }, params2));
  }
  resizeWindow(w2, h2, rerender = true) {
    this.window.resize(w2, h2), rerender && this.render();
  }
  resize(w2, h2, rerender = true) {
    this.window.resize(w2, h2), this.forEachChildren((c4) => {
      c4.resize(w2, h2);
    }), this._subView || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w2, this.viewBox.y1 + h2), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();
  }
  resizeView(w2, h2, rerender = true) {
    this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w2, this.viewBox.y1 + h2), this.forEachChildren((c4) => {
      c4.resizeView(w2, h2);
    }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
      right: this.width,
      bottom: this.height
    })), rerender && this.render();
  }
  setViewBox(x3, y3, w2, h2, rerender) {
    let isRerender = true;
    "object" == typeof x3 ? (this.viewBox.setValue(x3.x1, x3.y1, x3.x2, x3.y2), false === y3 && (isRerender = false)) : (this.viewBox.setValue(x3, y3, x3 + w2, y3 + h2), false === rerender && (isRerender = false)), this.forEachChildren((c4) => {
      c4.resizeView(this.viewBox.width(), this.viewBox.height());
    }), isRerender && this.render();
  }
  setDpr(dpr, rerender = true) {
    this.forEachChildren((c4) => {
      c4.setDpr(dpr);
    }), rerender && this.render();
  }
  setOrigin(x3, y3) {
    throw new Error("暂不支持");
  }
  export(type) {
    throw new Error("暂不支持");
  }
  pick(x3, y3) {
    this.pickerService || (this.pickerService = container.get(PickerService));
    const result2 = this.pickerService.pick(this.children, new Point(x3, y3), {
      bounds: this.AABBBounds
    });
    return !(!(null == result2 ? void 0 : result2.graphic) && !(null == result2 ? void 0 : result2.group)) && result2;
  }
  startAnimate(t2) {
    throw new Error("暂不支持");
  }
  setToFrame(t2) {
    throw new Error("暂不支持");
  }
  release() {
    super.release(), this.eventSystem && this.eventSystem.release(), this.pluginService.release(), this.forEach((layer) => {
      layer.release();
    }), this.interactiveLayer && this.interactiveLayer.release(), this.window.release();
  }
  setStage(stage) {
  }
  dirty(b2, matrix) {
    matrix && b2.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b2.x1, b2.y1, b2.x2, b2.y2), this.dirtyBounds.union(b2);
  }
  getLayer(name) {
    return this.children.filter((layer) => layer.name === name)[0];
  }
  renderTo(window2, params2) {
    this.forEachChildren((layer, i2) => {
      layer.drawTo(window2, Object.assign(Object.assign({}, params2), {
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        clear: 0 === i2,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      }));
    });
  }
  renderToNewWindow(fullImage = true, viewBox) {
    const window2 = container.get(VWindow);
    if (fullImage) window2.create({
      width: this.viewWidth,
      height: this.viewHeight,
      dpr: this.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    });
    else {
      const width = viewBox ? viewBox.width() : Math.min(this.viewWidth, this.window.width - this.x), height = viewBox ? viewBox.height() : Math.min(this.viewHeight, this.window.height - this.y);
      window2.create({
        width,
        height,
        dpr: this.window.dpr,
        canvasControled: true,
        offscreen: true,
        title: ""
      });
    }
    const x3 = viewBox ? -viewBox.x1 : 0, y3 = viewBox ? -viewBox.y1 : 0;
    return this.renderTo(window2, {
      x: x3,
      y: y3,
      width: viewBox ? viewBox.x2 : window2.width,
      height: viewBox ? viewBox.y2 : window2.height
    }), window2;
  }
  toCanvas(fullImage = true, viewBox) {
    const c4 = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
    return c4.nativeCanvas ? c4.nativeCanvas : null;
  }
  setCursor(mode2) {
    this._cursor = mode2, this.eventSystem.setCursor(mode2, "ignore");
  }
  getCursor() {
    return this._cursor;
  }
};

// node_modules/@visactor/vrender-core/es/create.js
function createStage(params2) {
  return new Stage(params2);
}

// node_modules/@visactor/vrender-core/es/interface/graphic/bounds.js
var params;
!function(params2) {
  params2[params2.W = 1] = "W", params2[params2.H = 2] = "H", params2[params2.WH = 3] = "WH";
}(params || (params = {}));

// node_modules/@visactor/vrender-core/es/canvas/empty-context.js
var __decorate33 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata25 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
var globalPoint = {
  x: 0,
  y: 0
};
var EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D();
  }
  getCanvas() {
    throw new Error("不支持getCanvas");
  }
  getContext() {
    throw new Error("不支持getContext");
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m5) {
    return matrixAllocate.allocateByObj(m5);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a4, b2, c4, d2, e3, f2, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a4, dpr * b2, dpr * c4, dpr * d2, dpr * e3, dpr * f2), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a4, b2, c4, d2, e3, f2, setTransform = true) {
    this.matrix.multiply(a4, b2, c4, d2, e3, f2), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x3, y3, setTransform = true) {
    this.matrix.translate(x3, y3), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x3, y3, setTransform = true) {
    this.translate(x3, y3, false), this.rotate(rad, false), this.translate(-x3, -y3, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x3, y3, setTransform = true) {
    this.translate(x3, y3, false), this.rotateDegrees(deg, false), this.translate(-x3, -y3, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {
  }
  arc(x3, y3, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x3, y3, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x14, y14, x23, y23, radiusX) {
    this.path.arcTo(x14, y14, x23, y23, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x3, y3, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  }
  lineTo(x3, y3) {
    this.path.lineTo(x3, y3);
  }
  moveTo(x3, y3) {
    this.path.moveTo(x3, y3);
  }
  quadraticCurveTo(cpx, cpy, x3, y3) {
    this.path.quadraticCurveTo(cpx, cpy, x3, y3);
  }
  rect(x3, y3, w2, h2) {
    this.path.rect(x3, y3, w2, h2);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x05, y05, x14, y14) {
    throw new Error("不支持createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("不支持createPattern");
  }
  createRadialGradient(x05, y05, r0, x14, y14, r1) {
    throw new Error("不支持createRadialGradient");
  }
  createConicGradient(x3, y3, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {
  }
  fillRect(x3, y3, width, height) {
    this.path.rect(x3, y3, width, height);
  }
  clearRect(x3, y3, w2, h2) {
  }
  fillText(text2, x3, y3) {
  }
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x3, y3) {
    return this.matrix.transformPoint({
      x: x3,
      y: y3
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x3, y3) {
    if (!this.lineWidth) return false;
    this.matrix.transformPoint({
      x: x3,
      y: y3
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text2) {
    throw new Error("不支持measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("不支持measureText");
  }
  setLineDash(segments2) {
  }
  stroke(path) {
  }
  strokeRect(x3, y3, width, height) {
    this.path.rect(x3, y3, width, height);
  }
  strokeText(text2, x3, y3) {
  }
  drawImage() {
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setCommonStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setStrokeStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
  }
  setTextStyle(params2, defaultParams) {
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m5) => matrixAllocate.free(m5)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate33([injectable(), __metadata25("design:paramtypes", [Object, Number])], EmptyContext2d);

// node_modules/@visactor/vrender-core/es/canvas/contributions/base-canvas.js
var __decorate34 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata26 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DefaultConfig2 = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1
};
var BaseCanvas = class {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(_x) {
    this._x = _x;
  }
  get y() {
    return this._y;
  }
  set y(_y) {
    this._y = _y;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(width) {
    this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
  }
  get height() {
    return this._pixelHeight;
  }
  set height(height) {
    this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
  }
  getContext(str) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(visiable) {
    this._visiable = visiable, visiable ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(dpr) {
    this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(params2) {
    var _a;
    const { nativeCanvas, width = DefaultConfig2.WIDTH, height = DefaultConfig2.HEIGHT, dpr = DefaultConfig2.DPR, x: x3, y: y3, id: id2, canvasControled = true } = params2;
    this._x = null != x3 ? x3 : 0, this._y = null != y3 ? y3 : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = false !== params2.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id2, id2 && (nativeCanvas.id = id2), this.init(params2);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {
  }
  show() {
  }
  applyPosition() {
  }
  resetStyle(params2) {
  }
  resize(width, height) {
  }
  toDataURL(mimeType, quality) {
    return "";
  }
  readPixels(x3, y3, w2, h2) {
    return this._context.getImageData(x3, y3, w2, h2);
  }
  convertToBlob(options) {
    throw new Error("暂未实现");
  }
  transferToImageBitmap() {
    throw new Error("暂未实现");
  }
  release(...params2) {
    this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
};
BaseCanvas.env = "browser", BaseCanvas = __decorate34([injectable(), __metadata26("design:paramtypes", [Object])], BaseCanvas);

// node_modules/@visactor/vrender-core/es/core/contributions/env/base-contribution.js
var __decorate35 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var BaseEnvContribution = class {
  configure(service, ...p2) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(dom) {
    return new AABBBounds();
  }
  removeDom(dom) {
    return false;
  }
  createDom(params2) {
    return null;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadBlob(url) {
    return fetch(url).then((data) => data.blob()).then((blob) => ({
      data: blob,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  getElementTop(dom, baseWindow) {
    return 0;
  }
  getElementLeft(dom, baseWindow) {
    return 0;
  }
  getElementTopLeft(dom, baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
};
BaseEnvContribution = __decorate35([injectable()], BaseEnvContribution);

// node_modules/@visactor/vrender-core/es/core/contributions/window/base-contribution.js
var __decorate36 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata27 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var BaseWindowHandlerContribution = class {
  constructor() {
    this._uid = Generator.GenAutoIncrementId();
  }
  onChange(cb) {
    this._onChangeCb = cb;
  }
  configure(window2, global) {
    global.env === this.type && window2.setWindowHandler(this);
  }
  release(...params2) {
    this.releaseWindow();
  }
  isVisible(bbox) {
    return true;
  }
  onVisibleChange(cb) {
  }
  getTopLeft(baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
};
BaseWindowHandlerContribution = __decorate36([injectable(), __metadata27("design:paramtypes", [])], BaseWindowHandlerContribution);

// node_modules/@visactor/vrender-core/es/picker/picker-service.js
var __decorate37 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata28 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPickService = class {
  constructor(pickItemInterceptorContributions) {
    this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.type = "default", this.global = application.global;
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a4, b2) => a4.order - b2.order);
  }
  pick(graphics, point6, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    params2.pickerService = this;
    let offsetX = 0, offsetY = 0;
    if (params2 && params2.bounds) {
      if (!params2.bounds.contains(point6.x, point6.y)) return result2;
      offsetX = params2.bounds.x1, offsetY = params2.bounds.y1;
    }
    this.pickContext && (this.pickContext.inuse = true), params2.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(true, 1);
    const parentMatrix = new Matrix(1, 0, 0, 1, offsetX, offsetY);
    let group;
    for (let i2 = graphics.length - 1; i2 >= 0 && (result2 = graphics[i2].isContainer ? this.pickGroup(graphics[i2], point6, parentMatrix, params2) : this.pickItem(graphics[i2], point6, parentMatrix, params2), !result2.graphic); i2--) group || (group = result2.group);
    if (result2.graphic || (result2.group = group), this.pickContext && (this.pickContext.inuse = false), result2.graphic) {
      let g3 = result2.graphic;
      for (; g3.parent; ) g3 = g3.parent;
      g3.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g3.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point6, params2) {
    var _a;
    return !!(null === (_a = this.pickItem(graphic, point6, null, null != params2 ? params2 : {
      pickContext: this.pickContext,
      pickerService: this
    })) || void 0 === _a ? void 0 : _a.graphic);
  }
  pickGroup(group, point6, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const context = params2.pickContext, lastMatrix = context.modelMatrix;
    if (context.camera) {
      const m5 = group.transMatrix, matrix = mat4Allocate.allocate();
      if (mat3Tomat4(matrix, m5), lastMatrix) {
        if (matrix) {
          const m6 = mat4Allocate.allocate();
          context.modelMatrix = multiplyMat4Mat4(m6, lastMatrix, matrix), mat4Allocate.free(matrix);
        }
      } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
    }
    if (this.InterceptorContributions.length) for (let i2 = 0; i2 < this.InterceptorContributions.length; i2++) {
      const drawContribution = this.InterceptorContributions[i2];
      if (drawContribution.beforePickItem) {
        const result3 = drawContribution.beforePickItem(group, this, point6, params2, {
          parentMatrix
        });
        if (result3) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result3;
      }
    }
    const transMatrix = group.transMatrix, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(point6.x, point6.y);
    currentGroupMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup && !group.stage.camera) return result2;
    const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params2);
    pickedItem && pickedItem.graphic && (result2.graphic = pickedItem.graphic, result2.params = pickedItem.params);
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, (graphic) => {
      if (graphic.isContainer) {
        const newPoint2 = new Point(point6.x, point6.y), theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY, result2 = this.pickGroup(graphic, newPoint2, currentGroupMatrix, params2);
      } else {
        const newPoint2 = new Point(point6.x, point6.y);
        currentGroupMatrix.transformPoint(newPoint2, newPoint2);
        const theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY;
        const pickedItem2 = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        pickedItem2 && pickedItem2.graphic && (result2.graphic = pickedItem2.graphic, result2.params = pickedItem2.params);
      }
      return !!result2.graphic || !!result2.group;
    }, true, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result2.graphic || result2.group || !groupPicked || group.stage.camera || (result2.group = group), matrixAllocate.free(currentGroupMatrix), result2;
  }
  selectPicker(graphic) {
    const picker = this.pickerMap.get(graphic.numberType);
    return picker || null;
  }
};
DefaultPickService = __decorate37([injectable(), __param19(0, inject(ContributionProvider)), __param19(0, named(PickItemInterceptor)), __metadata28("design:paramtypes", [Object])], DefaultPickService);

// node_modules/@visactor/vrender-core/es/picker/global-picker-service.js
var __decorate38 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata29 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DefaultGlobalPickerService = class {
  constructor() {
    this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env);
  }
  configure(global, env) {
  }
  pick(graphics, point6, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i2 = 0; i2 < graphics.length; i2++) {
      if (graphics[i2].isContainer) result2 = this.pickGroup(graphics[i2], point6, parentMatrix, params2);
      else {
        const data = this.pickItem(graphics[i2], point6, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      if (result2.graphic) break;
      group || (group = result2.group);
    }
    if (result2.graphic || (result2.group = group), result2.graphic) {
      let g3 = result2.graphic;
      for (; g3.parent; ) g3 = g3.parent;
      g3.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g3.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point6, params2) {
    return !!this.pickItem(graphic, point6, null, params2);
  }
  pickGroup(group, point6, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll) return result2;
    const transMatrix = group.transMatrix, newPoint = new Point(point6.x, point6.y);
    parentMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup) return result2;
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false !== group.attribute.childrenPickable && group.forEachChildren((graphic) => {
      if (graphic.isContainer) result2 = this.pickGroup(graphic, point6, parentMatrix, params2);
      else {
        const newPoint2 = new Point(point6.x, point6.y);
        parentMatrix.transformPoint(newPoint2, newPoint2);
        const data = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      return !!result2.graphic || !!result2.group;
    }), result2.graphic || result2.group || !groupPicked || (result2.group = group), result2;
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    return false === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point6) ? {
      graphic
    } : null;
  }
};
DefaultGlobalPickerService = __decorate38([injectable(), __metadata29("design:paramtypes", [])], DefaultGlobalPickerService);

// node_modules/@visactor/vrender-core/es/allocator/graphic-allocate.js
var DefaultGraphicAllocate = class {
  constructor() {
    this.pools = [];
  }
  free(d2) {
    this.pools.push(d2);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultRectAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.rect(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(rect) {
    if (!this.pools.length) return application.graphicService.creator.rect(rect.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(rect.attribute), g3;
  }
};
var defaultRectAllocate = new DefaultRectAllocate();
var DefaultArcAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.arc(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(arc) {
    if (!this.pools.length) return application.graphicService.creator.arc(arc.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(arc.attribute), g3;
  }
};
var defaultArcAllocate = new DefaultArcAllocate();
var DefaultAreaAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.area(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(area2) {
    if (!this.pools.length) return application.graphicService.creator.area(area2.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(area2.attribute), g3;
  }
};
var defaultAreaAllocate = new DefaultAreaAllocate();
var DefaultCircleAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.circle(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(area2) {
    if (!this.pools.length) return application.graphicService.creator.circle(area2.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(area2.attribute), g3;
  }
};
var defaultCircleAllocate = new DefaultCircleAllocate();
var DefaultLineAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.line(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(line2) {
    if (!this.pools.length) return application.graphicService.creator.line(line2.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(line2.attribute), g3;
  }
};
var defaultLineAllocate = new DefaultLineAllocate();
var DefaultPathAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.path(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(path) {
    if (!this.pools.length) return application.graphicService.creator.path(path.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(path.attribute), g3;
  }
};
var defaultPathAllocate = new DefaultPathAllocate();
var DefaultSymbolAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.symbol(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(symbol) {
    if (!this.pools.length) return application.graphicService.creator.symbol(symbol.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(symbol.attribute), g3;
  }
};
var defaultSymbolAllocate = new DefaultSymbolAllocate();
var DefaultTextAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.text(attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(attribute), g3;
  }
  allocateByObj(text2) {
    if (!this.pools.length) return application.graphicService.creator.text(text2.attribute);
    const g3 = this.pools.pop();
    return g3.initAttributes(text2.attribute), g3;
  }
};
var defaultTextAllocate = new DefaultTextAllocate();
var DefaultGraphicMemoryManager = class {
  constructor() {
    this.map = {
      text: defaultTextAllocate,
      symbol: defaultSymbolAllocate
    };
  }
  gc(g3) {
    g3.isContainer ? g3.forEachChildren((i2) => this.gc(i2)) : this.gcItem(g3);
  }
  gcItem(g3) {
    const allocate = this.map[g3.type];
    allocate && allocate.free(g3);
  }
};
var defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc-module.js
var loadArcModule = false;
var arcModule = new ContainerModule((bind) => {
  loadArcModule || (loadArcModule = true, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect-module.js
var loadRectModule = false;
var rectModule = new ContainerModule((bind) => {
  loadRectModule || (loadRectModule = true, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/line-module.js
var loadLineModule = false;
var lineModule = new ContainerModule((bind) => {
  loadLineModule || (loadLineModule = true, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/area-module.js
var loadAreaModule = false;
var areaModule = new ContainerModule((bind) => {
  loadAreaModule || (loadAreaModule = true, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/symbol-module.js
var loadSymbolModule = false;
var symbolModule = new ContainerModule((bind) => {
  loadSymbolModule || (loadSymbolModule = true, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/circle-module.js
var loadCircleModule = false;
var circleModule = new ContainerModule((bind) => {
  loadCircleModule || (loadCircleModule = true, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/text-module.js
var loadTextModule = false;
var textModule = new ContainerModule((bind) => {
  loadTextModule || (loadTextModule = true, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/path-module.js
var loadPathModule = false;
var pathModule = new ContainerModule((bind) => {
  loadPathModule || (loadPathModule = true, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/polygon-module.js
var loadPolygonModule = false;
var polygonModule = new ContainerModule((bind) => {
  loadPolygonModule || (loadPolygonModule = true, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-render.js
var __decorate39 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  drawShape(glyph, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    drawContext.drawContribution && glyph.getSubGraphic().forEach((item) => {
      const renderer = drawContext.drawContribution.getRenderContribution(item);
      renderer && renderer.drawShape && renderer.drawShape(item, context, x3, y3, drawContext, params2, fillCb, strokeCb);
    });
  }
  draw(glyph, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    if (context.highPerformanceSave(), !drawContext.drawContribution) return;
    const glyphTheme = getTheme(glyph), subGraphic = glyph.getSubGraphic();
    subGraphic.length && subGraphic.forEach((g3) => {
      drawContext.drawContribution.renderItem(g3, drawContext, {
        theme: glyphTheme
      });
    }), context.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate39([injectable()], DefaultCanvasGlyphRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/glyph-module.js
var loadGlyphModule = false;
var glyphModule = new ContainerModule((bind) => {
  loadGlyphModule || (loadGlyphModule = true, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-render.js
var __decorate40 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata30 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x3, y3, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext, { strokeOpacity = richtextAttribute.strokeOpacity, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
    if (!richtext.valid || !visible) return;
    const fVisible = fillVisible(opacity, fillOpacity, true), sVisible = fillVisible(opacity, strokeOpacity, true);
    if (!fVisible) return;
    context.translate(x3, y3), this.beforeRenderStep(richtext, context, x3, y3, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x3, y3, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon, context, x3, y3, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon).richtextIcon, { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon.attribute, { backgroundWidth = width, backgroundHeight = height } = icon.attribute;
    if (margin && (x3 += icon._marginArray[3], y3 += icon._marginArray[0]), icon._hovered) {
      const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x3 - expandX, y3 - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x3 - expandX, y3 - expandY, backgroundWidth, backgroundHeight, backgroundRadius)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x3, y3, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, false, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate40([injectable(), __metadata30("design:paramtypes", [])], DefaultCanvasRichTextRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/richtext-module.js
var loadRichtextModule = false;
var richtextModule = new ContainerModule((bind) => {
  loadRichtextModule || (loadRichtextModule = true, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/image-module.js
var loadImageModule = false;
var imageModule = new ContainerModule((bind) => {
  loadImageModule || (loadImageModule = true, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-render.js
var __decorate41 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasRect3dRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  drawShape(rect, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect3d, { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, x1: x14, y1: y14, x: originX, y: originY, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - originX) || 0, height = (null != height ? height : y14 - originY) || 0;
    const z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return;
    const { light, camera } = drawContext.stage || {}, face3d = rect.findFace();
    if (false !== fill) {
      context.setCommonStyle(rect, rect.attribute, x3, y3, rectAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x3, y3, z2, face3d, fc, context, light, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(rect, rect.attribute, x3, y3, rectAttribute), this.stroke(x3, y3, z2, face3d, context));
  }
  stroke(x3, y3, z2, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((edge) => {
      const p1 = vertices[edge[0]], v1 = {
        x: x3 + p1[0],
        y: y3 + p1[1],
        z: z2 + p1[2]
      }, p2 = vertices[edge[1]], v2 = {
        x: x3 + p2[0],
        y: y3 + p2[1],
        z: z2 + p2[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x3, y3, z2, face3d, fillColor, context, light, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v2) => context.view(v2[0], v2[1], v2[2])[2]), sortFace = [];
    face3d.polygons.forEach((p2, i2) => {
      sortFace.push({
        faceIdx: i2,
        polygon: p2
      });
      const { polygon, normal } = p2, z1 = viewdVerticesZ[polygon[0]], z22 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p2.ave_z = z1 + z22 + z3 + z4;
    }), sortFace.sort((a4, b2) => b2.polygon.ave_z - a4.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x3 + p1[0],
        y: y3 + p1[1],
        z: z2 + p1[2]
      }, v2 = {
        x: x3 + p2[0],
        y: y3 + p2[1],
        z: z2 + p2[2]
      }, v3 = {
        x: x3 + p3[0],
        y: y3 + p3[1],
        z: z2 + p3[2]
      }, v4 = {
        x: x3 + p4[0],
        y: y3 + p4[1],
        z: z2 + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, null, null) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
  draw(rect, renderService, drawContext) {
    const rectAttribute = getTheme(rect).rect;
    this._draw(rect, rectAttribute, false, drawContext);
  }
};
DefaultCanvasRect3dRender = __decorate41([injectable()], DefaultCanvasRect3dRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/rect3d-module.js
var loadRect3dModule = false;
var rect3dModule = new ContainerModule((bind) => {
  loadRect3dModule || (loadRect3dModule = true, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-render.js
var __decorate42 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
function drawArcPath2(arc, context, cx, cy, z2, outerRadius, innerRadius) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp3 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp3;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy, z2);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z2), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z2), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z2), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z2));
  else {
    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    outerDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z2), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z2)), !(innerRadius > epsilon) || innerDeltaAngle < 1e-3 ? (context.lineTo(cx + xire, cy + yire, z2), collapsedToLine = true) : (context.lineTo(cx + xire, cy + yire, z2), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (radius <= epsilon) context.moveTo(cx, cy, z1);
  else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
  else {
    const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle), xors = radius * cos(innerouterStartAngle), yors = radius * sin(innerouterStartAngle), xore = radius * cos(innerouterEndAngle), yore = radius * sin(innerouterEndAngle);
    innerouterDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
var DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
  }
  drawShape(arc, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const { fVisible, sVisible, doFill, doStroke } = data, z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, height = 10 } = arc.attribute, rgbArray = ColorStore.Get(fill, ColorType.Color255), { light } = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
      top: z2,
      bottom: z2 + height
    }, n_face = {
      top: [0, 1, 0],
      bottom: [0, -1, 0],
      outside: [1, 0, -1],
      inside: [1, 0, -1]
    };
    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath2(arc, context, x3, y3, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x3, y3, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x3, y3, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x3, y3, innerRadius, 0, pi2, true, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x3, y3, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
      const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
      return "outside" === face ? {
        innerouterDeltaAngle: outerDeltaAngle,
        innerouterEndAngle: outerEndAngle,
        innerouterStartAngle: outerStartAngle
      } : {
        innerouterDeltaAngle: innerDeltaAngle,
        innerouterEndAngle: innerEndAngle,
        innerouterStartAngle: innerStartAngle
      };
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x3, y3, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x3, y3, arcAttribute), context.stroke())), "inside" === face && context.restore());
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArc3DRender = __decorate42([injectable()], DefaultCanvasArc3DRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/arc3d-module.js
var loadArc3dModule = false;
var arc3dModule = new ContainerModule((bind) => {
  loadArc3dModule || (loadArc3dModule = true, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
});

// node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-render.js
var __decorate43 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasPyramid3dRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  drawShape(pyramid3d, context, x3, y3, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const pyramidAttribute = getTheme(pyramid3d, null == params2 ? void 0 : params2.theme).polygon, { fill = pyramidAttribute.fill, stroke: stroke2 = pyramidAttribute.stroke, face = [true, true, true, true, true, true] } = pyramid3d.attribute, z2 = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
    const { light, camera } = drawContext.stage || {}, face3d = pyramid3d.findFace();
    if (false !== fill) {
      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x3, y3, pyramidAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x3, y3, z2, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x3, y3, pyramidAttribute), this.stroke(x3, y3, z2, face3d, context));
  }
  stroke(x3, y3, z2, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((p2) => {
      const p1 = vertices[p2[0]], p22 = vertices[p2[1]], v1 = {
        x: x3 + p1[0],
        y: y3 + p1[1],
        z: z2 + p1[2]
      }, v2 = {
        x: x3 + p22[0],
        y: y3 + p22[1],
        z: z2 + p22[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x3, y3, z2, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v2) => context.view(v2[0], v2[1], v2[2])[2]), sortFace = [];
    face3d.polygons.forEach((p2, i2) => {
      if (!faces[i2]) return;
      sortFace.push({
        faceIdx: i2,
        polygon: p2
      });
      const { polygon, normal } = p2, z1 = viewdVerticesZ[polygon[0]], z22 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p2.ave_z = z1 + z22 + z3 + z4;
    }), sortFace.sort((a4, b2) => b2.polygon.ave_z - a4.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x3 + p1[0],
        y: y3 + p1[1],
        z: z2 + p1[2]
      }, v2 = {
        x: x3 + p2[0],
        y: y3 + p2[1],
        z: z2 + p2[2]
      }, v3 = {
        x: x3 + p3[0],
        y: y3 + p3[1],
        z: z2 + p3[2]
      }, v4 = {
        x: x3 + p4[0],
        y: y3 + p4[1],
        z: z2 + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, pyramid3d.attribute, pyramid3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
  draw(pyramid3d, renderService, drawContext) {
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    this._draw(pyramid3d, pyramid3dAttribute, false, drawContext);
  }
};
DefaultCanvasPyramid3dRender = __decorate43([injectable()], DefaultCanvasPyramid3dRender);

// node_modules/@visactor/vrender-core/es/render/contributions/render/pyramid3d-module.js
var loadPyramid3dModule = false;
var pyramid3dModule = new ContainerModule((bind) => {
  loadPyramid3dModule || (loadPyramid3dModule = true, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
});

// node_modules/@visactor/vrender-core/es/register/register-arc.js
function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

// node_modules/@visactor/vrender-core/es/register/register-arc3d.js
function registerArc3dGraphic() {
  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
}

// node_modules/@visactor/vrender-core/es/register/register-area.js
function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

// node_modules/@visactor/vrender-core/es/register/register-circle.js
function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

// node_modules/@visactor/vrender-core/es/register/register-glyph.js
function registerGlyphGraphic() {
  graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
}

// node_modules/@visactor/vrender-core/es/register/register-group.js
function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

// node_modules/@visactor/vrender-core/es/register/register-image.js
function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

// node_modules/@visactor/vrender-core/es/register/register-line.js
function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

// node_modules/@visactor/vrender-core/es/register/register-path.js
function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

// node_modules/@visactor/vrender-core/es/register/register-polygon.js
function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

// node_modules/@visactor/vrender-core/es/register/register-pyramid3d.js
function registerPyramid3dGraphic() {
  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
}

// node_modules/@visactor/vrender-core/es/register/register-rect.js
function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

// node_modules/@visactor/vrender-core/es/register/register-rect3d.js
function registerRect3dGraphic() {
  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
}

// node_modules/@visactor/vrender-core/es/register/register-richtext.js
function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

// node_modules/@visactor/vrender-core/es/register/register-symbol.js
function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

// node_modules/@visactor/vrender-core/es/register/register-text.js
function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

// node_modules/@visactor/vrender-core/es/register/register-shadowRoot.js
function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}

// node_modules/@visactor/vrender-core/es/register/register-wraptext.js
function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}

// node_modules/@visactor/vchart/esm/util/env.js
var isBrowser = isBrowserEnv();
var domDocument = isBrowser && globalThis ? globalThis.document : void 0;
function isTrueBrowser(mode2) {
  return ("desktop-browser" === mode2 || "mobile-browser" === mode2) && isBrowser;
}
function isMobileLikeMode(mode2) {
  return isMiniAppLikeMode(mode2) || "mobile-browser" === mode2;
}
function isMiniAppLikeMode(mode2) {
  return mode2.includes("miniApp") || "lynx" === mode2 || "wx" === mode2;
}

// node_modules/@visactor/vchart/esm/util/id.js
var VChartId = 0;
function createID() {
  return VChartId >= 9999999 && (VChartId = 0), VChartId++;
}

// node_modules/@visactor/vchart/esm/util/type.js
function couldBeValidNumber(v2) {
  return null != v2 && "" !== v2 && (!!isNumber_default(v2) || +v2 == +v2);
}
function toValidNumber2(v2) {
  if (isValidNumber_default(v2)) return v2;
  const value = +v2;
  return isValidNumber_default(value) ? value : 0;
}
function isDataDomainSpec(domain) {
  return !(!domain || 0 === domain.length) && (!isNil_default(domain[0]) && !isNil_default(domain[0].dataId) && isArray_default(domain[0].fields));
}

// node_modules/@visactor/vgrammar-util/es/accessor.js
var accessor = (fn, fields2, name) => (fn.fields = fields2 || [], fn.fname = name, fn);

// node_modules/@visactor/vgrammar-util/es/getter.js
var getter = (path) => (obj) => get_default(obj, path);

// node_modules/@visactor/vgrammar-util/es/error.js
var error2 = (message) => {
  Logger.getInstance().error(message);
};

// node_modules/@visactor/vgrammar-util/es/splitAccessPath.js
var splitAccessPath = (p2) => {
  const path = [], n2 = p2.length;
  let i2, j2, c4, q2 = null, b2 = 0, s3 = "";
  p2 += "";
  const push = () => {
    path.push(s3 + p2.substring(i2, j2)), s3 = "", i2 = j2 + 1;
  };
  for (i2 = 0, j2 = 0; j2 < n2; j2 += 1) if (c4 = p2[j2], "\\" === c4) s3 += p2.substring(i2, j2), s3 += p2.substring(++j2, ++j2), i2 = j2;
  else if (c4 === q2) push(), q2 = null, b2 = -1;
  else {
    if (q2) continue;
    i2 === b2 && '"' === c4 || i2 === b2 && "'" === c4 ? (i2 = j2 + 1, q2 = c4) : "." !== c4 || b2 ? "[" === c4 ? (j2 > i2 && push(), i2 = j2 + 1, b2 = i2) : "]" === c4 && (b2 || error2("Access path missing open bracket: " + p2), b2 > 0 && push(), b2 = 0, i2 = j2 + 1) : j2 > i2 ? push() : i2 = j2 + 1;
  }
  return b2 && error2("Access path missing closing bracket: " + p2), q2 && error2("Access path missing closing quote: " + p2), j2 > i2 && (j2 += 1, push()), path;
};

// node_modules/@visactor/vgrammar-util/es/field.js
var fieldSingle = (fieldStr, name, opt = {}) => {
  if (isFunction_default(fieldStr)) return fieldStr;
  const path = splitAccessPath(fieldStr), parsedField = 1 === path.length ? path[0] : fieldStr;
  return accessor((opt && opt.get || getter)(path), [parsedField], name || parsedField);
};
var field = (fieldStr, name, opt = {}) => {
  if (isArray_default(fieldStr)) {
    const funcs = fieldStr.map((entry) => fieldSingle(entry, name, opt));
    return (datum) => funcs.map((func) => func(datum));
  }
  return fieldSingle(fieldStr, name, opt);
};

// node_modules/@visactor/vgrammar-util/es/accessors.js
var id = field("id");
var identity2 = accessor(function(_2) {
  return _2;
}, [], "identity");
var zero2 = accessor(function() {
  return 0;
}, [], "zero");
var one2 = accessor(function() {
  return 1;
}, [], "one");
var truthy = accessor(function() {
  return true;
}, [], "true");
var falsy = accessor(function() {
  return false;
}, [], "false");
var emptyObject = accessor(function() {
  return {};
}, [], "emptyObject");

// node_modules/@visactor/vgrammar-util/es/extent.js
var extent2 = (array2, func) => {
  const valueGetter = isFunction_default(func) ? func : (val) => val;
  let min4, max4;
  if (array2 && array2.length) {
    const n2 = array2.length;
    for (let i2 = 0; i2 < n2; i2 += 1) {
      let value = valueGetter(array2[i2]);
      isNil_default(value) || !isNumber_default(value = +value) || Number.isNaN(value) || (isNil_default(min4) ? (min4 = value, max4 = value) : (min4 = Math.min(min4, value), max4 = Math.max(max4, value)));
    }
    return [min4, max4];
  }
  return [min4, max4];
};

// node_modules/@visactor/vgrammar-util/es/isEqual.js
var isEqual2 = (key, current, target, deep = true) => {
  if (current === target) return true;
  if (isNil_default(current) || isNil_default(target)) return isNil_default(current) && isNil_default(target);
  if (!isObjectLike_default(current) && !isObjectLike_default(target)) return current === target;
  const c4 = isArray_default(current) ? current : current[key], t2 = isArray_default(target) ? target : target[key];
  return c4 === t2 || false !== deep && (isArray_default(t2) ? !(!isArray_default(c4) || t2.length !== c4.length || !t2.every((v2, i2) => v2 === c4[i2])) : !!isObject_default(t2) && !(!isObject_default(c4) || Object.keys(t2).length !== Object.keys(c4).length || !Object.keys(t2).every((k3) => isEqual2(k3, t2, c4))));
};

// node_modules/@visactor/vgrammar-util/es/toPercent.js
var toPercent = (percent, total) => isNil_default(percent) ? total : isString_default(percent) ? total * parseFloat(percent) / 100 : percent;

// node_modules/@visactor/vgrammar-util/es/regression-linear.js
function ordinaryLeastSquares(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta;
  return [uY - slope * uX, slope];
}
function visitPoints(data, x3, y3, callback) {
  let u2, v2, i2 = -1;
  data.forEach((d2) => {
    u2 = x3(d2), v2 = y3(d2), !isNil_default(u2) && (u2 = +u2) >= u2 && !isNil_default(v2) && (v2 = +v2) >= v2 && callback(u2, v2, ++i2);
  });
}
function rSquared2(data, x3, y3, uY, predict2) {
  let SSE = 0, SST = 0;
  return visitPoints(data, x3, y3, (dx, dy) => {
    const sse = dy - predict2(dx), sst = dy - uY;
    SSE += sse * sse, SST += sst * sst;
  }), 1 - SSE / SST;
}
function regressionLinear(data, x3 = (datum) => datum.x, y3 = (datum) => datum.y) {
  let X = 0, Y = 0, XY = 0, X22 = 0, n2 = 0;
  visitPoints(data, x3, y3, (dx, dy) => {
    ++n2, X += (dx - X) / n2, Y += (dy - Y) / n2, XY += (dx * dy - XY) / n2, X22 += (dx * dx - X22) / n2;
  });
  const coef = ordinaryLeastSquares(X, Y, XY, X22), predict2 = (x4) => coef[0] + coef[1] * x4;
  return {
    coef,
    predict: predict2,
    rSquared: rSquared2(data, x3, y3, Y, predict2)
  };
}

// node_modules/@visactor/vgrammar-util/es/direction.js
function isHorizontal(direction2) {
  return "horizontal" === direction2;
}
function isVertical(direction2) {
  return "vertical" === direction2;
}
function isValidDirection(direction2) {
  return "vertical" === direction2 || "horizontal" === direction2;
}
function isValidPosition(position) {
  return "top" === position || "bottom" === position || "left" === position || "right" === position;
}
function isHorizontalPosition(position) {
  return "top" === position || "bottom" === position;
}

// node_modules/@visactor/vscale/es/type.js
var ScaleEnum;
!function(ScaleEnum2) {
  ScaleEnum2.Identity = "identity", ScaleEnum2.Linear = "linear", ScaleEnum2.Log = "log", ScaleEnum2.Pow = "pow", ScaleEnum2.Sqrt = "sqrt", ScaleEnum2.Symlog = "symlog", ScaleEnum2.Time = "time", ScaleEnum2.Quantile = "quantile", ScaleEnum2.Quantize = "quantize", ScaleEnum2.Threshold = "threshold", ScaleEnum2.Ordinal = "ordinal", ScaleEnum2.Point = "point", ScaleEnum2.Band = "band";
}(ScaleEnum || (ScaleEnum = {}));
var EnableScaleMap = {};
Object.values(ScaleEnum).forEach((v2) => {
  EnableScaleMap[v2] = true;
});
function isContinuous(type) {
  switch (type) {
    case ScaleEnum.Linear:
    case ScaleEnum.Log:
    case ScaleEnum.Pow:
    case ScaleEnum.Sqrt:
    case ScaleEnum.Symlog:
    case ScaleEnum.Time:
      return true;
    default:
      return false;
  }
}
function isValidScaleType(type) {
  return !!EnableScaleMap[type];
}
function isDiscrete(type) {
  switch (type) {
    case ScaleEnum.Ordinal:
    case ScaleEnum.Point:
    case ScaleEnum.Band:
      return true;
    default:
      return false;
  }
}

// node_modules/@visactor/vscale/es/utils/utils.js
function identity3(x3) {
  return x3;
}
var sqrt4 = (x3) => x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
var square2 = (x3) => x3 < 0 ? -x3 * x3 : x3 * x3;
var logNegative = (x3) => -Math.log(-x3);
var expNegative = (x3) => -Math.exp(-x3);
var pow10 = (x3) => isFinite(x3) ? Math.pow(10, x3) : x3 < 0 ? 0 : x3;
var powp = (base) => 10 === base ? pow10 : base === Math.E ? Math.exp : (x3) => Math.pow(base, x3);
var logp = (base) => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), (x3) => Math.log(x3) / base);
var symlog = (c4) => (x3) => Math.sign(x3) * Math.log1p(Math.abs(x3 / c4));
var symexp = (c4) => (x3) => Math.sign(x3) * Math.expm1(Math.abs(x3)) * c4;
function normalize(a4, b2) {
  if (a4 = Number(a4), b2 = Number(b2), b2 -= a4) return (x3) => (x3 - a4) / b2;
  const result2 = Number.isNaN(b2) ? NaN : 0.5;
  return () => result2;
}
function bimap(domain, range2, interpolate2) {
  const d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  let d0Fuc, r0Fuc;
  return d1 < d0 ? (d0Fuc = normalize(d1, d0), r0Fuc = interpolate2(r1, r0)) : (d0Fuc = normalize(d0, d1), r0Fuc = interpolate2(r0, r1)), (x3) => r0Fuc(d0Fuc(x3));
}
function bandSpace(count, paddingInner, paddingOuter) {
  let space;
  return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
}
function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
  1 === paddingInner && (paddingInner = 0);
  return bandSpace(count, paddingInner, paddingOuter) * (bandwidth / (1 - paddingInner));
}
function calculateBandwidthFromWholeRangeSize(count, wholeSize, paddingInner, paddingOuter, round) {
  const space = bandSpace(count, paddingInner, paddingOuter);
  let step = wholeSize / Math.max(1, space || 1);
  round && (step = Math.floor(step));
  let bandwidth = step * (1 - paddingInner);
  return round && (bandwidth = Math.round(bandwidth)), bandwidth;
}
function calculateWholeRangeFromRangeFactor(range2, rangeFactor) {
  const k3 = (range2[1] - range2[0]) / (rangeFactor[1] - rangeFactor[0]), b2 = range2[0] - k3 * rangeFactor[0];
  return [b2, k3 + b2];
}
function polymap(domain, range2, interpolate2) {
  const j2 = Math.min(domain.length, range2.length) - 1, d2 = new Array(j2), r2 = new Array(j2);
  let i2 = -1;
  for (domain[j2] < domain[0] && (domain = domain.slice().reverse(), range2 = range2.slice().reverse()); ++i2 < j2; ) d2[i2] = normalize(domain[i2], domain[i2 + 1]), r2[i2] = interpolate2(range2[i2], range2[i2 + 1]);
  return function(x3) {
    const i3 = bisect(domain, x3, 1, j2) - 1;
    return r2[i3](d2[i3](x3));
  };
}
var nice = (domain, options) => {
  const newDomain = domain.slice();
  let startIndex = 0, endIndex = newDomain.length - 1, x05 = newDomain[startIndex], x14 = newDomain[endIndex];
  return x14 < x05 && ([startIndex, endIndex] = [endIndex, startIndex], [x05, x14] = [x14, x05]), newDomain[startIndex] = options.floor(x05), newDomain[endIndex] = options.ceil(x14), newDomain;
};
var niceNumber = (value, round = false) => {
  const exponent = Math.floor(Math.log10(value)), fraction = value / Math.pow(10, exponent);
  let niceFraction;
  return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent);
};
var restrictNumber = (value, domain) => {
  let min4, max4;
  return domain[0] < domain[1] ? (min4 = domain[0], max4 = domain[1]) : (min4 = domain[1], max4 = domain[0]), Math.min(Math.max(value, min4), max4);
};

// node_modules/@visactor/vscale/es/base-scale.js
var BaseScale = class {
  constructor() {
    this._rangeFactorStart = null, this._rangeFactorEnd = null;
  }
  _calculateWholeRange(range2) {
    return this._wholeRange ? this._wholeRange : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range2;
  }
  rangeFactor(_2, slience, clear) {
    return _2 ? (2 === _2.length && _2.every((r2) => r2 >= 0 && r2 <= 1) && (this._wholeRange = null, 0 === _2[0] && 1 === _2[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _2[0], this._rangeFactorEnd = _2[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
  }
  rangeFactorStart(_2, slience) {
    var _a;
    return isNil_default(_2) ? this._rangeFactorStart : (_2 >= 0 && _2 <= 1 && (this._wholeRange = null, 0 !== _2 || !isNil_default(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _2, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  rangeFactorEnd(_2, slience) {
    var _a;
    return isNil_default(_2) ? this._rangeFactorEnd : (_2 >= 0 && _2 <= 1 && (this._wholeRange = null, 0 !== _2 || !isNil_default(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _2, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  generateFishEyeTransform() {
    var _a;
    if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
    const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions, range2 = this.range(), first = range2[0], last2 = range2[range2.length - 1], min4 = Math.min(first, last2), max4 = Math.max(first, last2), focus = clamp_default(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min4, max4), rangeRadius = isNil_default(radius) ? (max4 - min4) * radiusRatio : radius;
    let k0 = Math.exp(distortion);
    k0 = k0 / (k0 - 1) * rangeRadius;
    const k1 = distortion / rangeRadius;
    this._fishEyeTransform = (output) => {
      const delta = Math.abs(output - focus);
      if (delta >= rangeRadius) return output;
      if (delta <= 1e-6) return focus;
      const k3 = k0 * (1 - Math.exp(-delta * k1)) / delta * 0.75 + 0.25;
      return focus + (output - focus) * k3;
    };
  }
  unknown(_2) {
    return arguments.length ? (this._unknown = _2, this) : this._unknown;
  }
};

// node_modules/@visactor/vscale/es/ordinal-scale.js
var implicit = Symbol("implicit");
var OrdinalScale = class _OrdinalScale extends BaseScale {
  specified(_2) {
    var _a;
    return _2 ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _2), this) : Object.assign({}, this._specified);
  }
  _getSpecifiedValue(input) {
    if (this._specified) return this._specified[input];
  }
  constructor() {
    super(), this.type = ScaleEnum.Ordinal, this._index = /* @__PURE__ */ new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit;
  }
  clone() {
    return new _OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
  }
  calculateVisibleDomain(range2) {
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return this._domain;
  }
  scale(d2) {
    const key = `${d2}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i2 = this._index.get(key);
    if (!i2) {
      if (this._unknown !== implicit) return this._unknown;
      i2 = this._domain.push(d2), this._index.set(key, i2);
    }
    const output = this._ordinalRange[(i2 - 1) % this._ordinalRange.length];
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(d2) {
    let i2 = 0;
    for (; i2 < this._ordinalRange.length && this._ordinalRange[i2] !== d2; ) i2++;
    return this._domain[(i2 - 1) % this._domain.length];
  }
  domain(_2) {
    if (!_2) return this._domain.slice();
    this._domain = [], this._index = /* @__PURE__ */ new Map();
    for (const value of _2) {
      const key = `${value}`;
      this._index.has(key) || this._index.set(key, this._domain.push(value));
    }
    return this;
  }
  range(_2) {
    if (!_2) return this._ordinalRange.slice();
    const nextRange = Array.from(_2);
    return this._ordinalRange = nextRange, this;
  }
};

// node_modules/@visactor/vscale/es/utils/tick-sample-int.js
function ticks(start, stop, count, allowExcessive) {
  let reverse2;
  const ticks4 = [];
  let step;
  if (stop = Math.floor(+stop), start = Math.floor(+start), !(count = Math.floor(+count))) return [];
  if (start === stop) return [start];
  if (reverse2 = stop < start) {
    const n2 = start;
    start = stop, stop = n2;
  }
  let expectedCount = clamper(1, stop - start + 1)(count);
  if (step = Math.floor((stop - start + 1) / expectedCount), !allowExcessive) for (; Math.ceil((stop - start + 1) / step) > count && expectedCount > 1; ) expectedCount -= 1, step = Math.floor((stop - start) / expectedCount);
  let ptr = start;
  for (; ptr <= stop; ) ticks4.push(ptr), ptr += step;
  return reverse2 && ticks4.reverse(), ticks4;
}
function stepTicks(start, stop, step) {
  const ticks4 = [];
  let reverse2;
  if (stop = Math.floor(+stop), start = Math.floor(+start), step = clamper(1, stop - start + 1)(Math.floor(+step)), reverse2 = stop < start) {
    const n2 = start;
    start = stop, stop = n2;
  }
  let ptr = start;
  for (; ptr <= stop; ) ticks4.push(ptr), ptr += step;
  return reverse2 && ticks4.reverse(), ticks4;
}

// node_modules/@visactor/vscale/es/band-scale.js
var BandScale = class _BandScale extends OrdinalScale {
  constructor(slience) {
    super(), this.type = ScaleEnum.Band, this._range = [0, 1], this._step = void 0, this._bandwidth = void 0, this._isFixed = false, this._round = false, this._paddingInner = 0, this._paddingOuter = 0, this._align = 0.5, this._unknown = void 0, delete this.unknown, this.rescale(slience);
  }
  rescale(slience, changeProperty) {
    if (slience) return this;
    this._wholeRange = null;
    const wholeRange = this._calculateWholeRange(this._range, changeProperty), n2 = super.domain().length, reverse2 = wholeRange[1] < wholeRange[0];
    let start = wholeRange[Number(reverse2) - 0];
    const stop = wholeRange[1 - Number(reverse2)], space = bandSpace(n2, this._paddingInner, this._paddingOuter);
    return this._step = (stop - start) / Math.max(1, space || 1), this._round && (this._step = Math.floor(this._step)), start += (stop - start - this._step * (n2 - this._paddingInner)) * this._align, this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)), this._round && (start = Math.round(start), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth))), this._bandRangeState = {
      reverse: reverse2,
      start: reverse2 ? start + this._step * (n2 - 1) : start,
      count: n2
    }, this.generateFishEyeTransform(), this;
  }
  scale(d2) {
    if (!this._bandRangeState) return;
    const key = `${d2}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special) return special;
    let i2 = this._index.get(key);
    if (!i2) {
      if (this._unknown !== implicit) return this._unknown;
      i2 = this._domain.push(d2), this._index.set(key, i2);
    }
    const { count, start, reverse: reverse2 } = this._bandRangeState, output = start + (reverse2 ? -1 : 1) * ((i2 - 1) % count) * this._step;
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  _calculateWholeRange(range2, changeProperty) {
    if (this._wholeRange) return this._wholeRange;
    if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
      let wholeSize;
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
        const wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]);
        wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
      } else wholeSize = Math.abs(range2[1] - range2[0]);
      const autoBandwidth = calculateBandwidthFromWholeRangeSize(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
      autoBandwidth < this._minBandwidth ? (this._bandwidth = this._minBandwidth, this._isFixed = true) : autoBandwidth > this._maxBandwidth ? (this._bandwidth = this._maxBandwidth, this._isFixed = true) : (this._bandwidth = autoBandwidth, this._isFixed = false);
    }
    if (this.isBandwidthFixed()) {
      const wholeLength = scaleWholeRangeSize(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) * Math.sign(range2[1] - range2[0]), rangeFactorSize = Math.min((range2[1] - range2[0]) / wholeLength, 1);
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd)) {
        if (wholeLength > 0) {
          const r0 = range2[0] - wholeLength * this._rangeFactorStart, r1 = r0 + wholeLength;
          this._wholeRange = [r0, r1];
        } else {
          const r1 = range2[1] + wholeLength * (1 - this._rangeFactorEnd), r0 = r1 - wholeLength;
          this._wholeRange = [r0, r1];
        }
        const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1, canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
        "rangeFactorStart" === changeProperty && canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : "rangeFactorEnd" === changeProperty && canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : range2[0] <= range2[1] ? canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : (this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize) : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : (this._rangeFactorStart = 1 - rangeFactorSize, this._rangeFactorEnd = 1);
      } else this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize, this._wholeRange = [range2[0], range2[0] + wholeLength];
      return this._wholeRange;
    }
    return super._calculateWholeRange(range2);
  }
  calculateWholeRangeSize() {
    const wholeRange = this._calculateWholeRange(this._range);
    return Math.abs(wholeRange[1] - wholeRange[0]);
  }
  calculateVisibleDomain(range2) {
    const domain = this._domain;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && domain.length) {
      const d0 = this._getInvertIndex(range2[0]), d1 = this._getInvertIndex(range2[1]);
      return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
    }
    return domain;
  }
  domain(_2, slience) {
    return _2 ? (super.domain(_2), this.rescale(slience)) : super.domain();
  }
  range(_2, slience) {
    return _2 ? (this._range = [toNumber(_2[0]), toNumber(_2[1])], this.rescale(slience)) : this._range;
  }
  rangeRound(_2, slience) {
    return this._range = [toNumber(_2[0]), toNumber(_2[1])], this._round = true, this.rescale(slience);
  }
  ticks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    if (-1 === count) return d2;
    return ticks(0, d2.length - 1, count, false).map((i2) => d2[i2]);
  }
  tickData(count = 10) {
    return this.ticks(count).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
    }));
  }
  forceTicks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return ticks(0, d2.length - 1, count, true).filter((i2) => i2 < d2.length).map((i2) => d2[i2]);
  }
  stepTicks(step) {
    const d2 = this.calculateVisibleDomain(this._range);
    return stepTicks(0, d2.length - 1, step).map((i2) => d2[i2]);
  }
  _getInvertIndex(d2) {
    let i2 = 0;
    const halfStep = this.step() / 2, halfBandwidth = this.bandwidth() / 2, len = this._domain.length, range2 = this.range(), reverse2 = range2[0] > range2[range2.length - 1];
    for (i2 = 0; i2 < len; i2++) {
      const r2 = this.scale(this._domain[i2]) + halfBandwidth;
      if (0 === i2 && (!reverse2 && !isGreater(d2, r2 + halfStep) || reverse2 && !isLess(d2, r2 - halfStep))) break;
      if (i2 === len - 1) break;
      if (!isLess(d2, r2 - halfStep) && !isGreater(d2, r2 + halfStep)) break;
    }
    return i2 >= 0 && i2 <= len - 1 ? i2 : len - 1;
  }
  invert(d2) {
    return this._domain[this._getInvertIndex(d2)];
  }
  padding(p2, slience) {
    return void 0 !== p2 ? (this._paddingOuter = Math.max(0, Math.min(Array.isArray(p2) ? Math.min.apply(null, p2) : p2)), this._paddingInner = this._paddingOuter, this.rescale(slience)) : this._paddingInner;
  }
  paddingInner(_2, slience) {
    return void 0 !== _2 ? (this._paddingInner = Math.max(0, Math.min(1, _2)), this.rescale(slience)) : this._paddingInner;
  }
  paddingOuter(_2, slience) {
    return void 0 !== _2 ? (this._paddingOuter = Math.max(0, Math.min(1, _2)), this.rescale(slience)) : this._paddingOuter;
  }
  step() {
    return this._step;
  }
  round(_2, slience) {
    return void 0 !== _2 ? (this._round = _2, this.rescale(slience)) : this._round;
  }
  align(_2, slience) {
    return void 0 !== _2 ? (this._align = Math.max(0, Math.min(1, _2)), this.rescale(slience)) : this._align;
  }
  rangeFactor(_2, slience) {
    return _2 ? (super.rangeFactor(_2), this.rescale(slience)) : super.rangeFactor();
  }
  rangeFactorStart(_2, slience) {
    return isNil_default(_2) ? super.rangeFactorStart() : (super.rangeFactorStart(_2), this.rescale(slience, "rangeFactorStart"));
  }
  rangeFactorEnd(_2, slience) {
    return isNil_default(_2) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_2), this.rescale(slience, "rangeFactorEnd"));
  }
  bandwidth(_2, slience) {
    return _2 ? ("auto" === _2 ? (this._bandwidth = void 0, this._isFixed = false) : (this._bandwidth = _2, this._isFixed = true), this._userBandwidth = _2, this.rescale(slience)) : this._bandwidth;
  }
  maxBandwidth(_2, slience) {
    return _2 ? (this._maxBandwidth = "auto" === _2 ? void 0 : _2, this.rescale(slience)) : this._maxBandwidth;
  }
  minBandwidth(_2, slience) {
    return _2 ? (this._minBandwidth = "auto" === _2 ? void 0 : _2, this.rescale(slience)) : this._minBandwidth;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  isBandwidthFixed() {
    return this._isFixed && !!this._bandwidth;
  }
  _isBandwidthFixedByUser() {
    return this._isFixed && this._userBandwidth && isNumber_default(this._userBandwidth);
  }
  clone() {
    var _a, _b, _c;
    return new _BandScale(true).domain(this._domain, true).range(this._range, true).round(this._round, true).paddingInner(this._paddingInner, true).paddingOuter(this._paddingOuter, true).align(this._align, true).bandwidth(null !== (_a = this._userBandwidth) && void 0 !== _a ? _a : "auto", true).maxBandwidth(null !== (_b = this._maxBandwidth) && void 0 !== _b ? _b : "auto", true).minBandwidth(null !== (_c = this._maxBandwidth) && void 0 !== _c ? _c : "auto");
  }
};

// node_modules/@visactor/vscale/es/utils/interpolate.js
var { interpolateRgb: interpolateRgb2 } = color_exports;
function interpolate(a4, b2) {
  const t2 = typeof b2;
  let c4;
  if (isNil_default(b2) || "boolean" === t2) return () => b2;
  if ("number" === t2) return interpolateNumber(a4, b2);
  if ("string" === t2) {
    if (c4 = color_exports.Color.parseColorString(b2)) {
      const rgb2 = interpolateRgb2(color_exports.Color.parseColorString(a4), c4);
      return (t3) => rgb2(t3).formatRgb();
    }
    return interpolateNumber(Number(a4), Number(b2));
  }
  return b2 instanceof color_exports.RGB ? interpolateRgb2(a4, b2) : b2 instanceof color_exports.Color ? interpolateRgb2(a4.color, b2.color) : b2 instanceof Date ? interpolateDate(a4, b2) : interpolateNumber(Number(a4), Number(b2));
}

// node_modules/@visactor/vscale/es/continuous-scale.js
var ContinuousScale = class extends BaseScale {
  constructor(transformer2 = identity3, untransformer = identity3) {
    super(), this._unknown = void 0, this.transformer = transformer2, this.untransformer = untransformer, this._forceAlign = true, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity3, this._piecewise = bimap, this._interpolate = interpolate;
  }
  calculateVisibleDomain(range2) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  scale(x3) {
    var _a;
    if (x3 = Number(x3), Number.isNaN(x3) || this._domainValidator && !this._domainValidator(x3)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._clamp(x3)));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(y3) {
    var _a;
    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y3)));
  }
  domain(_2, slience) {
    var _a;
    if (!_2) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
    const nextDomain = Array.from(_2, toNumber);
    return this._domain = nextDomain, this.rescale(slience);
  }
  range(_2, slience) {
    if (!_2) return this._range.slice();
    const nextRange = Array.from(_2);
    return this._range = nextRange, this.rescale(slience);
  }
  rangeRound(_2, slience) {
    const nextRange = Array.from(_2);
    return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
    let n2 = Math.min(domainLength, rangeLength);
    if (domainLength && domainLength < rangeLength && this._forceAlign) {
      const deltaStep = rangeLength - domainLength + 1, last2 = domain[domainLength - 1], delta = domainLength >= 2 ? (last2 - domain[domainLength - 2]) / deltaStep : 0;
      for (let i2 = 1; i2 <= deltaStep; i2++) domain[domainLength - 2 + i2] = last2 - delta * (deltaStep - i2);
      n2 = rangeLength;
    }
    return this._autoClamp && (this._clamp = clamper(domain[0], domain[n2 - 1])), this._piecewise = n2 > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
  }
  clamp(_2, f2, slience) {
    return arguments.length ? (f2 ? (this._autoClamp = false, this._clamp = f2) : (this._autoClamp = !!_2, this._clamp = _2 ? void 0 : identity3), this.rescale(slience)) : this._clamp !== identity3;
  }
  interpolate(_2, slience) {
    return arguments.length ? (this._interpolate = _2, this.rescale(slience)) : this._interpolate;
  }
  ticks(count = 10) {
    return [];
  }
  tickData(count = 10) {
    const ticks4 = this.ticks(count);
    return (null != ticks4 ? ticks4 : []).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
    }));
  }
  rangeFactor(_2, slience) {
    return _2 ? (super.rangeFactor(_2), this._output = this._input = null, this) : super.rangeFactor();
  }
  rangeFactorStart(_2, slience) {
    return isNil_default(_2) ? super.rangeFactorStart() : (super.rangeFactorStart(_2), this._output = this._input = null, this);
  }
  rangeFactorEnd(_2, slience) {
    return isNil_default(_2) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_2), this._output = this._input = null, this);
  }
  forceAlignDomainRange(forceAlign) {
    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
  }
};

// node_modules/@visactor/vscale/es/utils/tick-sample.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
var niceNumbers = [1, 2, 5, 10];
var calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
  let step = 1, start = value;
  const middleIndex = Math.floor((tickCount - 1) / 2), absVal = Math.abs(value);
  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map((index) => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
};
var d3Ticks = memoize((start, stop, count, options) => {
  let reverse2, n2, ticks4, step, i2 = -1;
  if (count = +count, (start = +start) === (stop = +stop)) return [start];
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
  if ((reverse2 = stop < start) && (n2 = start, start = stop, stop = n2), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks4 = new Array(n2 = r1 - r0 + 1); ++i2 < n2; ) ticks4[i2] = (r0 + i2) * step;
  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
    step = 1;
    const r0 = Math.ceil(start), r1 = Math.floor(stop);
    if (!(r0 <= r1)) return [];
    for (ticks4 = new Array(n2 = r1 - r0 + 1); ++i2 < n2; ) ticks4[i2] = r0 + i2;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks4 = new Array(n2 = r1 - r0 + 1); ++i2 < n2; ) ticks4[i2] = (r0 + i2) / step;
  }
  return reverse2 && ticks4.reverse(), ticks4;
});
var calculateTicksByStep = (start, stop, step) => {
  let n2, ticks4, i2 = -1;
  if (step > 0) {
    let r0 = Math.floor(start / step), r1 = Math.ceil(stop / step);
    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks4 = new Array(n2 = r1 - r0 + 1); ++i2 < n2; ) ticks4[i2] = (r0 + i2) * step;
  } else {
    step = -step;
    let r0 = Math.floor(start * step), r1 = Math.ceil(stop * step);
    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks4 = new Array(n2 = r1 - r0 + 1); ++i2 < n2; ) ticks4[i2] = (r0 + i2) / step;
  }
  return ticks4;
};
var appendTicksToCount = (ticks4, count, step) => {
  let n2;
  const firstTick = ticks4[0], lastTick = ticks4[ticks4.length - 1], appendCount = count - ticks4.length;
  if (lastTick <= 0) {
    const headTicks2 = [];
    for (n2 = appendCount; n2 >= 1; n2--) headTicks2.push(firstTick - n2 * step);
    return headTicks2.concat(ticks4);
  }
  if (firstTick >= 0) {
    for (n2 = 1; n2 <= appendCount; n2++) ticks4.push(lastTick + n2 * step);
    return ticks4;
  }
  let headTicks = [];
  const tailTicks = [];
  for (n2 = 1; n2 <= appendCount; n2++) n2 % 2 == 0 ? headTicks = [firstTick - Math.floor(n2 / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n2 / 2) * step);
  return headTicks.concat(ticks4).concat(tailTicks);
};
var ticks2 = memoize((start, stop, count, options) => {
  let reverse2, ticks4, n2;
  if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  (reverse2 = stop < start) && (n2 = start, start = stop, stop = n2);
  const stepRes = tickIncrement(start, stop, count);
  let step = stepRes.step;
  if (!isFinite(step)) return [];
  if (step > 0) {
    let cur = 1;
    const { power, gap } = stepRes, delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
    for (; cur <= 5 && (ticks4 = calculateTicksByStep(start, stop, step), ticks4.length > count + 1) && count > 2; ) step += delatStep, cur += 1;
    count > 2 && ticks4.length < count - 1 && (ticks4 = appendTicksToCount(ticks4, count, step));
  } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks4 = calculateTicksByStep(start, stop, step);
  return reverse2 && ticks4.reverse(), ticks4;
});
var getNickStep = (step) => {
  const power = Math.floor(Math.log(step) / Math.LN10), error3 = step / 10 ** power;
  let gap = niceNumbers[0];
  return error3 >= e102 ? gap = niceNumbers[3] : error3 >= e52 ? gap = niceNumbers[2] : error3 >= e22 && (gap = niceNumbers[1]), power >= 0 ? {
    step: gap * 10 ** power,
    gap,
    power
  } : {
    step: -(10 ** -power) / gap,
    gap,
    power
  };
};
function tickIncrement(start, stop, count) {
  const step = (stop - start) / Math.max(0, count);
  return getNickStep(step);
}
function forceTicks(start, stop, count) {
  let step;
  if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
  if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
  const ticks4 = new Array(count);
  for (let i2 = 0; i2 < count; i2++) ticks4[i2] = start + i2 * step;
  return ticks4;
}
function forceTickIncrement(start, stop, count) {
  return (stop - start) / Math.max(1, count - 1);
}
function stepTicks2(start, stop, step) {
  let n2, reverse2, i2 = -1;
  if (step = +step, (reverse2 = (stop = +stop) < (start = +start)) && (n2 = start, start = stop, stop = n2), !isFinite(step) || stop - start <= step) return [start];
  const count = Math.floor((stop - start) / step + 1), ticks4 = new Array(count);
  for (; ++i2 < count; ) ticks4[i2] = start + i2 * step;
  return reverse2 && ticks4.reverse(), ticks4;
}
function niceLinear(d2, count = 10) {
  let prestep, step, i0 = 0, i1 = d2.length - 1, start = d2[i0], stop = d2[i1], maxIter = 10;
  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0; ) {
    if (step = tickIncrement(start, stop, count).step, step === prestep) return d2[i0] = start, d2[i1] = stop, d2;
    if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;
    else {
      if (!(step < 0)) break;
      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function parseNiceOptions(originalDomain, option) {
  const hasForceMin = isNumber_default(option.forceMin), hasForceMax = isNumber_default(option.forceMax);
  let niceType = null;
  const niceMinMax = [];
  let niceDomain = null;
  const domainValidator = hasForceMin && hasForceMax ? (x3) => x3 >= option.forceMin && x3 <= option.forceMax : hasForceMin ? (x3) => x3 >= option.forceMin : hasForceMax ? (x3) => x3 <= option.forceMax : null;
  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber_default(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber_default(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber_default(niceMinMax[0]) && isNumber_default(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber_default(niceMinMax[0]) || isNumber_default(niceMinMax[1]) ? isNumber_default(niceMinMax[0]) ? "max" : "min" : "all", {
    niceType,
    niceDomain,
    niceMinMax,
    domainValidator
  };
}
var fixPrecision2 = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
var d3TicksForLog = memoize((start, stop, count, base, transformer2, untransformer, options) => {
  let u2 = start, v2 = stop;
  const r2 = v2 < u2;
  r2 && ([u2, v2] = [v2, u2]);
  let k3, t2, i2 = transformer2(u2), j2 = transformer2(v2), z2 = [];
  if (!(base % 1) && j2 - i2 < count) {
    if (i2 = Math.floor(i2), j2 = Math.ceil(j2), u2 > 0) {
      for (; i2 <= j2; ++i2) for (k3 = 1; k3 < base; ++k3) if (t2 = i2 < 0 ? k3 / untransformer(-i2) : k3 * untransformer(i2), !(t2 < u2)) {
        if (t2 > v2) break;
        z2.push(t2);
      }
    } else for (; i2 <= j2; ++i2) for (k3 = base - 1; k3 >= 1; --k3) if (t2 = i2 > 0 ? k3 / untransformer(-i2) : k3 * untransformer(i2), !(t2 < u2)) {
      if (t2 > v2) break;
      z2.push(t2);
    }
    2 * z2.length < count && (z2 = ticks2(u2, v2, count));
  } else z2 = ticks2(i2, j2, Math.min(j2 - i2, count)).map(untransformer);
  return z2 = z2.filter((t3) => 0 !== t3), (null == options ? void 0 : options.noDecimals) && (z2 = Array.from(new Set(z2.map((t3) => Math.floor(t3))))), r2 ? z2.reverse() : z2;
});
var ticksBaseTransform = memoize((start, stop, count, base, transformer2, untransformer) => {
  const ticksResult = [], ticksMap = {}, startExp = transformer2(start), stopExp = transformer2(stop);
  let ticksExp = [];
  if (Number.isInteger(base)) ticksExp = ticks2(startExp, stopExp, count);
  else {
    const stepExp = (stopExp - startExp) / (count - 1);
    for (let i2 = 0; i2 < count; i2++) ticksExp.push(startExp + i2 * stepExp);
  }
  return ticksExp.forEach((tl) => {
    const power = untransformer(tl), nicePower = Number.isInteger(base) ? fixPrecision2(start, stop, power) : fixPrecision2(start, stop, niceNumber(power)), scopePower = fixPrecision2(start, stop, restrictNumber(nicePower, [start, stop]));
    !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
  }), ticksResult;
});
var forceTicksBaseTransform = memoize((start, stop, count, transformer2, untransformer) => forceTicks(transformer2(start), transformer2(stop), count).map((te) => niceNumber(untransformer(te))));
var forceStepTicksBaseTransform = memoize((start, stop, step, transformer2, untransformer) => stepTicks2(transformer2(start), transformer2(stop), step).map((te) => niceNumber(untransformer(te))));

// node_modules/@visactor/vscale/es/linear-scale.js
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super(...arguments), this.type = ScaleEnum.Linear;
  }
  clone() {
    return new _LinearScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate);
  }
  tickFormat() {
    return () => {
    };
  }
  d3Ticks(count = 10, options) {
    const d2 = this.calculateVisibleDomain(this._range);
    return d3Ticks(d2[0], d2[d2.length - 1], count, options);
  }
  ticks(count = 10, options) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
    let ticksResult = ticks2(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
    if (!ticksResult.length) return ticksResult;
    if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);
    else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
      const newNiceDomain = curNiceDomain.slice();
      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
        const min4 = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max4 = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
        ticksResult = ticksResult.filter((entry) => entry >= min4 && entry <= max4);
      }
    }
    return ticksResult;
  }
  forceTicks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return forceTicks(d2[0], d2[d2.length - 1], count);
  }
  stepTicks(step) {
    const d2 = this.calculateVisibleDomain(this._range);
    return stepTicks2(d2[0], d2[d2.length - 1], step);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [];
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else this._niceType = "all";
    if (this._niceType) {
      const niceDomain = niceLinear(originalDomain.slice(), count);
      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
    }
    return this;
  }
  niceMin(count = 10) {
    this._niceType = "min";
    const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear(this.domain(), count);
    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax(count = 10) {
    this._niceType = "max";
    const minD = this._domain[0], niceDomain = niceLinear(this._domain.slice(), count);
    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vscale/es/log-scale.js
function reflect(f2) {
  return (x3) => -f2(-x3);
}
function limitPositiveZero(min4 = Number.EPSILON) {
  return (x3) => Math.max(x3, min4);
}
function limitNegativeZero(min4 = Number.EPSILON) {
  return (x3) => Math.min(x3, -min4);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
  }
  clone() {
    return new _LogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).base(this._base);
  }
  rescale(slience) {
    var _a;
    if (slience) return this;
    super.rescale();
    const logs = logp(this._base), pows = powp(this._base);
    return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), this;
  }
  scale(x3) {
    var _a;
    if (x3 = Number(x3), Number.isNaN(x3) || this._domainValidator && !this._domainValidator(x3)) return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._limit(this._clamp(x3))));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  base(_2, slience) {
    return arguments.length ? (this._base = _2, this.rescale(slience)) : this._base;
  }
  tickFormat() {
    return identity3;
  }
  d3Ticks(count = 10, options) {
    const d2 = this.domain(), u2 = this._limit(d2[0]), v2 = this._limit(d2[d2.length - 1]);
    return d3TicksForLog(u2, v2, count, this._base, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(this._limit(d2[0]), this._limit(d2[d2.length - 1]), count, this._base, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d2[0], d2[d2.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d2 = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(this._limit(d2[0]), this._limit(d2[d2.length - 1]), step, this.transformer, this.untransformer);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), {
        floor: (x3) => this._pows(Math.floor(this._logs(this._limit(x3)))),
        ceil: (x3) => Math.abs(x3) >= 1 ? Math.ceil(x3) : this._pows(Math.ceil(this._logs(this._limit(x3))))
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vscale/es/point-scale.js
var PointScale = class extends BandScale {
  constructor(slience) {
    super(false), this.type = ScaleEnum.Point, this._padding = 0, this.paddingInner(1, slience), this.padding = this.paddingOuter, this.paddingInner = void 0, this.paddingOuter = void 0;
  }
};

// node_modules/@visactor/vscale/es/sqrt-scale.js
var SqrtScale = class _SqrtScale extends LinearScale {
  constructor() {
    super(sqrt4, square2), this.type = ScaleEnum.Sqrt;
  }
  clone() {
    return new _SqrtScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate);
  }
};

// node_modules/@visactor/vscale/es/symlog-scale.js
var SymlogScale = class _SymlogScale extends LinearScale {
  constructor() {
    super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
  }
  clone() {
    return new _SymlogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).constant(this._const);
  }
  constant(_2, slience) {
    return arguments.length ? (this._const = _2, this.transformer = symlog(_2), this.untransformer = symexp(_2), this.rescale(slience)) : this._const;
  }
  d3Ticks(count = 10, options) {
    const d2 = this.domain(), u2 = d2[0], v2 = d2[d2.length - 1];
    return d3TicksForLog(u2, v2, count, this._const, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(d2[0], d2[d2.length - 1], count, this._const, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d2 = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d2[0], d2[d2.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d2 = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d2[0], d2[d2.length - 1], step, this.transformer, this.untransformer);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), {
        floor: (x3) => Math.floor(x3),
        ceil: (x3) => Math.ceil(x3)
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// node_modules/@visactor/vscale/es/threshold-scale.js
var ThresholdScale = class _ThresholdScale {
  constructor() {
    this.type = ScaleEnum.Threshold, this._range = [0, 1], this._domain = [0.5], this.n = 1;
  }
  unknown(_2) {
    return arguments.length ? (this._unknown = _2, this) : this._unknown;
  }
  scale(x3) {
    return !isNil_default(x3) && isValidNumber_default(+x3) ? this._range[bisect(this._domain, x3, 0, this.n)] : this._unknown;
  }
  invertExtent(y3) {
    const i2 = this._range.indexOf(y3);
    return [this._domain[i2 - 1], this._domain[i2]];
  }
  domain(_2) {
    return _2 ? (this._domain = Array.from(_2), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._domain.slice();
  }
  range(_2) {
    return _2 ? (this._range = Array.from(_2), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._range.slice();
  }
  clone() {
    return new _ThresholdScale().domain(this._domain).range(this._range).unknown(this._unknown);
  }
};

// node_modules/@visactor/vscale/es/utils/time.js
var timeIntervals = [["second", 1, SECOND], ["second", 5, 5 * SECOND], ["second", 10, 10 * SECOND], ["second", 30, 30 * SECOND], ["minute", 1, MINUTE], ["minute", 5, 5 * MINUTE], ["minute", 10, 10 * MINUTE], ["minute", 30, 30 * MINUTE], ["hour", 1, HOUR], ["hour", 3, 3 * HOUR], ["hour", 6, 6 * HOUR], ["hour", 12, 12 * HOUR], ["day", 1, DAY], ["day", 2, 2 * DAY], ["day", 7, 7 * DAY], ["month", 1, MONTH], ["month", 3, 3 * MONTH], ["month", 6, 6 * MONTH], ["year", 1, 365 * DAY]];

// node_modules/@visactor/vscale/es/identity-scale.js
var implicit2 = Symbol("implicit");

// node_modules/@visactor/vutils-extension/es/transform/tick-data/config.js
var DEFAULT_CONTINUOUS_TICK_COUNT = 5;

// node_modules/@visactor/vutils-extension/es/utils/text.js
var initTextMeasure = (textSpec, option, useNaiveCanvas, defaultFontParams) => new TextMeasure(Object.assign({
  defaultFontParams: Object.assign({
    fontFamily: "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol",
    fontSize: 14
  }, defaultFontParams),
  getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
  specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
}, null != option ? option : {}), textSpec);

// node_modules/@visactor/vutils-extension/es/utils/polar.js
function normalizeAngle(angle2) {
  for (; angle2 < 0; ) angle2 += 2 * Math.PI;
  for (; angle2 >= 2 * Math.PI; ) angle2 -= 2 * Math.PI;
  return angle2;
}
function angleLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "left" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "right" : "center", baseline = angle2 >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "bottom" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "top" : "middle", {
    align,
    baseline
  };
}

// node_modules/@visactor/vutils-extension/es/transform/tick-data/util.js
var convertDomainToTickData = (domain) => domain.map((t2, index) => ({
  index,
  value: t2
}));
var labelOverlap = (prevLabel, nextLabel, gap = 0) => {
  const prevBounds = new AABBBounds(prevLabel).expand(gap / 2), nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
  return prevBounds.intersects(nextBounds);
};
function intersect2(a4, b2, sep) {
  return sep > Math.max(b2.x1 - a4.x2, a4.x1 - b2.x2, b2.y1 - a4.y2, a4.y1 - b2.y2);
}
function hasOverlap(items, pad) {
  for (let b2, i2 = 1, n2 = items.length, a4 = items[0]; i2 < n2; a4 = b2, ++i2) if (b2 = items[i2], intersect2(a4.AABBBounds, b2.AABBBounds, pad)) return true;
  return false;
}
var getCartesianLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, axisOrientType, labelFlush, labelFormatter, startAngle = 0 } = op;
  let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
  "vertical" === labelStyle.direction && (labelAngle += degreeToRadian(90));
  const isHorizontal4 = ["bottom", "top"].includes(axisOrientType), isVertical3 = ["left", "right"].includes(axisOrientType);
  let scaleX = 1, scaleY = 0;
  isHorizontal4 || (isVertical3 ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), scaleY = -Math.sin(startAngle)));
  const textMeasure = initTextMeasure(labelStyle), labelBoundsList = domain.map((v2, i2) => {
    var _a2, _b;
    const str = labelFormatter ? labelFormatter(v2) : `${v2}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), pos = scale4.scale(v2), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
    let align, baseline, textX = baseTextX, textY = baseTextY;
    align = labelFlush && isHorizontal4 && 0 === i2 ? "left" : labelFlush && isHorizontal4 && i2 === domain.length - 1 ? "right" : null !== (_a2 = labelStyle.textAlign) && void 0 !== _a2 ? _a2 : "center", "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), baseline = labelFlush && isVertical3 && 0 === i2 ? "top" : labelFlush && isVertical3 && i2 === domain.length - 1 ? "bottom" : null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
    const bounds = new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight);
    return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
  });
  return labelBoundsList;
};
var getPolarAngleLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, getRadius, labelOffset, labelFormatter } = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure = initTextMeasure(labelStyle);
  return domain.map((v2) => {
    const str = labelFormatter ? labelFormatter(v2) : `${v2}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), angle2 = scale4.scale(v2);
    let textX = 0, textY = 0;
    const orient = angleLabelOrientAttribute(angle2), { x: x3, y: y3 } = polarToCartesian({
      x: 0,
      y: 0
    }, radius + labelOffset, angle2);
    textX = x3 + ("right" === orient.align ? -textWidth : "center" === orient.align ? -textWidth / 2 : 0), textY = y3 + ("bottom" === orient.baseline ? -textHeight : "middle" === orient.baseline ? -textHeight / 2 : 0);
    return new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
  });
};
var isAxisHorizontal = (axisOrientType) => ["bottom", "top", "z"].includes(axisOrientType);

// node_modules/@visactor/vutils-extension/es/transform/tick-data/continuous.js
var continuousTicks = (scale4, op) => {
  if (!isContinuous(scale4.type)) return convertDomainToTickData(scale4.domain());
  const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]);
  if (rangeSize < 2) return convertDomainToTickData([scale4.domain()[0]]);
  const { tickCount, forceTickCount, tickStep: tickStep2, noDecimals = false, labelStyle } = op;
  let scaleTicks;
  if (isValid_default(tickStep2)) scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount)) scaleTicks = scale4.forceTicks(forceTickCount);
  else if ("d3" === op.tickMode) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.d3Ticks(null != count ? count : DEFAULT_CONTINUOUS_TICK_COUNT, {
      noDecimals
    });
  } else {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(null != count ? count : DEFAULT_CONTINUOUS_TICK_COUNT, {
      noDecimals
    });
  }
  if (op.sampling && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
    const { labelGap = 4, labelFlush } = op;
    let items = getCartesianLabelBounds(scale4, scaleTicks, op).map((bounds, i2) => ({
      AABBBounds: bounds,
      value: scaleTicks[i2]
    }));
    for (; items.length >= 3 && hasOverlap(items, labelGap); ) items = methods.parity(items);
    const ticks4 = items.map((item) => item.value);
    ticks4.length < 3 && labelFlush && (ticks4.length > 1 && ticks4.pop(), last(ticks4) !== last(scaleTicks) && ticks4.push(last(scaleTicks))), scaleTicks = ticks4;
  }
  return convertDomainToTickData(scaleTicks);
};
var methods = {
  parity: function(items) {
    return items.filter((item, i2) => i2 % 2 == 0);
  },
  greedy: function(items, sep) {
    let a4;
    return items.filter((b2, i2) => (!i2 || !intersect2(a4.AABBBounds, b2.AABBBounds, sep)) && (a4 = b2, true));
  }
};

// node_modules/@visactor/vutils-extension/es/algorithm/binary-search.js
var binaryFuzzySearch = (arr, compareFn) => binaryFuzzySearchInNumberRange(0, arr.length, (value) => compareFn(arr[value]));
var binaryFuzzySearchInNumberRange = (x14, x23, compareFn) => {
  let left2 = x14, right2 = x23;
  for (; left2 < right2; ) {
    const mid = Math.floor((left2 + right2) / 2);
    compareFn(mid) >= 0 ? right2 = mid : left2 = mid + 1;
  }
  return left2;
};

// node_modules/@visactor/vutils-extension/es/transform/tick-data/discrete/linear.js
var getOneDimensionalLabelBounds = (scale4, domain, op, isHorizontal4) => getCartesianLabelBounds(scale4, domain, op).map((bounds) => isHorizontal4 ? [bounds.x1, bounds.x2, bounds.width()] : [bounds.y1, bounds.y2, bounds.height()]);
var boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
var boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;
var linearDiscreteTicks = (scale4, op) => {
  var _a;
  const domain = scale4.domain();
  if (!domain.length) return [];
  const { tickCount, forceTickCount, tickStep: tickStep2, labelGap = 4, axisOrientType, labelStyle } = op, isHorizontal4 = isAxisHorizontal(axisOrientType), range2 = scale4.range(), rangeSize = scale4.calculateWholeRangeSize();
  if (rangeSize < 2) return op.labelLastVisible ? convertDomainToTickData([domain[domain.length - 1]]) : convertDomainToTickData([domain[0]]);
  let scaleTicks;
  if (isValid_default(tickStep2)) scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount)) scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = minInArray(range2), rangeEnd = maxInArray(range2);
    if (domain.length <= rangeSize / fontSize) {
      const incrementUnit = (rangeEnd - rangeStart) / domain.length, labelBoundsList = getOneDimensionalLabelBounds(scale4, domain, op, isHorizontal4), minBoundsLength = Math.min(...labelBoundsList.map((bounds) => bounds[2])), stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), false);
      scaleTicks = scale4.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), scaleTicks.push(domain[domain.length - 1]));
    } else {
      const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]], tempList = getOneDimensionalLabelBounds(scale4, tempDomain, op, isHorizontal4);
      let maxBounds = null;
      tempList.forEach((current) => {
        maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
      });
      const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
      scaleTicks = scale4.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale4.scale(scaleTicks[scaleTicks.length - 1]) - scale4.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), scaleTicks.push(domain[domain.length - 1]));
    }
  } else scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
  let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
  const validateStep = (step2) => {
    let success = true, ptr = 0;
    do {
      ptr + step2 < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step2], labelGap) && (success = false), ptr += step2;
    } while (success && ptr < domain.length);
    return success;
  }, minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, (step2) => validateStep(step2) ? 1 : -1);
  let step = minValidStep;
  do {
    if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++;
    else {
      if (!labelLastVisible) {
        resultStep = step;
        break;
      }
      {
        const lastIndex = domain.length - 1;
        let ptr, delCount = 0;
        ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
        do {
          if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
          delCount++;
        } while (ptr > 0);
        if (ptr === lastIndex) {
          resultStep = step, resultDelCount = delCount;
          break;
        }
        {
          const tickCount = Math.floor(domain.length / step) - delCount + 1;
          if (tickCount < resultTickCount) break;
          {
            resultTickCount = tickCount;
            const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
            if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), distance1 <= distance2) break;
          }
        }
      }
      step++;
    }
  } while (step <= domain.length);
  return {
    step: resultStep,
    delCount: resultDelCount
  };
};

// node_modules/@visactor/vutils-extension/es/transform/tick-data/discrete/polar-angle.js
var polarAngleAxisDiscreteTicks = (scale4, op) => {
  const { tickCount, forceTickCount, tickStep: tickStep2, getRadius, labelOffset, labelGap = 0, labelStyle } = op, radius = null == getRadius ? void 0 : getRadius();
  if (!radius) return convertDomainToTickData(scale4.domain());
  let scaleTicks;
  if (isValid_default(tickStep2)) scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount)) scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]), count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const domain = scale4.domain(), range2 = scale4.range(), labelBoundsList = getPolarAngleLabelBounds(scale4, domain, op), rangeStart = minInArray(range2), rangeEnd = maxInArray(range2), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, { step, delCount } = getStep2(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min4, curBounds) => Math.min(min4, curBounds.width(), curBounds.height()), Number.MAX_VALUE) / incrementUnit));
    scaleTicks = scale4.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
  } else scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep2 = (domain, labelBoundsList, labelGap, defaultStep) => {
  let step = defaultStep;
  do {
    let success = true;
    step++;
    let ptr = 0;
    do {
      ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = false), ptr += step;
    } while (success && ptr < domain.length);
    if (success) break;
  } while (step <= domain.length);
  let delCount = 0;
  if (domain.length > 2) {
    let ptr = domain.length - domain.length % step;
    for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]); ) delCount++, ptr -= step;
  }
  return {
    step,
    delCount
  };
};

// node_modules/@visactor/vutils-extension/es/transform/tick-data/index.js
var ticks3 = (scale4, op) => {
  if (isContinuous(scale4.type)) return continuousTicks(scale4, op);
  if (isDiscrete(scale4.type)) {
    if ("cartesian" === op.coordinateType) return linearDiscreteTicks(scale4, op);
    if ("polar" === op.coordinateType && "angle" === op.axisOrientType) return polarAngleAxisDiscreteTicks(scale4, op);
  }
  return convertDomainToTickData(scale4.domain());
};

// node_modules/@visactor/vutils-extension/es/utils/object.js
var includeSpec = (spec, searchSpec) => spec === searchSpec || !isFunction_default(spec) && !isFunction_default(searchSpec) && (isArray_default(spec) && isArray_default(searchSpec) ? searchSpec.every((searchItem) => spec.some((item) => includeSpec(item, searchItem))) : !(!isObject_default(spec) || !isObject_default(searchSpec)) && Object.keys(searchSpec).every((key) => includeSpec(spec[key], searchSpec[key])));
var setProperty = (target, path, value) => {
  if (isNil_default(path)) return target;
  const key = path[0];
  return isNil_default(key) ? target : 1 === path.length ? (target[key] = value, target) : (isNil_default(target[key]) && ("number" == typeof path[1] ? target[key] = [] : target[key] = {}), setProperty(target[key], path.slice(1), value));
};
var getProperty = (target, path, defaultValue) => {
  if (!isNil_default(path)) return get_default(target, path, defaultValue);
};

// node_modules/@visactor/vchart/esm/util/math.js
function polarToCartesian2(point6) {
  return point6.radius ? {
    x: Math.cos(point6.angle) * point6.radius,
    y: Math.sin(point6.angle) * point6.radius
  } : {
    x: 0,
    y: 0
  };
}
function computeQuadrant(angle2) {
  return (angle2 = normalizeAngle(angle2)) > 0 && angle2 <= Math.PI / 2 ? 2 : angle2 > Math.PI / 2 && angle2 <= Math.PI ? 3 : angle2 > Math.PI && angle2 <= 3 * Math.PI / 2 ? 4 : 1;
}
function normalizeStartEndAngle(start, end) {
  let startAngle = 0, endAngle = 2 * Math.PI;
  const isStartValid = isValid_default(start), isEndValid = isValid_default(end);
  for (isStartValid || isEndValid ? isEndValid ? isStartValid ? (startAngle = start, endAngle = end) : (startAngle = end - 2 * Math.PI, endAngle = end) : (startAngle = start, endAngle = start + 2 * Math.PI) : (startAngle = 0, endAngle = 2 * Math.PI); endAngle <= startAngle; ) endAngle += 2 * Math.PI;
  for (; startAngle > 2 * Math.PI; ) startAngle -= 2 * Math.PI, endAngle -= 2 * Math.PI;
  for (; endAngle < 0; ) startAngle += 2 * Math.PI, endAngle += 2 * Math.PI;
  return {
    startAngle,
    endAngle
  };
}
function outOfBounds(bounds, x3, y3) {
  return bounds.x1 > x3 || bounds.x2 < x3 || bounds.y1 > y3 || bounds.y2 < y3;
}
function min3(data, field5) {
  const dataArray = [];
  return data.forEach((d2) => {
    const value = +d2[field5];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : minInArray(dataArray);
}
function max3(data, field5) {
  const dataArray = [];
  return data.forEach((d2) => {
    const value = +d2[field5];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : maxInArray(dataArray);
}
function sum3(data, field5) {
  return data.reduce((pre, _cur) => {
    const cur = field5 ? +_cur[field5] : +_cur;
    return isValidNumber_default(cur) && (pre += cur), pre;
  }, 0);
}
function average(data, field5) {
  let sum5 = 0, count = 0;
  data.forEach((x3) => {
    const v2 = field5 ? +x3[field5] : +x3;
    isValidNumber_default(v2) && (sum5 += v2, count++);
  });
  return sum5 / count;
}
function variance3(data, field5) {
  const averageNumber = average(data, field5);
  if (data.length <= 1) return 0;
  const total = data.reduce((sum5, cur) => sum5 + (field5 ? +cur[field5] : +cur - averageNumber) ** 2, 0);
  return total / (data.length - 1);
}
function standardDeviation2(data, field5) {
  return Math.sqrt(variance3(data, field5));
}
function median3(data, field5) {
  return median(data.map((datum) => datum[field5]));
}
function regression(data, fieldX, fieldY) {
  const { predict: predict2 } = regressionLinear(data, (datum) => datum[fieldX], (datum) => datum[fieldY]), x14 = min3(data, fieldX), x23 = max3(data, fieldX), predict1 = predict2(x14), predict22 = predict2(x23);
  return [{
    [fieldX]: x14,
    [fieldY]: predict1
  }, {
    [fieldX]: x23,
    [fieldY]: predict22
  }];
}
function radiusLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "right" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "left" : "center", baseline = angle2 >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "bottom" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "top" : "middle", {
    align,
    baseline
  };
}
function vectorAngle(v1, v2) {
  const v1Length = distance(v1), v2Length = distance(v2), rho = Math.asin((v1.x * v2.y - v2.x * v1.y) / v1Length / v2Length), theta = Math.acos((v1.x * v2.x + v1.y * v2.y) / v1Length / v2Length);
  return rho < 0 ? -theta : theta;
}
function distance(p1, p2 = {
  x: 0,
  y: 0
}) {
  return PointService.distancePP(p1, p2);
}

// node_modules/@visactor/vchart/esm/util/model.js
function eachSeries(regions, callback, filter2) {
  let flag = false;
  if (callback && isFunction_default(callback)) {
    for (const r2 of regions) for (const s3 of r2.getSeries(filter2)) if (flag = !!callback.call(null, s3), flag) return flag;
  }
  return flag;
}
function getSeries(regions, filter2) {
  const result2 = [];
  for (const r2 of regions) for (const s3 of r2.getSeries(filter2)) result2.push(s3);
  return result2;
}
var getFirstSeries = (regions, coordinateType) => {
  for (let i2 = 0; i2 < regions.length; i2++) {
    const series2 = regions[i2].getSeries();
    for (let j2 = 0; j2 < series2.length; j2++) {
      const s3 = series2[j2];
      if (coordinateType && s3 && s3.coordinate === coordinateType) return s3;
      if (!coordinateType && s3) return s3;
    }
  }
  return null;
};

// node_modules/@visactor/vchart/esm/util/object.js
function field2(f2) {
  return function(datum) {
    let value;
    return value = isArray_default(f2) ? f2.reduce((cur, g3) => null == cur ? void 0 : cur[g3], datum) : null == datum ? void 0 : datum[f2], value;
  };
}

// node_modules/@visactor/vchart/esm/series/interface/type.js
var SeriesTypeEnum;
!function(SeriesTypeEnum2) {
  SeriesTypeEnum2.area = "area", SeriesTypeEnum2.line = "line", SeriesTypeEnum2.bar = "bar", SeriesTypeEnum2.bar3d = "bar3d", SeriesTypeEnum2.rangeColumn = "rangeColumn", SeriesTypeEnum2.rangeColumn3d = "rangeColumn3d", SeriesTypeEnum2.rangeArea = "rangeArea", SeriesTypeEnum2.dot = "dot", SeriesTypeEnum2.geo = "geo", SeriesTypeEnum2.link = "link", SeriesTypeEnum2.map = "map", SeriesTypeEnum2.pie = "pie", SeriesTypeEnum2.pie3d = "pie3d", SeriesTypeEnum2.radar = "radar", SeriesTypeEnum2.rose = "rose", SeriesTypeEnum2.scatter = "scatter", SeriesTypeEnum2.circularProgress = "circularProgress", SeriesTypeEnum2.wordCloud = "wordCloud", SeriesTypeEnum2.wordCloud3d = "wordCloud3d", SeriesTypeEnum2.funnel = "funnel", SeriesTypeEnum2.funnel3d = "funnel3d", SeriesTypeEnum2.linearProgress = "linearProgress", SeriesTypeEnum2.boxPlot = "boxPlot", SeriesTypeEnum2.sankey = "sankey", SeriesTypeEnum2.gaugePointer = "gaugePointer", SeriesTypeEnum2.gauge = "gauge", SeriesTypeEnum2.treemap = "treemap", SeriesTypeEnum2.sunburst = "sunburst", SeriesTypeEnum2.circlePacking = "circlePacking", SeriesTypeEnum2.waterfall = "waterfall", SeriesTypeEnum2.heatmap = "heatmap", SeriesTypeEnum2.correlation = "correlation";
}(SeriesTypeEnum || (SeriesTypeEnum = {}));
var SeriesMarkNameEnum;
!function(SeriesMarkNameEnum2) {
  SeriesMarkNameEnum2.label = "label", SeriesMarkNameEnum2.point = "point", SeriesMarkNameEnum2.line = "line", SeriesMarkNameEnum2.area = "area", SeriesMarkNameEnum2.bar = "bar", SeriesMarkNameEnum2.bar3d = "bar3d", SeriesMarkNameEnum2.boxPlot = "boxPlot", SeriesMarkNameEnum2.outlier = "outlier", SeriesMarkNameEnum2.circlePacking = "circlePacking", SeriesMarkNameEnum2.group = "group", SeriesMarkNameEnum2.gridBackground = "gridBackground", SeriesMarkNameEnum2.grid = "grid", SeriesMarkNameEnum2.dot = "dot", SeriesMarkNameEnum2.title = "title", SeriesMarkNameEnum2.subTitle = "subTitle", SeriesMarkNameEnum2.symbol = "symbol", SeriesMarkNameEnum2.funnel = "funnel", SeriesMarkNameEnum2.funnel3d = "funnel3d", SeriesMarkNameEnum2.transform = "transform", SeriesMarkNameEnum2.transform3d = "transform3d", SeriesMarkNameEnum2.transformLabel = "transformLabel", SeriesMarkNameEnum2.outerLabel = "outerLabel", SeriesMarkNameEnum2.outerLabelLine = "outerLabelLine", SeriesMarkNameEnum2.pin = "pin", SeriesMarkNameEnum2.pinBackground = "pinBackground", SeriesMarkNameEnum2.pointer = "pointer", SeriesMarkNameEnum2.segment = "segment", SeriesMarkNameEnum2.track = "track", SeriesMarkNameEnum2.cell = "cell", SeriesMarkNameEnum2.cellBackground = "cellBackground", SeriesMarkNameEnum2.link = "link", SeriesMarkNameEnum2.arrow = "arrow", SeriesMarkNameEnum2.pie = "pie", SeriesMarkNameEnum2.pie3d = "pie3d", SeriesMarkNameEnum2.labelLine = "labelLine", SeriesMarkNameEnum2.progress = "progress", SeriesMarkNameEnum2.minLabel = "minLabel", SeriesMarkNameEnum2.maxLabel = "maxLabel", SeriesMarkNameEnum2.rose = "rose", SeriesMarkNameEnum2.node = "node", SeriesMarkNameEnum2.sunburst = "sunburst", SeriesMarkNameEnum2.nonLeaf = "nonLeaf", SeriesMarkNameEnum2.leaf = "leaf", SeriesMarkNameEnum2.nonLeafLabel = "nonLeafLabel", SeriesMarkNameEnum2.leaderLine = "leaderLine", SeriesMarkNameEnum2.stackLabel = "stackLabel", SeriesMarkNameEnum2.word = "word", SeriesMarkNameEnum2.fillingWord = "fillingWord", SeriesMarkNameEnum2.nodePoint = "nodePoint", SeriesMarkNameEnum2.ripplePoint = "ripplePoint", SeriesMarkNameEnum2.centerPoint = "centerPoint", SeriesMarkNameEnum2.centerLabel = "centerLabel", SeriesMarkNameEnum2.barBackground = "barBackground", SeriesMarkNameEnum2.lineLabel = "lineLabel", SeriesMarkNameEnum2.areaLabel = "areaLabel";
}(SeriesMarkNameEnum || (SeriesMarkNameEnum = {}));

// node_modules/@visactor/vchart/esm/constant/base.js
var PREFIX = "__VCHART";
var DEFAULT_CHART_WIDTH = 500;
var DEFAULT_CHART_HEIGHT = 500;

// node_modules/@visactor/vchart/esm/constant/label.js
var DEFAULT_LABEL_LIMIT = `${PREFIX}_LABEL_LIMIT`;
var DEFAULT_LABEL_ALIGN = `${PREFIX}_LABEL_ALIGN`;
var DEFAULT_LABEL_TEXT = `${PREFIX}_LABEL_TEXT`;
var DEFAULT_LABEL_VISIBLE = `${PREFIX}_LABEL_VISIBLE`;
var DEFAULT_LABEL_X = `${PREFIX}_LABEL_X`;
var DEFAULT_LABEL_Y = `${PREFIX}_LABEL_Y`;

// node_modules/@visactor/vchart/esm/constant/polar.js
var ARC_TRANSFORM_VALUE = `${PREFIX}_ARC_TRANSFORM_VALUE`;
var ARC_RATIO = `${PREFIX}_ARC_RATIO`;
var ARC_START_ANGLE = `${PREFIX}_ARC_START_ANGLE`;
var ARC_END_ANGLE = `${PREFIX}_ARC_END_ANGLE`;
var ARC_K = `${PREFIX}_ARC_K`;
var ARC_MIDDLE_ANGLE = `${PREFIX}_ARC_MIDDLE_ANGLE`;
var ARC_QUADRANT = `${PREFIX}_ARC_QUADRANT`;
var ARC_RADIAN = `${PREFIX}_ARC_RADIAN`;
var POLAR_START_RADIAN = -Math.PI / 2;
var POLAR_END_RADIAN = 3 * Math.PI / 2;
var POLAR_START_ANGLE = -90;
var POLAR_END_ANGLE = 270;
var POLAR_DEFAULT_RADIUS = 0.6;

// node_modules/@visactor/vchart/esm/constant/layout.js
var USER_LAYOUT_RECT_LEVEL = 9;
var DEFAULT_LAYOUT_RECT_LEVEL = 0;

// node_modules/@visactor/vgrammar-core/es/graph/enums.js
var BuiltInEncodeNames;
!function(BuiltInEncodeNames2) {
  BuiltInEncodeNames2.enter = "enter", BuiltInEncodeNames2.update = "update", BuiltInEncodeNames2.exit = "exit", BuiltInEncodeNames2.group = "group";
}(BuiltInEncodeNames || (BuiltInEncodeNames = {}));
var DiffState;
!function(DiffState2) {
  DiffState2.enter = "enter", DiffState2.update = "update", DiffState2.exit = "exit", DiffState2.unChange = "unChange";
}(DiffState || (DiffState = {}));
var GrammarMarkType;
!function(GrammarMarkType2) {
  GrammarMarkType2.arc = "arc", GrammarMarkType2.arc3d = "arc3d", GrammarMarkType2.area = "area", GrammarMarkType2.image = "image", GrammarMarkType2.line = "line", GrammarMarkType2.path = "path", GrammarMarkType2.rect = "rect", GrammarMarkType2.rect3d = "rect3d", GrammarMarkType2.rule = "rule", GrammarMarkType2.shape = "shape", GrammarMarkType2.symbol = "symbol", GrammarMarkType2.text = "text", GrammarMarkType2.richtext = "richtext", GrammarMarkType2.polygon = "polygon", GrammarMarkType2.pyramid3d = "pyramid3d", GrammarMarkType2.circle = "circle", GrammarMarkType2.cell = "cell", GrammarMarkType2.interval = "interval", GrammarMarkType2.group = "group", GrammarMarkType2.glyph = "glyph", GrammarMarkType2.component = "component", GrammarMarkType2.largeRects = "largeRects", GrammarMarkType2.largeSymbols = "largeSymbols";
}(GrammarMarkType || (GrammarMarkType = {}));
var ComponentEnum;
!function(ComponentEnum2) {
  ComponentEnum2.axis = "axis", ComponentEnum2.grid = "grid", ComponentEnum2.legend = "legend", ComponentEnum2.slider = "slider", ComponentEnum2.label = "label", ComponentEnum2.datazoom = "datazoom", ComponentEnum2.player = "player", ComponentEnum2.title = "title", ComponentEnum2.scrollbar = "scrollbar";
}(ComponentEnum || (ComponentEnum = {}));
var DataFilterRank;
!function(DataFilterRank2) {
  DataFilterRank2[DataFilterRank2.player = 1] = "player", DataFilterRank2[DataFilterRank2.rollUp = 2] = "rollUp", DataFilterRank2[DataFilterRank2.drillDown = 3] = "drillDown", DataFilterRank2[DataFilterRank2.slider = 4] = "slider", DataFilterRank2[DataFilterRank2.datazoom = 5] = "datazoom", DataFilterRank2[DataFilterRank2.legend = 6] = "legend", DataFilterRank2[DataFilterRank2.scrollbar = 7] = "scrollbar", DataFilterRank2[DataFilterRank2.brush = 8] = "brush", DataFilterRank2[DataFilterRank2.normal = 9] = "normal";
}(DataFilterRank || (DataFilterRank = {}));
var AxisEnum;
!function(AxisEnum2) {
  AxisEnum2.lineAxis = "lineAxis", AxisEnum2.circleAxis = "circleAxis";
}(AxisEnum || (AxisEnum = {}));
var GridEnum;
!function(GridEnum2) {
  GridEnum2.lineAxisGrid = "lineAxisGrid", GridEnum2.circleAxisGrid = "circleAxisGrid";
}(GridEnum || (GridEnum = {}));
var LegendEnum;
!function(LegendEnum2) {
  LegendEnum2.discreteLegend = "discreteLegend", LegendEnum2.colorLegend = "colorLegend", LegendEnum2.sizeLegend = "sizeLegend";
}(LegendEnum || (LegendEnum = {}));
var CrosshairEnum;
!function(CrosshairEnum2) {
  CrosshairEnum2.lineCrosshair = "lineCrosshair", CrosshairEnum2.rectCrosshair = "rectCrosshair", CrosshairEnum2.sectorCrosshair = "sectorCrosshair", CrosshairEnum2.circleCrosshair = "circleCrosshair", CrosshairEnum2.polygonCrosshair = "polygonCrosshair", CrosshairEnum2.ringCrosshair = "ringCrosshair";
}(CrosshairEnum || (CrosshairEnum = {}));
var LabelEnum;
!function(LabelEnum2) {
  LabelEnum2.symbolLabel = "symbolLabel", LabelEnum2.rectLabel = "rectLabel", LabelEnum2.lineLabel = "lineLabel", LabelEnum2.dataLabel = "dataLabel";
}(LabelEnum || (LabelEnum = {}));
var PlayerEnum;
!function(PlayerEnum2) {
  PlayerEnum2.continuousPlayer = "continuousPlayer", PlayerEnum2.discretePlayer = "discretePlayer";
}(PlayerEnum || (PlayerEnum = {}));
var LayoutState;
!function(LayoutState2) {
  LayoutState2.before = "before", LayoutState2.layouting = "layouting", LayoutState2.reevaluate = "reevaluate", LayoutState2.after = "after";
}(LayoutState || (LayoutState = {}));
var HOOK_EVENT;
!function(HOOK_EVENT2) {
  HOOK_EVENT2.BEFORE_EVALUATE_DATA = "beforeEvaluateData", HOOK_EVENT2.AFTER_EVALUATE_DATA = "afterEvaluateData", HOOK_EVENT2.BEFORE_EVALUATE_SCALE = "beforeEvaluateScale", HOOK_EVENT2.AFTER_EVALUATE_SCALE = "afterEvaluateScale", HOOK_EVENT2.BEFORE_PARSE_VIEW = "beforeParseView", HOOK_EVENT2.AFTER_PARSE_VIEW = "afterParseView", HOOK_EVENT2.BEFORE_TRANSFORM = "beforeTransform", HOOK_EVENT2.AFTER_TRANSFORM = "afterTransform", HOOK_EVENT2.BEFORE_CREATE_VRENDER_STAGE = "beforeCreateVRenderStage", HOOK_EVENT2.AFTER_CREATE_VRENDER_STAGE = "afterCreateVRenderStage", HOOK_EVENT2.BEFORE_CREATE_VRENDER_LAYER = "beforeCreateVRenderLayer", HOOK_EVENT2.AFTER_CREATE_VRENDER_LAYER = "afterCreateVRenderLayer", HOOK_EVENT2.BEFORE_STAGE_RESIZE = "beforeStageResize", HOOK_EVENT2.AFTER_STAGE_RESIZE = "afterStageResize", HOOK_EVENT2.BEFORE_VRENDER_DRAW = "beforeVRenderDraw", HOOK_EVENT2.AFTER_VRENDER_DRAW = "afterVRenderDraw", HOOK_EVENT2.BEFORE_MARK_JOIN = "beforeMarkJoin", HOOK_EVENT2.AFTER_MARK_JOIN = "afterMarkJoin", HOOK_EVENT2.BEFORE_MARK_UPDATE = "beforeMarkUpdate", HOOK_EVENT2.AFTER_MARK_UPDATE = "afterMarkUpdate", HOOK_EVENT2.BEFORE_MARK_STATE = "beforeMarkState", HOOK_EVENT2.AFTER_MARK_STATE = "afterMarkState", HOOK_EVENT2.BEFORE_MARK_ENCODE = "beforeMarkEncode", HOOK_EVENT2.AFTER_MARK_ENCODE = "afterMarkEncode", HOOK_EVENT2.BEFORE_DO_LAYOUT = "beforeDoLayout", HOOK_EVENT2.AFTER_DO_LAYOUT = "afterDoLayout", HOOK_EVENT2.BEFORE_MARK_LAYOUT_END = "beforeMarkLayoutEnd", HOOK_EVENT2.AFTER_MARK_LAYOUT_END = "afterMarkLayoutEnd", HOOK_EVENT2.BEFORE_DO_RENDER = "beforeDoRender", HOOK_EVENT2.AFTER_DO_RENDER = "afterDoRender", HOOK_EVENT2.BEFORE_MARK_RENDER_END = "beforeMarkRenderEnd", HOOK_EVENT2.AFTER_MARK_RENDER_END = "afterMarkRenderEnd", HOOK_EVENT2.BEFORE_CREATE_VRENDER_MARK = "beforeCreateVRenderMark", HOOK_EVENT2.AFTER_CREATE_VRENDER_MARK = "afterCreateVRenderMark", HOOK_EVENT2.BEFORE_ADD_VRENDER_MARK = "beforeAddVRenderMark", HOOK_EVENT2.AFTER_ADD_VRENDER_MARK = "afterAddVRenderMark", HOOK_EVENT2.AFTER_VRENDER_NEXT_RENDER = "afterVRenderNextRender", HOOK_EVENT2.BEFORE_ELEMENT_UPDATE_DATA = "beforeElementUpdateData", HOOK_EVENT2.AFTER_ELEMENT_UPDATE_DATA = "afterElementUpdateData", HOOK_EVENT2.BEFORE_ELEMENT_STATE = "beforeElementState", HOOK_EVENT2.AFTER_ELEMENT_STATE = "afterElementState", HOOK_EVENT2.BEFORE_ELEMENT_ENCODE = "beforeElementEncode", HOOK_EVENT2.AFTER_ELEMENT_ENCODE = "afterElementEncode", HOOK_EVENT2.ANIMATION_START = "animationStart", HOOK_EVENT2.ANIMATION_END = "animationEnd", HOOK_EVENT2.ELEMENT_ANIMATION_START = "elementAnimationStart", HOOK_EVENT2.ELEMENT_ANIMATION_END = "elementAnimationEnd", HOOK_EVENT2.ALL_ANIMATION_START = "allAnimationStart", HOOK_EVENT2.ALL_ANIMATION_END = "allAnimationEnd";
}(HOOK_EVENT || (HOOK_EVENT = {}));
var GrammarTypeEnum;
!function(GrammarTypeEnum2) {
  GrammarTypeEnum2.signal = "signal", GrammarTypeEnum2.data = "data", GrammarTypeEnum2.scale = "scale", GrammarTypeEnum2.coordinate = "coordinate", GrammarTypeEnum2.mark = "mark";
}(GrammarTypeEnum || (GrammarTypeEnum = {}));
var InteractionStateEnum;
!function(InteractionStateEnum2) {
  InteractionStateEnum2.active = "active", InteractionStateEnum2.selected = "selected", InteractionStateEnum2.highlight = "highlight", InteractionStateEnum2.blur = "blur";
}(InteractionStateEnum || (InteractionStateEnum = {}));

// node_modules/@visactor/vgrammar-core/es/graph/constants.js
var BridgeElementKey = "__vgrammar_scene_item__";
var CollectionMarkType = [GrammarMarkType.line, GrammarMarkType.area];
var Mark3DType = [GrammarMarkType.arc3d, GrammarMarkType.rect3d, GrammarMarkType.pyramid3d];
var DefaultKey = "key";
var DefaultMarkData = [{}];
var DefaultGroupKeys = ["key"];
var DefaultReuse = true;
var DefaultMorph = true;
var DefaultMorphAll = false;
var DefaultSplitPath = null;
var DefaultEnableExitAnimation = true;
var ImmediateAnimationState = "VGRAMMAR_IMMEDIATE_ANIMATION";
var DefaultAnimationStartTime = 0;
var DefaultAnimationDuration = 1e3;
var DefaultAnimationDelay = 0;
var DefaultAnimationDelayAfter = 0;
var DefaultAnimationLoop = false;
var DefaultAnimationOneByOne = false;
var DefaultAnimationEasing = "quintInOut";
var DefaultAnimationControlOptions = {
  stopWhenStateChange: false,
  immediatelyApply: true
};
var DefaultAnimationParameters = "VGRAMMAR_ANIMATION_PARAMETERS";

// node_modules/@visactor/vgrammar-core/es/parse/util.js
function parseReference(dependency, view) {
  return array(dependency).reduce((refs, dep) => {
    const ref = isString_default(dep) ? view.getGrammarById(dep) : dep;
    return ref && refs.push(ref), refs;
  }, []);
}
function isSignalReferenceType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.signal);
}
function isSignalFunctionType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.callback);
}
function parseFunctionType(spec, view) {
  if (isNil_default(spec)) return [];
  if (isSignalReferenceType(spec)) {
    const signal = spec.signal;
    if (isString_default(signal)) return array(view.getGrammarById(signal));
    if ("signal" === (null == signal ? void 0 : signal.grammarType)) return [signal];
  } else if (isSignalFunctionType(spec)) return parseReference(spec.dependency, view);
  return [];
}
function isFunctionType(spec) {
  return isFunction_default(spec) || (null == spec ? void 0 : spec.signal) || !!(null == spec ? void 0 : spec.callback);
}
function invokeFunctionType(spec, parameters, datumOrGrammarInstance, element) {
  if (isNil_default(spec)) return spec;
  if (isFunction_default(spec)) return element ? spec.call(null, datumOrGrammarInstance, element, parameters) : spec.call(null, datumOrGrammarInstance, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? element ? spec.callback.call(null, datumOrGrammarInstance, element, parameters) : spec.callback.call(null, datumOrGrammarInstance, parameters) : spec;
}
function invokeParameterFunctionType(spec, parameters) {
  if (isNil_default(spec)) return spec;
  if (isFunction_default(spec)) return spec.call(null, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? spec.callback.call(null, parameters) : spec;
}
function getGrammarOutput(grammar, parameters) {
  return isGrammar(grammar) ? grammar.output() : parameters[grammar];
}
function isSignal(obj) {
  return obj && (obj.signal || obj.callback);
}
var isGrammar = (el) => el && !isNil_default(el.grammarType);
var parseField = (field5) => isFunction_default(field5) ? field5 : (datum) => datum[field5];
var parseColor = (color) => isString_default(color) && Color.parseColorString(color) ? color : null;

// node_modules/@visactor/vgrammar-core/es/parse/mark.js
function isScaleEncode(encode) {
  return !!(null == encode ? void 0 : encode.scale);
}
function isFieldEncode(encode) {
  return !!(null == encode ? void 0 : encode.field);
}
function parseEncodeType(encoder2, view) {
  if (!encoder2) return [];
  let dependencies = [];
  return encoder2.scale && (dependencies = isGrammar(encoder2.scale) ? [encoder2.scale] : array(view.getScaleById(encoder2.scale))), dependencies.concat(parseFunctionType(encoder2, view));
}

// node_modules/@visactor/vgrammar-core/es/graph/attributes/helpers.js
function isValidPointsChannel(channels, markType) {
  switch (markType) {
    case "line":
      return channels.some((channel) => ["x", "y", "defined"].includes(channel));
    case "area":
      return channels.some((channel) => ["x", "y", "x1", "y1", "defined"].includes(channel));
    case "largeRects":
      return channels.some((channel) => ["x", "y", "width", "y1"].includes(channel));
    case "largeSymbols":
      return channels.some((channel) => ["x", "y"].includes(channel));
  }
  return false;
}
function getRulePoints(nextAttrs) {
  const { x: x3, y: y3, x1: x14, y1: y14 } = nextAttrs;
  return isValidNumber_default(x3) && isValidNumber_default(y3) && isValidNumber_default(x14) && isValidNumber_default(y14) ? [{
    x: x3,
    y: y3
  }, {
    x: x14,
    y: y14
  }] : [];
}
function getLinePoints(items, includeOnePoint, lastPoints, isArea) {
  if (!items || !items.length || 1 === items.length && includeOnePoint) return [];
  return items.some((item) => isValidPointsChannel(Object.keys(item.nextAttrs), "line")) ? items.map((item, index) => {
    var _a;
    const attrs = item.nextAttrs, { x: x3, y: y3, x1: x14, y1: y14, defined } = null !== (_a = null == lastPoints ? void 0 : lastPoints[index]) && void 0 !== _a ? _a : {};
    return isNil_default(attrs.x) && (attrs.x = x3), isNil_default(attrs.y) && (attrs.y = y3), isNil_default(attrs.defined) && false === defined && (attrs.defined = false), attrs.context = item.key, isArea && (isNil_default(attrs.x1) && (attrs.x1 = x14), isNil_default(attrs.y1) && (attrs.y1 = y14)), attrs;
  }) : null != lastPoints ? lastPoints : [];
}
function getLargeRectsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && includeOnePoint) return [];
  const arr = new Float32Array(4 * items.length);
  return items.forEach((item, index) => {
    var _a, _b, _c, _d;
    const attrs = item.nextAttrs, x3 = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[4 * index], y3 = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[4 * index + 1], width = null !== (_c = attrs.width) && void 0 !== _c ? _c : lastPoints[4 * index + 2], y14 = null !== (_d = attrs.y1) && void 0 !== _d ? _d : lastPoints[4 * index + 3];
    arr[4 * index] = x3, arr[4 * index + 1] = y3, arr[4 * index + 2] = width, arr[4 * index + 3] = y14 - y3;
  }), arr;
}
function getLargeSymbolsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && includeOnePoint) return [];
  const arr = new Float32Array(2 * items.length);
  return items.forEach((item, index) => {
    var _a, _b;
    const attrs = item.nextAttrs, x3 = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[2 * index], y3 = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[2 * index + 1];
    arr[2 * index] = x3, arr[2 * index + 1] = y3;
  }), arr;
}
function isPositionOrSizeChannel(type, channel) {
  if (["x", "y", "dx", "dy"].includes(channel)) return true;
  switch (type) {
    case GrammarMarkType.arc:
      return ["innerRadius", "outerRadius", "startAngle", "endAngle"].includes(channel);
    case GrammarMarkType.group:
    case GrammarMarkType.rect:
    case GrammarMarkType.image:
      return ["width", "height", "y1"].includes(channel);
    case GrammarMarkType.path:
    case GrammarMarkType.shape:
      return ["path", "customPath"].includes(channel);
    case GrammarMarkType.line:
      return "defined" === channel;
    case GrammarMarkType.area:
      return ["x1", "y1", "defined"].includes(channel);
    case GrammarMarkType.rule:
      return ["x1", "y1"].includes(channel);
    case GrammarMarkType.symbol:
      return "size" === channel;
    case GrammarMarkType.polygon:
      return "points" === channel;
    case GrammarMarkType.text:
      return "text" === channel;
  }
  return false;
}
function isPointsMarkType(markType) {
  return [GrammarMarkType.line, GrammarMarkType.area, GrammarMarkType.largeRects, GrammarMarkType.largeSymbols].includes(markType);
}

// node_modules/@visactor/vgrammar-core/es/view/glyph-meta.js
var GlyphMeta = class {
  constructor(marks, encoders, defaultEncoder, progressiveChannels) {
    this.channelEncoder = {}, this.marks = marks, encoders && this.registerChannelEncoder(encoders), defaultEncoder && this.registerDefaultEncoder(defaultEncoder), this.progressiveChannels && this.registerProgressiveChannels(progressiveChannels);
  }
  getMarks() {
    return this.marks;
  }
  registerChannelEncoder(channel, encoder2) {
    return isString_default(channel) ? this.channelEncoder[channel] = encoder2 : Object.assign(this.channelEncoder, channel), this;
  }
  registerFunctionEncoder(encoder2) {
    return this.functionEncoder = encoder2, this;
  }
  registerDefaultEncoder(encoder2) {
    return this.defaultEncoder = encoder2, this;
  }
  registerProgressiveChannels(channels) {
    return this.progressiveChannels = array(channels), this;
  }
  getChannelEncoder() {
    return this.channelEncoder;
  }
  getFunctionEncoder() {
    return this.functionEncoder;
  }
  getDefaultEncoder() {
    return this.defaultEncoder;
  }
  getProgressiveChannels() {
    return this.progressiveChannels;
  }
};

// node_modules/@visactor/vgrammar-core/es/core/factory.js
var Factory = class _Factory {
  static registerPlotMarks(key, mark) {
    _Factory._plotMarks[key] = mark;
  }
  static createPlotMark(type, id2) {
    if (!_Factory._plotMarks[type]) return null;
    return new (0, _Factory._plotMarks[type])(id2);
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static createMark(type, view, group) {
    if (!_Factory._marks[type]) return null;
    return new (0, _Factory._marks[type])(view, type, group);
  }
  static hasMark(type) {
    return !!_Factory._marks[type];
  }
  static registerComponent(key, component2) {
    _Factory._components[key] = component2;
  }
  static createComponent(componentType, view, group, mode2) {
    const Ctor = _Factory._components[componentType];
    return Ctor ? new Ctor(view, group, mode2) : null;
  }
  static hasComponent(componentType) {
    return !!_Factory._components[componentType];
  }
  static registerGraphicComponent(key, creator) {
    _Factory._graphicComponents[key] = creator;
  }
  static createGraphicComponent(componentType, attrs, options) {
    const compCreator = _Factory._graphicComponents[componentType];
    return compCreator ? compCreator(attrs, options) : null;
  }
  static registerTransform(type, transform29, isBuiltIn) {
    _Factory._transforms[type] = Object.assign(transform29, {
      type,
      isBuiltIn: !!isBuiltIn
    });
  }
  static getTransform(type) {
    return _Factory._transforms[type];
  }
  static unregisterRuntimeTransforms() {
    Object.keys(_Factory._transforms).forEach((type) => {
      _Factory._transforms[type] && !_Factory._transforms[type].isBuiltIn && (_Factory._transforms[type] = null);
    });
  }
  static registerGrammar(type, grammarClass, specKey) {
    _Factory._grammars[type] = {
      grammarClass,
      specKey: null != specKey ? specKey : type
    };
  }
  static createGrammar(type, view, grammarType) {
    var _a;
    const Ctor = null === (_a = _Factory._grammars[type]) || void 0 === _a ? void 0 : _a.grammarClass;
    return Ctor ? new Ctor(view, grammarType) : null;
  }
  static getGrammars() {
    return this._grammars;
  }
  static getGlyph(glyphType) {
    return _Factory._glyphs[glyphType];
  }
  static createInteraction(interactionType, view, options) {
    const Ctor = _Factory._interactions[interactionType];
    return Ctor ? new Ctor(view, options) : null;
  }
};
Factory._plotMarks = {}, Factory._marks = {}, Factory._components = {}, Factory._graphicComponents = {}, Factory._transforms = {}, Factory._grammars = {}, Factory._glyphs = {}, Factory._animations = {}, Factory._interactions = {}, Factory._graphics = {}, Factory.registerGlyph = (glyphType, marks, encoders, defaultEncoder, progressiveChannels) => (Factory._glyphs[glyphType] = new GlyphMeta(marks, encoders, defaultEncoder, progressiveChannels), Factory._glyphs[glyphType]), Factory.registerAnimationType = (animationType, animation) => {
  Factory._animations[animationType] = animation;
}, Factory.getAnimationType = (animationType) => Factory._animations[animationType], Factory.registerInteraction = (interactionType, interaction) => {
  Factory._interactions[interactionType] = interaction;
}, Factory.registerGraphic = (graphicType, creator) => {
  Factory._graphics[graphicType] = creator;
}, Factory.getGraphicType = (graphicType) => Factory._graphics[graphicType], Factory.createGraphic = (graphicType, attributes) => {
  const creator = Factory._graphics[graphicType];
  return creator ? creator(attributes) : null;
};

// node_modules/@visactor/vgrammar-core/es/graph/mark/encode.js
function invokeEncoderToItems(element, items, encoder2, parameters, onlyFullEncodeFirst) {
  encoder2 && (isFunctionType(encoder2) ? items.forEach((item) => {
    const attributes = invokeFunctionType(encoder2, parameters, item.datum, element);
    Object.assign(item.nextAttrs, attributes);
  }) : Object.keys(encoder2).forEach((channel) => {
    var _a, _b;
    const encode = encoder2[channel], encodeItems = onlyFullEncodeFirst && !isPositionOrSizeChannel(element.mark.markType, channel) ? [items[0]] : items;
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null;
      let to = hasField ? null : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, encode.value);
      encodeItems.forEach((item) => {
        var _a2;
        hasField && (to = null === (_a2 = scale4.scale) || void 0 === _a2 ? void 0 : _a2.call(scale4, fieldAccessor(item.datum))), item.nextAttrs[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
      });
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      encodeItems.forEach((item) => {
        item.nextAttrs[channel] = fieldAccessor(item.datum);
      });
    } else encodeItems.forEach((item) => {
      item.nextAttrs[channel] = invokeFunctionType(encode, parameters, item.datum, element);
    });
  }));
}
function invokeEncoder(encoder2, datum, element, parameters) {
  if (!encoder2) return null;
  if (isFunctionType(encoder2)) return invokeFunctionType(encoder2, parameters, datum, element);
  const attributes = {};
  return Object.keys(encoder2).forEach((channel) => {
    var _a, _b, _c;
    const encode = encoder2[channel];
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null, to = hasField ? null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, fieldAccessor(datum)) : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_c = scale4.scale) || void 0 === _c ? void 0 : _c.call(scale4, encode.value);
      attributes[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      attributes[channel] = fieldAccessor(datum);
    } else attributes[channel] = invokeFunctionType(encode, parameters, datum, element);
  }), attributes;
}
function splitEncoderInLarge(markType, encoder2, glyphType) {
  if (isFunctionType(encoder2)) return {
    themeEncoder: {},
    positionEncoder: encoder2
  };
  const themeEncoder = {}, positionEncoder = {};
  if (markType === GrammarMarkType.glyph && Factory.getGlyph(glyphType)) {
    const glyphMeta = Factory.getGlyph(glyphType), progressiveChannels = glyphMeta.getProgressiveChannels();
    if (progressiveChannels) Object.keys(encoder2).forEach((channel) => {
      progressiveChannels.includes(channel) ? positionEncoder[channel] = encoder2[channel] : themeEncoder[channel] = encoder2[channel];
    });
    else {
      const markTypes = Array.from(new Set(Object.values(glyphMeta.getMarks())));
      Object.keys(encoder2).forEach((channel) => {
        markTypes.some((type) => isPositionOrSizeChannel(type, channel)) ? positionEncoder[channel] = encoder2[channel] : themeEncoder[channel] = encoder2[channel];
      });
    }
  } else Object.keys(encoder2).forEach((channel) => {
    isPositionOrSizeChannel(markType, channel) ? positionEncoder[channel] = encoder2[channel] : themeEncoder[channel] = encoder2[channel];
  });
  return {
    positionEncoder,
    themeEncoder
  };
}

// node_modules/@visactor/vgrammar-core/es/graph/util/graphic.js
var isMarkType = (type) => !!GrammarMarkType[type];
function createGraphicItem(mark, markType, attrs = {}) {
  var _a;
  const graphicItem = Factory.getGraphicType(markType) ? Factory.createGraphic(markType, attrs) : Factory.createGraphicComponent(markType, attrs, {
    skipDefault: null === (_a = null == mark ? void 0 : mark.spec) || void 0 === _a ? void 0 : _a.skipTheme
  });
  if (!graphicItem) {
    Logger.getInstance().error(`create ${markType} graphic failed!`);
  }
  return graphicItem;
}
function createGlyphGraphicItem(mark, glyphMeta, attrs = {}) {
  if (!Factory.getGraphicType(GrammarMarkType.glyph)) return;
  const graphicItem = Factory.createGraphic(GrammarMarkType.glyph, attrs), glyphMarks = glyphMeta.getMarks(), subGraphics = Object.keys(glyphMarks).map((name) => {
    if (Factory.getGraphicType(glyphMarks[name])) {
      const graphic = Factory.createGraphic(glyphMarks[name]);
      if (graphic) return graphic.name = name, graphic;
    }
  });
  return graphicItem.setSubGraphic(subGraphics), graphicItem;
}
var removeGraphicItem = (graphicItem) => {
  graphicItem && (graphicItem[BridgeElementKey] = null, graphicItem.release(), graphicItem.parent && graphicItem.parent.removeChild(graphicItem));
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/common.js
var commonAttributes = ["fillOpacity"];
var transformCommonAttribute = (graphicAttributes, changedKey, nextAttrs) => {
  var _a;
  return "fillOpacity" === changedKey ? (graphicAttributes.fillOpacity = null !== (_a = nextAttrs.fillOpacity) && void 0 !== _a ? _a : 1, ["fillOpacity"]) : [];
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/transform.js
function storeOriginAttributes(name, channels, graphicAttributes, nextAttrs, element, markName) {
  const prevStoredAttrs = element.getGraphicAttribute(name, false, markName);
  if (prevStoredAttrs) return channels.forEach((channel) => {
    channel in nextAttrs && (prevStoredAttrs[channel] = nextAttrs[channel]);
  }), prevStoredAttrs;
  const storedAttrs = {};
  return channels.forEach((channel) => {
    storedAttrs[channel] = nextAttrs[channel];
  }), graphicAttributes[name] = storedAttrs, storedAttrs;
}
var transformsByType = {
  rect3d: [{
    channels: ["x", "y", "z", "x1", "y1", "width", "height", "length"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      isValidNumber_default(nextAttrs.width) || !isValidNumber_default(nextAttrs.x1) && isValidNumber_default(storedAttrs.width) ? (graphicAttributes.x = Math.min(null !== (_a = storedAttrs.x) && void 0 !== _a ? _a : 0, null !== (_b = storedAttrs.x1) && void 0 !== _b ? _b : 1 / 0), graphicAttributes.width = storedAttrs.width) : isValidNumber_default(nextAttrs.x1) || !isValidNumber_default(nextAttrs.width) && isValidNumber_default(storedAttrs.x1) ? (graphicAttributes.x = Math.min(storedAttrs.x, storedAttrs.x1), graphicAttributes.width = Math.abs(storedAttrs.x1 - storedAttrs.x)) : (graphicAttributes.x = Math.min(null !== (_c = storedAttrs.x) && void 0 !== _c ? _c : 0, null !== (_d = storedAttrs.x1) && void 0 !== _d ? _d : 1 / 0), graphicAttributes.width = storedAttrs.width), isValidNumber_default(nextAttrs.height) || !isValidNumber_default(nextAttrs.y1) && isValidNumber_default(storedAttrs.height) ? (graphicAttributes.y = Math.min(null !== (_e = storedAttrs.y) && void 0 !== _e ? _e : 0, null !== (_f = storedAttrs.y1) && void 0 !== _f ? _f : 1 / 0), graphicAttributes.height = storedAttrs.height) : isValidNumber_default(nextAttrs.y1) || !isValidNumber_default(nextAttrs.height) && isValidNumber_default(storedAttrs.y1) ? (graphicAttributes.y = Math.min(storedAttrs.y, storedAttrs.y1), graphicAttributes.height = Math.abs(storedAttrs.y1 - storedAttrs.y)) : (graphicAttributes.y = Math.min(null !== (_g = storedAttrs.y) && void 0 !== _g ? _g : 0, null !== (_h = storedAttrs.y1) && void 0 !== _h ? _h : 1 / 0), graphicAttributes.height = storedAttrs.height), isValidNumber_default(nextAttrs.length) || !isValidNumber_default(nextAttrs.z1) && isValidNumber_default(storedAttrs.length) ? (graphicAttributes.z = Math.min(null !== (_j = storedAttrs.z) && void 0 !== _j ? _j : 0, null !== (_k = storedAttrs.z1) && void 0 !== _k ? _k : 1 / 0), graphicAttributes.length = storedAttrs.length) : isValidNumber_default(nextAttrs.z1) || !isValidNumber_default(nextAttrs.length) && isValidNumber_default(storedAttrs.z1) ? (graphicAttributes.z = Math.min(storedAttrs.z, storedAttrs.z1), graphicAttributes.length = Math.abs(storedAttrs.z1 - storedAttrs.z)) : (graphicAttributes.z = Math.min(null !== (_l = storedAttrs.z) && void 0 !== _l ? _l : 0, null !== (_m = storedAttrs.z1) && void 0 !== _m ? _m : 1 / 0), graphicAttributes.length = storedAttrs.length);
    },
    storedAttrs: "sizeAttrs"
  }],
  [GrammarMarkType.text]: [{
    channels: ["text", "limit", "autoLimit", "maxLineWidth"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d;
      const limit = null !== (_a = storedAttrs.limit) && void 0 !== _a ? _a : 1 / 0, autoLimit2 = null !== (_b = storedAttrs.autoLimit) && void 0 !== _b ? _b : 1 / 0, maxWidth = Math.min(limit, autoLimit2), isTextConfig = isPlainObject_default(storedAttrs.text) && !isNil_default(storedAttrs.text.text), text2 = isTextConfig ? storedAttrs.text.text : storedAttrs.text;
      Array.isArray(text2), graphicAttributes.maxLineWidth = maxWidth === 1 / 0 ? storedAttrs.maxLineWidth : maxWidth, isTextConfig ? "html" === storedAttrs.text.type ? (graphicAttributes.html = {
        dom: text2,
        width: null !== (_c = nextAttrs.width) && void 0 !== _c ? _c : maxWidth,
        height: null !== (_d = nextAttrs.height) && void 0 !== _d ? _d : nextAttrs.fontSize,
        anchorType: "position"
      }, graphicAttributes.text = "") : "rich" === storedAttrs.text.type ? graphicAttributes.textConfig = text2 : graphicAttributes.text = text2 : graphicAttributes.text = text2;
    },
    storedAttrs: "limitAttrs"
  }],
  [GrammarMarkType.rule]: [{
    channels: ["x", "y", "x1", "y1"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      const points = getRulePoints(storedAttrs);
      graphicAttributes.points = points, graphicAttributes.x = 0, graphicAttributes.y = 0;
    },
    storedAttrs: "pointAttrs"
  }],
  [GrammarMarkType.symbol]: [{
    channels: ["shape", "symbolType"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a;
      graphicAttributes.symbolType = null !== (_a = nextAttrs.shape) && void 0 !== _a ? _a : nextAttrs.symbolType;
    }
  }, {
    channels: ["image", "fill", "background"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      nextAttrs.image ? (graphicAttributes.background = nextAttrs.image, graphicAttributes.fill = false) : storedAttrs.image ? (graphicAttributes.background = storedAttrs.image, graphicAttributes.fill = false) : (graphicAttributes.fill = storedAttrs.fill, graphicAttributes.background = storedAttrs.background);
    },
    storedAttrs: "imageAttrs"
  }],
  [GrammarMarkType.richtext]: [{
    channels: ["text", "textConfig"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d;
      graphicAttributes.text = null, "rich" === (null === (_a = nextAttrs.text) || void 0 === _a ? void 0 : _a.type) ? graphicAttributes.textConfig = nextAttrs.text.text : "html" === (null === (_b = nextAttrs.textConfig) || void 0 === _b ? void 0 : _b.type) ? (graphicAttributes.html = {
        dom: nextAttrs.textConfig.text,
        width: nextAttrs.width,
        height: null !== (_c = nextAttrs.height) && void 0 !== _c ? _c : nextAttrs.fontSize,
        anchorType: "position"
      }, graphicAttributes.text = "") : "rich" === (null === (_d = nextAttrs.textConfig) || void 0 === _d ? void 0 : _d.type) ? graphicAttributes.textConfig = nextAttrs.textConfig.text : graphicAttributes.textConfig = nextAttrs.textConfig;
    }
  }]
};
function cloneTransformAttributes(markType, attributes) {
  var _a;
  return (null !== (_a = transformsByType[markType]) && void 0 !== _a ? _a : []).reduce((clonedAttributes, transform29) => (transform29.channels.forEach((channel) => {
    has_default(attributes, channel) && (clonedAttributes[channel] = attributes[channel]);
  }), clonedAttributes), {});
}
var transformAttributes = (markType, nextAttrs, element, markName) => {
  const graphicAttributes = {}, changedKeys = nextAttrs ? Object.keys(nextAttrs) : [], transforms = isString_default(markType) ? transformsByType[markType] : markType;
  if (transforms && transforms.length) {
    const tags = [];
    changedKeys.forEach((key) => {
      let isTransformed = false;
      transforms.forEach((transform29, index) => {
        if (transform29.channels.includes(key)) {
          if (!tags[index]) if (transform29.storedAttrs) {
            const storedAttrs = storeOriginAttributes(transform29.storedAttrs, transform29.channels, graphicAttributes, nextAttrs, element, markName);
            transform29.transform(graphicAttributes, nextAttrs, storedAttrs);
          } else transform29.transform(graphicAttributes, nextAttrs, null);
          tags[index] = true, isTransformed = true;
        }
      }), isTransformed || (commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key]);
    });
  } else changedKeys.forEach((key) => {
    commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key];
  });
  return graphicAttributes;
};

// node_modules/@visactor/vgrammar-core/es/graph/attributes/line.js
var isStopsEqual = (prev, next) => {
  var _a, _b;
  if (prev === next) return true;
  const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
  return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset);
};
var isColorAttrEqual = (prev, next) => {
  if (prev === next) return true;
  if (typeof prev != typeof next) return false;
  if (isString_default(prev)) return false;
  if (prev.gradient !== next.gradient) return false;
  const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
  return prevKeys.length === nextKeys.length && prevKeys.every((key) => "stops" === key ? isStopsEqual(prev[key], next[key]) : prev[key] === next[key]);
};
var isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-");
var isSegmentAttrEqual = (prev, next, key) => !(!isNil_default(prev) || !isNil_default(next)) || !isNil_default(prev) && (!isNil_default(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next));
var fillAttrs = ["fill", "fillOpacity", "background", "texture", "texturePadding", "textureSize", "textureColor"];
var strokeAttrs = ["stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit"];
var areaAttrs = fillAttrs.concat(strokeAttrs);
function getLineSegmentConfigs(items, points, element) {
  var _a;
  if (!items || items.length <= 1) return null;
  const checkAttributes = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? areaAttrs : strokeAttrs, segments2 = [];
  let prevSegmentAttrs = null;
  return items.forEach((item, index) => {
    prevSegmentAttrs && checkAttributes.every((key) => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key)) || (segments2.length && (segments2[segments2.length - 1].endIndex = index), prevSegmentAttrs = item, segments2.push({
      attrs: prevSegmentAttrs,
      startIndex: index
    }));
  }), segments2.length >= 2 ? segments2.map((entry) => {
    const res = transformAttributes(GrammarMarkType.line, parseCollectionMarkAttributes(entry.attrs), element);
    return res.points = points.slice(entry.startIndex, isNil_default(entry.endIndex) ? points.length : entry.endIndex), res;
  }) : null;
}
function getLinePointsFromSegments(segments2) {
  return segments2 ? segments2.reduce((points, segment) => points.concat(segment.points), []) : null;
}
function parseCollectionMarkAttributes(itemNextAttrs) {
  const result2 = {};
  return itemNextAttrs ? (Object.keys(itemNextAttrs).forEach((key) => {
    "x" !== key && "y" !== key && "x1" !== key && "y1" !== key && "defined" !== key && "size" !== key && "width" !== key && "height" !== key && "context" !== key && (result2[key] = itemNextAttrs[key]);
  }), result2) : result2;
}

// node_modules/@visactor/vgrammar-core/es/graph/element.js
var Element2 = class {
  constructor(mark) {
    this.data = null, this.states = [], this.diffState = DiffState.enter, this.isReserved = false, this.runtimeStatesEncoder = null, this.items = [], this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder2 = isRuntimeState ? this.runtimeStatesEncoder[stateName] : null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName];
      if (!encoder2) return {};
      if (isFunction_default(encoder2)) return encoder2(this.getDatum(), this, stateName, nextStates);
      if (!isRuntimeState && (null === (_c = this.graphicItem.states) || void 0 === _c ? void 0 : _c[stateName])) return this.graphicItem.states[stateName];
      const stateItems = this.items.map((item) => Object.assign({}, item, {
        nextAttrs: {}
      }));
      invokeEncoderToItems(this, stateItems, encoder2, this.mark.parameters());
      const graphicAttributes = this.transformElementItems(stateItems, this.mark.markType);
      return this.graphicItem.states ? this.graphicItem.states[stateName] || (this.graphicItem.states[stateName] = graphicAttributes) : this.graphicItem.states = {
        [stateName]: graphicAttributes
      }, graphicAttributes;
    }, this.mark = mark;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem) return;
    const attrTransforms = this.mark.getAttributeTransforms();
    this.graphicItem = this.mark.addGraphicItem(attrTransforms ? transformAttributes(attrTransforms, attributes, this) : attributes, this.groupKey), this.graphicItem && (this.graphicItem[BridgeElementKey] = this, attrTransforms && (this.graphicItem.onBeforeAttributeUpdate = (attributes2) => {
      if (!this.mark) return attributes2;
      return transformAttributes(attrTransforms, attributes2, this);
    }), this.clearGraphicAttributes(), this.mark.needAnimate() && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(attributes), this.setFinalGraphicAttributes(attributes)));
  }
  updateGraphicItem(config2) {
    if (!this.graphicItem) return;
    isNil_default(config2.clip) || this.graphicItem.setAttribute("clip", config2.clip), isNil_default(config2.interactive) || this.graphicItem.setAttribute("pickable", config2.interactive), isNil_default(config2.zIndex) || this.graphicItem.setAttribute("zIndex", config2.zIndex), this.diffState === DiffState.exit ? this.graphicItem.releaseStatus = "willRelease" : this.graphicItem.releaseStatus = void 0;
    const stateAnimation = this.mark.animate.getAnimationConfigs("state");
    0 !== stateAnimation.length && (this.graphicItem.stateAnimateConfig = stateAnimation[0].originConfig);
  }
  getGraphicItem() {
    return this.graphicItem;
  }
  removeGraphicItem() {
    var _a, _b;
    this.graphicItem && (null === (_b = null === (_a = this.graphicItem.animates) || void 0 === _a ? void 0 : _a.forEach) || void 0 === _b || _b.call(_a, (animate) => animate.stop())), this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem[BridgeElementKey] = null, this.graphicItem = null);
  }
  resetGraphicItem() {
    this.graphicItem && (this.graphicItem = null);
  }
  getBounds() {
    var _a;
    return null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getStates() {
    return this.states;
  }
  updateData(groupKey, data, key) {
    var _a;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.data = data;
    const keyGetter = parseField(key);
    return this.items = data.map((datum) => ({
      datum,
      key: keyGetter(datum),
      view: this.mark.view,
      nextAttrs: {}
    })), this.groupKey = groupKey, this.key = this.mark.isCollectionMark() ? groupKey : null === (_a = this.items) || void 0 === _a ? void 0 : _a[0].key, this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.items;
  }
  state(markState, parameters) {
    var _a;
    const isCollectionMark = this.mark.isCollectionMark(), prevStateValues = this.states, newStateValues = array(invokeFunctionType(markState, parameters, this.getDatum(), this)), stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && stateSort.sort(stateSort);
    const isStateChanged = newStateValues.length !== prevStateValues.length || newStateValues.some((newState, index) => newState !== prevStateValues[index]);
    this.states = newStateValues, !isCollectionMark && isStateChanged && this.diffState === DiffState.unChange && (this.diffState = DiffState.update);
  }
  encodeGraphic(attrs) {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
    attrs && (this.mark.isCollectionMark() && delete attrs.defined, Object.assign(graphicAttributes, attrs)), this.graphicItem ? (this.graphicItem.clearStates(), this.graphicItem.states = {}, this.graphicItem.stateProxy = null, this.applyGraphicAttributes(graphicAttributes)) : this.initGraphicItem(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || this.useStates(this.states), this.mark.markType === GrammarMarkType.shape && (this.graphicItem.datum = this.items[0].datum), this.items.forEach((item) => {
      item.nextAttrs = {};
    }), this._setCustomizedShape();
  }
  _setCustomizedShape() {
    var _a;
    if (!this.graphicItem) return;
    const setCustomizedShape = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.setCustomizedShape;
    setCustomizedShape && (this.graphicItem.pathProxy = (attrs) => setCustomizedShape(this.data, attrs, new CustomPath2D()));
  }
  encodeItems(items, encoders, isReentered = false, parameters) {
    const isCollectionMark = this.mark.isCollectionMark(), updateEncoder = encoders[BuiltInEncodeNames.update], enterEncoder = encoders[BuiltInEncodeNames.enter], exitEncoder = encoders[BuiltInEncodeNames.exit], onlyFullEncodeFirst = this.mark.isLargeMode() || isCollectionMark && !this.mark.getSpec().enableSegments;
    this.diffState === DiffState.enter ? (enterEncoder && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.update ? ((isCollectionMark && enterEncoder || isReentered) && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.exit && exitEncoder && (isReentered && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), invokeEncoderToItems(this, items, exitEncoder, parameters, onlyFullEncodeFirst));
  }
  coordinateTransformEncode(items) {
    if (!this.mark.coord || "arc" === this.mark.markType || true === this.mark.disableCoordinateTransform) return;
    const coord = this.mark.coord.output();
    items.forEach((item) => {
      const nextAttrs = item.nextAttrs, convertedPoint = coord.convert(nextAttrs);
      Object.assign(nextAttrs, convertedPoint);
    });
  }
  clearStates(hasAnimation) {
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    this.states = [], this.graphicItem && this.graphicItem.clearStates(stateAnimationEnable), this.runtimeStatesEncoder && (this.runtimeStatesEncoder = {});
  }
  _updateRuntimeStates(state, attrs) {
    this.runtimeStatesEncoder || (this.runtimeStatesEncoder = {}), this.runtimeStatesEncoder[state] = attrs;
  }
  hasState(state) {
    return this.states && state && this.states.includes(state);
  }
  addState(state, attrs) {
    var _a;
    if (!this.graphicItem) return false;
    if (attrs && isString_default(state) && !isEqual(attrs, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[state])) {
      const nextStates2 = this.states.slice();
      return nextStates2.includes(state) ? this.graphicItem.clearStates() : nextStates2.push(state), this._updateRuntimeStates(state, attrs), this.useStates(nextStates2), true;
    }
    const encode = this.mark.getSpec().encode, nextStates = array(state).reduce((nextStates2, stateName) => (stateName && !nextStates2.includes(stateName) && (null == encode ? void 0 : encode[stateName]) && nextStates2.push(stateName), nextStates2), this.states.slice());
    return nextStates.length !== this.states.length && (this.useStates(nextStates), true);
  }
  removeState(state) {
    if (!this.graphicItem) return false;
    const states = array(state);
    if (!states.length) return false;
    const nextStates = this.states.filter((state2) => !states.includes(state2));
    return nextStates.length !== this.states.length && (this.runtimeStatesEncoder && states.forEach((state2) => {
      this.runtimeStatesEncoder[state2] = null;
    }), this.useStates(nextStates), true);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!this.graphicItem) return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this);
    const stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && states.sort(stateSort), this.states = states;
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    return this.graphicItem.stateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  diffAttributes(graphicAttributes) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes();
    for (const key in graphicAttributes) isEqual2(key, finalGraphicAttributes, graphicAttributes) && has_default(finalGraphicAttributes, key) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  transformElementItems(items, markType, computePoints) {
    var _a, _b, _c, _d;
    const item = items[0];
    if (!item.nextAttrs || 0 === Object.keys(item.nextAttrs).length) return {};
    let nextAttrs = item.nextAttrs;
    if (isPointsMarkType(markType) && items && items.length && isNil_default(null === (_a = item.nextAttrs) || void 0 === _a ? void 0 : _a.points) && (true === computePoints || isValidPointsChannel(Object.keys(item.nextAttrs), this.mark.markType))) {
      const lastPoints = this.getGraphicAttribute("points", false), lastSegments = this.getGraphicAttribute("segments", false), enableSegments = this.mark.getSpec().enableSegments, itemNextAttrs = items.map((item2) => item2.nextAttrs), isProgressive = this.mark.isProgressive();
      if (nextAttrs = parseCollectionMarkAttributes(nextAttrs), markType === GrammarMarkType.line || markType === GrammarMarkType.area) {
        const linePoints = getLinePoints(items, true, lastPoints, markType === GrammarMarkType.area);
        if (enableSegments && !isProgressive) {
          const points = linePoints && 0 !== linePoints.length ? linePoints : getLinePointsFromSegments(lastSegments), segments2 = getLineSegmentConfigs(itemNextAttrs, points, this);
          segments2 ? (nextAttrs.segments = segments2, nextAttrs.points = null) : (nextAttrs.segments = null, nextAttrs.points = points);
        } else isProgressive ? nextAttrs.segments = (null !== (_d = null === (_c = null === (_b = this.graphicItem) || void 0 === _b ? void 0 : _b.attribute) || void 0 === _c ? void 0 : _c.segments) && void 0 !== _d ? _d : []).concat([{
          points: linePoints
        }]) : (nextAttrs.points = linePoints, nextAttrs.segments = null);
      } else markType === GrammarMarkType.largeRects ? nextAttrs.points = getLargeRectsPoints(items, true, lastPoints) : markType === GrammarMarkType.largeSymbols && (nextAttrs.points = getLargeSymbolsPoints(items, true, lastPoints));
    }
    return nextAttrs;
  }
  applyGraphicAttributes(graphicAttributes) {
    var _a, _b;
    if (!isEmpty_default(graphicAttributes)) if (this.mark.needAnimate()) {
      const nextGraphicAttributes = this.diffAttributes(graphicAttributes), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes()) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes()) && void 0 !== _b ? _b : {};
      Object.keys(nextGraphicAttributes).forEach((channel) => {
        prevGraphicAttributes[channel] = this.getGraphicAttribute(channel), finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
      }), this.setNextGraphicAttributes(nextGraphicAttributes), this.setPrevGraphicAttributes(prevGraphicAttributes), this.setFinalGraphicAttributes(finalGraphicAttributes);
      const animateGraphicAttributes = this.mark.animate.getElementAnimators(this).reduce((attributes, animator) => Object.assign(attributes, animator.getEndAttributes()), {}), currentGraphicAttributes = Object.assign({}, animateGraphicAttributes, finalGraphicAttributes);
      this.graphicItem.setAttributes(currentGraphicAttributes);
    } else this.graphicItem.setAttributes(graphicAttributes);
  }
  getGraphicAttribute(channel, prev = false) {
    var _a;
    if (!this.graphicItem) return;
    if (prev) {
      let value;
      const prevGraphicAttributes = this.getPrevGraphicAttributes();
      if (!isNil_default(value = get_default(prevGraphicAttributes, channel))) return value;
    }
    const trans = this.mark.getAttributeTransforms();
    let getKey = [channel];
    if (trans && trans.length) {
      const channelTransform = trans.find((entry) => entry.storedAttrs && entry.channels.includes(channel));
      channelTransform && (getKey = [channelTransform.storedAttrs, channel]);
    }
    return get_default(null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, getKey);
  }
  setGraphicAttribute(channel, value, final = true) {
    if (!this.graphicItem) return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    final && finalGraphicAttributes && (finalGraphicAttributes[channel] = value), prevGraphicAttributes && !has_default(prevGraphicAttributes, channel) && (prevGraphicAttributes[channel] = this.graphicItem.attribute[channel]), this.graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true) {
    if (!this.graphicItem) return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    Object.keys(attributes).forEach((key) => {
      finalGraphicAttributes && final && (finalGraphicAttributes[key] = attributes[key]), prevGraphicAttributes && !has_default(prevGraphicAttributes, key) && (prevGraphicAttributes[key] = this.graphicItem.attribute[key]);
    }), this.graphicItem.setAttributes(attributes);
  }
  getFinalGraphicAttributes() {
    return this.graphicItem.finalAttrs;
  }
  setFinalGraphicAttributes(attributes) {
    this.graphicItem.finalAttrs = attributes;
  }
  getPrevGraphicAttributes() {
    return this.graphicItem.prevAttrs;
  }
  setPrevGraphicAttributes(attributes) {
    this.graphicItem.prevAttrs = attributes;
  }
  getNextGraphicAttributes() {
    return this.graphicItem.nextAttrs;
  }
  setNextGraphicAttributes(attributes) {
    this.graphicItem.nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.graphicItem && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null));
  }
  clearGraphicAttributes() {
    this.graphicItem && (this.graphicItem.prevAttrs && this.setPrevGraphicAttributes(null), this.graphicItem.nextAttrs && this.setNextGraphicAttributes(null), this.graphicItem.finalAttrs && this.setFinalGraphicAttributes(null));
  }
  remove() {
    this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem = null);
  }
  release() {
    this.removeGraphicItem(), this.mark = null, this.data = null, this.items = null;
  }
  getItemAttribute(channel) {
    var _a, _b;
    if (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) return this.mark.isCollectionMark() ? isNil_default(channel) ? this.items.map((item) => item.nextAttrs) : this.items.map((item) => {
      var _a2;
      return null === (_a2 = item.nextAttrs) || void 0 === _a2 ? void 0 : _a2[channel];
    }) : isNil_default(channel) ? this.items[0].nextAttrs : null === (_b = this.items[0].nextAttrs) || void 0 === _b ? void 0 : _b[channel];
  }
  setItemAttributes(attributes) {
    var _a;
    (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) && (this.mark.isCollectionMark() ? isArray_default(attributes) && this.items.forEach((item, index) => {
      Object.assign(item.nextAttrs, attributes[index]);
    }) : Object.assign(this.items[0].nextAttrs, attributes));
  }
  getItem() {
    var _a, _b;
    return this.mark.isCollectionMark() ? null !== (_a = this.items) && void 0 !== _a ? _a : [] : null === (_b = this.items) || void 0 === _b ? void 0 : _b[0];
  }
  getDatum() {
    var _a, _b;
    return this.mark.isCollectionMark() ? null !== (_a = this.data) && void 0 !== _a ? _a : [] : null === (_b = this.data) || void 0 === _b ? void 0 : _b[0];
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/base.js
var BaseInteraction = class {
  constructor(view, options) {
    this.references = /* @__PURE__ */ new Map(), this.view = view, this.depend(null == options ? void 0 : options.dependency);
  }
  depend(grammar) {
    this.references.clear(), array(grammar).map((grammar2) => isString_default(grammar2) ? this.view.getGrammarById(grammar2) : grammar2).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + 1);
    });
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  bind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && this.view.addEventListener(evtType, evt.handler);
      }) : this.view.addEventListener(evt.type, evt.handler));
    });
  }
  unbind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && this.view.removeEventListener(evtType, evt.handler);
      }) : this.view.removeEventListener(evt.type, evt.handler));
    });
  }
  dispatchEvent(type, params2) {
    this.view.emit(`${this.type}:${type}`, params2), "start" === type && this.options.onStart ? this.options.onStart(params2) : "reset" === type && this.options.onReset ? this.options.onReset(params2) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params2) : "end" === type && this.options.onEnd && this.options.onEnd(params2);
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-active.js
var ElementActive = class _ElementActive extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActive.type, this.handleStart = (e3) => {
      e3.element && this._marks && this._marks.includes(e3.element.mark) && e3.element.addState(this.options.state);
    }, this.handleReset = (e3) => {
      e3.element && this._marks && this._marks.includes(e3.element.mark) && e3.element.removeState(this.options.state);
    }, this.options = Object.assign({}, _ElementActive.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
};
ElementActive.type = "element-active", ElementActive.defaultOptions = {
  state: InteractionStateEnum.active,
  trigger: "pointerover",
  resetTrigger: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/utils.js
var generateFilterValue = (options) => options.filterField ? (el) => {
  var _a;
  return null === (_a = el.getDatum()) || void 0 === _a ? void 0 : _a[options.filterField];
} : (el) => el[options.filterType];
var groupMarksByState = (marks, states) => {
  if (!states || !marks) return null;
  const res = {};
  return marks.forEach((mark) => {
    const markSpec = mark && mark.getSpec(), encode = markSpec && markSpec.encode;
    encode && states.forEach((state) => {
      state && encode[state] && (res[state] || (res[state] = []), res[state].push(mark));
    });
  }), res;
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-select.js
var ElementSelect = class _ElementSelect extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementSelect.type, this.clearPrevElements = () => {
      const { state, reverseState } = this.options;
      this._statedElements && this._statedElements.length && (this.clearAllStates(state, reverseState), this.dispatchEvent("reset", {
        elements: this._statedElements,
        options: this.options
      }), this._statedElements = []);
    }, this.handleStart = (e3) => {
      const { state, reverseState, isMultiple } = this.options;
      e3.element && this._marks && this._marks.includes(e3.element.mark) ? e3.element.hasState(state) ? "self" === this._resetType && (this._statedElements && (this._statedElements = this._statedElements.filter((el) => el !== e3.element)), this.updateStates(state, reverseState)) : (this._timer && clearTimeout(this._timer), e3.element.addState(state), this._statedElements || (this._statedElements = []), isMultiple ? this._statedElements.push(e3.element) : this._statedElements[0] = e3.element, this.updateStates(state, reverseState), this.dispatchEvent("start", {
        elements: this._statedElements,
        options: this.options
      }), "timeout" === this._resetType && (this._timer = setTimeout(() => {
        this.clearPrevElements();
      }, this.options.resetTrigger))) : "view" === this._resetType && this._statedElements && this._statedElements.length && this.clearPrevElements();
    }, this.handleReset = (e3) => {
      const hasActiveElement = e3.element && this._marks && this._marks.includes(e3.element.mark);
      this._statedElements && this._statedElements.length && ("view" !== this._resetType || hasActiveElement ? "self" === this._resetType && hasActiveElement && this.clearPrevElements() : this.clearPrevElements());
    }, this.options = Object.assign({}, _ElementSelect.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.state, this.options.reverseState]);
  }
  getEvents() {
    const resetTrigger = this.options.resetTrigger, trigger = this.options.trigger, events = [{
      type: trigger,
      handler: this.handleStart
    }];
    let eventName = resetTrigger;
    return "empty" === resetTrigger ? (eventName = trigger, this._resetType = "view") : isString_default(resetTrigger) ? resetTrigger.includes("view:") ? (eventName = resetTrigger.replace("view:", ""), this._resetType = "view") : (eventName = resetTrigger, this._resetType = "self") : isNumber_default(resetTrigger) ? (eventName = null, this._resetType = "timeout") : this._resetType = null, eventName && eventName !== trigger && events.push({
      type: eventName,
      handler: this.handleReset
    }), events;
  }
};
ElementSelect.type = "element-select", ElementSelect.defaultOptions = {
  state: InteractionStateEnum.selected,
  trigger: "click"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight.js
var ElementHighlight = class _ElementHighlight extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlight.type, this.handleStart = (e3) => {
      if (e3.element && this._marks && this._marks.includes(e3.element.mark)) {
        const { highlightState, blurState } = this.options;
        if (this._lastElement === e3.element) return;
        this._statedElements = [e3.element], this.updateStates(highlightState, blurState), this._lastElement = e3.element, this.dispatchEvent("start", {
          elements: [e3.element],
          options: this.options
        });
      } else this._lastElement && this.clearPrevElements();
    }, this.handleReset = (e3) => {
      e3.element && this._marks && this._marks.includes(e3.element.mark) && this.clearPrevElements();
    }, this.options = Object.assign({}, _ElementHighlight.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.highlightState, this.options.blurState]);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    const { highlightState, blurState } = this.options;
    this._lastElement && (this.clearAllStates(highlightState, blurState), this.dispatchEvent("reset", {
      elements: [this._lastElement],
      options: this.options
    }), this._lastElement = null);
  }
};
ElementHighlight.type = "element-highlight", ElementHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  resetTrigger: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-key.js
var ElementHighlightByKey = class _ElementHighlightByKey extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByKey.type, this.handleStart = (e3) => {
      if (e3.element && this._marks && this._marks.includes(e3.element.mark)) {
        const highlightKey = e3.element.key;
        if (isNil_default(highlightKey)) return;
        this._marks.forEach((mark) => {
          mark.elements.forEach((el) => {
            el.key === highlightKey ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
          });
        });
      }
    }, this.handleReset = (e3) => {
      e3.element && this._marks && this._marks.includes(e3.element.mark) && this.clearPrevElements();
    }, this.options = Object.assign({}, _ElementHighlightByKey.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(this.options.highlightState), el.removeState(this.options.blurState);
      });
    });
  }
};
ElementHighlightByKey.type = "element-highlight-by-key", ElementHighlightByKey.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  resetTrigger: "pointerout"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-group.js
var ElementHighlightByGroup = class _ElementHighlightByGroup extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByGroup.type, this.handleStart = (e3) => {
      if (e3.element && this._marks && this._marks.includes(e3.element.mark)) {
        const highlightKey = e3.element.groupKey;
        if (isNil_default(highlightKey)) return;
        this._marks.forEach((mark) => {
          mark.elements.forEach((el) => {
            el.groupKey === highlightKey ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
          });
        });
      }
    }, this.handleReset = (e3) => {
      e3.element && this._marks && this._marks.includes(e3.element.mark) && this.clearPrevElements();
    }, this.options = Object.assign({}, _ElementHighlightByGroup.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(this.options.highlightState), el.removeState(this.options.blurState);
      });
    });
  }
};
ElementHighlightByGroup.type = "element-highlight-by-group", ElementHighlightByGroup.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  resetTrigger: "pointerout"
};

// node_modules/@visactor/vrender-components/es/core/base.js
var GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
var AbstractComponent = class extends Group {
  constructor(attributes, options) {
    super(attributes), (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = true), this.setTheme({
      common: {
        strokeBoundsBuffer: 0
      }
    }), this.attribute = attributes, this.onSetStage(() => {
      this.render(), this.bindEvents();
    });
  }
  setAttribute(key, value, forceUpdateTag) {
    isPlainObject_default(this.attribute[key]) && isPlainObject_default(value) && !isFunction_default(this.attribute[key]) && !isFunction_default(value) ? merge(this.attribute[key], value) : this.attribute[key] = value, GROUP_ATTRIBUTES.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this._mergeAttributes(params2, keys2), keys2.every((key) => GROUP_ATTRIBUTES.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  _mergeAttributes(params2, keys2) {
    isNil_default(keys2) && (keys2 = Object.keys(params2));
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      !isPlainObject_default(this.attribute[key]) || isFunction_default(this.attribute[key]) || isFunction_default(params2[key]) ? this.attribute[key] = params2[key] : merge(this.attribute[key], params2[key]);
    }
  }
  bindEvents() {
  }
  _getNodeId(id2) {
    return `${this.id}-${this.name}-${id2}`;
  }
  _dispatchEvent(eventName, details) {
    var _a;
    const changeEvent = new CustomEvent(eventName, details);
    changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
  }
};

// node_modules/roughjs/bundled/rough.esm.js
function t(t2, e3, s3) {
  if (t2 && t2.length) {
    const [n2, a4] = e3, o2 = Math.PI / 180 * s3, h2 = Math.cos(o2), r2 = Math.sin(o2);
    t2.forEach((t3) => {
      const [e4, s4] = t3;
      t3[0] = (e4 - n2) * h2 - (s4 - a4) * r2 + n2, t3[1] = (e4 - n2) * r2 + (s4 - a4) * h2 + a4;
    });
  }
}
function e(t2) {
  const e3 = t2[0], s3 = t2[1];
  return Math.sqrt(Math.pow(e3[0] - s3[0], 2) + Math.pow(e3[1] - s3[1], 2));
}
function s2(e3, s3) {
  const n2 = s3.hachureAngle + 90;
  let a4 = s3.hachureGap;
  a4 < 0 && (a4 = 4 * s3.strokeWidth), a4 = Math.max(a4, 0.1);
  const o2 = [0, 0];
  if (n2) for (const s4 of e3) t(s4, o2, n2);
  const h2 = function(t2, e4) {
    const s4 = [];
    for (const e6 of t2) {
      const t3 = [...e6];
      t3[0].join(",") !== t3[t3.length - 1].join(",") && t3.push([t3[0][0], t3[0][1]]), t3.length > 2 && s4.push(t3);
    }
    const n3 = [];
    e4 = Math.max(e4, 0.1);
    const a5 = [];
    for (const t3 of s4) for (let e6 = 0; e6 < t3.length - 1; e6++) {
      const s5 = t3[e6], n4 = t3[e6 + 1];
      if (s5[1] !== n4[1]) {
        const t4 = Math.min(s5[1], n4[1]);
        a5.push({ ymin: t4, ymax: Math.max(s5[1], n4[1]), x: t4 === s5[1] ? s5[0] : n4[0], islope: (n4[0] - s5[0]) / (n4[1] - s5[1]) });
      }
    }
    if (a5.sort((t3, e6) => t3.ymin < e6.ymin ? -1 : t3.ymin > e6.ymin ? 1 : t3.x < e6.x ? -1 : t3.x > e6.x ? 1 : t3.ymax === e6.ymax ? 0 : (t3.ymax - e6.ymax) / Math.abs(t3.ymax - e6.ymax)), !a5.length) return n3;
    let o3 = [], h3 = a5[0].ymin;
    for (; o3.length || a5.length; ) {
      if (a5.length) {
        let t3 = -1;
        for (let e6 = 0; e6 < a5.length && !(a5[e6].ymin > h3); e6++) t3 = e6;
        a5.splice(0, t3 + 1).forEach((t4) => {
          o3.push({ s: h3, edge: t4 });
        });
      }
      if (o3 = o3.filter((t3) => !(t3.edge.ymax <= h3)), o3.sort((t3, e6) => t3.edge.x === e6.edge.x ? 0 : (t3.edge.x - e6.edge.x) / Math.abs(t3.edge.x - e6.edge.x)), o3.length > 1) for (let t3 = 0; t3 < o3.length; t3 += 2) {
        const e6 = t3 + 1;
        if (e6 >= o3.length) break;
        const s5 = o3[t3].edge, a6 = o3[e6].edge;
        n3.push([[Math.round(s5.x), h3], [Math.round(a6.x), h3]]);
      }
      h3 += e4, o3.forEach((t3) => {
        t3.edge.x = t3.edge.x + e4 * t3.edge.islope;
      });
    }
    return n3;
  }(e3, a4);
  if (n2) {
    for (const s4 of e3) t(s4, o2, -n2);
    !function(e4, s4, n3) {
      const a5 = [];
      e4.forEach((t2) => a5.push(...t2)), t(a5, s4, n3);
    }(h2, o2, -n2);
  }
  return h2;
}
var n = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    return this._fillPolygons(t2, e3);
  }
  _fillPolygons(t2, e3) {
    const n2 = s2(t2, e3);
    return { type: "fillSketch", ops: this.renderLines(n2, e3) };
  }
  renderLines(t2, e3) {
    const s3 = [];
    for (const n2 of t2) s3.push(...this.helper.doubleLineOps(n2[0][0], n2[0][1], n2[1][0], n2[1][1], e3));
    return s3;
  }
};
var a2 = class extends n {
  fillPolygons(t2, n2) {
    let a4 = n2.hachureGap;
    a4 < 0 && (a4 = 4 * n2.strokeWidth), a4 = Math.max(a4, 0.1);
    const o2 = s2(t2, Object.assign({}, n2, { hachureGap: a4 })), h2 = Math.PI / 180 * n2.hachureAngle, r2 = [], i2 = 0.5 * a4 * Math.cos(h2), c4 = 0.5 * a4 * Math.sin(h2);
    for (const [t3, s3] of o2) e([t3, s3]) && r2.push([[t3[0] - i2, t3[1] + c4], [...s3]], [[t3[0] + i2, t3[1] - c4], [...s3]]);
    return { type: "fillSketch", ops: this.renderLines(r2, n2) };
  }
};
var o = class extends n {
  fillPolygons(t2, e3) {
    const s3 = this._fillPolygons(t2, e3), n2 = Object.assign({}, e3, { hachureAngle: e3.hachureAngle + 90 }), a4 = this._fillPolygons(t2, n2);
    return s3.ops = s3.ops.concat(a4.ops), s3;
  }
};
var h = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = s2(t2, e3 = Object.assign({}, e3, { hachureAngle: 0 }));
    return this.dotsOnLines(n2, e3);
  }
  dotsOnLines(t2, s3) {
    const n2 = [];
    let a4 = s3.hachureGap;
    a4 < 0 && (a4 = 4 * s3.strokeWidth), a4 = Math.max(a4, 0.1);
    let o2 = s3.fillWeight;
    o2 < 0 && (o2 = s3.strokeWidth / 2);
    const h2 = a4 / 4;
    for (const r2 of t2) {
      const t3 = e(r2), i2 = t3 / a4, c4 = Math.ceil(i2) - 1, l2 = t3 - c4 * a4, u2 = (r2[0][0] + r2[1][0]) / 2 - a4 / 4, p2 = Math.min(r2[0][1], r2[1][1]);
      for (let t4 = 0; t4 < c4; t4++) {
        const e3 = p2 + l2 + t4 * a4, r3 = u2 - h2 + 2 * Math.random() * h2, i3 = e3 - h2 + 2 * Math.random() * h2, c5 = this.helper.ellipse(r3, i3, o2, o2, s3);
        n2.push(...c5.ops);
      }
    }
    return { type: "fillSketch", ops: n2 };
  }
};
var r = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = s2(t2, e3);
    return { type: "fillSketch", ops: this.dashedLine(n2, e3) };
  }
  dashedLine(t2, s3) {
    const n2 = s3.dashOffset < 0 ? s3.hachureGap < 0 ? 4 * s3.strokeWidth : s3.hachureGap : s3.dashOffset, a4 = s3.dashGap < 0 ? s3.hachureGap < 0 ? 4 * s3.strokeWidth : s3.hachureGap : s3.dashGap, o2 = [];
    return t2.forEach((t3) => {
      const h2 = e(t3), r2 = Math.floor(h2 / (n2 + a4)), i2 = (h2 + a4 - r2 * (n2 + a4)) / 2;
      let c4 = t3[0], l2 = t3[1];
      c4[0] > l2[0] && (c4 = t3[1], l2 = t3[0]);
      const u2 = Math.atan((l2[1] - c4[1]) / (l2[0] - c4[0]));
      for (let t4 = 0; t4 < r2; t4++) {
        const e3 = t4 * (n2 + a4), h3 = e3 + n2, r3 = [c4[0] + e3 * Math.cos(u2) + i2 * Math.cos(u2), c4[1] + e3 * Math.sin(u2) + i2 * Math.sin(u2)], l3 = [c4[0] + h3 * Math.cos(u2) + i2 * Math.cos(u2), c4[1] + h3 * Math.sin(u2) + i2 * Math.sin(u2)];
        o2.push(...this.helper.doubleLineOps(r3[0], r3[1], l3[0], l3[1], s3));
      }
    }), o2;
  }
};
var i = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e3) {
    const n2 = e3.hachureGap < 0 ? 4 * e3.strokeWidth : e3.hachureGap, a4 = e3.zigzagOffset < 0 ? n2 : e3.zigzagOffset, o2 = s2(t2, e3 = Object.assign({}, e3, { hachureGap: n2 + a4 }));
    return { type: "fillSketch", ops: this.zigzagLines(o2, a4, e3) };
  }
  zigzagLines(t2, s3, n2) {
    const a4 = [];
    return t2.forEach((t3) => {
      const o2 = e(t3), h2 = Math.round(o2 / (2 * s3));
      let r2 = t3[0], i2 = t3[1];
      r2[0] > i2[0] && (r2 = t3[1], i2 = t3[0]);
      const c4 = Math.atan((i2[1] - r2[1]) / (i2[0] - r2[0]));
      for (let t4 = 0; t4 < h2; t4++) {
        const e3 = 2 * t4 * s3, o3 = 2 * (t4 + 1) * s3, h3 = Math.sqrt(2 * Math.pow(s3, 2)), i3 = [r2[0] + e3 * Math.cos(c4), r2[1] + e3 * Math.sin(c4)], l2 = [r2[0] + o3 * Math.cos(c4), r2[1] + o3 * Math.sin(c4)], u2 = [i3[0] + h3 * Math.cos(c4 + Math.PI / 4), i3[1] + h3 * Math.sin(c4 + Math.PI / 4)];
        a4.push(...this.helper.doubleLineOps(i3[0], i3[1], u2[0], u2[1], n2), ...this.helper.doubleLineOps(u2[0], u2[1], l2[0], l2[1], n2));
      }
    }), a4;
  }
};
var c2 = {};
var l = class {
  constructor(t2) {
    this.seed = t2;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
var u = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function p(t2, e3) {
  return t2.type === e3;
}
function f(t2) {
  const e3 = [], s3 = function(t3) {
    const e4 = new Array();
    for (; "" !== t3; ) if (t3.match(/^([ \t\r\n,]+)/)) t3 = t3.substr(RegExp.$1.length);
    else if (t3.match(/^([aAcChHlLmMqQsStTvVzZ])/)) e4[e4.length] = { type: 0, text: RegExp.$1 }, t3 = t3.substr(RegExp.$1.length);
    else {
      if (!t3.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      e4[e4.length] = { type: 1, text: `${parseFloat(RegExp.$1)}` }, t3 = t3.substr(RegExp.$1.length);
    }
    return e4[e4.length] = { type: 2, text: "" }, e4;
  }(t2);
  let n2 = "BOD", a4 = 0, o2 = s3[a4];
  for (; !p(o2, 2); ) {
    let h2 = 0;
    const r2 = [];
    if ("BOD" === n2) {
      if ("M" !== o2.text && "m" !== o2.text) return f("M0,0" + t2);
      a4++, h2 = u[o2.text], n2 = o2.text;
    } else p(o2, 1) ? h2 = u[n2] : (a4++, h2 = u[o2.text], n2 = o2.text);
    if (!(a4 + h2 < s3.length)) throw new Error("Path data ended short");
    for (let t3 = a4; t3 < a4 + h2; t3++) {
      const e4 = s3[t3];
      if (!p(e4, 1)) throw new Error("Param not a number: " + n2 + "," + e4.text);
      r2[r2.length] = +e4.text;
    }
    if ("number" != typeof u[n2]) throw new Error("Bad segment: " + n2);
    {
      const t3 = { key: n2, data: r2 };
      e3.push(t3), a4 += h2, o2 = s3[a4], "M" === n2 && (n2 = "L"), "m" === n2 && (n2 = "l");
    }
  }
  return e3;
}
function d(t2) {
  let e3 = 0, s3 = 0, n2 = 0, a4 = 0;
  const o2 = [];
  for (const { key: h2, data: r2 } of t2) switch (h2) {
    case "M":
      o2.push({ key: "M", data: [...r2] }), [e3, s3] = r2, [n2, a4] = r2;
      break;
    case "m":
      e3 += r2[0], s3 += r2[1], o2.push({ key: "M", data: [e3, s3] }), n2 = e3, a4 = s3;
      break;
    case "L":
      o2.push({ key: "L", data: [...r2] }), [e3, s3] = r2;
      break;
    case "l":
      e3 += r2[0], s3 += r2[1], o2.push({ key: "L", data: [e3, s3] });
      break;
    case "C":
      o2.push({ key: "C", data: [...r2] }), e3 = r2[4], s3 = r2[5];
      break;
    case "c": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s3 : t4 + e3);
      o2.push({ key: "C", data: t3 }), e3 = t3[4], s3 = t3[5];
      break;
    }
    case "Q":
      o2.push({ key: "Q", data: [...r2] }), e3 = r2[2], s3 = r2[3];
      break;
    case "q": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s3 : t4 + e3);
      o2.push({ key: "Q", data: t3 }), e3 = t3[2], s3 = t3[3];
      break;
    }
    case "A":
      o2.push({ key: "A", data: [...r2] }), e3 = r2[5], s3 = r2[6];
      break;
    case "a":
      e3 += r2[5], s3 += r2[6], o2.push({ key: "A", data: [r2[0], r2[1], r2[2], r2[3], r2[4], e3, s3] });
      break;
    case "H":
      o2.push({ key: "H", data: [...r2] }), e3 = r2[0];
      break;
    case "h":
      e3 += r2[0], o2.push({ key: "H", data: [e3] });
      break;
    case "V":
      o2.push({ key: "V", data: [...r2] }), s3 = r2[0];
      break;
    case "v":
      s3 += r2[0], o2.push({ key: "V", data: [s3] });
      break;
    case "S":
      o2.push({ key: "S", data: [...r2] }), e3 = r2[2], s3 = r2[3];
      break;
    case "s": {
      const t3 = r2.map((t4, n3) => n3 % 2 ? t4 + s3 : t4 + e3);
      o2.push({ key: "S", data: t3 }), e3 = t3[2], s3 = t3[3];
      break;
    }
    case "T":
      o2.push({ key: "T", data: [...r2] }), e3 = r2[0], s3 = r2[1];
      break;
    case "t":
      e3 += r2[0], s3 += r2[1], o2.push({ key: "T", data: [e3, s3] });
      break;
    case "Z":
    case "z":
      o2.push({ key: "Z", data: [] }), e3 = n2, s3 = a4;
  }
  return o2;
}
function g2(t2) {
  const e3 = [];
  let s3 = "", n2 = 0, a4 = 0, o2 = 0, h2 = 0, r2 = 0, i2 = 0;
  for (const { key: c4, data: l2 } of t2) {
    switch (c4) {
      case "M":
        e3.push({ key: "M", data: [...l2] }), [n2, a4] = l2, [o2, h2] = l2;
        break;
      case "C":
        e3.push({ key: "C", data: [...l2] }), n2 = l2[4], a4 = l2[5], r2 = l2[2], i2 = l2[3];
        break;
      case "L":
        e3.push({ key: "L", data: [...l2] }), [n2, a4] = l2;
        break;
      case "H":
        n2 = l2[0], e3.push({ key: "L", data: [n2, a4] });
        break;
      case "V":
        a4 = l2[0], e3.push({ key: "L", data: [n2, a4] });
        break;
      case "S": {
        let t3 = 0, o3 = 0;
        "C" === s3 || "S" === s3 ? (t3 = n2 + (n2 - r2), o3 = a4 + (a4 - i2)) : (t3 = n2, o3 = a4), e3.push({ key: "C", data: [t3, o3, ...l2] }), r2 = l2[0], i2 = l2[1], n2 = l2[2], a4 = l2[3];
        break;
      }
      case "T": {
        const [t3, o3] = l2;
        let h3 = 0, c5 = 0;
        "Q" === s3 || "T" === s3 ? (h3 = n2 + (n2 - r2), c5 = a4 + (a4 - i2)) : (h3 = n2, c5 = a4);
        const u2 = n2 + 2 * (h3 - n2) / 3, p2 = a4 + 2 * (c5 - a4) / 3, f2 = t3 + 2 * (h3 - t3) / 3, d2 = o3 + 2 * (c5 - o3) / 3;
        e3.push({ key: "C", data: [u2, p2, f2, d2, t3, o3] }), r2 = h3, i2 = c5, n2 = t3, a4 = o3;
        break;
      }
      case "Q": {
        const [t3, s4, o3, h3] = l2, c5 = n2 + 2 * (t3 - n2) / 3, u2 = a4 + 2 * (s4 - a4) / 3, p2 = o3 + 2 * (t3 - o3) / 3, f2 = h3 + 2 * (s4 - h3) / 3;
        e3.push({ key: "C", data: [c5, u2, p2, f2, o3, h3] }), r2 = t3, i2 = s4, n2 = o3, a4 = h3;
        break;
      }
      case "A": {
        const t3 = Math.abs(l2[0]), s4 = Math.abs(l2[1]), o3 = l2[2], h3 = l2[3], r3 = l2[4], i3 = l2[5], c5 = l2[6];
        if (0 === t3 || 0 === s4) e3.push({ key: "C", data: [n2, a4, i3, c5, i3, c5] }), n2 = i3, a4 = c5;
        else if (n2 !== i3 || a4 !== c5) {
          k2(n2, a4, i3, c5, t3, s4, o3, h3, r3).forEach(function(t4) {
            e3.push({ key: "C", data: t4 });
          }), n2 = i3, a4 = c5;
        }
        break;
      }
      case "Z":
        e3.push({ key: "Z", data: [] }), n2 = o2, a4 = h2;
    }
    s3 = c4;
  }
  return e3;
}
function M2(t2, e3, s3) {
  return [t2 * Math.cos(s3) - e3 * Math.sin(s3), t2 * Math.sin(s3) + e3 * Math.cos(s3)];
}
function k2(t2, e3, s3, n2, a4, o2, h2, r2, i2, c4) {
  const l2 = (u2 = h2, Math.PI * u2 / 180);
  var u2;
  let p2 = [], f2 = 0, d2 = 0, g3 = 0, b2 = 0;
  if (c4) [f2, d2, g3, b2] = c4;
  else {
    [t2, e3] = M2(t2, e3, -l2), [s3, n2] = M2(s3, n2, -l2);
    const h3 = (t2 - s3) / 2, c5 = (e3 - n2) / 2;
    let u3 = h3 * h3 / (a4 * a4) + c5 * c5 / (o2 * o2);
    u3 > 1 && (u3 = Math.sqrt(u3), a4 *= u3, o2 *= u3);
    const p3 = a4 * a4, k3 = o2 * o2, y4 = p3 * k3 - p3 * c5 * c5 - k3 * h3 * h3, m6 = p3 * c5 * c5 + k3 * h3 * h3, w3 = (r2 === i2 ? -1 : 1) * Math.sqrt(Math.abs(y4 / m6));
    g3 = w3 * a4 * c5 / o2 + (t2 + s3) / 2, b2 = w3 * -o2 * h3 / a4 + (e3 + n2) / 2, f2 = Math.asin(parseFloat(((e3 - b2) / o2).toFixed(9))), d2 = Math.asin(parseFloat(((n2 - b2) / o2).toFixed(9))), t2 < g3 && (f2 = Math.PI - f2), s3 < g3 && (d2 = Math.PI - d2), f2 < 0 && (f2 = 2 * Math.PI + f2), d2 < 0 && (d2 = 2 * Math.PI + d2), i2 && f2 > d2 && (f2 -= 2 * Math.PI), !i2 && d2 > f2 && (d2 -= 2 * Math.PI);
  }
  let y3 = d2 - f2;
  if (Math.abs(y3) > 120 * Math.PI / 180) {
    const t3 = d2, e4 = s3, r3 = n2;
    d2 = i2 && d2 > f2 ? f2 + 120 * Math.PI / 180 * 1 : f2 + 120 * Math.PI / 180 * -1, p2 = k2(s3 = g3 + a4 * Math.cos(d2), n2 = b2 + o2 * Math.sin(d2), e4, r3, a4, o2, h2, 0, i2, [d2, t3, g3, b2]);
  }
  y3 = d2 - f2;
  const m5 = Math.cos(f2), w2 = Math.sin(f2), x3 = Math.cos(d2), P2 = Math.sin(d2), v2 = Math.tan(y3 / 4), O2 = 4 / 3 * a4 * v2, S2 = 4 / 3 * o2 * v2, L2 = [t2, e3], T2 = [t2 + O2 * w2, e3 - S2 * m5], D2 = [s3 + O2 * P2, n2 - S2 * x3], A5 = [s3, n2];
  if (T2[0] = 2 * L2[0] - T2[0], T2[1] = 2 * L2[1] - T2[1], c4) return [T2, D2, A5].concat(p2);
  {
    p2 = [T2, D2, A5].concat(p2);
    const t3 = [];
    for (let e4 = 0; e4 < p2.length; e4 += 3) {
      const s4 = M2(p2[e4][0], p2[e4][1], l2), n3 = M2(p2[e4 + 1][0], p2[e4 + 1][1], l2), a5 = M2(p2[e4 + 2][0], p2[e4 + 2][1], l2);
      t3.push([s4[0], s4[1], n3[0], n3[1], a5[0], a5[1]]);
    }
    return t3;
  }
}
var b = { randOffset: function(t2, e3) {
  return A(t2, e3);
}, randOffsetWithRange: function(t2, e3, s3) {
  return D(t2, e3, s3);
}, ellipse: function(t2, e3, s3, n2, a4) {
  const o2 = P(s3, n2, a4);
  return v(t2, e3, a4, o2).opset;
}, doubleLineOps: function(t2, e3, s3, n2, a4) {
  return I(t2, e3, s3, n2, a4, true);
} };
function y(t2, e3, s3, n2, a4) {
  return { type: "path", ops: I(t2, e3, s3, n2, a4) };
}
function m(t2, e3, s3) {
  const n2 = (t2 || []).length;
  if (n2 > 2) {
    const a4 = [];
    for (let e4 = 0; e4 < n2 - 1; e4++) a4.push(...I(t2[e4][0], t2[e4][1], t2[e4 + 1][0], t2[e4 + 1][1], s3));
    return e3 && a4.push(...I(t2[n2 - 1][0], t2[n2 - 1][1], t2[0][0], t2[0][1], s3)), { type: "path", ops: a4 };
  }
  return 2 === n2 ? y(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s3) : { type: "path", ops: [] };
}
function w(t2, e3, s3, n2, a4) {
  return function(t3, e4) {
    return m(t3, true, e4);
  }([[t2, e3], [t2 + s3, e3], [t2 + s3, e3 + n2], [t2, e3 + n2]], a4);
}
function x(t2, e3) {
  let s3 = _(t2, 1 * (1 + 0.2 * e3.roughness), e3);
  if (!e3.disableMultiStroke) {
    const n2 = _(t2, 1.5 * (1 + 0.22 * e3.roughness), function(t3) {
      const e4 = Object.assign({}, t3);
      e4.randomizer = void 0, t3.seed && (e4.seed = t3.seed + 1);
      return e4;
    }(e3));
    s3 = s3.concat(n2);
  }
  return { type: "path", ops: s3 };
}
function P(t2, e3, s3) {
  const n2 = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t2 / 2, 2) + Math.pow(e3 / 2, 2)) / 2)), a4 = Math.ceil(Math.max(s3.curveStepCount, s3.curveStepCount / Math.sqrt(200) * n2)), o2 = 2 * Math.PI / a4;
  let h2 = Math.abs(t2 / 2), r2 = Math.abs(e3 / 2);
  const i2 = 1 - s3.curveFitting;
  return h2 += A(h2 * i2, s3), r2 += A(r2 * i2, s3), { increment: o2, rx: h2, ry: r2 };
}
function v(t2, e3, s3, n2) {
  const [a4, o2] = z(n2.increment, t2, e3, n2.rx, n2.ry, 1, n2.increment * D(0.1, D(0.4, 1, s3), s3), s3);
  let h2 = W(a4, null, s3);
  if (!s3.disableMultiStroke && 0 !== s3.roughness) {
    const [a5] = z(n2.increment, t2, e3, n2.rx, n2.ry, 1.5, 0, s3), o3 = W(a5, null, s3);
    h2 = h2.concat(o3);
  }
  return { estimatedPoints: o2, opset: { type: "path", ops: h2 } };
}
function O(t2, e3, s3, n2, a4, o2, h2, r2, i2) {
  const c4 = t2, l2 = e3;
  let u2 = Math.abs(s3 / 2), p2 = Math.abs(n2 / 2);
  u2 += A(0.01 * u2, i2), p2 += A(0.01 * p2, i2);
  let f2 = a4, d2 = o2;
  for (; f2 < 0; ) f2 += 2 * Math.PI, d2 += 2 * Math.PI;
  d2 - f2 > 2 * Math.PI && (f2 = 0, d2 = 2 * Math.PI);
  const g3 = 2 * Math.PI / i2.curveStepCount, M3 = Math.min(g3 / 2, (d2 - f2) / 2), k3 = E(M3, c4, l2, u2, p2, f2, d2, 1, i2);
  if (!i2.disableMultiStroke) {
    const t3 = E(M3, c4, l2, u2, p2, f2, d2, 1.5, i2);
    k3.push(...t3);
  }
  return h2 && (r2 ? k3.push(...I(c4, l2, c4 + u2 * Math.cos(f2), l2 + p2 * Math.sin(f2), i2), ...I(c4, l2, c4 + u2 * Math.cos(d2), l2 + p2 * Math.sin(d2), i2)) : k3.push({ op: "lineTo", data: [c4, l2] }, { op: "lineTo", data: [c4 + u2 * Math.cos(f2), l2 + p2 * Math.sin(f2)] })), { type: "path", ops: k3 };
}
function S(t2, e3) {
  const s3 = [];
  for (const n2 of t2) if (n2.length) {
    const t3 = e3.maxRandomnessOffset || 0, a4 = n2.length;
    if (a4 > 2) {
      s3.push({ op: "move", data: [n2[0][0] + A(t3, e3), n2[0][1] + A(t3, e3)] });
      for (let o2 = 1; o2 < a4; o2++) s3.push({ op: "lineTo", data: [n2[o2][0] + A(t3, e3), n2[o2][1] + A(t3, e3)] });
    }
  }
  return { type: "fillPath", ops: s3 };
}
function L(t2, e3) {
  return function(t3, e4) {
    let s3 = t3.fillStyle || "hachure";
    if (!c2[s3]) switch (s3) {
      case "zigzag":
        c2[s3] || (c2[s3] = new a2(e4));
        break;
      case "cross-hatch":
        c2[s3] || (c2[s3] = new o(e4));
        break;
      case "dots":
        c2[s3] || (c2[s3] = new h(e4));
        break;
      case "dashed":
        c2[s3] || (c2[s3] = new r(e4));
        break;
      case "zigzag-line":
        c2[s3] || (c2[s3] = new i(e4));
        break;
      case "hachure":
      default:
        s3 = "hachure", c2[s3] || (c2[s3] = new n(e4));
    }
    return c2[s3];
  }(e3, b).fillPolygons(t2, e3);
}
function T(t2) {
  return t2.randomizer || (t2.randomizer = new l(t2.seed || 0)), t2.randomizer.next();
}
function D(t2, e3, s3, n2 = 1) {
  return s3.roughness * n2 * (T(s3) * (e3 - t2) + t2);
}
function A(t2, e3, s3 = 1) {
  return D(-t2, t2, e3, s3);
}
function I(t2, e3, s3, n2, a4, o2 = false) {
  const h2 = o2 ? a4.disableMultiStrokeFill : a4.disableMultiStroke, r2 = C(t2, e3, s3, n2, a4, true, false);
  if (h2) return r2;
  const i2 = C(t2, e3, s3, n2, a4, true, true);
  return r2.concat(i2);
}
function C(t2, e3, s3, n2, a4, o2, h2) {
  const r2 = Math.pow(t2 - s3, 2) + Math.pow(e3 - n2, 2), i2 = Math.sqrt(r2);
  let c4 = 1;
  c4 = i2 < 200 ? 1 : i2 > 500 ? 0.4 : -16668e-7 * i2 + 1.233334;
  let l2 = a4.maxRandomnessOffset || 0;
  l2 * l2 * 100 > r2 && (l2 = i2 / 10);
  const u2 = l2 / 2, p2 = 0.2 + 0.2 * T(a4);
  let f2 = a4.bowing * a4.maxRandomnessOffset * (n2 - e3) / 200, d2 = a4.bowing * a4.maxRandomnessOffset * (t2 - s3) / 200;
  f2 = A(f2, a4, c4), d2 = A(d2, a4, c4);
  const g3 = [], M3 = () => A(u2, a4, c4), k3 = () => A(l2, a4, c4), b2 = a4.preserveVertices;
  return o2 && (h2 ? g3.push({ op: "move", data: [t2 + (b2 ? 0 : M3()), e3 + (b2 ? 0 : M3())] }) : g3.push({ op: "move", data: [t2 + (b2 ? 0 : A(l2, a4, c4)), e3 + (b2 ? 0 : A(l2, a4, c4))] })), h2 ? g3.push({ op: "bcurveTo", data: [f2 + t2 + (s3 - t2) * p2 + M3(), d2 + e3 + (n2 - e3) * p2 + M3(), f2 + t2 + 2 * (s3 - t2) * p2 + M3(), d2 + e3 + 2 * (n2 - e3) * p2 + M3(), s3 + (b2 ? 0 : M3()), n2 + (b2 ? 0 : M3())] }) : g3.push({ op: "bcurveTo", data: [f2 + t2 + (s3 - t2) * p2 + k3(), d2 + e3 + (n2 - e3) * p2 + k3(), f2 + t2 + 2 * (s3 - t2) * p2 + k3(), d2 + e3 + 2 * (n2 - e3) * p2 + k3(), s3 + (b2 ? 0 : k3()), n2 + (b2 ? 0 : k3())] }), g3;
}
function _(t2, e3, s3) {
  const n2 = [];
  n2.push([t2[0][0] + A(e3, s3), t2[0][1] + A(e3, s3)]), n2.push([t2[0][0] + A(e3, s3), t2[0][1] + A(e3, s3)]);
  for (let a4 = 1; a4 < t2.length; a4++) n2.push([t2[a4][0] + A(e3, s3), t2[a4][1] + A(e3, s3)]), a4 === t2.length - 1 && n2.push([t2[a4][0] + A(e3, s3), t2[a4][1] + A(e3, s3)]);
  return W(n2, null, s3);
}
function W(t2, e3, s3) {
  const n2 = t2.length, a4 = [];
  if (n2 > 3) {
    const o2 = [], h2 = 1 - s3.curveTightness;
    a4.push({ op: "move", data: [t2[1][0], t2[1][1]] });
    for (let e4 = 1; e4 + 2 < n2; e4++) {
      const s4 = t2[e4];
      o2[0] = [s4[0], s4[1]], o2[1] = [s4[0] + (h2 * t2[e4 + 1][0] - h2 * t2[e4 - 1][0]) / 6, s4[1] + (h2 * t2[e4 + 1][1] - h2 * t2[e4 - 1][1]) / 6], o2[2] = [t2[e4 + 1][0] + (h2 * t2[e4][0] - h2 * t2[e4 + 2][0]) / 6, t2[e4 + 1][1] + (h2 * t2[e4][1] - h2 * t2[e4 + 2][1]) / 6], o2[3] = [t2[e4 + 1][0], t2[e4 + 1][1]], a4.push({ op: "bcurveTo", data: [o2[1][0], o2[1][1], o2[2][0], o2[2][1], o2[3][0], o2[3][1]] });
    }
    if (e3 && 2 === e3.length) {
      const t3 = s3.maxRandomnessOffset;
      a4.push({ op: "lineTo", data: [e3[0] + A(t3, s3), e3[1] + A(t3, s3)] });
    }
  } else 3 === n2 ? (a4.push({ op: "move", data: [t2[1][0], t2[1][1]] }), a4.push({ op: "bcurveTo", data: [t2[1][0], t2[1][1], t2[2][0], t2[2][1], t2[2][0], t2[2][1]] })) : 2 === n2 && a4.push(...I(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s3));
  return a4;
}
function z(t2, e3, s3, n2, a4, o2, h2, r2) {
  const i2 = [], c4 = [];
  if (0 === r2.roughness) {
    t2 /= 4, c4.push([e3 + n2 * Math.cos(-t2), s3 + a4 * Math.sin(-t2)]);
    for (let o3 = 0; o3 <= 2 * Math.PI; o3 += t2) {
      const t3 = [e3 + n2 * Math.cos(o3), s3 + a4 * Math.sin(o3)];
      i2.push(t3), c4.push(t3);
    }
    c4.push([e3 + n2 * Math.cos(0), s3 + a4 * Math.sin(0)]), c4.push([e3 + n2 * Math.cos(t2), s3 + a4 * Math.sin(t2)]);
  } else {
    const l2 = A(0.5, r2) - Math.PI / 2;
    c4.push([A(o2, r2) + e3 + 0.9 * n2 * Math.cos(l2 - t2), A(o2, r2) + s3 + 0.9 * a4 * Math.sin(l2 - t2)]);
    const u2 = 2 * Math.PI + l2 - 0.01;
    for (let h3 = l2; h3 < u2; h3 += t2) {
      const t3 = [A(o2, r2) + e3 + n2 * Math.cos(h3), A(o2, r2) + s3 + a4 * Math.sin(h3)];
      i2.push(t3), c4.push(t3);
    }
    c4.push([A(o2, r2) + e3 + n2 * Math.cos(l2 + 2 * Math.PI + 0.5 * h2), A(o2, r2) + s3 + a4 * Math.sin(l2 + 2 * Math.PI + 0.5 * h2)]), c4.push([A(o2, r2) + e3 + 0.98 * n2 * Math.cos(l2 + h2), A(o2, r2) + s3 + 0.98 * a4 * Math.sin(l2 + h2)]), c4.push([A(o2, r2) + e3 + 0.9 * n2 * Math.cos(l2 + 0.5 * h2), A(o2, r2) + s3 + 0.9 * a4 * Math.sin(l2 + 0.5 * h2)]);
  }
  return [c4, i2];
}
function E(t2, e3, s3, n2, a4, o2, h2, r2, i2) {
  const c4 = o2 + A(0.1, i2), l2 = [];
  l2.push([A(r2, i2) + e3 + 0.9 * n2 * Math.cos(c4 - t2), A(r2, i2) + s3 + 0.9 * a4 * Math.sin(c4 - t2)]);
  for (let o3 = c4; o3 <= h2; o3 += t2) l2.push([A(r2, i2) + e3 + n2 * Math.cos(o3), A(r2, i2) + s3 + a4 * Math.sin(o3)]);
  return l2.push([e3 + n2 * Math.cos(h2), s3 + a4 * Math.sin(h2)]), l2.push([e3 + n2 * Math.cos(h2), s3 + a4 * Math.sin(h2)]), W(l2, null, i2);
}
function $(t2, e3, s3, n2, a4, o2, h2, r2) {
  const i2 = [], c4 = [r2.maxRandomnessOffset || 1, (r2.maxRandomnessOffset || 1) + 0.3];
  let l2 = [0, 0];
  const u2 = r2.disableMultiStroke ? 1 : 2, p2 = r2.preserveVertices;
  for (let f2 = 0; f2 < u2; f2++) 0 === f2 ? i2.push({ op: "move", data: [h2[0], h2[1]] }) : i2.push({ op: "move", data: [h2[0] + (p2 ? 0 : A(c4[0], r2)), h2[1] + (p2 ? 0 : A(c4[0], r2))] }), l2 = p2 ? [a4, o2] : [a4 + A(c4[f2], r2), o2 + A(c4[f2], r2)], i2.push({ op: "bcurveTo", data: [t2 + A(c4[f2], r2), e3 + A(c4[f2], r2), s3 + A(c4[f2], r2), n2 + A(c4[f2], r2), l2[0], l2[1]] });
  return i2;
}
function G(t2) {
  return [...t2];
}
function R(t2, e3) {
  return Math.pow(t2[0] - e3[0], 2) + Math.pow(t2[1] - e3[1], 2);
}
function q(t2, e3, s3) {
  const n2 = R(e3, s3);
  if (0 === n2) return R(t2, e3);
  let a4 = ((t2[0] - e3[0]) * (s3[0] - e3[0]) + (t2[1] - e3[1]) * (s3[1] - e3[1])) / n2;
  return a4 = Math.max(0, Math.min(1, a4)), R(t2, j(e3, s3, a4));
}
function j(t2, e3, s3) {
  return [t2[0] + (e3[0] - t2[0]) * s3, t2[1] + (e3[1] - t2[1]) * s3];
}
function F(t2, e3, s3, n2) {
  const a4 = n2 || [];
  if (function(t3, e4) {
    const s4 = t3[e4 + 0], n3 = t3[e4 + 1], a5 = t3[e4 + 2], o3 = t3[e4 + 3];
    let h3 = 3 * n3[0] - 2 * s4[0] - o3[0];
    h3 *= h3;
    let r2 = 3 * n3[1] - 2 * s4[1] - o3[1];
    r2 *= r2;
    let i2 = 3 * a5[0] - 2 * o3[0] - s4[0];
    i2 *= i2;
    let c4 = 3 * a5[1] - 2 * o3[1] - s4[1];
    return c4 *= c4, h3 < i2 && (h3 = i2), r2 < c4 && (r2 = c4), h3 + r2;
  }(t2, e3) < s3) {
    const s4 = t2[e3 + 0];
    if (a4.length) {
      (o2 = a4[a4.length - 1], h2 = s4, Math.sqrt(R(o2, h2))) > 1 && a4.push(s4);
    } else a4.push(s4);
    a4.push(t2[e3 + 3]);
  } else {
    const n3 = 0.5, o3 = t2[e3 + 0], h3 = t2[e3 + 1], r2 = t2[e3 + 2], i2 = t2[e3 + 3], c4 = j(o3, h3, n3), l2 = j(h3, r2, n3), u2 = j(r2, i2, n3), p2 = j(c4, l2, n3), f2 = j(l2, u2, n3), d2 = j(p2, f2, n3);
    F([o3, c4, p2, d2], 0, s3, a4), F([d2, f2, u2, i2], 0, s3, a4);
  }
  var o2, h2;
  return a4;
}
function V(t2, e3) {
  return Z(t2, 0, t2.length, e3);
}
function Z(t2, e3, s3, n2, a4) {
  const o2 = a4 || [], h2 = t2[e3], r2 = t2[s3 - 1];
  let i2 = 0, c4 = 1;
  for (let n3 = e3 + 1; n3 < s3 - 1; ++n3) {
    const e4 = q(t2[n3], h2, r2);
    e4 > i2 && (i2 = e4, c4 = n3);
  }
  return Math.sqrt(i2) > n2 ? (Z(t2, e3, c4 + 1, n2, o2), Z(t2, c4, s3, n2, o2)) : (o2.length || o2.push(h2), o2.push(r2)), o2;
}
function Q(t2, e3 = 0.15, s3) {
  const n2 = [], a4 = (t2.length - 1) / 3;
  for (let s4 = 0; s4 < a4; s4++) {
    F(t2, 3 * s4, e3, n2);
  }
  return s3 && s3 > 0 ? Z(n2, 0, n2.length, s3) : n2;
}
var H = "none";
var N = class {
  constructor(t2) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: false, disableMultiStrokeFill: false, preserveVertices: false }, this.config = t2 || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(t2) {
    return t2 ? Object.assign({}, this.defaultOptions, t2) : this.defaultOptions;
  }
  _d(t2, e3, s3) {
    return { shape: t2, sets: e3 || [], options: s3 || this.defaultOptions };
  }
  line(t2, e3, s3, n2, a4) {
    const o2 = this._o(a4);
    return this._d("line", [y(t2, e3, s3, n2, o2)], o2);
  }
  rectangle(t2, e3, s3, n2, a4) {
    const o2 = this._o(a4), h2 = [], r2 = w(t2, e3, s3, n2, o2);
    if (o2.fill) {
      const a5 = [[t2, e3], [t2 + s3, e3], [t2 + s3, e3 + n2], [t2, e3 + n2]];
      "solid" === o2.fillStyle ? h2.push(S([a5], o2)) : h2.push(L([a5], o2));
    }
    return o2.stroke !== H && h2.push(r2), this._d("rectangle", h2, o2);
  }
  ellipse(t2, e3, s3, n2, a4) {
    const o2 = this._o(a4), h2 = [], r2 = P(s3, n2, o2), i2 = v(t2, e3, o2, r2);
    if (o2.fill) if ("solid" === o2.fillStyle) {
      const s4 = v(t2, e3, o2, r2).opset;
      s4.type = "fillPath", h2.push(s4);
    } else h2.push(L([i2.estimatedPoints], o2));
    return o2.stroke !== H && h2.push(i2.opset), this._d("ellipse", h2, o2);
  }
  circle(t2, e3, s3, n2) {
    const a4 = this.ellipse(t2, e3, s3, s3, n2);
    return a4.shape = "circle", a4;
  }
  linearPath(t2, e3) {
    const s3 = this._o(e3);
    return this._d("linearPath", [m(t2, false, s3)], s3);
  }
  arc(t2, e3, s3, n2, a4, o2, h2 = false, r2) {
    const i2 = this._o(r2), c4 = [], l2 = O(t2, e3, s3, n2, a4, o2, h2, true, i2);
    if (h2 && i2.fill) if ("solid" === i2.fillStyle) {
      const h3 = Object.assign({}, i2);
      h3.disableMultiStroke = true;
      const r3 = O(t2, e3, s3, n2, a4, o2, true, false, h3);
      r3.type = "fillPath", c4.push(r3);
    } else c4.push(function(t3, e4, s4, n3, a5, o3, h3) {
      const r3 = t3, i3 = e4;
      let c5 = Math.abs(s4 / 2), l3 = Math.abs(n3 / 2);
      c5 += A(0.01 * c5, h3), l3 += A(0.01 * l3, h3);
      let u2 = a5, p2 = o3;
      for (; u2 < 0; ) u2 += 2 * Math.PI, p2 += 2 * Math.PI;
      p2 - u2 > 2 * Math.PI && (u2 = 0, p2 = 2 * Math.PI);
      const f2 = (p2 - u2) / h3.curveStepCount, d2 = [];
      for (let t4 = u2; t4 <= p2; t4 += f2) d2.push([r3 + c5 * Math.cos(t4), i3 + l3 * Math.sin(t4)]);
      return d2.push([r3 + c5 * Math.cos(p2), i3 + l3 * Math.sin(p2)]), d2.push([r3, i3]), L([d2], h3);
    }(t2, e3, s3, n2, a4, o2, i2));
    return i2.stroke !== H && c4.push(l2), this._d("arc", c4, i2);
  }
  curve(t2, e3) {
    const s3 = this._o(e3), n2 = [], a4 = x(t2, s3);
    if (s3.fill && s3.fill !== H && t2.length >= 3) {
      const e4 = Q(function(t3, e6 = 0) {
        const s4 = t3.length;
        if (s4 < 3) throw new Error("A curve must have at least three points.");
        const n3 = [];
        if (3 === s4) n3.push(G(t3[0]), G(t3[1]), G(t3[2]), G(t3[2]));
        else {
          const s5 = [];
          s5.push(t3[0], t3[0]);
          for (let e7 = 1; e7 < t3.length; e7++) s5.push(t3[e7]), e7 === t3.length - 1 && s5.push(t3[e7]);
          const a5 = [], o2 = 1 - e6;
          n3.push(G(s5[0]));
          for (let t4 = 1; t4 + 2 < s5.length; t4++) {
            const e7 = s5[t4];
            a5[0] = [e7[0], e7[1]], a5[1] = [e7[0] + (o2 * s5[t4 + 1][0] - o2 * s5[t4 - 1][0]) / 6, e7[1] + (o2 * s5[t4 + 1][1] - o2 * s5[t4 - 1][1]) / 6], a5[2] = [s5[t4 + 1][0] + (o2 * s5[t4][0] - o2 * s5[t4 + 2][0]) / 6, s5[t4 + 1][1] + (o2 * s5[t4][1] - o2 * s5[t4 + 2][1]) / 6], a5[3] = [s5[t4 + 1][0], s5[t4 + 1][1]], n3.push(a5[1], a5[2], a5[3]);
          }
        }
        return n3;
      }(t2), 10, (1 + s3.roughness) / 2);
      "solid" === s3.fillStyle ? n2.push(S([e4], s3)) : n2.push(L([e4], s3));
    }
    return s3.stroke !== H && n2.push(a4), this._d("curve", n2, s3);
  }
  polygon(t2, e3) {
    const s3 = this._o(e3), n2 = [], a4 = m(t2, true, s3);
    return s3.fill && ("solid" === s3.fillStyle ? n2.push(S([t2], s3)) : n2.push(L([t2], s3))), s3.stroke !== H && n2.push(a4), this._d("polygon", n2, s3);
  }
  path(t2, e3) {
    const s3 = this._o(e3), n2 = [];
    if (!t2) return this._d("path", n2, s3);
    t2 = (t2 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a4 = s3.fill && "transparent" !== s3.fill && s3.fill !== H, o2 = s3.stroke !== H, h2 = !!(s3.simplification && s3.simplification < 1), r2 = function(t3, e4, s4) {
      const n3 = g2(d(f(t3))), a5 = [];
      let o3 = [], h3 = [0, 0], r3 = [];
      const i2 = () => {
        r3.length >= 4 && o3.push(...Q(r3, e4)), r3 = [];
      }, c4 = () => {
        i2(), o3.length && (a5.push(o3), o3 = []);
      };
      for (const { key: t4, data: e6 } of n3) switch (t4) {
        case "M":
          c4(), h3 = [e6[0], e6[1]], o3.push(h3);
          break;
        case "L":
          i2(), o3.push([e6[0], e6[1]]);
          break;
        case "C":
          if (!r3.length) {
            const t5 = o3.length ? o3[o3.length - 1] : h3;
            r3.push([t5[0], t5[1]]);
          }
          r3.push([e6[0], e6[1]]), r3.push([e6[2], e6[3]]), r3.push([e6[4], e6[5]]);
          break;
        case "Z":
          i2(), o3.push([h3[0], h3[1]]);
      }
      if (c4(), !s4) return a5;
      const l2 = [];
      for (const t4 of a5) {
        const e6 = V(t4, s4);
        e6.length && l2.push(e6);
      }
      return l2;
    }(t2, 1, h2 ? 4 - 4 * s3.simplification : (1 + s3.roughness) / 2);
    return a4 && ("solid" === s3.fillStyle ? n2.push(S(r2, s3)) : n2.push(L(r2, s3))), o2 && (h2 ? r2.forEach((t3) => {
      n2.push(m(t3, false, s3));
    }) : n2.push(function(t3, e4) {
      const s4 = g2(d(f(t3))), n3 = [];
      let a5 = [0, 0], o3 = [0, 0];
      for (const { key: t4, data: h3 } of s4) switch (t4) {
        case "M": {
          const t5 = 1 * (e4.maxRandomnessOffset || 0), s5 = e4.preserveVertices;
          n3.push({ op: "move", data: h3.map((n4) => n4 + (s5 ? 0 : A(t5, e4))) }), o3 = [h3[0], h3[1]], a5 = [h3[0], h3[1]];
          break;
        }
        case "L":
          n3.push(...I(o3[0], o3[1], h3[0], h3[1], e4)), o3 = [h3[0], h3[1]];
          break;
        case "C": {
          const [t5, s5, a6, r3, i2, c4] = h3;
          n3.push(...$(t5, s5, a6, r3, i2, c4, o3, e4)), o3 = [i2, c4];
          break;
        }
        case "Z":
          n3.push(...I(o3[0], o3[1], a5[0], a5[1], e4)), o3 = [a5[0], a5[1]];
      }
      return { type: "path", ops: n3 };
    }(t2, s3))), this._d("path", n2, s3);
  }
  opsToPath(t2, e3) {
    let s3 = "";
    for (const n2 of t2.ops) {
      const t3 = "number" == typeof e3 && e3 >= 0 ? n2.data.map((t4) => +t4.toFixed(e3)) : n2.data;
      switch (n2.op) {
        case "move":
          s3 += `M${t3[0]} ${t3[1]} `;
          break;
        case "bcurveTo":
          s3 += `C${t3[0]} ${t3[1]}, ${t3[2]} ${t3[3]}, ${t3[4]} ${t3[5]} `;
          break;
        case "lineTo":
          s3 += `L${t3[0]} ${t3[1]} `;
      }
    }
    return s3.trim();
  }
  toPaths(t2) {
    const e3 = t2.sets || [], s3 = t2.options || this.defaultOptions, n2 = [];
    for (const t3 of e3) {
      let e4 = null;
      switch (t3.type) {
        case "path":
          e4 = { d: this.opsToPath(t3), stroke: s3.stroke, strokeWidth: s3.strokeWidth, fill: H };
          break;
        case "fillPath":
          e4 = { d: this.opsToPath(t3), stroke: H, strokeWidth: 0, fill: s3.fill || H };
          break;
        case "fillSketch":
          e4 = this.fillSketch(t3, s3);
      }
      e4 && n2.push(e4);
    }
    return n2;
  }
  fillSketch(t2, e3) {
    let s3 = e3.fillWeight;
    return s3 < 0 && (s3 = e3.strokeWidth / 2), { d: this.opsToPath(t2), stroke: e3.fill || H, strokeWidth: s3, fill: H };
  }
};
var B = class {
  constructor(t2, e3) {
    this.canvas = t2, this.ctx = this.canvas.getContext("2d"), this.gen = new N(e3);
  }
  draw(t2) {
    const e3 = t2.sets || [], s3 = t2.options || this.getDefaultOptions(), n2 = this.ctx, a4 = t2.options.fixedDecimalPlaceDigits;
    for (const o2 of e3) switch (o2.type) {
      case "path":
        n2.save(), n2.strokeStyle = "none" === s3.stroke ? "transparent" : s3.stroke, n2.lineWidth = s3.strokeWidth, s3.strokeLineDash && n2.setLineDash(s3.strokeLineDash), s3.strokeLineDashOffset && (n2.lineDashOffset = s3.strokeLineDashOffset), this._drawToContext(n2, o2, a4), n2.restore();
        break;
      case "fillPath": {
        n2.save(), n2.fillStyle = s3.fill || "";
        const e4 = "curve" === t2.shape || "polygon" === t2.shape || "path" === t2.shape ? "evenodd" : "nonzero";
        this._drawToContext(n2, o2, a4, e4), n2.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(n2, o2, s3);
    }
  }
  fillSketch(t2, e3, s3) {
    let n2 = s3.fillWeight;
    n2 < 0 && (n2 = s3.strokeWidth / 2), t2.save(), s3.fillLineDash && t2.setLineDash(s3.fillLineDash), s3.fillLineDashOffset && (t2.lineDashOffset = s3.fillLineDashOffset), t2.strokeStyle = s3.fill || "", t2.lineWidth = n2, this._drawToContext(t2, e3, s3.fixedDecimalPlaceDigits), t2.restore();
  }
  _drawToContext(t2, e3, s3, n2 = "nonzero") {
    t2.beginPath();
    for (const n3 of e3.ops) {
      const e4 = "number" == typeof s3 && s3 >= 0 ? n3.data.map((t3) => +t3.toFixed(s3)) : n3.data;
      switch (n3.op) {
        case "move":
          t2.moveTo(e4[0], e4[1]);
          break;
        case "bcurveTo":
          t2.bezierCurveTo(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]);
          break;
        case "lineTo":
          t2.lineTo(e4[0], e4[1]);
      }
    }
    "fillPath" === e3.type ? t2.fill(n2) : t2.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(t2, e3, s3, n2, a4) {
    const o2 = this.gen.line(t2, e3, s3, n2, a4);
    return this.draw(o2), o2;
  }
  rectangle(t2, e3, s3, n2, a4) {
    const o2 = this.gen.rectangle(t2, e3, s3, n2, a4);
    return this.draw(o2), o2;
  }
  ellipse(t2, e3, s3, n2, a4) {
    const o2 = this.gen.ellipse(t2, e3, s3, n2, a4);
    return this.draw(o2), o2;
  }
  circle(t2, e3, s3, n2) {
    const a4 = this.gen.circle(t2, e3, s3, n2);
    return this.draw(a4), a4;
  }
  linearPath(t2, e3) {
    const s3 = this.gen.linearPath(t2, e3);
    return this.draw(s3), s3;
  }
  polygon(t2, e3) {
    const s3 = this.gen.polygon(t2, e3);
    return this.draw(s3), s3;
  }
  arc(t2, e3, s3, n2, a4, o2, h2 = false, r2) {
    const i2 = this.gen.arc(t2, e3, s3, n2, a4, o2, h2, r2);
    return this.draw(i2), i2;
  }
  curve(t2, e3) {
    const s3 = this.gen.curve(t2, e3);
    return this.draw(s3), s3;
  }
  path(t2, e3) {
    const s3 = this.gen.path(t2, e3);
    return this.draw(s3), s3;
  }
};
var J = "http://www.w3.org/2000/svg";
var K = class {
  constructor(t2, e3) {
    this.svg = t2, this.gen = new N(e3);
  }
  draw(t2) {
    const e3 = t2.sets || [], s3 = t2.options || this.getDefaultOptions(), n2 = this.svg.ownerDocument || window.document, a4 = n2.createElementNS(J, "g"), o2 = t2.options.fixedDecimalPlaceDigits;
    for (const h2 of e3) {
      let e4 = null;
      switch (h2.type) {
        case "path":
          e4 = n2.createElementNS(J, "path"), e4.setAttribute("d", this.opsToPath(h2, o2)), e4.setAttribute("stroke", s3.stroke), e4.setAttribute("stroke-width", s3.strokeWidth + ""), e4.setAttribute("fill", "none"), s3.strokeLineDash && e4.setAttribute("stroke-dasharray", s3.strokeLineDash.join(" ").trim()), s3.strokeLineDashOffset && e4.setAttribute("stroke-dashoffset", `${s3.strokeLineDashOffset}`);
          break;
        case "fillPath":
          e4 = n2.createElementNS(J, "path"), e4.setAttribute("d", this.opsToPath(h2, o2)), e4.setAttribute("stroke", "none"), e4.setAttribute("stroke-width", "0"), e4.setAttribute("fill", s3.fill || ""), "curve" !== t2.shape && "polygon" !== t2.shape || e4.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          e4 = this.fillSketch(n2, h2, s3);
      }
      e4 && a4.appendChild(e4);
    }
    return a4;
  }
  fillSketch(t2, e3, s3) {
    let n2 = s3.fillWeight;
    n2 < 0 && (n2 = s3.strokeWidth / 2);
    const a4 = t2.createElementNS(J, "path");
    return a4.setAttribute("d", this.opsToPath(e3, s3.fixedDecimalPlaceDigits)), a4.setAttribute("stroke", s3.fill || ""), a4.setAttribute("stroke-width", n2 + ""), a4.setAttribute("fill", "none"), s3.fillLineDash && a4.setAttribute("stroke-dasharray", s3.fillLineDash.join(" ").trim()), s3.fillLineDashOffset && a4.setAttribute("stroke-dashoffset", `${s3.fillLineDashOffset}`), a4;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(t2, e3) {
    return this.gen.opsToPath(t2, e3);
  }
  line(t2, e3, s3, n2, a4) {
    const o2 = this.gen.line(t2, e3, s3, n2, a4);
    return this.draw(o2);
  }
  rectangle(t2, e3, s3, n2, a4) {
    const o2 = this.gen.rectangle(t2, e3, s3, n2, a4);
    return this.draw(o2);
  }
  ellipse(t2, e3, s3, n2, a4) {
    const o2 = this.gen.ellipse(t2, e3, s3, n2, a4);
    return this.draw(o2);
  }
  circle(t2, e3, s3, n2) {
    const a4 = this.gen.circle(t2, e3, s3, n2);
    return this.draw(a4);
  }
  linearPath(t2, e3) {
    const s3 = this.gen.linearPath(t2, e3);
    return this.draw(s3);
  }
  polygon(t2, e3) {
    const s3 = this.gen.polygon(t2, e3);
    return this.draw(s3);
  }
  arc(t2, e3, s3, n2, a4, o2, h2 = false, r2) {
    const i2 = this.gen.arc(t2, e3, s3, n2, a4, o2, h2, r2);
    return this.draw(i2);
  }
  curve(t2, e3) {
    const s3 = this.gen.curve(t2, e3);
    return this.draw(s3);
  }
  path(t2, e3) {
    const s3 = this.gen.path(t2, e3);
    return this.draw(s3);
  }
};
var U = { canvas: (t2, e3) => new B(t2, e3), svg: (t2, e3) => new K(t2, e3), generator: (t2) => new N(t2), newSeed: () => N.newSeed() };

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/config.js
var defaultRouthThemeSpec = {
  maxRandomnessOffset: 3,
  roughness: 1,
  bowing: 1,
  curveFitting: 0.95,
  curveTightness: void 0,
  curveStepCount: 9,
  fillStyle: "hachure",
  fillWeight: void 0,
  hachureAngle: 60,
  hachureGap: 6,
  simplification: 0,
  dashOffset: void 0,
  dashGap: void 0,
  zigzagOffset: void 0,
  seed: 1,
  fillLineDash: void 0,
  fillLineDashOffset: void 0,
  disableMultiStroke: false,
  disableMultiStrokeFill: false,
  preserveVertices: true,
  fixedDecimalPlaceDigits: void 0
};

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-arc.js
var __decorate44 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata31 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasArcRender = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  draw(arc, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const arcAttribute = getTheme(arc).arc;
    let { x: x3 = arcAttribute.x, y: y3 = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const { dx = arcAttribute.dx, dy = arcAttribute.dy } = arc.attribute;
      x3 += dx, y3 += dy, context.setTransformForCurrent();
    } else x3 = 0, y3 = 0, context.transformFromMatrix(arc.transMatrix, true);
    const customPath = new CustomPath2D(), { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, lineWidth = arcAttribute.lineWidth, outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = arc.attribute;
    drawArcPath(arc, customPath, x3, y3, outerRadius, innerRadius), rc.path(customPath.toString(), {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasArcRender = __decorate44([injectable(), __param20(0, inject(DefaultCanvasArcRender)), __metadata31("design:paramtypes", [Object])], RoughCanvasArcRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-area.js
var __decorate45 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var RoughCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb) {
    if (fillCb) return super.drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawAreaSegments(customPath, cache, clipRange, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasAreaRender = __decorate45([injectable()], RoughCanvasAreaRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-circle.js
var __decorate46 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata32 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasCircleRender = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  draw(circle4, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), circleAttribute = getTheme(circle4).circle;
    let { x: x3 = circleAttribute.x, y: y3 = circleAttribute.y } = circle4.attribute;
    circle4.transMatrix.onlyTranslate() ? context.onlyTranslate() || context.clearMatrix() : (x3 = 0, y3 = 0, context.transformFromMatrix(circle4.transMatrix, true));
    const { radius = circleAttribute.radius, fill = circleAttribute.fill, stroke: stroke2 = circleAttribute.stroke, lineWidth = circleAttribute.lineWidth } = circle4.attribute;
    rc.circle(x3, y3, radius, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      fillStyle: "zigzag",
      roughness: 0.5
    });
  }
  drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasCircleRender = __decorate46([injectable(), __param21(0, inject(DefaultCanvasCircleRender)), __metadata32("design:paramtypes", [Object])], RoughCanvasCircleRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-line.js
var __decorate47 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var RoughCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb) {
    if (fillCb || strokeCb) return super.drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {}), customPath = new CustomPath2D();
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY
    });
    const { maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = attribute;
    let { fill: fillColor, stroke: strokeColor, lineWidth } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach((item) => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), false;
  }
};
RoughCanvasLineRender = __decorate47([injectable()], RoughCanvasLineRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-path.js
var __decorate48 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata33 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasPathRender = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  draw(path, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas, {});
    context.highPerformanceSave();
    const pathAttribute = getTheme(path).path;
    context.transformFromMatrix(path.transMatrix, true);
    const { fill = pathAttribute.fill, stroke: stroke2 = pathAttribute.stroke, lineWidth = pathAttribute.lineWidth, path: p2 = pathAttribute.path, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = path.attribute;
    "string" == typeof p2 && rc.path(p2, {
      fill: fill || void 0,
      stroke: stroke2 || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasPathRender = __decorate48([injectable(), __param22(0, inject(DefaultCanvasPathRender)), __metadata33("design:paramtypes", [Object])], RoughCanvasPathRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-rect.js
var __decorate49 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata34 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasRectRender = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  draw(rect, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const rectAttribute = getTheme(rect).rect;
    let { x: x3 = rectAttribute.x, y: y3 = rectAttribute.y } = rect.attribute;
    if (rect.transMatrix.onlyTranslate()) {
      const { dx = rectAttribute.dx, dy = rectAttribute.dy } = rect.attribute;
      x3 += dx, y3 += dy, context.setTransformForCurrent();
    } else x3 = 0, y3 = 0, context.transformFromMatrix(rect.transMatrix, true);
    const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, fillColor = rectAttribute.fill, strokeColor = rectAttribute.stroke, x1: x14, y1: y14, lineWidth = rectAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = rect.attribute;
    let { width = rectAttribute.width, height = rectAttribute.height } = rect.attribute;
    width = (null != width ? width : x14 - x3) || 0, height = (null != height ? height : y14 - y3) || 0, rc.rectangle(x3, y3, width, height, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasRectRender = __decorate49([injectable(), __param23(0, inject(DefaultCanvasRectRender)), __metadata34("design:paramtypes", [Object])], RoughCanvasRectRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/rough-symbol.js
var __decorate50 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata35 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RoughCanvasSymbolRender = class extends BaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE, this.style = "rough";
  }
  draw(symbol, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas, rc = U.canvas(canvas);
    context.highPerformanceSave();
    const symbolAttribute = getTheme(symbol).symbol, data = this.transform(symbol, symbolAttribute, context), { x: x3, y: y3, z: z2, lastModelMatrix } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const { fill = symbolAttribute.fill, stroke: stroke2 = symbolAttribute.stroke, fillColor = symbolAttribute.fill, strokeColor = symbolAttribute.stroke, size = symbolAttribute.size, lineWidth = symbolAttribute.lineWidth, maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset, roughness = defaultRouthThemeSpec.roughness, bowing = defaultRouthThemeSpec.bowing, curveFitting = defaultRouthThemeSpec.curveFitting, curveTightness = defaultRouthThemeSpec.curveTightness, curveStepCount = defaultRouthThemeSpec.curveStepCount, fillStyle = defaultRouthThemeSpec.fillStyle, fillWeight = defaultRouthThemeSpec.fillWeight, hachureAngle = defaultRouthThemeSpec.hachureAngle, hachureGap = defaultRouthThemeSpec.hachureGap, simplification = defaultRouthThemeSpec.simplification, dashOffset = defaultRouthThemeSpec.dashOffset, dashGap = defaultRouthThemeSpec.dashGap, zigzagOffset = defaultRouthThemeSpec.zigzagOffset, seed = defaultRouthThemeSpec.seed, fillLineDash = defaultRouthThemeSpec.fillLineDash, fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset, disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke, disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill, preserveVertices = defaultRouthThemeSpec.preserveVertices, fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits } = symbol.attribute;
    let svgPath = "";
    if (parsedPath.drawToSvgPath) svgPath = parsedPath.drawToSvgPath(size, x3, y3);
    else {
      const customPath = new CustomPath2D();
      parsedPath.draw(customPath, size, x3, y3) && customPath.closePath(), svgPath = customPath.toString();
    }
    rc.path(svgPath, {
      fill: fill ? fillColor : void 0,
      stroke: stroke2 ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset,
      roughness,
      bowing,
      curveFitting,
      curveTightness,
      curveStepCount,
      fillStyle,
      fillWeight,
      hachureAngle,
      hachureGap,
      simplification,
      dashOffset,
      dashGap,
      zigzagOffset,
      seed,
      fillLineDash,
      fillLineDashOffset,
      disableMultiStroke,
      disableMultiStrokeFill,
      preserveVertices,
      fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x3, y3, drawContext, params2, fillCb, strokeCb);
  }
};
RoughCanvasSymbolRender = __decorate50([injectable(), __param24(0, inject(DefaultCanvasSymbolRender)), __metadata35("design:paramtypes", [Object])], RoughCanvasSymbolRender);

// node_modules/@visactor/vrender-kits/es/render/contributions/rough/module.js
var module_default2 = new ContainerModule((bind) => {
  bind(RoughCanvasCircleRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasCircleRender), bind(RoughCanvasRectRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasRectRender), bind(RoughCanvasPathRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasPathRender), bind(RoughCanvasSymbolRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasSymbolRender), bind(RoughCanvasLineRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasLineRender), bind(RoughCanvasAreaRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasAreaRender), bind(RoughCanvasArcRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasArcRender);
});

// node_modules/@visactor/vrender-kits/es/jsx/graphicType.js
var REACT_TO_CANOPUS_EVENTS = {
  onPointerDown: "pointerdown",
  onPointerUp: "pointerup",
  onPointerUpOutside: "pointerupoutside",
  onPointerTap: "pointertap",
  onPointerOver: "pointerover",
  onPointerMove: "pointermove",
  onPointerEnter: "pointerenter",
  onPointerLeave: "pointerleave",
  onPointerOut: "pointerout",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onMouseUpOutside: "mouseupoutside",
  onMouseMove: "mousemove",
  onMouseOver: "mouseover",
  onMouseOut: "mouseout",
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave",
  onPinch: "pinch",
  onPinchStart: "pinchstart",
  onPinchEnd: "pinchend",
  onPan: "pan",
  onPanStart: "panstart",
  onPanEnd: "panend",
  onDrag: "drag",
  onDragStart: "dragstart",
  onDragEnter: "dragenter",
  onDragLeave: "dragleave",
  onDragOver: "dragover",
  onDragEnd: "dragend",
  onRightDown: "rightdown",
  onRightUp: "rightup",
  onRightUpOutside: "rightupoutside",
  onTouchStart: "touchstart",
  onTouchEnd: "touchend",
  onTouchEndOutside: "touchendoutside",
  onTouchMove: "touchmove",
  onTouchCancel: "touchcancel",
  onPress: "press",
  onPressUp: "pressup",
  onPressEnd: "pressend",
  onSwipe: "swipe",
  onDrop: "drop",
  onWeel: "wheel",
  onClick: "click",
  onDblClick: "dblclick"
};
var REACT_TO_CANOPUS_EVENTS_LIST = Object.keys(REACT_TO_CANOPUS_EVENTS);
function VRichText(params2) {
  return graphicCreator.richtext(params2 ? params2.attribute : {});
}
VRichText.Text = function(params2) {
  return Object.assign({
    type: "rich/text"
  }, params2);
}, VRichText.Image = function(params2) {
  return Object.assign({
    type: "rich/image"
  }, params2);
};

// node_modules/@visactor/vrender-kits/es/event/extension/drag.js
var DragNDrop = class {
  constructor(rootNode) {
    this.onPointerDown = (event) => {
      const target = event.target, rootNode2 = this.rootNode, isRoot = target === rootNode2;
      if (target && !isRoot) {
        let handlePointerMove = function(moveEvent) {
          if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), dragstartTriggered = true), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), !isRoot) {
            target.pickable = false;
            const elemBelow = (null == rootNode2 ? void 0 : rootNode2.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
            target.pickable = true, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
          }
        };
        let currentDroppable, dragstartTriggered = false;
        null == rootNode2 || rootNode2.addEventListener("pointermove", handlePointerMove);
        const stopDragging = function() {
          dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), dragstartTriggered = false), null == rootNode2 || rootNode2.removeEventListener("pointermove", handlePointerMove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: true
        }), target.addEventListener("pointerupoutside", stopDragging, {
          once: true
        });
      }
    }, this.rootNode = rootNode, this.initEvents();
  }
  initEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
  }
  removeEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
  }
  release() {
    this.removeEvents(), this.rootNode = null;
  }
};

// node_modules/@visactor/vrender-kits/es/event/extension/gesture.js
var calcDirection = (start, end) => {
  const xDistance = end.x - start.x, yDistance = end.y - start.y;
  return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
};
var calcDistance = (point1, point22) => {
  const xDistance = Math.abs(point22.x - point1.x), yDistance = Math.abs(point22.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter = (points) => {
  const pointersLength = points.length;
  if (1 === pointersLength) return {
    x: Math.round(points[0].x),
    y: Math.round(points[0].y)
  };
  let x3 = 0, y3 = 0, i2 = 0;
  for (; i2 < pointersLength; ) x3 += points[i2].x, y3 += points[i2].y, i2++;
  return {
    x: Math.round(x3 / pointersLength),
    y: Math.round(y3 / pointersLength)
  };
};
var Gesture = class extends import_eventemitter3.default {
  constructor(element, config2 = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = (ev) => {
      this.reset(), this.startTime = clock.now();
      const { cachedEvents, startPoints } = this;
      ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
      for (let i2 = 0; i2 < cachedEvents.length; i2++) {
        const { x: x3, y: y3 } = cachedEvents[i2], point6 = {
          x: x3,
          y: y3
        };
        startPoints[i2] = point6;
      }
      if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter([startPoints[0], startPoints[1]]);
      else {
        const event = cachedEvents[0];
        this.pressTimeout = setTimeout(() => {
          event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", this.direction = "none";
        }, this.config.press.time);
      }
    }, this.onMove = (ev) => {
      this.clearPressTimeout();
      const { startPoints, cachedEvents } = this;
      if (!startPoints.length) return;
      const moveEvent = ev.clone(), { x: x3, y: y3, pointerId } = moveEvent;
      for (let i2 = 0, len = cachedEvents.length; i2 < len; i2++) if (pointerId === cachedEvents[i2].pointerId) {
        cachedEvents[i2] = moveEvent;
        break;
      }
      const point6 = {
        x: x3,
        y: y3
      }, points = cachedEvents.map((cachedEvent) => ({
        x: cachedEvent.x,
        y: cachedEvent.y
      })), now = clock.now();
      if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point6, 1 === startPoints.length) {
        const startPoint = startPoints[0], deltaX = x3 - startPoint.x, deltaY = y3 - startPoint.y, direction2 = this.direction || calcDirection(startPoint, point6);
        this.direction = direction2;
        const eventType = this.getEventType(point6);
        return moveEvent.direction = direction2, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
      }
      const { startDistance } = this, currentDistance = calcDistance(points[0], points[1]);
      moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
    }, this.onEnd = (ev) => {
      const endEvent = ev.clone(), { cachedEvents, startPoints } = this, points = cachedEvents.map((ev2) => ({
        x: ev2.x,
        y: ev2.y
      }));
      if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
        const now = clock.now(), lastMoveTime = this.lastMoveTime;
        if (now - lastMoveTime < 100) {
          const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
          if (intervalTime > 0) {
            const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance2 = calcDistance(prevMovePoint, lastMovePoint), velocity = distance2 / intervalTime;
            velocity > this.config.swipe.velocity && distance2 > this.config.swipe.threshold && (endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent));
          }
        }
        now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0);
      }
      for (let i2 = 0, len = cachedEvents.length; i2 < len; i2++) if (cachedEvents[i2].pointerId === endEvent.pointerId) {
        cachedEvents.splice(i2, 1), startPoints.splice(i2, 1);
        break;
      }
      this.reset(), cachedEvents.length > 0 && this.onStart();
    }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
      press: {
        time: null !== (_b = null === (_a = null == config2 ? void 0 : config2.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
        threshold: null !== (_d = null === (_c = null == config2 ? void 0 : config2.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
      },
      swipe: {
        threshold: null !== (_f = null === (_e = null == config2 ? void 0 : config2.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
        velocity: null !== (_h = null === (_g = null == config2 ? void 0 : config2.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : 0.3
      },
      tap: {
        interval: null !== (_k = null === (_j = null == config2 ? void 0 : config2.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
      }
    }, this.initEvents();
  }
  initEvents() {
    const { element } = this;
    element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
  }
  removeEvents() {
    const { element } = this;
    element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
  }
  release() {
    this.removeEvents(), this.element = null;
  }
  getEventType(point6) {
    const { eventType, startTime, startPoints } = this;
    if (eventType) return eventType;
    let type;
    return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point6) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
  }
  enable(eventType) {
    this.processEvent[eventType] = true;
  }
  isProcess(eventType) {
    return this.processEvent[eventType];
  }
  pushEvent(type, ev) {
    const { emitThrottles } = this, newEvent = {
      type,
      ev
    };
    for (let i2 = 0, len = emitThrottles.length; i2 < len; i2++) if (emitThrottles[i2].type === type) return void emitThrottles.splice(i2, 1, newEvent);
    emitThrottles.push(newEvent);
  }
  clearPressTimeout() {
    this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
  }
  reset() {
    this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
  }
  triggerEvent(type, ev) {
    this.pushEvent(type, ev);
    const { throttleTimer, emitThrottles } = this;
    throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
      for (let i2 = 0, len = emitThrottles.length; i2 < len; i2++) {
        const { type: type2, ev: ev2 } = emitThrottles[i2];
        this.emitEvent(type2, ev2);
      }
      this.throttleTimer = 0, this.emitThrottles.length = 0;
    }));
  }
  triggerStartEvent(type, ev) {
    this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
  }
  triggerEndEvent(ev) {
    const processEvent = this.processEvent;
    Object.keys(processEvent).forEach((type) => {
      this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
    });
  }
  emitEvent(type, e3) {
    const listeners = this.element._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e3, type);
    else for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e3.propagationImmediatelyStopped; i2++) listeners[i2].fn.call(listeners[i2].context, e3, type);
    this.emit(type, e3);
  }
};

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/context.js
var __decorate51 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata36 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var outP = [0, 0, 0];
var initMatrix2 = new Matrix(1, 0, 0, 1, 0, 0);
var addArcToBezierPath2 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
  if (clockwise) for (; endAngle > startAngle; ) endAngle -= pi2;
  else for (; endAngle < startAngle; ) endAngle += pi2;
  const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
  let sa = startAngle, ea = sa;
  for (; ea !== endAngle; ) {
    ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
    const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c22 = Math.cos(ea), s22 = Math.sin(ea), x14 = c1 * rx + cx, y14 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s22 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push([x14 - hx * s1, y14 + hy * c1, x4 + hx * s22, y4 - hy * c22, x4, y4]), sa = ea;
  }
};
var BrowserContext2d = class {
  set fillStyle(d2) {
    this.nativeContext.fillStyle = d2;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(d2) {
    this.nativeContext.font = d2;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(d2) {
    this.nativeContext.globalAlpha = d2;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(d2) {
    this.nativeContext.lineCap = d2;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(d2) {
    this.nativeContext.lineDashOffset = d2;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(d2) {
    this.nativeContext.lineJoin = d2;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(d2) {
    this.nativeContext.lineWidth = d2;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(d2) {
    this.nativeContext.miterLimit = d2;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(d2) {
    this.nativeContext.shadowBlur = d2;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(d2) {
    this.nativeContext.shadowColor = d2;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(d2) {
    this.nativeContext.shadowOffsetX = d2;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(d2) {
    this.nativeContext.shadowOffsetY = d2;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(d2) {
    this.nativeContext.strokeStyle = d2;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(d2) {
    this.nativeContext.textAlign = d2;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(d2) {
    this.nativeContext.textBaseline = d2;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(use) {
    use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
  }
  constructor(canvas, dpr) {
    this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1
    }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
      opacity: 1
    }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
      opacity: 1
    }), this._clearShadowStyle = false, this._clearFilterStyle = false, this._clearGlobalCompositeOperationStyle = false;
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  reset() {
    this.stack.length && Logger.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m5) {
    return matrixAllocate.allocateByObj(m5);
  }
  clear() {
    this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
  }
  restore() {
    this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(true));
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix), this.nativeContext.save();
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a4, b2, c4, d2, e3, f2, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a4, dpr * b2, dpr * c4, dpr * d2, dpr * e3, dpr * f2), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a4, b2, c4, d2, e3, f2, setTransform = true) {
    this.matrix.multiply(a4, b2, c4, d2, e3, f2), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x3, y3, setTransform = true) {
    this.matrix.translate(x3, y3), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x3, y3, setTransform = true) {
    this.translate(x3, y3, false), this.rotate(rad, false), this.translate(-x3, -y3, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x3, y3, setTransform = true) {
    this.translate(x3, y3, false), this.rotateDegrees(deg, false), this.translate(-x3, -y3, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(path, fillRule) {
    path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
  }
  arc(x3, y3, radius, startAngle, endAngle, anticlockwise, z2) {
    if (z2 = z2 || 0, this.camera) {
      const arr = [];
      addArcToBezierPath2(arr, startAngle, endAngle, x3, y3, radius, radius, anticlockwise);
      for (let i2 = 0; i2 < arr.length; ++i2) {
        const bez = arr[i2];
        this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z2);
      }
    } else this.nativeContext.arc(x3, y3, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x14, y14, x23, y23, radiusX) {
    this.nativeContext.arcTo(x14, y14, x23, y23, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      let cp1z = z2, cp2z = z2;
      this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z2], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z2], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      let data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
    }
    this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(x3, y3, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    null == anticlockwise ? this.nativeContext.ellipse(x3, y3, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x3, y3, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  lineTo(x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      const data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y;
    }
    this.nativeContext.lineTo(x3, y3);
  }
  moveTo(x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      const data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y;
    }
    this.nativeContext.moveTo(x3, y3);
  }
  quadraticCurveTo(cpx, cpy, x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      let cpz = z2;
      this.modelMatrix && (transformMat4(outP, [cpx, cpy, z2], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      let data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
    }
    this.nativeContext.quadraticCurveTo(cpx, cpy, x3, y3);
  }
  rect(x3, y3, w2, h2, z2) {
    z2 = z2 || 0, this.camera ? (this.moveTo(x3, y3, z2), this.lineTo(x3 + w2, y3, z2), this.lineTo(x3 + w2, y3 + h2, z2), this.lineTo(x3, y3 + h2, z2), this.closePath()) : this.nativeContext.rect(x3, y3, w2, h2);
  }
  createImageData() {
    const a4 = arguments;
    return 2 === a4.length ? this.nativeContext.createImageData(a4[0], a4[1]) : 1 === a4.length ? this.nativeContext.createImageData(a4[0]) : null;
  }
  createLinearGradient(x05, y05, x14, y14) {
    return this.nativeContext.createLinearGradient(x05, y05, x14, y14);
  }
  createPattern(image, repetition) {
    return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
  }
  createRadialGradient(x05, y05, r0, x14, y14, r1) {
    return this.nativeContext.createRadialGradient(x05, y05, r0, x14, y14, r1);
  }
  createConicGradient(x3, y3, startAngle, endAngle) {
    let pattern, edit = false;
    const ctx = this;
    return {
      stops: [],
      addColorStop(offset, color) {
        this.stops.push([offset, color]), edit = true;
      },
      GetPattern(minW, minH, deltaAngle) {
        return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x3, y3, deltaAngle, startAngle, endAngle, minW, minH), edit = false), pattern;
      }
    };
  }
  fill(path, fillRule) {
    this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
  }
  fillRect(x3, y3, width, height) {
    this.nativeContext.fillRect(x3, y3, width, height);
  }
  clearRect(x3, y3, w2, h2) {
    this.nativeContext.clearRect(x3, y3, w2, h2);
  }
  project(x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      const data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y;
    }
    return {
      x: x3,
      y: y3
    };
  }
  view(x3, y3, z2) {
    return z2 = z2 || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]), this.camera.view(x3, y3, z2)) : [x3, y3, z2];
  }
  fillText(text2, x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      const data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y;
    }
    this.nativeContext.fillText(text2, x3, y3);
  }
  getImageData(sx, sy, sw, sh) {
    return this.nativeContext.getImageData(sx, sy, sw, sh);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(x3, y3) {
    return this.nativeContext.isPointInPath(x3, y3);
  }
  isPointInStroke(x3, y3) {
    return this.nativeContext.isPointInStroke(x3, y3);
  }
  measureText(text2, method = application.global.measureTextMethod) {
    var _a, _b;
    if (!method || "native" === method) return this.nativeContext.measureText(text2);
    this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
    const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily, fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
    return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text2, method);
  }
  putImageData(imagedata, dx, dy) {
    this.nativeContext.putImageData(imagedata, dx, dy);
  }
  setLineDash(segments2) {
    const a4 = arguments, _context = this.nativeContext;
    this.nativeContext.setLineDash ? _context.setLineDash(a4[0]) : "mozDash" in _context ? _context.mozDash = a4[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a4[0]);
  }
  stroke(path) {
    this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
  }
  strokeRect(x3, y3, width, height) {
    this.nativeContext.strokeRect(x3, y3, width, height);
  }
  strokeText(text2, x3, y3, z2) {
    if (z2 = z2 || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x3, y3, z2], this.modelMatrix), x3 = outP[0], y3 = outP[1], z2 = outP[2]);
      const data = this.camera.vp(x3, y3, z2);
      x3 = data.x, y3 = data.y;
    }
    this.nativeContext.strokeText(text2, x3, y3);
  }
  drawImage() {
    const _context = this.nativeContext, a4 = arguments;
    3 === a4.length ? _context.drawImage(a4[0], a4[1], a4[2]) : 5 === a4.length ? _context.drawImage(a4[0], a4[1], a4[2], a4[3], a4[4]) : 9 === a4.length && _context.drawImage(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8]);
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p2, i2) => {
        0 !== i2 && Object.assign(dp, p2);
      }), this._setCommonStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 ? (_context.globalAlpha = fillOpacity * opacity, _context.fillStyle = createColor(this, fill, params2, offsetX, offsetY)) : _context.globalAlpha = fillOpacity * opacity;
  }
  setShadowBlendStyle(params2, attribute, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setShadowBlendStyle(params2, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p2, i2) => {
        0 !== i2 && Object.assign(dp, p2);
      }), this._setShadowBlendStyle(params2, attribute, dp);
    }
    return this._setShadowBlendStyle(params2, attribute, defaultParams);
  }
  _setShadowBlendStyle(params2, attribute, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { opacity = defaultParams.opacity, shadowBlur = defaultParams.shadowBlur, shadowColor = defaultParams.shadowColor, shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY = defaultParams.shadowOffsetY, blur = defaultParams.blur, globalCompositeOperation = defaultParams.globalCompositeOperation } = attribute;
    opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = true) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = true) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = false), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = true) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = false));
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p2, i2) => {
        0 !== i2 && Object.assign(dp, p2);
      }), this._setStrokeStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
      _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, _context.setLineDash(lineDash), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z2) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z2));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z2) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams, this.camera && this.camera.getProjectionScale(z2));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix2, setTransform, dpr);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m5) => matrixAllocate.free(m5)), this.stack.length = 0;
  }
};
BrowserContext2d.env = "browser", BrowserContext2d = __decorate51([injectable(), __metadata36("design:paramtypes", [Object, Number])], BrowserContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/canvas.js
var __decorate52 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata37 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var BrowserCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init(params2) {
    const { container: container2 } = params2;
    if ("string" == typeof container2) {
      const _c = application.global.getElementById(container2);
      _c && (this._container = _c);
    } else this._container = container2;
    this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
  }
  initStyle() {
    if (!this.controled) return;
    const { nativeCanvas } = this;
    nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const canvas = this._nativeCanvas;
    canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
  }
  resetStyle(params2) {
    if (!this.controled) return;
    const { width = this._displayWidth, height = this._displayHeight, dpr = this._dpr, x: x3 = this._x, y: y3 = this._y } = params2, { nativeCanvas } = this;
    nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x3, y3, width, height), params2.id && (nativeCanvas.id = params2.id), this.visiable || this.hide();
  }
  setCanvasStyle(canvas, x3, y3, w2, h2) {
    this.controled && (canvas.style.width = `${w2}px`, canvas.style.height = `${h2}px`);
  }
  toDataURL(mimeType, quality) {
    return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
  }
  resize(width, height) {
    if (!this.controled) return;
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
    this._context.dpr = this._dpr;
  }
};
BrowserCanvas.env = "browser", BrowserCanvas = __decorate52([injectable(), __metadata37("design:paramtypes", [Object])], BrowserCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/create-canvas-module.js
function createModule(CanvasConstructor, ContextConstructor) {
  return new ContainerModule((bind) => {
    bind(CanvasFactory).toDynamicValue(() => (params2) => new CanvasConstructor(params2)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params2, dpr) => new ContextConstructor(params2, dpr)).whenTargetNamed(ContextConstructor.env);
  });
}

// node_modules/@visactor/vrender-kits/es/canvas/contributions/browser/modules.js
var browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

// node_modules/@visactor/vrender-kits/es/picker/contributions/constants.js
var MathPickerContribution = Symbol.for("MathPickerContribution");
var MathArcPicker = Symbol.for("MathArcPicker");
var MathAreaPicker = Symbol.for("MathAreaPicker");
var MathCirclePicker = Symbol.for("MathCirclePicker");
var MathImagePicker = Symbol.for("MathImagePicker");
var MathLinePicker = Symbol.for("MathLinePicker");
var MathPathPicker = Symbol.for("MathPathPicker");
var MathRectPicker = Symbol.for("MathRectPicker");
var MathSymbolPicker = Symbol.for("MathSymbolPicker");
var MathTextPicker = Symbol.for("MathTextPicker");
var MathPolygonPicker = Symbol.for("MathPolygonPicker");
var MathGlyphPicker = Symbol.for("MathGlyphPicker");
var CanvasArcPicker = Symbol.for("CanvasArcPicker");
var CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
var CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
var CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
var CanvasImagePicker = Symbol.for("CanvasImagePicker");
var CanvasLinePicker = Symbol.for("CanvasLinePicker");
var CanvasPathPicker = Symbol.for("CanvasPathPicker");
var CanvasRectPicker = Symbol.for("CanvasRectPicker");
var CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
var CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
var CanvasTextPicker = Symbol.for("CanvasTextPicker");
var CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
var CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
var CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
var CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker");
var CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
var CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

// node_modules/@visactor/vrender-kits/es/picker/canvas-picker-service.js
var __decorate53 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata38 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(contributions, drawContribution, pickItemInterceptorContributions) {
    super(pickItemInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_2, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    if (this.InterceptorContributions.length) for (let i2 = 0; i2 < this.InterceptorContributions.length; i2++) {
      const drawContribution = this.InterceptorContributions[i2];
      if (drawContribution.beforePickItem) {
        const ret = drawContribution.beforePickItem(graphic, this, point6, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const g3 = picker.contains(graphic, point6, params2) ? graphic : null, data = {
      graphic: g3
    };
    if (g3) return data;
    if (this.InterceptorContributions.length) for (let i2 = 0; i2 < this.InterceptorContributions.length; i2++) {
      const drawContribution = this.InterceptorContributions[i2];
      if (drawContribution.afterPickItem) {
        const ret = drawContribution.afterPickItem(graphic, this, point6, params2, {
          parentMatrix
        });
        if (ret) return ret;
      }
    }
    return data;
  }
};
DefaultCanvasPickerService = __decorate53([injectable(), __param25(0, inject(ContributionProvider)), __param25(0, named(CanvasPickerContribution)), __param25(1, inject(DrawContribution)), __param25(2, inject(ContributionProvider)), __param25(2, named(PickItemInterceptor)), __metadata38("design:paramtypes", [Object, Object, Object])], DefaultCanvasPickerService);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/group-picker.js
var __decorate54 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasGroupPicker = class {
  constructor() {
    this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
  }
  contains(group, point6, params2) {
    return false;
  }
};
DefaultCanvasGroupPicker = __decorate54([injectable()], DefaultCanvasGroupPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/module.js
var m2 = new ContainerModule((bind, unbind, isBound, rebind) => {
  m2.__vloaded || (m2.__vloaded = true, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
});
m2.__vloaded = false;
var module_default3 = m2;

// node_modules/@visactor/vrender-kits/es/picker/canvas-module.js
var canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
});
function loadCanvasPicker(c4) {
  c4.load(module_default3), c4.load(canvasPickerModule);
}

// node_modules/@visactor/vrender-kits/es/window/contributions/browser-contribution.js
var BrowserWindowHandlerContribution_1;
var __decorate55 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata39 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
  get container() {
    return this.canvas.nativeCanvas.parentElement;
  }
  static GenerateCanvasId() {
    return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
  }
  constructor() {
    super(), this.type = "browser", this._canvasIsIntersecting = true, this.global = application.global;
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return this.canvas.nativeCanvas.getBoundingClientRect();
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2), this.postInit();
  }
  postInit() {
    if (this.global.optimizeVisible) try {
      this.observerCanvas();
    } catch (err) {
      console.error("发生错误，该环境不存在IntersectionObserver");
    }
  }
  isElementVisible(el) {
    const rect = el.getBoundingClientRect(), vWidth = window.innerWidth || document.documentElement.clientWidth, vHeight = window.innerHeight || document.documentElement.clientHeight;
    return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
  }
  observerCanvas() {
    this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
    const observer = new IntersectionObserver((entries, observer2) => {
      entries.forEach((entry) => {
        this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
      });
    });
    observer && observer.observe(this.canvas.nativeCanvas);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    });
    let container2;
    if (container2 = "string" == typeof params2.container ? this.global.getElementById(params2.container) : params2.container ? params2.container : this.global.getRootElement(), !container2) throw new Error("发生错误，containerId可能传入有误");
    params2.offscreen ? container2 = null : container2.appendChild(nativeCanvas);
    const options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      container: container2,
      id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
      canvasControled: true
    };
    this.canvas = new BrowserCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    if (!canvas) throw new Error("发生错误，传入的canvas不正确");
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    if (null == dpr) {
      dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
    }
    this.canvas = new BrowserCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this.canvas.nativeCanvas.dispatchEvent(event);
  }
  getStyle() {
    return this.canvas.nativeCanvas.style;
  }
  setStyle(style) {
    this.canvas.nativeCanvas.style = style;
  }
  getBoundingClientRect() {
    const c4 = this.canvas.nativeCanvas, wh = this.getWH();
    return c4.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(vb, color) {
    const context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
  isVisible(bbox) {
    return this._canvasIsIntersecting;
  }
  onVisibleChange(cb) {
    this._onVisibleChangeCb = cb;
  }
  getTopLeft(baseWindow) {
    return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
  }
};
BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate55([injectable(), __metadata39("design:paramtypes", [])], BrowserWindowHandlerContribution);
var browserWindowModule = new ContainerModule((bind) => {
  bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/browser-contribution.js
var __decorate56 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata40 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var DynamicB = class {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(dom) {
    this.dom = dom;
  }
};
function createImageElement(src, isSvg2 = false) {
  const img = document.createElement("img");
  if (img.crossOrigin = "anonymous", isSvg2) {
    const data = new Blob([src], {
      type: "image/svg+xml"
    });
    src = window.URL.createObjectURL(data);
  }
  if (img.src = src, img.complete) return Promise.resolve(img);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "browser", this.supportEvent = true;
    try {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsTouchEvents = false, this.supportsPointerEvents = false, this.supportsPointerEvents = false;
    }
    this.applyStyles = true;
  }
  mapToCanvasPoint(nativeEvent, domElement) {
    var _a;
    if (domElement) {
      const { clientX: x3, clientY: y3 } = nativeEvent, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_a = domElement.getNativeHandler) || void 0 === _a ? void 0 : _a.call(domElement).nativeCanvas;
      let scaleX, scaleY;
      return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
        x: (x3 - rect.left) / (isValidNumber_default(scaleX) ? scaleX : 1),
        y: (y3 - rect.top) / (isValidNumber_default(scaleY) ? scaleY : 1)
      };
    }
    return {
      x: nativeEvent.offsetX,
      y: nativeEvent.offsetY
    };
  }
  getNativeAABBBounds(_dom) {
    let dom = _dom;
    if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
      const b2 = dom.getBoundingClientRect();
      return new DynamicB(b2);
    }
    return new AABBBounds();
  }
  removeDom(dom) {
    return dom.parentElement.removeChild(dom), true;
  }
  createDom(params2) {
    const { tagName = "div", width, height, style, parent } = params2, element = document.createElement(tagName);
    if (style && (isString_default(style) ? element.setAttribute("style", style) : Object.keys(style).forEach((k3) => {
      element.setAttribute(k3, style[k3]);
    })), null != width && (element.style.width = `${width}px`), null != height && (element.style.height = `${height}px`), parent) {
      const pd = isString_default(parent) ? this.getElementById(parent) : parent;
      pd && pd.appendChild && pd.appendChild(element);
    }
    return element;
  }
  loadImage(url) {
    return createImageElement(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return createImageElement(url, true).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  createCanvas(params2) {
    var _a, _b;
    const canvas = document.createElement("canvas");
    params2.id && (canvas.id = null !== (_a = params2.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
    const dpr = null !== (_b = params2.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
    return params2.width && params2.height && (canvas.style.width = `${params2.width}px`, canvas.style.height = `${params2.height}px`, canvas.width = params2.width * dpr, canvas.height = params2.height * dpr), canvas;
  }
  createOffscreenCanvas(params2) {
    var _a;
    const dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
    return new OffscreenCanvas(params2.width * dpr, params2.height * dpr);
  }
  releaseCanvas(canvas) {
    let c4;
    c4 = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c4 && c4.parentElement && c4.parentElement.removeChild(c4);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return document.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return document.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return document.dispatchEvent(event);
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release(...params2) {
  }
  getElementTop(element, baseWindow) {
    let actualTop = element.offsetTop, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, current = current.offsetParent;
    return actualTop;
  }
  getElementLeft(element, baseWindow) {
    let actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualLeft += current.offsetLeft, current = current.offsetParent;
    return actualLeft;
  }
  getElementTopLeft(element, baseWindow) {
    let actualTop = element.offsetTop, actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; ) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
    return {
      top: actualTop,
      left: actualLeft
    };
  }
};
BrowserEnvContribution = __decorate56([injectable(), __metadata40("design:paramtypes", [])], BrowserEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/browser.js
var browserEnvModule = new ContainerModule((bind) => {
  browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = true, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
});
browserEnvModule.isBrowserBound = false;
function loadBrowserEnv(container2, loadPicker = true) {
  loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = true, container2.load(browserEnvModule), container2.load(browserCanvasModule), container2.load(browserWindowModule), loadPicker && loadCanvasPicker(container2));
}
loadBrowserEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/context.js
var __decorate57 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var FeishuContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
  }
  getImageData(sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      var _a;
      try {
        tt.canvasGetImageData({
          canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,
          x: sx,
          y: sy,
          width: sw,
          height: sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
  createPattern(image, repetition) {
    return null;
  }
};
FeishuContext2d.env = "feishu", FeishuContext2d = __decorate57([injectable()], FeishuContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/canvas.js
var __decorate58 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata41 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var FeishuCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new FeishuContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
FeishuCanvas.env = "feishu", FeishuCanvas = __decorate58([injectable(), __metadata41("design:paramtypes", [Object])], FeishuCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/feishu/modules.js
var feishuCanvasModule = createModule(FeishuCanvas, FeishuContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/feishu-contribution.js
var __decorate59 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata42 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f2) => f2 === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var FeishuWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "feishu", this.eventManager = new MiniAppEventManager();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new FeishuCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new FeishuCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f2) => {
      f2(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(vb, color) {
    const context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate59([injectable(), __param26(0, inject(VGlobal)), __metadata42("design:paramtypes", [Object])], FeishuWindowHandlerContribution);
var feishuWindowModule = new ContainerModule((bind) => {
  bind(FeishuWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(FeishuWindowHandlerContribution)).whenTargetNamed(FeishuWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/picker/math-picker-service.js
var __decorate60 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata43 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPickerService = class extends DefaultPickService {
  constructor(contributions, pickItemInterceptorContributions) {
    super(pickItemInterceptorContributions), this.contributions = contributions, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.global.hooks.onSetEnv.tap("math-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickContext = new EmptyContext2d(null, 1);
  }
  pickItem(graphic, point6, parentMatrix, params2) {
    if (false === graphic.attribute.pickable) return null;
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const g3 = picker.contains(graphic, point6, params2) ? graphic : null;
    return g3 ? {
      graphic: g3
    } : null;
  }
};
DefaultMathPickerService = __decorate60([injectable(), __param27(0, inject(ContributionProvider)), __param27(0, named(MathPickerContribution)), __param27(1, inject(ContributionProvider)), __param27(1, named(PickItemInterceptor)), __metadata43("design:paramtypes", [Object, Object])], DefaultMathPickerService);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/module.js
var m3 = new ContainerModule((bind) => {
  m3.__vloaded || (m3.__vloaded = true, bindContributionProvider(bind, MathPickerContribution));
});
m3.__vloaded = false;
var module_default4 = m3;

// node_modules/@visactor/vrender-kits/es/picker/math-module.js
var mathPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
});
function loadMathPicker(c4) {
  c4.load(module_default4), c4.load(mathPickerModule);
}

// node_modules/@visactor/vrender-kits/es/env/contributions/feishu-contribution.js
var __decorate61 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata44 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
  const dpr = tt.getSystemInfoSync().pixelRatio;
  canvasIdLists.forEach((id2, i2) => {
    const ctx = tt.createCanvasContext(id2);
    ctx.canvas = {
      width: domref.width * dpr,
      height: domref.height * dpr
    };
    const canvas = {
      width: domref.width * dpr,
      height: domref.height * dpr,
      offsetWidth: domref.width,
      offsetHeight: domref.height,
      id: null != id2 ? id2 : "",
      getContext: () => ctx,
      getBoundingClientRect: () => ({
        height: domref.height,
        width: domref.width
      })
    };
    canvasMap.set(id2, canvas), i2 >= freeCanvasIdx && freeCanvasList.push(canvas);
  });
}
var FeishuEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "feishu", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList));
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h2) => {
      rafBasedSto.clear(h2);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
FeishuEnvContribution = __decorate61([injectable(), __metadata44("design:paramtypes", [])], FeishuEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/feishu.js
var feishuEnvModule = new ContainerModule((bind) => {
  feishuEnvModule.isFeishuBound || (feishuEnvModule.isFeishuBound = true, bind(FeishuEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(FeishuEnvContribution));
});
feishuEnvModule.isFeishuBound = false;
function loadFeishuEnv(container2, loadPicker = true) {
  loadFeishuEnv.__loaded || (loadFeishuEnv.__loaded = true, container2.load(feishuEnvModule), container2.load(feishuCanvasModule), container2.load(feishuWindowModule), loadPicker && loadMathPicker(container2));
}
loadFeishuEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/context.js
var __decorate62 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var LynxContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
  }
  setLineDash(segments2) {
    const a4 = arguments, _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a4[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
      _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || _context.setLineDash(lineDash), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text2, method = application.global.measureTextMethod) {
    this.setTransform(1, 0, 0, 1, 0, 0, true, application.global.devicePixelRatio);
    return super.measureText(text2, method);
  }
  createPattern(image, repetition) {
    return null;
  }
  draw() {
    const _context = this.nativeContext;
    this.drawPromise = new Promise((resolve) => {
      _context.draw(true, () => {
        this.drawPromise = null, resolve(null);
      });
    });
  }
};
LynxContext2d.env = "lynx", LynxContext2d = __decorate62([injectable()], LynxContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/canvas.js
var __decorate63 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata45 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var LynxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new LynxContext2d(this, this._dpr);
  }
  resize(width, height) {
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight, this._nativeCanvas.nativeCanvas && (this._nativeCanvas.nativeCanvas.width = this._pixelWidth, this._nativeCanvas.nativeCanvas.height = this._pixelHeight);
    this._context.dpr = this._dpr;
  }
  release(...params2) {
  }
};
LynxCanvas.env = "lynx", LynxCanvas = __decorate63([injectable(), __metadata45("design:paramtypes", [Object])], LynxCanvas);

// node_modules/@visactor/vrender-kits/es/window/contributions/lynx-contribution.js
var __decorate64 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata46 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager2 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f2) => f2 === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var LynxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "lynx", this.eventManager = new MiniAppEventManager2();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new LynxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new LynxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f2) => {
      f2(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(vb, color) {
    const context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate64([injectable(), __param28(0, inject(VGlobal)), __metadata46("design:paramtypes", [Object])], LynxWindowHandlerContribution);
var lynxWindowModule = new ContainerModule((bind) => {
  bind(LynxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(LynxWindowHandlerContribution)).whenTargetNamed(LynxWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/canvas/contributions/lynx/modules.js
var lynxCanvasModule = createModule(LynxCanvas, LynxContext2d);

// node_modules/@visactor/vrender-kits/es/env/contributions/lynx-contribution.js
var __decorate65 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata47 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var ng = false;
try {
  ng = !!lynx.createCanvasNG;
} catch (err) {
}
function makeUpCanvas2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
  const dpr = SystemInfo.pixelRatio;
  canvasIdLists.forEach((id2, i2) => {
    const _canvas = ng ? lynx.createCanvasNG(id2) : lynx.createCanvas(id2);
    _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr, ng && _canvas.attachToCanvasView(id2);
    const ctx = _canvas.getContext("2d");
    ctx.draw = (a4, b2) => {
      b2();
    };
    const canvas = {
      width: domref.width * dpr,
      height: domref.height * dpr,
      offsetWidth: domref.width,
      offsetHeight: domref.height,
      id: null != id2 ? id2 : "",
      getContext: () => ctx,
      getBoundingClientRect: () => ({
        height: domref.height,
        width: domref.width
      }),
      nativeCanvas: _canvas
    };
    canvasMap.set(id2, canvas), i2 >= freeCanvasIdx && freeCanvasList.push(canvas);
  });
}
function createImageElement2(src, isSvg2 = false) {
  if (isSvg2) return Promise.reject();
  const img = lynx.createImage(src);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
var LynxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "lynx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas2(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList));
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
    return createImageElement2(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return SystemInfo.pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h2) => {
      rafBasedSto.clear(h2);
    };
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
LynxEnvContribution = __decorate65([injectable(), __metadata47("design:paramtypes", [])], LynxEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/lynx.js
var lynxEnvModule = new ContainerModule((bind) => {
  lynxEnvModule.isLynxBound || (lynxEnvModule.isLynxBound = true, bind(LynxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(LynxEnvContribution));
});
lynxEnvModule.isLynxBound = false;
function loadLynxEnv(container2, loadPicker = true) {
  loadLynxEnv.__loaded || (loadLynxEnv.__loaded = true, container2.load(lynxEnvModule), container2.load(lynxCanvasModule), container2.load(lynxWindowModule), loadPicker && loadMathPicker(container2));
}
loadLynxEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/context.js
var __decorate66 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata48 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var NodeContext2d = class extends BrowserContext2d {
  constructor(canvas, dpr) {
    super(canvas, dpr);
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
  }
  release(...params2) {
  }
};
NodeContext2d.env = "node", NodeContext2d = __decorate66([injectable(), __metadata48("design:paramtypes", [Object, Number])], NodeContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/canvas.js
var __decorate67 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata49 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var NodeCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
  }
  release(...params2) {
    this._nativeCanvas.release && isFunction_default(this._nativeCanvas.release) && this._nativeCanvas.release();
  }
};
NodeCanvas.env = "node", NodeCanvas = __decorate67([injectable(), __metadata49("design:paramtypes", [Object])], NodeCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/node/modules.js
var nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/node-contribution.js
var __decorate68 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata50 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "node";
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: true
    };
    this.canvas = new NodeCanvas(options);
  }
  createWindowByCanvas(params2) {
    const canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    null != width && null != height && params2.canvasControled || (width = canvas.width, height = canvas.height), this.canvas = new NodeCanvas({
      width,
      height,
      dpr: 1,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer(type = "image/png") {
    return this.canvas.nativeCanvas.toBuffer(type);
  }
  addEventListener(type, listener, options) {
  }
  dispatchEvent(event) {
    return true;
  }
  removeEventListener(type, listener, options) {
  }
  getStyle() {
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(vb, color) {
  }
};
NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate68([injectable(), __param29(0, inject(VGlobal)), __metadata50("design:paramtypes", [Object])], NodeWindowHandlerContribution);
var nodeWindowModule = new ContainerModule((bind) => {
  bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/node-contribution.js
var __decorate69 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = false;
  }
  configure(service, pkg) {
    service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadImage(url) {
    const { loadImage: loadImage2 } = this.pkg;
    return loadImage2 ? loadImage2(url).then((image) => ({
      loadState: image ? "success" : "fail",
      data: image
    })).catch(() => ({
      loadState: "fail",
      data: null
    })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(svgStr) {
    const Resvg = this.pkg.Resvg;
    if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
    const pngData = new Resvg(svgStr).render().asPng();
    return this.loadImage(pngData);
  }
  createCanvas(params2) {
    return this.pkg.createCanvas(params2.width, params2.height);
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h2) => {
      rafBasedSto.clear(h2);
    };
  }
  addEventListener(type, listener, options) {
  }
  removeEventListener(type, listener, options) {
  }
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(event) {
  }
  release(...params2) {
  }
  createOffscreenCanvas(params2) {
  }
};
NodeEnvContribution = __decorate69([injectable()], NodeEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/node.js
var nodeEnvModule = new ContainerModule((bind) => {
  nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = true, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
});
nodeEnvModule.isNodeBound = false;
function loadNodeEnv(container2, loadPicker = true) {
  loadNodeEnv.__loaded || (loadNodeEnv.__loaded = true, container2.load(nodeEnvModule), container2.load(nodeCanvasModule), container2.load(nodeWindowModule));
}
loadNodeEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/context.js
var __decorate70 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var TaroContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
  }
  draw() {
    this.nativeContext.draw();
  }
  strokeText(text2, x3, y3) {
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), _context.setFillStyle(createColor(this, fill, params2, offsetX, offsetY)));
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
      _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth(getScaledStroke(this, lineWidth, this.dpr)), _context.setStrokeStyle(createColor(this, stroke2, params2, offsetX, offsetY)), _context.setLineJoin(lineJoin), _context.setLineDash(lineDash), _context.setLineCap(lineCap), _context.setMiterLimit(miterLimit);
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
    var _a;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams), _context.setFontSize(null !== (_a = params2.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
  }
  setTextStyle(params2, defaultParams) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams), _context.setTextAlign(null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), _context.setTextBaseline(null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
  }
  createConicGradient(x3, y3, startAngle, endAngle) {
    return null;
  }
  createPattern(image, repetition) {
    return null;
  }
};
TaroContext2d.env = "taro", TaroContext2d = __decorate70([injectable()], TaroContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/canvas.js
var __decorate71 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata51 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var TaroCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new TaroContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
TaroCanvas.env = "taro", TaroCanvas = __decorate71([injectable(), __metadata51("design:paramtypes", [Object])], TaroCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/taro/modules.js
var taroCanvasModule = createModule(TaroCanvas, TaroContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/taro-contribution.js
var __decorate72 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata52 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager3 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f2) => f2 === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var TaroWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "taro", this.eventManager = new MiniAppEventManager3();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new TaroCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TaroCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach((d2, i2) => {
      event.changedTouches[i2] = Object.assign(Object.assign({}, event.changedTouches[i2]), {
        offsetX: d2.x,
        offsetY: d2.y
      });
    }), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), event.touches.length > 0 && event.touches.forEach((d2, i2) => {
      event.touches[i2] = Object.assign(Object.assign({}, event.touches[i2]), {
        offsetX: d2.x,
        offsetY: d2.y
      });
    }), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f2) => {
      f2(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(vb, color) {
    const context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate72([injectable(), __param30(0, inject(VGlobal)), __metadata52("design:paramtypes", [Object])], TaroWindowHandlerContribution);
var taroWindowModule = new ContainerModule((bind) => {
  bind(TaroWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(TaroWindowHandlerContribution)).whenTargetNamed(TaroWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/taro-contribution.js
var __decorate73 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata53 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
function makeUpCanvas3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
  canvasIdLists.forEach((id2, i2) => {
    const ctx = taro.createCanvasContext(id2);
    ctx.canvas = {
      width: domref.width * dpr,
      height: domref.height * dpr
    }, ctx.createRadialGradient || (ctx.createRadialGradient = (...cc) => ctx.createCircularGradient(...cc)), !ctx.getImageData && taro.canvasGetImageData && (ctx.getImageData = (x3, y3, width, height) => new Promise((resolve, reject) => {
      try {
        taro.canvasGetImageData({
          canvasId: id2,
          x: x3,
          y: y3,
          width,
          height,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    }));
    const canvas = {
      id: id2,
      width: domref.width * dpr,
      height: domref.height * dpr,
      offsetWidth: domref.width,
      offsetHeight: domref.height,
      getContext: () => ctx,
      getBoundingClientRect: () => ({
        height: domref.height,
        width: domref.width
      })
    };
    return canvasMap.set(id2, canvas), i2 >= freeCanvasIdx && freeCanvasList.push(canvas), canvas;
  });
}
var TaroEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "taro", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  configure(service, params2) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas3(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.taro, params2.pixelRatio), this.taro = params2.taro, this.pixelRatio = params2.pixelRatio);
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(svgStr) {
    const _window = window || globalThis;
    if (_window.DOMParser) {
      const svg = new _window.DOMParser().parseFromString(svgStr, "image/svg+xml").children[0], data = new XMLSerializer().serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    if (_window.Blob) {
      const data = new _window.Blob([svgStr], {
        type: "image/svg+xml"
      }), url = _window.URL.createObjectURL(data);
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return this.pixelRatio;
  }
  getRequestAnimationFrame() {
    return requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
};
TaroEnvContribution = __decorate73([injectable(), __metadata53("design:paramtypes", [])], TaroEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/taro.js
var taroEnvModule = new ContainerModule((bind) => {
  taroEnvModule.isTaroBound || (taroEnvModule.isTaroBound = true, bind(TaroEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TaroEnvContribution));
});
taroEnvModule.isTaroBound = false;
function loadTaroEnv(container2, loadPicker = true) {
  loadTaroEnv.__loaded || (loadTaroEnv.__loaded = true, container2.load(taroEnvModule), container2.load(taroCanvasModule), container2.load(taroWindowModule), loadPicker && loadMathPicker(container2));
}
loadTaroEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/context.js
var __decorate74 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var WxContext2d = class extends BrowserContext2d {
  draw() {
  }
  createPattern(image, repetition) {
    return null;
  }
};
WxContext2d.env = "wx", WxContext2d = __decorate74([injectable()], WxContext2d);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/canvas.js
var __decorate75 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata54 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var WxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new WxContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
WxCanvas.env = "wx", WxCanvas = __decorate75([injectable(), __metadata54("design:paramtypes", [Object])], WxCanvas);

// node_modules/@visactor/vrender-kits/es/canvas/contributions/wx/modules.js
var wxCanvasModule = createModule(WxCanvas, WxContext2d);

// node_modules/@visactor/vrender-kits/es/window/contributions/wx-contribution.js
var __decorate76 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata55 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager4 = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex((f2) => f2 === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "wx", this.eventManager = new MiniAppEventManager4();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new WxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    var _a, _b, _c, _d;
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f2) => {
      f2(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(vb, color) {
    const context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate76([injectable(), __param31(0, inject(VGlobal)), __metadata55("design:paramtypes", [Object])], WxWindowHandlerContribution);
var wxWindowModule = new ContainerModule((bind) => {
  bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(WxWindowHandlerContribution)).whenTargetNamed(WxWindowHandlerContribution.env);
});

// node_modules/@visactor/vrender-kits/es/env/contributions/wx-contribution.js
var __decorate77 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata56 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas4(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component2) {
  return __awaiter5(this, void 0, void 0, function* () {
    const dpr = wx.getSystemInfoSync().pixelRatio;
    for (let i2 = 0; i2 < canvasIdLists.length; i2++) {
      const id2 = canvasIdLists[i2];
      yield new Promise((resolve) => {
        let data = wx.createSelectorQuery();
        component2 && (data = data.in(component2)), data.select(`#${id2}`).fields({
          node: true,
          size: true
        }).exec((res) => {
          if (!res[0]) return;
          const canvas = res[0].node, width = res[0].width, height = res[0].height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id2, canvas), i2 >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      });
    }
  });
}
var WxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "wx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas4(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component).then(() => {
    });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return wx.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h2) => {
      rafBasedSto.clear(h2);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
WxEnvContribution = __decorate77([injectable(), __metadata56("design:paramtypes", [])], WxEnvContribution);

// node_modules/@visactor/vrender-kits/es/env/wx.js
var wxEnvModule = new ContainerModule((bind) => {
  wxEnvModule._isWxBound || (wxEnvModule._isWxBound = true, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
});
wxEnvModule._isWxBound = false;
function loadWxEnv(container2, loadPicker = true) {
  loadWxEnv.__loaded || (loadWxEnv.__loaded = true, container2.load(wxEnvModule), container2.load(wxCanvasModule), container2.load(wxWindowModule), loadPicker && loadMathPicker(container2));
}
loadWxEnv.__loaded = false;

// node_modules/@visactor/vrender-kits/es/env/all.js
function loadAllModule(container2) {
  loadAllModule.__loaded || (loadAllModule.__loaded = true, loadBrowserEnv(container2, false), loadFeishuEnv(container2, false), loadLynxEnv(container2, false), loadNodeEnv(container2, false), loadTaroEnv(container2, false), loadWxEnv(container2, false), loadCanvasPicker(container2), vglobal.hooks.onSetEnv.tap("loadMathPicker", (lastEnv, env) => {
    "browser" !== env && loadMathPicker(container2);
  }));
}
loadAllModule.__loaded = false;

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-picker.js
var __decorate78 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata57 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  contains(arc, point6, params2) {
    if (!arc.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === arc.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const arcAttribute = getTheme(arc).arc;
    pickContext.highPerformanceSave();
    let { x: x3 = arcAttribute.x, y: y3 = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const point7 = arc.getOffsetXY(arcAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(arc.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(arc, pickContext, x3, y3, {}, null, (context, arcAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, arcAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = arcAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasArcPicker = __decorate78([injectable(), __param32(0, inject(ArcRender)), __metadata57("design:paramtypes", [Object])], DefaultCanvasArcPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc-module.js
var loadArcPick = false;
var arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = true, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-picker.js
var __decorate79 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata58 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathArcPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  contains(arc, point6, params2) {
    if (!arc.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === arc.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const arcAttribute = getTheme(arc).arc;
    pickContext.highPerformanceSave();
    let { x: x3 = arcAttribute.x, y: y3 = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const point7 = arc.getOffsetXY(arcAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(arc.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(arc, pickContext, x3, y3, {}, null, (context, arcAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, arcAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = arcAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathArcPicker = __decorate79([injectable(), __param33(0, inject(ArcRender)), __metadata58("design:paramtypes", [Object])], DefaultMathArcPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/arc-module.js
var loadArcPick2 = false;
var arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick2 || (loadArcPick2 = true, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-picker.js
var __decorate80 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata59 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _bounds = new AABBBounds();
var DefaultCanvasRectPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point6, params2) {
    if (!rect.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === rect.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const rectAttribute = getTheme(rect).rect, { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x: x3 = rectAttribute.x, y: y3 = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point7 = rect.getOffsetXY(rectAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || rect.shadowRoot || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num)) picked = false, this.canvasRenderer.drawShape(rect, pickContext, x3, y3, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, rectAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    });
    else {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill) picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point6);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasRectPicker = __decorate80([injectable(), __param34(0, inject(RectRender)), __metadata59("design:paramtypes", [Object])], DefaultCanvasRectPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect-module.js
var loadRectPick = false;
var rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = true, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-picker.js
var __decorate81 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata60 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _bounds2 = new AABBBounds();
var DefaultMathRectPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point6, params2) {
    if (!rect.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === rect.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const rectAttribute = getTheme(rect).rect, { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x: x3 = rectAttribute.x, y: y3 = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point7 = rect.getOffsetXY(rectAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num)) picked = false, this.canvasRenderer.drawShape(rect, pickContext, x3, y3, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, rectAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    });
    else if (picked) {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill) picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds2.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds2.expand(-lineWidth / 2), picked = !_bounds2.containsPoint(point6);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathRectPicker = __decorate81([injectable(), __param35(0, inject(RectRender)), __metadata60("design:paramtypes", [Object])], DefaultMathRectPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/rect-module.js
var loadRectPick2 = false;
var rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick2 || (loadRectPick2 = true, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/base-picker.js
var __decorate82 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var BasePicker = class extends BaseRender {
};
BasePicker = __decorate82([injectable()], BasePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-picker.js
var __decorate83 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata61 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLinePicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  contains(line2, point6, params2) {
    if (!line2.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === line2.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    pickContext.highPerformanceSave();
    const lineAttribute = getTheme(line2).line, data = this.transform(line2, lineAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = line2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(line2, pickContext, x3, y3, {}, null, (context) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = lineAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = lineAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasLinePicker = __decorate83([injectable(), __param36(0, inject(LineRender)), __metadata61("design:paramtypes", [Object])], DefaultCanvasLinePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/line-module.js
var loadLinePick = false;
var lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = true, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-picker.js
var __decorate84 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata62 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathLinePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  contains(line2, point6, params2) {
    if (!line2.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === line2.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const lineAttribute = getTheme(line2).line;
    let { x: x3 = lineAttribute.x, y: y3 = lineAttribute.y } = line2.attribute;
    if (pickContext.highPerformanceSave(), line2.transMatrix.onlyTranslate()) {
      const point7 = line2.getOffsetXY(lineAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(line2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(line2, pickContext, x3, y3, {}, null, (context) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, circleAttribute, themeAttribute) => {
      if (picked) return true;
      const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathLinePicker = __decorate84([injectable(), __param37(0, inject(LineRender)), __metadata62("design:paramtypes", [Object])], DefaultMathLinePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/line-module.js
var loadLinePick2 = false;
var lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick2 || (loadLinePick2 = true, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-picker.js
var __decorate85 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata63 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  contains(area2, point6, params2) {
    if (!area2.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === area2.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const areaAttribute = getTheme(area2).area;
    let { x: x3 = areaAttribute.x, y: y3 = areaAttribute.y } = area2.attribute;
    const { fillPickable = areaAttribute.fillPickable, strokePickable = areaAttribute.strokePickable } = area2.attribute;
    if (pickContext.highPerformanceSave(), area2.transMatrix.onlyTranslate()) {
      const point7 = area2.getOffsetXY(areaAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(area2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(area2, pickContext, x3, y3, {}, null, (context) => !!picked || !!fillPickable && (picked = context.isPointInPath(point6.x, point6.y), picked), (context, areaAttribute2, themeAttribute) => {
      if (picked) return true;
      if (!strokePickable) return false;
      const lineWidth = areaAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = areaAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasAreaPicker = __decorate85([injectable(), __param38(0, inject(AreaRender)), __metadata63("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/area-module.js
var loadAreaPick = false;
var areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = true, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-picker.js
var __decorate86 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata64 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathAreaPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  contains(area2, point6, params2) {
    if (!area2.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === area2.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const areaAttribute = getTheme(area2).area;
    let { x: x3 = areaAttribute.x, y: y3 = areaAttribute.y } = area2.attribute;
    if (pickContext.highPerformanceSave(), area2.transMatrix.onlyTranslate()) {
      const point7 = area2.getOffsetXY(areaAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(area2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(area2, pickContext, x3, y3, {}, null, (context) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked)), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathAreaPicker = __decorate86([injectable(), __param39(0, inject(AreaRender)), __metadata64("design:paramtypes", [Object])], DefaultMathAreaPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/area-module.js
var loadAreaPick2 = false;
var areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick2 || (loadAreaPick2 = true, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-picker.js
var __decorate87 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata65 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point6)) return false;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return true;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = getTheme(symbol).symbol, data = this.transform(symbol, symbolAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x3, y3, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate87([injectable(), __param40(0, inject(SymbolRender)), __metadata65("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/symbol-module.js
var loadSymbolPick = false;
var symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = true, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-picker.js
var __decorate88 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata66 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathSymbolPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point6, params2) {
    if (!symbol.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === symbol.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const symbolAttribute = getTheme(symbol).symbol;
    let { x: x3 = symbolAttribute.x, y: y3 = symbolAttribute.y } = symbol.attribute;
    if (pickContext.highPerformanceSave(), symbol.transMatrix.onlyTranslate()) {
      const point7 = symbol.getOffsetXY(symbolAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(symbol.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x3, y3, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathSymbolPicker = __decorate88([injectable(), __param41(0, inject(SymbolRender)), __metadata66("design:paramtypes", [Object])], DefaultMathSymbolPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/symbol-module.js
var loadSymbolPick2 = false;
var symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick2 || (loadSymbolPick2 = true, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-picker.js
var __decorate89 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata67 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCirclePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  contains(circle4, point6, params2) {
    if (!circle4.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === circle4.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const circleAttribute = getTheme(circle4).circle;
    let { x: x3 = circleAttribute.x, y: y3 = circleAttribute.y } = circle4.attribute;
    if (pickContext.highPerformanceSave(), circle4.transMatrix.onlyTranslate()) {
      const point7 = circle4.getOffsetXY(circleAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(circle4.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(circle4, pickContext, x3, y3, {}, null, (context, circleAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, circleAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = circleAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasCirclePicker = __decorate89([injectable(), __param42(0, inject(CircleRender)), __metadata67("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/circle-module.js
var loadCirclePick = false;
var circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = true, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-picker.js
var __decorate90 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata68 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathCirclePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  contains(circle4, point6, params2) {
    if (!circle4.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === circle4.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const circleAttribute = getTheme(circle4).circle;
    let { x: x3 = circleAttribute.x, y: y3 = circleAttribute.y } = circle4.attribute;
    if (pickContext.highPerformanceSave(), circle4.transMatrix.onlyTranslate()) {
      const point7 = circle4.getOffsetXY(circleAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(circle4.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(circle4, pickContext, x3, y3, {}, null, (context, circleAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, circleAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = circleAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathCirclePicker = __decorate90([injectable(), __param43(0, inject(CircleRender)), __metadata68("design:paramtypes", [Object])], DefaultMathCirclePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/circle-module.js
var loadCirclePick2 = false;
var circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick2 || (loadCirclePick2 = true, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-picker.js
var __decorate91 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata69 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const bounds = text2.AABBBounds;
    if (!pickContext.camera) return !!bounds.containsPoint(point6);
    pickContext.highPerformanceSave();
    const textAttribute2 = getTheme(text2).text, { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text2, textAttribute2, pickContext, computed3dMatrix), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    this.canvasRenderer.z = z2;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = text2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    let picked = false;
    return this.canvasRenderer.drawShape(text2, pickContext, x3, y3, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked) return true;
      const { fontSize = textAttribute2.fontSize, textBaseline = textAttribute2.textBaseline, textAlign = textAttribute2.textAlign } = text2.attribute, bounds2 = text2.AABBBounds, height = bounds2.height(), width = bounds2.width(), offsetY = textLayoutOffsetY(textBaseline, height, fontSize), offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x3, offsetY + y3, width, height, z2), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate91([injectable(), __param44(0, inject(TextRender)), __metadata69("design:paramtypes", [Object])], DefaultCanvasTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/text-module.js
var loadTextPick = false;
var textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = true, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-picker.js
var __decorate92 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point6, params2) {
    return !!text2.AABBBounds.containsPoint(point6);
  }
};
DefaultMathTextPicker = __decorate92([injectable()], DefaultMathTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/text-module.js
var loadTextPick2 = false;
var textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick2 || (loadTextPick2 = true, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-picker.js
var __decorate93 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata70 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  contains(path, point6, params2) {
    if (!path.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === path.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pathAttribute = getTheme(path).path;
    pickContext.highPerformanceSave();
    const data = this.transform(path, pathAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = path.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(path, pickContext, x3, y3, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasPathPicker = __decorate93([injectable(), __param45(0, inject(PathRender)), __metadata70("design:paramtypes", [Object])], DefaultCanvasPathPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/path-module.js
var loadPathPick = false;
var pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = true, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-picker.js
var __decorate94 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata71 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPathPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  contains(path, point6, params2) {
    if (!path.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === path.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pathAttribute = getTheme(path).path;
    let { x: x3 = pathAttribute.x, y: y3 = pathAttribute.y } = path.attribute;
    if (pickContext.highPerformanceSave(), path.transMatrix.onlyTranslate()) {
      const point7 = path.getOffsetXY(pathAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(path.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(path, pickContext, x3, y3, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathPathPicker = __decorate94([injectable(), __param46(0, inject(PathRender)), __metadata71("design:paramtypes", [Object])], DefaultMathPathPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/path-module.js
var loadPathPick2 = false;
var pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick2 || (loadPathPick2 = true, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-picker.js
var __decorate95 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata72 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  contains(polygon, point6, params2) {
    if (!polygon.AABBBounds.contains(point6.x, point6.y)) return false;
    if ("imprecise" === polygon.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const polygonAttribute = getTheme(polygon).polygon;
    let { x: x3 = polygonAttribute.x, y: y3 = polygonAttribute.y } = polygon.attribute;
    if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
      const point7 = polygon.getOffsetXY(polygonAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(polygon.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(polygon, pickContext, x3, y3, {}, null, (context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, pathAttribute, themeAttribute) => {
      if (picked) return true;
      const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasPolygonPicker = __decorate95([injectable(), __param47(0, inject(PolygonRender)), __metadata72("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/polygon-module.js
var loadPolygonPick = false;
var polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = true, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-picker.js
var __decorate96 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata73 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPolygonPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  contains(polygon, point6, params2) {
    if (!polygon.AABBBounds.contains(point6.x, point6.y)) return false;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pathAttribute = getTheme(polygon).polygon;
    let { x: x3 = pathAttribute.x, y: y3 = pathAttribute.y } = polygon.attribute;
    if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
      const point7 = polygon.getOffsetXY(pathAttribute);
      x3 += point7.x, y3 += point7.y, pickContext.setTransformForCurrent();
    } else x3 = 0, y3 = 0, pickContext.transformFromMatrix(polygon.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(polygon, pickContext, x3, y3, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point6.x, point6.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked) return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point6.x, point6.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathPolygonPicker = __decorate96([injectable(), __param48(0, inject(PolygonRender)), __metadata73("design:paramtypes", [Object])], DefaultMathPolygonPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/polygon-module.js
var loadPolygonPick2 = false;
var polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick2 || (loadPolygonPick2 = true, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-picker.js
var __decorate97 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata74 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGlyphPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point6, params2) {
    if (!glyph.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === glyph.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pickerService = null == params2 ? void 0 : params2.pickerService;
    if (pickerService) {
      let picked = false;
      return glyph.getSubGraphic().forEach((g3) => {
        if (picked) return;
        const data = pickerService.pickItem(g3, point6, null, params2);
        picked = !(!data || !data.graphic);
      }), picked;
    }
    return false;
  }
};
DefaultCanvasGlyphPicker = __decorate97([injectable(), __param49(0, inject(GlyphRender)), __metadata74("design:paramtypes", [Object])], DefaultCanvasGlyphPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/glyph-module.js
var loadGlyphPick = false;
var glyphCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick || (loadGlyphPick = true, bind(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGlyphPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-picker.js
var __decorate98 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata75 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathGlyphPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point6, params2) {
    if (!glyph.AABBBounds.containsPoint(point6)) return false;
    if ("imprecise" === glyph.attribute.pickMode) return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pickerService = null == params2 ? void 0 : params2.pickerService;
    if (pickerService) {
      let picked = false;
      return glyph.getSubGraphic().forEach((g3) => {
        picked || (picked = !!pickerService.pickItem(g3, point6, null, params2));
      }), picked;
    }
    return false;
  }
};
DefaultMathGlyphPicker = __decorate98([injectable(), __param50(0, inject(GlyphRender)), __metadata75("design:paramtypes", [Object])], DefaultMathGlyphPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/glyph-module.js
var loadGlyphPick2 = false;
var glyphMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick2 || (loadGlyphPick2 = true, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-picker.js
var __decorate99 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata76 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point6, params2) {
    return !!richtext.AABBBounds.containsPoint(point6);
  }
};
DefaultCanvasRichTextPicker = __decorate99([injectable(), __param51(0, inject(RichTextRender)), __metadata76("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/richtext-module.js
var loadRichtextPick = false;
var richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = true, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-picker.js
var __decorate100 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point6);
  }
};
DefaultMathImagePicker = __decorate100([injectable()], DefaultMathImagePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/richtext-module.js
var loadRichTextPick = false;
var richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-picker.js
var __decorate101 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var DefaultCanvasImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point6);
  }
};
DefaultCanvasImagePicker = __decorate101([injectable()], DefaultCanvasImagePicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/image-module.js
var loadImagePick = false;
var imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = true, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/math-picker/image-module.js
var loadImagePick2 = false;
var imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick2 || (loadImagePick2 = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-picker.js
var __decorate102 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata77 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _bounds3 = new AABBBounds();
var DefaultCanvasRect3dPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  contains(rect, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const rectAttribute = getTheme(rect).rect;
    pickContext.highPerformanceSave();
    const data = this.transform(rect, rectAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = rect.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(rect, pickContext, x3, y3, params2, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasRect3dPicker = __decorate102([injectable(), __param52(0, inject(Rect3DRender)), __metadata77("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/rect3d-module.js
var loadRect3dPick = false;
var rect3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRect3dPick || (loadRect3dPick = true, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-picker.js
var __decorate103 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata78 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArc3dPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  contains(arc3d, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const arc3dAttribute = getTheme(arc3d).arc;
    pickContext.highPerformanceSave();
    const data = this.transform(arc3d, arc3dAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = arc3d.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(arc3d, pickContext, x3, y3, params2, null, (context, arc3dAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasArc3dPicker = __decorate103([injectable(), __param53(0, inject(Arc3dRender)), __metadata78("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/arc3d-module.js
var loadArc3dPick = false;
var arc3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArc3dPick || (loadArc3dPick = true, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
});

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-picker.js
var __decorate104 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __metadata79 = function(k3, v2) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k3, v2);
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPyramid3dPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  contains(pyramid3d, point6, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext) return false;
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    pickContext.highPerformanceSave();
    const data = this.transform(pyramid3d, pyramid3dAttribute, pickContext), { x: x3, y: y3, z: z2, lastModelMatrix } = data;
    let pickPoint = point6;
    if (pickContext.camera) {
      pickPoint = point6.clone();
      const globalMatrix = pyramid3d.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point6.x + globalMatrix.c * point6.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point6.x + globalMatrix.d * point6.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z2;
    let picked = false;
    return this.canvasRenderer.drawShape(pyramid3d, pickContext, x3, y3, {}, null, (context, pyramid3dAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, pyramid3dAttribute2, themeAttribute) => false), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasPyramid3dPicker = __decorate104([injectable(), __param54(0, inject(Pyramid3dRender)), __metadata79("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

// node_modules/@visactor/vrender-kits/es/picker/contributions/canvas-picker/pyramid3d-module.js
var loadPyramid3dPick = false;
var pyramid3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPyramid3dPick || (loadPyramid3dPick = true, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
});

// node_modules/@visactor/vrender-kits/es/register/env.js
var browser = isBrowserEnv();

// node_modules/@visactor/vrender-kits/es/register/register-arc.js
function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = true, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = false;
var registerArc = _registerArc;

// node_modules/@visactor/vrender-kits/es/register/register-arc3d.js
function _registerArc3d() {
  _registerArc3d.__loaded || (_registerArc3d.__loaded = true, registerArc3dGraphic(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
}
_registerArc3d.__loaded = false;
var registerArc3d = _registerArc3d;

// node_modules/@visactor/vrender-kits/es/register/register-area.js
function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = true, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = false;
var registerArea = _registerArea;

// node_modules/@visactor/vrender-kits/es/register/register-circle.js
function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = true, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = false;
var registerCircle = _registerCircle;

// node_modules/@visactor/vrender-kits/es/register/register-glyph.js
function _registerGlyph() {
  _registerGlyph.__loaded || (_registerGlyph.__loaded = true, registerGlyphGraphic(), container.load(glyphModule), container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
}
_registerGlyph.__loaded = false;
var registerGlyph = _registerGlyph;

// node_modules/@visactor/vrender-kits/es/register/register-group.js
function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = true, registerGroupGraphic());
}
_registerGroup.__loaded = false;
var registerGroup = _registerGroup;

// node_modules/@visactor/vrender-kits/es/register/register-image.js
function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = true, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = false;
var registerImage = _registerImage;

// node_modules/@visactor/vrender-kits/es/register/register-line.js
function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = true, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = false;
var registerLine = _registerLine;

// node_modules/@visactor/vrender-kits/es/register/register-path.js
function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = true, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = false;
var registerPath = _registerPath;

// node_modules/@visactor/vrender-kits/es/register/register-polygon.js
function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = true, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = false;
var registerPolygon = _registerPolygon;

// node_modules/@visactor/vrender-kits/es/register/register-pyramid3d.js
function _registerPyramid3d() {
  _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = true, registerPyramid3dGraphic(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
}
_registerPyramid3d.__loaded = false;
var registerPyramid3d = _registerPyramid3d;

// node_modules/@visactor/vrender-kits/es/register/register-rect.js
function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = true, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = false;
var registerRect = _registerRect;

// node_modules/@visactor/vrender-kits/es/register/register-rect3d.js
function _registerRect3d() {
  _registerRect3d.__loaded || (_registerRect3d.__loaded = true, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
}
_registerRect3d.__loaded = false;
var registerRect3d = _registerRect3d;

// node_modules/@visactor/vrender-kits/es/register/register-richtext.js
function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = true, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = false;
var registerRichtext = _registerRichtext;

// node_modules/@visactor/vrender-kits/es/register/register-shadowRoot.js
function _registerShadowRoot() {
  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = true, registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = false;
var registerShadowRoot = _registerShadowRoot;

// node_modules/@visactor/vrender-kits/es/register/register-symbol.js
function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = true, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = false;
var registerSymbol = _registerSymbol;

// node_modules/@visactor/vrender-kits/es/register/register-text.js
function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = true, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = false;
var registerText = _registerText;

// node_modules/@visactor/vrender-kits/es/register/register-wraptext.js
function _registerWrapText() {
  _registerWrapText.__loaded || (_registerWrapText.__loaded = true, registerWrapTextGraphic());
}
_registerWrapText.__loaded = false;
var registerWrapText = _registerWrapText;

// node_modules/@visactor/vrender-components/es/scrollbar/register.js
function loadScrollbarComponent() {
  registerGroup(), registerRect();
}

// node_modules/@visactor/vrender-components/es/scrollbar/scrollbar.js
var delayMap = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadScrollbarComponent();
var ScrollBar = class _ScrollBar extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ScrollBar.defaultAttributes, attributes)), this.name = "scrollbar", this._onRailPointerDown = (e3) => {
      const { viewX, viewY } = e3, { direction: direction2, width, height, range: range2 } = this.attribute, sliderSize = this._sliderSize, [min4, max4] = this._getScrollRange();
      let currentScrollValue;
      if ("vertical" === direction2) {
        const relativeY = viewY - this._viewPosition.y, currentYPos = clamp_default(relativeY - sliderSize / 2, min4, max4);
        currentScrollValue = relativeY / height, this._slider.setAttribute("y", currentYPos, true);
      } else {
        const relativeX = viewX - this._viewPosition.x, currentXPos = clamp_default(relativeX - sliderSize / 2, min4, max4);
        currentScrollValue = relativeX / width, this._slider.setAttribute("x", currentXPos, true);
      }
      this.setScrollRange([currentScrollValue - (range2[1] - range2[0]) / 2, currentScrollValue + (range2[1] - range2[0]) / 2], false), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
    }, this._onSliderPointerDown = (e3) => {
      e3.stopPropagation();
      const { direction: direction2 } = this.attribute;
      this._prePos = "horizontal" === direction2 ? e3.clientX : e3.clientY, this._dispatchEvent("scrollDown", {
        pos: this._prePos,
        event: e3
      }), "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onSliderPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onSliderPointerUp)) : (this.stage.addEventListener("pointermove", this._onSliderPointerMove, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onSliderPointerUp), this.stage.addEventListener("pointerupoutside", this._onSliderPointerUp));
    }, this._computeScrollValue = (e3) => {
      const { direction: direction2 } = this.attribute;
      let currentScrollValue, currentPos, delta = 0;
      const { width, height } = this._getSliderRenderBounds();
      return "vertical" === direction2 ? (currentPos = e3.clientY, delta = currentPos - this._prePos, currentScrollValue = delta / height) : (currentPos = e3.clientX, delta = currentPos - this._prePos, currentScrollValue = delta / width), [currentPos, currentScrollValue];
    }, this._onSliderPointerMove = delayMap[this.attribute.delayType]((e3) => {
      e3.stopPropagation();
      const preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e3);
      this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this._prePos = currentPos;
    }, this.attribute.delayTime), this._onSliderPointerUp = (e3) => {
      e3.preventDefault();
      const { realTime = true, range: preRange, limitRange = [0, 1] } = this.attribute, preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e3), range2 = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
      realTime || this._dispatchEvent("scroll", {
        pre: preRange,
        value: clampRange_default(range2, limitRange[0], limitRange[1])
      }), this._dispatchEvent("scrollUp", {
        pre: preRange,
        value: clampRange_default(range2, limitRange[0], limitRange[1])
      }), "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onSliderPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onSliderPointerUp)) : (this.stage.removeEventListener("pointermove", this._onSliderPointerMove, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onSliderPointerUp), this.stage.removeEventListener("pointerupoutside", this._onSliderPointerUp));
    };
  }
  setScrollRange(range2, render = true) {
    const { direction: direction2 = "horizontal", limitRange = [0, 1], range: preRange, realTime = true } = this.attribute, currScrollRange = clampRange_default(range2, limitRange[0], limitRange[1]);
    if (render) {
      const sliderPos = this._getSliderPos(currScrollRange);
      this._slider && ("horizontal" === direction2 ? this._slider.setAttribute("x", sliderPos[0], true) : this._slider.setAttribute("y", sliderPos[0], true), this.stage && !this.stage.autoRender && this.stage.renderNextFrame());
    }
    this.attribute.range = currScrollRange, realTime && (this._dispatchEvent("scroll", {
      pre: preRange,
      value: currScrollRange
    }), this._dispatchEvent("scrollDrag", {
      pre: preRange,
      value: currScrollRange
    }));
  }
  getScrollRange() {
    return this.attribute.range;
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { delayType = "throttle", delayTime = 0 } = this.attribute;
    this._rail && this._rail.addEventListener("pointerdown", delayMap[delayType](this._onRailPointerDown, delayTime)), this._slider && this._slider.addEventListener("pointerdown", this._onSliderPointerDown);
  }
  render() {
    this._reset();
    const { direction: direction2 = "horizontal", width, height, range: range2, limitRange = [0, 1], railStyle, sliderStyle, padding = 2 } = this.attribute, group = this.createOrUpdateChild("scrollbar-container", {}, "group"), rail = group.createOrUpdateChild("scrollbar-rail", Object.assign({
      x: 0,
      y: 0,
      width,
      height
    }, railStyle), "rect");
    this._rail = rail;
    const sliderRenderBounds = this._getSliderRenderBounds(), sliderPos = this._getSliderPos(clampRange_default(range2, limitRange[0], limitRange[1])), sliderSize = sliderPos[1] - sliderPos[0];
    let sliderAttribute;
    this._sliderSize = sliderSize, sliderAttribute = "horizontal" === direction2 ? {
      x: sliderPos[0],
      y: sliderRenderBounds.y1,
      width: sliderSize,
      height: sliderRenderBounds.height
    } : {
      x: sliderRenderBounds.x1,
      y: sliderPos[0],
      width: sliderRenderBounds.width,
      height: sliderSize
    };
    const slider2 = group.createOrUpdateChild("slider", Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), {
      cornerRadius: this._getDefaultSliderCornerRadius()
    }), sliderStyle), {
      boundsPadding: normalizePadding(padding),
      pickMode: "imprecise"
    }), "rect");
    this._slider = slider2, this._container = group;
    const containerAABBBounds = this._container.AABBBounds;
    this._viewPosition = {
      x: containerAABBBounds.x1,
      y: containerAABBBounds.y1
    };
  }
  _getSliderRenderBounds() {
    if (this._sliderRenderBounds) return this._sliderRenderBounds;
    const { width, height, padding = 2 } = this.attribute, [top, right2, bottom, left2] = normalizePadding(padding), renderBounds = {
      x1: left2,
      y1: top,
      x2: width - right2,
      y2: height - bottom,
      width: Math.max(0, width - (left2 + right2)),
      height: Math.max(0, height - (top + bottom))
    };
    return this._sliderRenderBounds = renderBounds, renderBounds;
  }
  _getDefaultSliderCornerRadius() {
    const { direction: direction2, round } = this.attribute;
    if (round) {
      const { width, height } = this._getSliderRenderBounds();
      return "horizontal" === direction2 ? height : width;
    }
    return 0;
  }
  _getSliderPos(range2) {
    const { direction: direction2 } = this.attribute, { width, height, x1: x14, y1: y14 } = this._getSliderRenderBounds();
    return "horizontal" === direction2 ? [width * range2[0] + x14, width * range2[1] + x14] : [height * range2[0] + y14, height * range2[1] + y14];
  }
  _getScrollRange() {
    if (this._sliderLimitRange) return this._sliderLimitRange;
    const { limitRange = [0, 1], direction: direction2 } = this.attribute, [min4, max4] = clampRange_default(limitRange, 0, 1), { width, height, x1: x14, y1: y14 } = this._getSliderRenderBounds(), sliderSize = this._sliderSize;
    return "horizontal" === direction2 ? clampRange_default([x14 + min4 * width, x14 + max4 * width], x14, width - sliderSize) : clampRange_default([y14 + min4 * height, y14 + max4 * height], y14, height - sliderSize);
  }
  _reset() {
    this._sliderRenderBounds = null, this._sliderLimitRange = null;
  }
};
ScrollBar.defaultAttributes = {
  direction: "horizontal",
  round: true,
  sliderSize: 20,
  sliderStyle: {
    fill: "rgba(0, 0, 0, .5)"
  },
  railStyle: {
    fill: "rgba(0, 0, 0, .0)"
  },
  padding: 2,
  scrollRange: [0, 1],
  delayType: "throttle",
  delayTime: 0,
  realTime: true
};

// node_modules/@visactor/vrender-components/es/util/common.js
function traverseGroup(group, cb) {
  group.forEachChildren((node) => {
    const stopped = cb(node);
    node.isContainer && !stopped && traverseGroup(node, cb);
  });
}
var isVisible = (obj) => !isNil_default(obj) && false !== obj.visible;
function getMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.getChildren() : [];
}
function getNoneGroupMarksByName(root, name) {
  if (!name) return [];
  const group = root.find((node) => node.name === name, true);
  return group ? group.findAll((node) => "group" !== node.type, true) : [];
}

// node_modules/@visactor/vrender-components/es/util/label-smartInvert.js
var defaultAlternativeColors = ["#ffffff", "#000000"];
function labelSmartInvert(foregroundColorOrigin, backgroundColorOrogin, textType, contrastRatiosThreshold, alternativeColors, mode2) {
  if ("string" != typeof foregroundColorOrigin || "string" != typeof backgroundColorOrogin) return foregroundColorOrigin;
  const foregroundColor = new Color(foregroundColorOrigin).toHex(), backgroundColor = new Color(backgroundColorOrogin).toHex();
  return contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode2) ? foregroundColor : improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode2);
}
function improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode2) {
  const alternativeColorPalletes = [];
  alternativeColors && (alternativeColors instanceof Array ? alternativeColorPalletes.push(...alternativeColors) : alternativeColorPalletes.push(alternativeColors)), alternativeColorPalletes.push(...defaultAlternativeColors);
  for (const alternativeColor of alternativeColorPalletes) if (foregroundColor !== alternativeColor && contrastAccessibilityChecker(alternativeColor, backgroundColor, textType, contrastRatiosThreshold, mode2)) return alternativeColor;
}
function contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode2) {
  if ("lightness" === mode2) {
    const backgroundColorLightness = Color.getColorBrightness(new Color(backgroundColor));
    return Color.getColorBrightness(new Color(foregroundColor)) < 0.5 ? backgroundColorLightness >= 0.5 : backgroundColorLightness < 0.5;
  }
  return contrastRatiosThreshold ? contrastRatios(foregroundColor, backgroundColor) > contrastRatiosThreshold : "largeText" === textType ? contrastRatios(foregroundColor, backgroundColor) > 3 : contrastRatios(foregroundColor, backgroundColor) > 4.5;
}
function contrastRatios(foregroundColor, backgroundColor) {
  const foregroundColorLuminance = getColorLuminance(foregroundColor), backgroundColorLuminance = getColorLuminance(backgroundColor);
  return ((foregroundColorLuminance > backgroundColorLuminance ? foregroundColorLuminance : backgroundColorLuminance) + 0.05) / ((foregroundColorLuminance > backgroundColorLuminance ? backgroundColorLuminance : foregroundColorLuminance) + 0.05);
}
function getColorLuminance(color) {
  const rgb8bit = hexToRgb(color), RsRGB = rgb8bit[0] / 255, GsRGB = rgb8bit[1] / 255, BsRGB = rgb8bit[2] / 255;
  let R2, G2, B2;
  R2 = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4), G2 = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4), B2 = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
  return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
}
function smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor) {
  let result2;
  switch (fillStrategy) {
    case "base":
      result2 = baseColor;
      break;
    case "invertBase":
      result2 = invertColor;
      break;
    case "similarBase":
      result2 = similarColor;
  }
  return result2;
}

// node_modules/@visactor/vrender-components/es/util/matrix.js
function scale3(vector, scale4) {
  return [vector[0] * scale4, vector[1] * scale4];
}
function length(vector) {
  const [x3, y3] = vector;
  return Math.sqrt(x3 * x3 + y3 * y3);
}
function normalize2(vector) {
  const [x3, y3] = vector;
  let len = x3 * x3 + y3 * y3;
  return len > 0 && (len = 1 / Math.sqrt(len)), [vector[0] * len, vector[1] * len];
}
function angle(vector1, vector2) {
  const [x14, y14] = vector1, [x23, y23] = vector2, mag = Math.sqrt((x14 * x14 + y14 * y14) * (x23 * x23 + y23 * y23)), cosine = mag && (x14 * x23 + y14 * y23) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  const ang = angle(v1, v2), angleLargeThanPI = direction(v1, v2) >= 0;
  return direct ? angleLargeThanPI ? 2 * Math.PI - ang : ang : angleLargeThanPI ? ang : 2 * Math.PI - ang;
}

// node_modules/@visactor/vrender-components/es/constant.js
var POLAR_START_ANGLE2 = -0.5 * Math.PI;
var POLAR_END_ANGLE2 = 1.5 * Math.PI;
var DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol";
var DEFAULT_TEXT_FONT_SIZE = 11;
var StateValue;
!function(StateValue2) {
  StateValue2.selected = "selected", StateValue2.selectedReverse = "selected_reverse", StateValue2.hover = "hover", StateValue2.hoverReverse = "hover_reverse";
}(StateValue || (StateValue = {}));
var DEFAULT_STATES = {
  [StateValue.selectedReverse]: {},
  [StateValue.selected]: {},
  [StateValue.hover]: {},
  [StateValue.hoverReverse]: {}
};
var DEFAULT_HTML_TEXT_SPEC = {
  container: "",
  width: 30,
  height: 30,
  style: {}
};

// node_modules/@visactor/vrender-components/es/util/text.js
var initTextMeasure2 = (textSpec, option, useNaiveCanvas) => new TextMeasure(Object.assign({
  defaultFontParams: {
    fontFamily: DEFAULT_TEXT_FONT_FAMILY,
    fontSize: DEFAULT_TEXT_FONT_SIZE
  },
  getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
  specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
}, null != option ? option : {}), textSpec);
function measureTextSize(text2, textSpec, fontFamily = DEFAULT_TEXT_FONT_FAMILY) {
  var _a, _b;
  if (!text2) return {
    width: 0,
    height: 0
  };
  const bounds = getTextBounds({
    text: text2,
    fontFamily: null !== (_a = textSpec.fontFamily) && void 0 !== _a ? _a : fontFamily,
    fontSize: textSpec.fontSize || 12,
    fontWeight: textSpec.fontWeight,
    textAlign: null !== (_b = textSpec.textAlign) && void 0 !== _b ? _b : "center",
    textBaseline: textSpec.textBaseline,
    ellipsis: !!textSpec.ellipsis,
    maxLineWidth: textSpec.maxLineWidth || 1 / 0,
    lineHeight: textSpec.fontSize || 12
  });
  return {
    width: bounds.width(),
    height: bounds.height()
  };
}

// node_modules/@visactor/vrender-components/es/tag/register.js
function loadTagComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
}

// node_modules/@visactor/vrender-components/es/tag/tag.js
var __rest = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
loadTagComponent();
var Tag = class _Tag extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tag.defaultAttributes, attributes)), this.name = "tag";
  }
  render() {
    var _a, _b, _c, _d;
    const { text: text2 = "", textStyle = {}, shape = {}, panel = {}, space = 4, minWidth, maxWidth, padding = 4, visible, state, type, textAlwaysCenter } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("tag-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    let symbol, tagWidth = parsedPadding[1] + parsedPadding[3], tagHeight = parsedPadding[0] + parsedPadding[2], textX = 0, symbolPlaceWidth = 0;
    const { visible: shapeVisible } = shape, shapeStyle = __rest(shape, ["visible"]);
    if (isBoolean_default(shapeVisible)) {
      const size = (null == shapeStyle ? void 0 : shapeStyle.size) || 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
      symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
        symbolType: "circle",
        size,
        strokeBoundsBuffer: 0
      }, shapeStyle), {
        visible: shapeVisible,
        x: maxSize / 2,
        y: maxSize / 2
      }), "symbol"), isEmpty_default(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize + space);
    }
    let textShape;
    if (tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth, "rich" === type) {
      const richTextAttrs = Object.assign(Object.assign({
        textConfig: text2,
        visible: isValid_default(text2) && false !== visible
      }, textStyle), {
        x: textX,
        y: 0,
        width: null !== (_a = textStyle.width) && void 0 !== _a ? _a : 0,
        height: null !== (_b = textStyle.height) && void 0 !== _b ? _b : 0
      });
      textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext");
      const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
      if (visible && isBoolean_default(bgVisible)) {
        const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && !!text2,
          x: textShape.AABBBounds.x1,
          y: textShape.AABBBounds.y1,
          width: textShape.AABBBounds.width(),
          height: textShape.AABBBounds.height()
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
    } else if ("html" === type) {
      const richTextAttrs = Object.assign(Object.assign({
        textConfig: [],
        visible: isValid_default(text2) && false !== visible,
        html: Object.assign(Object.assign({
          dom: text2
        }, DEFAULT_HTML_TEXT_SPEC), textStyle)
      }, textStyle), {
        x: textX,
        y: 0
      });
      textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext");
      const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
      if (visible && isBoolean_default(bgVisible)) {
        const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && !!text2,
          x: textShape.AABBBounds.x1,
          y: textShape.AABBBounds.y1,
          width: textShape.AABBBounds.width(),
          height: textShape.AABBBounds.height()
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
    } else {
      const textAttrs = Object.assign(Object.assign({
        text: text2,
        visible: isValid_default(text2) && false !== visible,
        lineHeight: null == textStyle ? void 0 : textStyle.fontSize
      }, textStyle), {
        x: textX,
        y: 0
      });
      isNil_default(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text"), isEmpty_default(null == state ? void 0 : state.text) || (textShape.states = state.text);
      const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_c = this.stage) || void 0 === _c ? void 0 : _c.getTheme().text.fontFamily), textWidth = textBounds.width, textHeight = textBounds.height;
      tagWidth += textWidth;
      const size = null !== (_d = shape.size) && void 0 !== _d ? _d : 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
      tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
      const { textAlign, textBaseline } = textStyle;
      (isValid_default(minWidth) || isValid_default(maxWidth)) && (isValid_default(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid_default(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2])));
      let x3 = 0, y3 = 0;
      "center" === textAlign ? (x3 -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2)) : "right" === textAlign || "end" === textAlign ? (x3 -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : "left" !== textAlign && "start" !== textAlign || group.setAttribute("x", parsedPadding[3]), !textAlwaysCenter || "left" !== textAlign && "start" !== textAlign || textShape.setAttributes({
        x: textX + tagWidth / 2,
        textAlign: "center"
      }), "middle" === textBaseline ? (y3 -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (y3 -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2));
      const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
      if (visible && isBoolean_default(bgVisible)) {
        const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && !!text2,
          x: x3,
          y: y3,
          width: tagWidth,
          height: tagHeight
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
    }
  }
};
Tag.defaultAttributes = {
  visible: true,
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  space: 4,
  padding: 4,
  shape: {
    fill: "#000"
  }
};

// node_modules/@visactor/vrender-components/es/poptip/theme.js
var DEFAULT_THEME = {
  visible: true,
  position: "auto",
  titleStyle: {
    fontSize: 16,
    fill: "#08979c"
  },
  contentStyle: {
    fontSize: 12,
    fill: "green"
  },
  panel: {
    visible: true,
    fill: "#e6fffb",
    size: 12,
    space: 0,
    stroke: "#87e8de",
    lineWidth: 1,
    cornerRadius: 4
  }
};
var theme = {
  poptip: merge({}, DEFAULT_THEME)
};

// node_modules/@visactor/vrender-components/es/poptip/register.js
function loadPoptipComponent() {
  registerGroup(), registerWrapText(), registerSymbol(), registerRect();
}
function setPoptipTheme(defaultPoptipTheme) {
  merge(theme.poptip, DEFAULT_THEME, defaultPoptipTheme);
}

// node_modules/@visactor/vrender-components/es/poptip/poptip.js
var __rest2 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var _tBounds = new AABBBounds();
loadPoptipComponent();
var PopTip = class _PopTip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PopTip.defaultAttributes, attributes)), this.name = "poptip", this.positionList = ["top", "tl", "tr", "bottom", "bl", "br", "left", "lt", "lb", "right", "rt", "rb"];
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { titleStyle = {}, position, contentStyle = {}, panel = {}, space = 4, minWidth = 0, maxWidth = 1 / 0, padding = 4, maxWidthPercent, visible, state, dx = 0, dy = 0 } = this.attribute;
    let { title: title3 = "", content = "" } = this.attribute;
    title3 = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title3) : title3, content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
    const parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("poptip-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group"), maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3], titleVisible = isValid_default(title3) && false !== visible, titleAttrs = Object.assign(Object.assign({
      text: isArray_default(title3) ? title3 : [title3],
      visible: titleVisible
    }, titleStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0],
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), titleShape = group.createOrUpdateChild("poptip-title", titleAttrs, "wrapText");
    isEmpty_default(null == state ? void 0 : state.title) || (titleShape.states = state.title);
    const titleBounds = titleShape.AABBBounds, titleHeight = titleBounds.height(), titleWidth = titleBounds.width();
    let height = titleHeight + space;
    titleVisible || (height = 0);
    const contentVisible = isValid_default(content) && false !== visible, contentAttrs = Object.assign(Object.assign({
      text: isArray_default(content) ? content : [content],
      visible: contentVisible
    }, contentStyle), {
      x: parsedPadding[3],
      y: parsedPadding[0] + height,
      maxLineWidth,
      textAlign: "left",
      textBaseline: "top"
    }), contentShape = group.createOrUpdateChild("poptip-content", contentAttrs, "wrapText");
    isEmpty_default(null == state ? void 0 : state.content) || (contentShape.states = state.content);
    const contentBounds = contentShape.AABBBounds, contentHeight = contentBounds.height(), contentWidth = contentBounds.width();
    contentVisible && (height += contentHeight);
    let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
    popTipWidth > maxWidth ? popTipWidth = maxWidth : popTipWidth < minWidth && (popTipWidth = minWidth);
    let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
    const { visible: bgVisible } = panel, backgroundStyle = __rest2(panel, ["visible"]), symbolSize = null !== (_a = backgroundStyle.size) && void 0 !== _a ? _a : 12, spaceSize = isArray_default(symbolSize) ? [symbolSize[0] + (null !== (_b = backgroundStyle.space) && void 0 !== _b ? _b : 0), symbolSize[1] + (null !== (_c = backgroundStyle.space) && void 0 !== _c ? _c : 0)] : symbolSize + (null !== (_d = backgroundStyle.space) && void 0 !== _d ? _d : 0), lineWidth = null !== (_e = backgroundStyle.lineWidth) && void 0 !== _e ? _e : 1, range2 = this.stage ? [null !== (_f = this.stage.viewWidth) && void 0 !== _f ? _f : this.stage.width, null !== (_g = this.stage.viewHeight) && void 0 !== _g ? _g : this.stage.height] : void 0;
    if (range2) {
      const b2 = this.AABBBounds, leftWidth = null !== (_h = this.attribute.x) && void 0 !== _h ? _h : b2.x1, rightWidth = range2[0] - b2.x1;
      let maxSpace = Math.max(leftWidth, rightWidth);
      const buf = (isArray_default(symbolSize) ? symbolSize[0] : 12) + 3;
      if (maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent), maxSpace < popTipWidth) {
        popTipWidth = maxSpace;
        const buf2 = parsedPadding[1] + parsedPadding[3];
        titleShape.setAttribute("maxLineWidth", maxSpace - buf2), contentShape.setAttribute("maxLineWidth", maxSpace - buf2), poptipHeight = parsedPadding[0] + parsedPadding[2], titleVisible && (poptipHeight += titleShape.AABBBounds.height() + space), poptipHeight += contentShape.AABBBounds.height();
      }
    }
    const layout2 = "auto" === position;
    let maxBBoxI, maxBBoxSize = -1 / 0;
    for (let i2 = 0; i2 < this.positionList.length + 1; i2++) {
      const p2 = layout2 ? this.positionList[i2 === this.positionList.length ? maxBBoxI : i2] : position, { angle: angle2, offset, rectOffset } = this.getAngleAndOffset(p2, popTipWidth, poptipHeight, isArray_default(spaceSize) ? spaceSize : [spaceSize, spaceSize - lineWidth]);
      if (isBoolean_default(bgVisible)) {
        const offsetX = (isArray_default(symbolSize) ? symbolSize[0] : symbolSize) / 4, bgSymbol = group.createOrUpdateChild("poptip-symbol-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: offsetX,
          y: 0,
          strokeBoundsBuffer: -1,
          boundsPadding: -2,
          anchor: [0, 0],
          symbolType: "arrow2Left",
          angle: angle2,
          dx: offset[0],
          dy: offset[1],
          size: symbolSize,
          zIndex: -9
        }), "symbol");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgSymbol.states = state.panel);
        const bgRect = group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && (contentVisible || titleVisible),
          x: 0,
          y: 0,
          width: popTipWidth,
          height: poptipHeight,
          zIndex: -8
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
      }
      if (group.setAttributes({
        x: -offset[0] + dx,
        y: -offset[1] + dy
      }), !layout2 || !range2) break;
      {
        _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
        const b2 = _tBounds, stageBounds = new Bounds().setValue(0, 0, range2[0], range2[1]);
        if (rectInsideAnotherRect(b2, stageBounds, false)) break;
        {
          const bbox = getRectIntersect(b2, stageBounds, false), size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
          size > maxBBoxSize && (maxBBoxSize = size, maxBBoxI = i2);
        }
      }
    }
  }
  getAngleAndOffset(position, width, height, size) {
    const sizeH = size[1] / 2;
    switch (position) {
      case "tl":
        return {
          angle: pi / 2 * 3,
          offset: [width / 4, height + sizeH],
          rectOffset: [-width / 4, -height - size[1]]
        };
      case "top":
        return {
          angle: pi / 2 * 3,
          offset: [width / 2, height + sizeH],
          rectOffset: [0, -height - size[1]]
        };
      case "tr":
        return {
          angle: pi / 2 * 3,
          offset: [width / 4 * 3, height + sizeH],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
      case "rt":
        return {
          angle: 0,
          offset: [-sizeH, height / 5],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
      case "right":
        return {
          angle: 0,
          offset: [-sizeH, height / 2],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
      case "rb":
        return {
          angle: 0,
          offset: [-sizeH, height / 5 * 4],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
      case "bl":
        return {
          angle: pi / 2,
          offset: [width / 4, -sizeH],
          rectOffset: [-width / 4, -height - size[1]]
        };
      case "bottom":
        return {
          angle: pi / 2,
          offset: [width / 2, -sizeH],
          rectOffset: [0, -height - size[1]]
        };
      case "br":
        return {
          angle: pi / 2,
          offset: [width / 4 * 3, -sizeH],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
      case "lt":
        return {
          angle: pi,
          offset: [width + sizeH, height / 5],
          rectOffset: [-width / 4, -height - size[1]]
        };
      case "left":
        return {
          angle: pi,
          offset: [width + sizeH, height / 2],
          rectOffset: [0, -height - size[1]]
        };
      case "lb":
        return {
          angle: pi,
          offset: [width + sizeH, height / 5 * 4],
          rectOffset: [width / 4 * 3, -height - size[1]]
        };
    }
  }
};
PopTip.defaultAttributes = {
  position: "rt",
  visible: true,
  title: null,
  content: null,
  titleStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  contentStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  maxWidthPercent: 0.8,
  space: 8,
  padding: 10
};

// node_modules/@visactor/vrender-components/es/poptip/contribution.js
var __decorate105 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
function wrapPoptip(target, source) {
  return merge(target, theme.poptip, source), target;
}
var PopTipRenderContribution = class {
  render(graphic, context, x3, y3, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    if (1 === graphic._showPoptip) {
      const { visible, visibleCb } = graphic.attribute.poptip || {};
      if (false === visible || visibleCb && false === visibleCb(graphic)) return;
      const attribute = {};
      merge(attribute, PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {}), this.poptipComponent ? this.poptipComponent.initAttributes(attribute) : this.poptipComponent = new PopTip(attribute);
      let poptip2 = graphic.attribute.poptip || {};
      if ("text" === graphic.type && null == poptip2.title && null == poptip2.content) {
        const out = {};
        wrapPoptip(out, poptip2), poptip2 = out, poptip2.content = null !== (_a = poptip2.content) && void 0 !== _a ? _a : graphic.attribute.text;
      }
      const matrix = graphic.globalTransMatrix;
      this.poptipComponent.setAttributes(Object.assign(Object.assign({
        visibleAll: true,
        pickable: false,
        childrenPickable: false
      }, poptip2), {
        x: matrix.e,
        y: matrix.f
      })), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      interactiveLayer && interactiveLayer.add(this.poptipComponent);
    } else 2 === graphic._showPoptip && (graphic._showPoptip = 0, this.poptipComponent && this.poptipComponent.setAttributes({
      visibleAll: false
    }));
  }
};
PopTipRenderContribution = __decorate105([injectable()], PopTipRenderContribution);

// node_modules/@visactor/vrender-components/es/poptip/poptip-plugin.js
var __decorate106 = function(decorators, target, key, desc) {
  var d2, c4 = arguments.length, r2 = c4 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d2 = decorators[i2]) && (r2 = (c4 < 3 ? d2(r2) : c4 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c4 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var PopTipPlugin = class {
  constructor() {
    this.name = "poptip", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.poptip = (e3) => {
      const graphic = e3.target;
      if (graphic.isContainer || !graphic.attribute) return void this.unpoptip(e3);
      if (graphic === this.activeGraphic) return;
      const { poptip: poptip2 } = graphic.attribute;
      poptip2 && (graphic.setAttributes({}), graphic._showPoptip = 1), this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2), this.setActiveGraphic(graphic, true);
    }, this.unpoptip = (e3) => {
      this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2, this.setActiveGraphic(null, true));
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    stage.addEventListener("pointerover", this.poptip);
  }
  setActiveGraphic(graphic, rerender) {
    this.activeGraphic = graphic, this.pluginService.stage.renderNextFrame();
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("pointerover", this.poptip);
  }
};
PopTipPlugin = __decorate106([injectable()], PopTipPlugin);
var PopTipForClipedTextPlugin = class {
  constructor() {
    this.name = "poptipForText", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.pointerlave = (e3) => {
      const { stage } = this.pluginService;
      e3.target === stage && this.unpoptip(e3);
    }, this.poptip = (e3) => {
      const graphic = e3.target;
      if ("text" !== graphic.type || !graphic.cliped || graphic.isContainer || !graphic.attribute || graphic.attribute.disableAutoClipedPoptip) return void this.unpoptip(e3);
      if (graphic === this.activeGraphic) return;
      const { poptip: poptip2 = {} } = graphic.attribute;
      poptip2 && (graphic.setAttributes({}), graphic._showPoptip = 1), this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2), this.setActiveGraphic(graphic, true);
    }, this.unpoptip = (e3) => {
      this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2, this.setActiveGraphic(null, true));
    };
  }
  activate(context) {
    this.pluginService = context;
    const { stage } = this.pluginService;
    stage.addEventListener("pointerover", this.poptip), stage.addEventListener("pointerleave", this.pointerlave);
  }
  setActiveGraphic(graphic, rerender) {
    this.activeGraphic = graphic, this.pluginService.stage.renderNextFrame();
  }
  deactivate(context) {
    const { stage } = this.pluginService;
    stage.removeEventListener("pointerover", this.poptip), stage.removeEventListener("pointerleave", this.pointerlave);
  }
};
PopTipForClipedTextPlugin = __decorate106([injectable()], PopTipForClipedTextPlugin);

// node_modules/@visactor/vrender-components/es/poptip/module.js
var popTipModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(PopTipRenderContribution) || (bind(PopTipRenderContribution).toSelf().inSingletonScope(), bind(InteractiveSubRenderContribution).toService(PopTipRenderContribution)), isBound(PopTipPlugin) || (bind(PopTipPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipPlugin)), isBound(PopTipForClipedTextPlugin) || (bind(PopTipForClipedTextPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipForClipedTextPlugin));
});
function loadPoptip() {
  container.load(popTipModule);
}

// node_modules/@visactor/vrender-components/es/crosshair/base.js
var CrosshairBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "crosshair";
  }
  render() {
    this.renderCrosshair(this);
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/register.js
function loadLineCrosshairComponent() {
  registerGroup(), registerLine();
}
function loadCircleCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonCrosshairComponent() {
  registerGroup(), registerPath();
}
function loadRectCrosshairComponent() {
  registerGroup(), registerRect();
}
function loadSectorCrosshairComponent() {
  registerGroup(), registerArc();
}

// node_modules/@visactor/vrender-components/es/crosshair/line.js
loadLineCrosshairComponent();
var LineCrosshair = class _LineCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-line", Object.assign({
      points: [start, end]
    }, lineStyle), "line");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
LineCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/rect.js
loadRectCrosshairComponent();
var RectCrosshair = class _RectCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _RectCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, rectStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-rect", Object.assign({
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    }, rectStyle), "rect");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
RectCrosshair.defaultAttributes = {
  rectStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/circle.js
loadCircleCrosshairComponent();
var CircleCrosshair = class _CircleCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-circle", Object.assign(Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius
    }), this.attribute), lineStyle), "arc");
  }
  setLocation(point6) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point6, center2);
    this.setAttribute("radius", radius);
  }
};
CircleCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: ["#b2bacf", false, false, false],
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/sector.js
loadSectorCrosshairComponent();
var SectorCrosshair = class _SectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, innerRadius = 0, sectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-sector", Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius,
      innerRadius,
      startAngle,
      endAngle
    }), sectorStyle), "arc");
  }
  setLocation(point6) {
    const { center: center2, startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2 } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center2, point6));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
SectorCrosshair.defaultAttributes = {
  sectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// node_modules/@visactor/vrender-components/es/crosshair/polygon.js
loadPolygonCrosshairComponent();
var PolygonCrosshair = class _PolygonCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, sides = 6, lineStyle } = this.attribute, { startAngle, endAngle } = this.attribute, isClose = (endAngle - startAngle) % (2 * Math.PI) == 0, eachAngle = (endAngle - startAngle) / sides;
    let path;
    for (let index = 0; index <= sides; index++) {
      const point6 = polarToCartesian(center2, radius, startAngle + eachAngle * index);
      0 === index ? path = `M${point6.x},${point6.y}` : path += `L${point6.x},${point6.y}`, index === sides && isClose && (path += "Z");
    }
    return container2.createOrUpdateChild("crosshair-polygon", Object.assign({
      path
    }, lineStyle), "path");
  }
  setLocation(point6) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point6, center2);
    this.setAttribute("radius", radius);
  }
};
PolygonCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// node_modules/@visactor/vrender-components/es/label/overlap/bitmap.js
var RIGHT0 = new Uint32Array(33);
var RIGHT1 = new Uint32Array(33);
RIGHT1[0] = 0, RIGHT0[0] = ~RIGHT1[0];
for (let i2 = 1; i2 <= 32; ++i2) RIGHT1[i2] = RIGHT1[i2 - 1] << 1 | 1, RIGHT0[i2] = ~RIGHT1[i2];
function bitmap(w2, h2) {
  const array2 = new Uint32Array(~~((w2 * h2 + 32) / 32));
  function _set(index, mask) {
    array2[index] |= mask;
  }
  function _clear(index, mask) {
    array2[index] &= mask;
  }
  return {
    array: array2,
    get: (x3, y3) => {
      const index = y3 * w2 + x3;
      return array2[index >>> 5] & 1 << (31 & index);
    },
    set: (x3, y3) => {
      const index = y3 * w2 + x3;
      _set(index >>> 5, 1 << (31 & index));
    },
    clear: (x3, y3) => {
      const index = y3 * w2 + x3;
      _clear(index >>> 5, ~(1 << (31 & index)));
    },
    getRange: ({ x1: x14, y1: y14, x2: x23, y2: y23 }) => {
      if (x23 < 0 || y23 < 0 || x14 > w2 || y14 > h2) return true;
      let start, end, indexStart, indexEnd, r2 = y23;
      for (; r2 >= y14; --r2) if (start = r2 * w2 + x14, end = r2 * w2 + x23, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) {
        if (array2[indexStart] & RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]) return true;
      } else {
        if (array2[indexStart] & RIGHT0[31 & start]) return true;
        if (array2[indexEnd] & RIGHT1[1 + (31 & end)]) return true;
        for (let i2 = indexStart + 1; i2 < indexEnd; ++i2) if (array2[i2]) return true;
      }
      return false;
    },
    setRange: ({ x1: x14, y1: y14, x2: x23, y2: y23 }) => {
      if (x23 < 0 || y23 < 0 || x14 > w2 || y14 > h2) return;
      let start, end, indexStart, indexEnd, i2;
      for (; y14 <= y23; ++y14) if (start = y14 * w2 + x14, end = y14 * w2 + x23, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _set(indexStart, RIGHT0[31 & start] & RIGHT1[1 + (31 & end)]);
      else for (_set(indexStart, RIGHT0[31 & start]), _set(indexEnd, RIGHT1[1 + (31 & end)]), i2 = indexStart + 1; i2 < indexEnd; ++i2) _set(i2, 4294967295);
    },
    clearRange: ({ x1: x14, y1: y14, x2: x23, y2: y23 }) => {
      let start, end, indexStart, indexEnd, i2;
      for (; y14 <= y23; ++y14) if (start = y14 * w2 + x14, end = y14 * w2 + x23, indexStart = start >>> 5, indexEnd = end >>> 5, indexStart === indexEnd) _clear(indexStart, RIGHT1[31 & start] | RIGHT0[1 + (31 & end)]);
      else for (_clear(indexStart, RIGHT1[31 & start]), _clear(indexEnd, RIGHT0[1 + (31 & end)]), i2 = indexStart + 1; i2 < indexEnd; ++i2) _clear(i2, 0);
    },
    outOfBounds: ({ x1: x14, y1: y14, x2: x23, y2: y23 }) => x14 < 0 || y14 < 0 || y23 >= h2 || x23 >= w2,
    toImageData: (ctx) => {
      const imageData = ctx.createImageData(w2, h2), data = imageData.data;
      for (let y3 = 0; y3 < h2; ++y3) for (let x3 = 0; x3 < w2; ++x3) {
        const index = y3 * w2 + x3, offset = 4 * index, occupied = array2[index >>> 5] & 1 << (31 & index);
        data[offset + 0] = 255 * occupied, data[offset + 1] = 255 * occupied, data[offset + 2] = 255 * occupied, data[offset + 3] = 31;
      }
      return imageData;
    }
  };
}

// node_modules/@visactor/vrender-components/es/label/overlap/scaler.js
function bitmapTool(width, height, padding = 0) {
  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)), w2 = ~~((width + 2 * padding + ratio) / ratio), h2 = ~~((height + 2 * padding + ratio) / ratio), scale4 = (_2) => ~~((_2 + padding) / ratio);
  return scale4.invert = (_2) => _2 * ratio - padding, scale4.bitmap = () => bitmap(w2, h2), scale4.ratio = ratio, scale4.padding = padding, scale4.width = width, scale4.height = height, scale4;
}
function boundToRange($2, bound2, clamp2 = false) {
  if (clamp2) {
    const { x1: x14, x2: x23, y1: y14, y2: y23 } = bound2, _x1 = clamp_default(x14, 0, $2.width), _x2 = clamp_default(x23, 0, $2.width), _y1 = clamp_default(y14, 0, $2.height), _y2 = clamp_default(y23, 0, $2.height);
    return {
      x1: $2(_x1),
      x2: $2(_x2),
      y1: $2(_y1),
      y2: $2(_y2)
    };
  }
  return {
    x1: $2(bound2.x1),
    x2: $2(bound2.x2),
    y1: $2(bound2.y1),
    y2: $2(bound2.y2)
  };
}

// node_modules/@visactor/vrender-components/es/label/overlap/place.js
function canPlace($2, bitmap2, bound2, checkBound = true, pad = 0) {
  let range2 = bound2;
  pad > 0 && (range2 = {
    x1: bound2.x1 - pad,
    x2: bound2.x2 + pad,
    y1: bound2.y1 - pad,
    y2: bound2.y2 + pad
  }), range2 = boundToRange($2, range2);
  return !(checkBound && bitmap2.outOfBounds(range2)) && !bitmap2.getRange(range2);
}
function placeToCandidates($2, bitmap2, text2, candidates = [], clampForce = true, pad = 0) {
  const validCandidates = candidates.filter((candidate) => isValid_default(candidate));
  for (let i2 = 0; i2 < validCandidates.length; i2++) {
    const tempText = text2.clone();
    if (tempText.setAttributes(validCandidates[i2]), tempText.update(), canPlace($2, bitmap2, boundToRange($2, tempText.AABBBounds), clampForce, pad)) return bitmap2.setRange(boundToRange($2, tempText.AABBBounds, true)), validCandidates[i2];
  }
  return false;
}
function place($2, bitmap2, s3, attrs, text2, bounds, labeling) {
  var _a, _b;
  const clampForce = null === (_a = attrs.overlap) || void 0 === _a ? void 0 : _a.clampForce, overlapPadding = null === (_b = attrs.overlap) || void 0 === _b ? void 0 : _b.overlapPadding;
  if ("bound" === s3.type || "position" === s3.type) {
    if (isFunction_default(labeling)) {
      const candidates = ((isFunction_default(s3.position) ? s3.position(text2.attribute) : s3.position) || defaultLabelPosition(attrs.type)).map((p2) => labeling(text2.AABBBounds, bounds, p2, attrs.offset));
      return placeToCandidates($2, bitmap2, text2, candidates, clampForce, overlapPadding);
    }
    return false;
  }
  if ("moveY" === s3.type) {
    const candidates = (s3.offset ? isFunction_default(s3.offset) ? s3.offset(text2.attribute) : s3.offset : []).map((dy) => ({
      x: text2.attribute.x,
      y: text2.attribute.y + dy
    }));
    return placeToCandidates($2, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  if ("moveX" === s3.type) {
    const candidates = (s3.offset ? isFunction_default(s3.offset) ? s3.offset(text2.attribute) : s3.offset : []).map((dx) => ({
      x: text2.attribute.x + dx,
      y: text2.attribute.y
    }));
    return placeToCandidates($2, bitmap2, text2, candidates, clampForce, overlapPadding);
  }
  return false;
}
var DefaultPositions = ["top", "bottom", "right", "left", "top-right", "bottom-right", "top-left", "bottom-left"];
var DefaultRectPositions = ["top", "inside-top", "inside"];
function defaultLabelPosition(type) {
  return "rect" === type ? DefaultRectPositions : DefaultPositions;
}
function clampText(text2, width, height) {
  const { x1: x14, x2: x23, y1: y14, y2: y23 } = text2.AABBBounds, minX = Math.min(x14, x23), maxX = Math.max(x14, x23), minY = Math.min(y14, y23), maxY2 = Math.max(y14, y23);
  let dx = 0, dy = 0;
  return minX < 0 && maxX - minX <= width ? dx = -minX : maxX > width && minX - (maxX - width) >= 0 && (dx = width - maxX), minY < 0 && maxY2 - minY <= height ? dy = -minY : maxY2 > height && minY - (maxY2 - height) >= 0 && (dy = height - maxY2), {
    dx,
    dy
  };
}

// node_modules/@visactor/vrender-components/es/label/animate/animate.js
var fadeIn = (textAttribute2 = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_a = textAttribute2.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute2.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute2.strokeOpacity) && void 0 !== _c ? _c : 1
    }
  };
};
var fadeOut = (textAttribute2 = {}) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = textAttribute2.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = textAttribute2.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = textAttribute2.strokeOpacity) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};
var animationEffects = {
  fadeIn,
  fadeOut
};
function getAnimationAttributes(textAttribute2, type) {
  var _a, _b;
  return null !== (_b = null === (_a = animationEffects[type]) || void 0 === _a ? void 0 : _a.call(animationEffects, textAttribute2)) && void 0 !== _b ? _b : {
    from: {},
    to: {}
  };
}
function updateAnimation(prev, next, animationConfig2) {
  if (!isArray_default(animationConfig2)) {
    const { duration, easing, increaseEffect = true } = animationConfig2;
    return prev.animate().to(next.attribute, duration, easing), void (increaseEffect && playIncreaseCount(prev, next, duration, easing));
  }
  animationConfig2.forEach((cfg, i2) => {
    const { duration, easing, increaseEffect = true, channel } = cfg, { from, to } = update(prev, next, channel, cfg.options);
    isEmpty_default(to) || prev.animate().to(to, duration, easing), "text" in from && "text" in to && increaseEffect && playIncreaseCount(prev, next, duration, easing);
  });
}
var update = (prev, next, channel, options) => {
  const from = Object.assign({}, prev.attribute), to = Object.assign({}, next.attribute);
  return array(null == options ? void 0 : options.excludeChannels).forEach((key) => {
    delete to[key];
  }), Object.keys(to).forEach((key) => {
    channel && !channel.includes(key) && delete to[key];
  }), {
    from,
    to
  };
};
function playIncreaseCount(prev, next, duration, easing) {
  prev.attribute.text !== next.attribute.text && isValidNumber_default(Number(prev.attribute.text) * Number(next.attribute.text)) && prev.animate().play(new IncreaseCount({
    text: prev.attribute.text
  }, {
    text: next.attribute.text
  }, duration, easing));
}
var DefaultLabelAnimation = {
  mode: "same-time",
  duration: 300,
  easing: "linear"
};

// node_modules/@visactor/vrender-components/es/label/util.js
function polarToCartesian3(point6) {
  return point6.radius ? {
    x: Math.cos(point6.angle) * point6.radius,
    y: Math.sin(point6.angle) * point6.radius
  } : {
    x: 0,
    y: 0
  };
}
function circlePoint(x05, y05, radius, radian) {
  const offset = polarToCartesian3({
    radius,
    angle: radian
  });
  return {
    x: x05 + offset.x,
    y: y05 + offset.y
  };
}
function computeQuadrant2(angle2) {
  return (angle2 = normalizeAngle2(angle2)) > 0 && angle2 <= Math.PI / 2 ? 2 : angle2 > Math.PI / 2 && angle2 <= Math.PI ? 3 : angle2 > Math.PI && angle2 <= 3 * Math.PI / 2 ? 4 : 1;
}
function normalizeAngle2(angle2) {
  for (; angle2 < 0; ) angle2 += 2 * Math.PI;
  for (; angle2 >= 2 * Math.PI; ) angle2 -= 2 * Math.PI;
  return angle2;
}
function isQuadrantLeft(quadrant) {
  return 3 === quadrant || 4 === quadrant;
}
function isQuadrantRight(quadrant) {
  return 1 === quadrant || 2 === quadrant;
}
function lineCirclePoints(a4, b2, c4, x05, y05, r2) {
  if (0 === a4 && 0 === b2 || r2 <= 0) return [];
  if (0 === a4) {
    const y15 = -c4 / b2, fd2 = r2 ** 2 - (y15 - y05) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x05,
      y: y15
    }];
    return [{
      x: Math.sqrt(fd2) + x05,
      y: y15
    }, {
      x: -Math.sqrt(fd2) + x05,
      y: y15
    }];
  }
  if (0 === b2) {
    const x15 = -c4 / a4, fd2 = r2 ** 2 - (x15 - x05) ** 2;
    if (fd2 < 0) return [];
    if (0 === fd2) return [{
      x: x15,
      y: y05
    }];
    return [{
      x: x15,
      y: Math.sqrt(fd2) + y05
    }, {
      x: x15,
      y: -Math.sqrt(fd2) + y05
    }];
  }
  const fa = (b2 / a4) ** 2 + 1, fb = 2 * ((c4 / a4 + x05) * (b2 / a4) - y05), fd = fb ** 2 - 4 * fa * ((c4 / a4 + x05) ** 2 + y05 ** 2 - r2 ** 2);
  if (fd < 0) return [];
  const y14 = (-fb + Math.sqrt(fd)) / (2 * fa), y23 = (-fb - Math.sqrt(fd)) / (2 * fa), x14 = -(b2 * y14 + c4) / a4;
  return 0 === fd ? [{
    x: x14,
    y: y14
  }] : [{
    x: x14,
    y: y14
  }, {
    x: -(b2 * y23 + c4) / a4,
    y: y23
  }];
}
function connectLineRadian(radius, length2) {
  return length2 > 2 * radius ? NaN : 2 * Math.asin(length2 / 2 / radius);
}
function checkBoundsOverlap(boundsA, boundsB) {
  const { x1: ax1, y1: ay1, x2: ax2, y2: ay2 } = boundsA, { x1: bx1, y1: by1, x2: bx2, y2: by2 } = boundsB;
  return !(ax1 <= bx1 && ax2 <= bx1 || ax1 >= bx2 && ax2 >= bx2 || ay1 <= by1 && ay2 <= by1 || ay1 >= by2 && ay2 >= by2);
}
var labelingPoint = (textBounds, graphicBounds, position = "top", offset = 0) => {
  if (!textBounds) return;
  const { x1: x14, y1: y14, x2: x23, y2: y23 } = textBounds, width = Math.abs(x23 - x14), height = Math.abs(y23 - y14), anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2, anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2;
  let sx = 0, sy = 0, offsetX = 0, offsetY = 0;
  graphicBounds && (offsetX = Math.abs(graphicBounds.x1 - graphicBounds.x2) / 2, offsetY = Math.abs(graphicBounds.y1 - graphicBounds.y2) / 2);
  const angle2 = {
    "top-right": -235,
    "top-left": 235,
    "bottom-right": 45,
    "bottom-left": -45
  };
  switch (position) {
    case "top":
      sy = -1;
      break;
    case "bottom":
      sy = 1;
      break;
    case "left":
      sx = -1;
      break;
    case "right":
      sx = 1;
      break;
    case "bottom-left":
    case "bottom-right":
    case "top-left":
    case "top-right":
      sx = Math.sin(angle2[position] * (Math.PI / 180)), sy = Math.cos(angle2[position] * (Math.PI / 180));
      break;
    case "center":
      sx = 0, sy = 0;
  }
  return {
    x: anchorX + sx * (offset + offsetX) + Math.sign(sx) * (width / 2),
    y: anchorY + sy * (offset + offsetY) + Math.sign(sy) * (height / 2)
  };
};
var getPointsOfLineArea = (graphic) => {
  if (!graphic || !graphic.attribute) return [];
  const { points, segments: segments2 } = graphic.attribute;
  if (segments2 && segments2.length) {
    const res = [];
    return segments2.forEach((seg) => {
      seg.points.forEach((point6) => {
        res.push(point6);
      });
    }), res;
  }
  return points;
};
function labelingLineOrArea(textBounds, graphicBounds, position = "end", offset = 0) {
  if (!textBounds || !graphicBounds) return {
    x: 1 / 0,
    y: 1 / 0
  };
  const { x1: x14, x2: x23 } = textBounds, width = Math.abs(x23 - x14), anchorX = graphicBounds.x1;
  let x3 = anchorX;
  return "end" === position ? x3 = anchorX + width / 2 + offset : "start" === position && (x3 = anchorX - width / 2 - offset), {
    x: x3,
    y: graphicBounds.y1
  };
}
function connectLineBetweenBounds(boundA, boundB) {
  if (!boundA || !boundB) return;
  if (isRectIntersect(boundA, boundB, true)) return;
  const x14 = Math.min(boundA.x1, boundA.x2), y14 = Math.min(boundA.y1, boundA.y2), x23 = Math.min(boundB.x1, boundB.x2), y23 = Math.min(boundB.y1, boundB.y2), w1 = Math.abs(boundA.x2 - x14) / 2, h1 = Math.abs(boundA.y2 - y14) / 2, w2 = Math.abs(boundB.x2 - x23) / 2, h2 = Math.abs(boundB.y2 - y23) / 2, cx1 = x14 + w1, cy1 = y14 + h1, cx2 = x23 + w2, cy2 = y23 + h2, dx = cx2 - cx1, dy = cy2 - cy1;
  return [getIntersection(dx, dy, cx1, cy1, w1, h1), getIntersection(-dx, -dy, cx2, cy2, w2, h2)];
}
function getIntersection(dx, dy, cx, cy, w2, h2) {
  return Math.abs(dy / dx) < h2 / w2 ? {
    x: cx + (dx > 0 ? w2 : -w2),
    y: cy + dy * w2 / Math.abs(dx)
  } : {
    x: cx + dx * h2 / Math.abs(dy),
    y: cy + (dy > 0 ? h2 : -h2)
  };
}

// node_modules/@visactor/vrender-components/es/label/register.js
function loadLabelComponent() {
  registerGroup(), registerText(), registerRichtext(), registerLine();
}

// node_modules/@visactor/vrender-components/es/label/base.js
loadLabelComponent();
var LabelBase = class _LabelBase extends AbstractComponent {
  setBitmap(bitmap2) {
    this._bitmap = bitmap2;
  }
  setBitmapTool(bmpTool) {
    this._bmpTool = bmpTool;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LabelBase.defaultAttributes, attributes)), this.name = "label", this._onHover = (e3) => {
      const target = e3.target;
      target === this._lastHover || isEmpty_default(target.states) || (target.addState(StateValue.hover, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.hoverReverse, true);
      }), this._lastHover = target);
    }, this._onUnHover = (e3) => {
      this._lastHover && (traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
      }), this._lastHover = null);
    }, this._onClick = (e3) => {
      const target = e3.target;
      if (this._lastSelect === target && target.hasState("selected")) return this._lastSelect = null, void traverseGroup(this, (node) => {
        isEmpty_default(node.states) || (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
      });
      isEmpty_default(target.states) || (target.addState(StateValue.selected, true), traverseGroup(this, (node) => {
        node === target || isEmpty_default(node.states) || node.addState(StateValue.selectedReverse, true);
      }), this._lastSelect = target);
    }, this._handleRelatedGraphicSetState = (e3) => {
      var _a, _b, _c, _d, _e;
      if ((null === (_a = e3.detail) || void 0 === _a ? void 0 : _a.type) === AttributeUpdateType.STATE || (null === (_b = e3.detail) || void 0 === _b ? void 0 : _b.type) === AttributeUpdateType.ANIMATE_UPDATE && (null === (_c = e3.detail.animationState) || void 0 === _c ? void 0 : _c.isFirstFrameOfStep)) {
        const currentStates = null !== (_e = null === (_d = e3.target) || void 0 === _d ? void 0 : _d.currentStates) && void 0 !== _e ? _e : [];
        (this._isCollectionBase ? [...this._graphicToText.values()] : [this._graphicToText.get(e3.target)]).forEach((label) => {
          label && (label.text && label.text.useStates(currentStates), label.labelLine && label.labelLine.useStates(currentStates));
        });
      }
    };
  }
  labeling(textBounds, graphicBounds, position, offset) {
  }
  _createLabelLine(text2, baseMark) {
    const points = connectLineBetweenBounds(text2.AABBBounds, null == baseMark ? void 0 : baseMark.AABBBounds);
    if (points) {
      const line2 = graphicCreator.line({
        points
      });
      return baseMark && baseMark.attribute.fill && line2.setAttribute("stroke", baseMark.attribute.fill), this.attribute.line && !isEmpty_default(this.attribute.line.style) && line2.setAttributes(this.attribute.line.style), this._setStatesOfLabelLine(line2), line2;
    }
  }
  render() {
    if (this._prepare(), isNil_default(this._idToGraphic) || this._isCollectionBase && isNil_default(this._idToPoint)) return;
    const { overlap: overlap2, smartInvert, dataFilter, customLayoutFunc, customOverlapFunc } = this.attribute;
    let labels, data = this.attribute.data;
    isFunction_default(dataFilter) && (data = dataFilter(data)), labels = isFunction_default(customLayoutFunc) ? customLayoutFunc(data, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d2) => this._idToPoint.get(d2.id) : null) : this._layout(data), isFunction_default(customOverlapFunc) ? labels = customOverlapFunc(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d2) => this._idToPoint.get(d2.id) : null) : false !== overlap2 && (labels = this._overlapping(labels)), labels && labels.length && labels.forEach((label) => {
      this._bindEvent(label), this._setStatesOfText(label);
    }), false !== smartInvert && this._smartInvert(labels), this._renderLabels(labels);
  }
  _bindEvent(target) {
    if (this.attribute.disableTriggerEvent) return;
    if (!target) return;
    const { hover, select } = this.attribute;
    hover && (target.addEventListener("pointermove", this._onHover), target.addEventListener("pointerout", this._onUnHover)), select && target.addEventListener("pointerdown", this._onClick);
  }
  _setStatesOfText(target) {
    if (!target) return;
    const state = this.attribute.state;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _setStatesOfLabelLine(target) {
    if (!target) return;
    const state = this.attribute.labelLineState;
    state && !isEmpty_default(state) && (target.states = state);
  }
  _createLabelText(attributes) {
    var _a, _b;
    if ("rich" === attributes.textType) {
      attributes.textConfig = attributes.text, attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0;
      return graphicCreator.richtext(attributes);
    }
    if ("html" === attributes.textType) {
      attributes.textConfig = [], attributes.html = Object.assign(Object.assign({
        dom: attributes.text
      }, DEFAULT_HTML_TEXT_SPEC), attributes);
      return graphicCreator.richtext(attributes);
    }
    return graphicCreator.text(attributes);
  }
  _prepare() {
    var _a, _b, _c, _d, _e;
    const currentBaseMarks = [];
    let baseMarks;
    if (baseMarks = isFunction_default(this.attribute.getBaseMarks) ? this.attribute.getBaseMarks() : getMarksByName(this.getRootNode(), this.attribute.baseMarkGroupName), baseMarks.forEach((mark) => {
      "willRelease" !== mark.releaseStatus && currentBaseMarks.push(mark);
    }), null === (_a = this._idToGraphic) || void 0 === _a || _a.clear(), null === (_b = this._idToPoint) || void 0 === _b || _b.clear(), this._baseMarks = currentBaseMarks, this._isCollectionBase = "line-data" === this.attribute.type, !currentBaseMarks || 0 === currentBaseMarks.length) return;
    const { data } = this.attribute;
    if (data && 0 !== data.length) {
      if (this._idToGraphic || (this._idToGraphic = /* @__PURE__ */ new Map()), this._isCollectionBase) {
        this._idToPoint || (this._idToPoint = /* @__PURE__ */ new Map());
        let cur = 0;
        for (let i2 = 0; i2 < currentBaseMarks.length; i2++) {
          const baseMark = currentBaseMarks[i2], points = getPointsOfLineArea(baseMark);
          if (points && points.length) for (let j2 = 0; j2 < points.length; j2++) {
            const textData = data[cur];
            textData && points[j2] && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${cur}`), this._idToPoint.set(textData.id, points[j2]), this._idToGraphic.set(textData.id, baseMark)), cur++;
          }
        }
      } else for (let i2 = 0; i2 < currentBaseMarks.length; i2++) {
        const textData = data[i2], baseMark = currentBaseMarks[i2];
        textData && baseMark && (isValid_default(textData.id) || (textData.id = `vrender-component-${this.name}-${i2}`), this._idToGraphic.set(textData.id, baseMark));
      }
      if (false !== this.attribute.animation) {
        const animation = isObject_default(this.attribute.animation) ? this.attribute.animation : {};
        this._animationConfig = {
          enter: merge({}, DefaultLabelAnimation, animation, null !== (_c = this.attribute.animationEnter) && void 0 !== _c ? _c : {}),
          exit: merge({}, DefaultLabelAnimation, animation, null !== (_d = this.attribute.animationExit) && void 0 !== _d ? _d : {}),
          update: isArray_default(this.attribute.animationUpdate) ? this.attribute.animationUpdate : merge({}, DefaultLabelAnimation, animation, null !== (_e = this.attribute.animationUpdate) && void 0 !== _e ? _e : {})
        };
      }
    }
  }
  getRelatedGraphic(item) {
    return this._idToGraphic.get(item.id);
  }
  _layout(data = []) {
    const { textStyle = {}, position, offset } = this.attribute, labels = [];
    for (let i2 = 0; i2 < data.length; i2++) {
      const textData = data[i2], baseMark = this.getRelatedGraphic(textData);
      if (!baseMark) continue;
      const labelAttribute = Object.assign(Object.assign({
        fill: this._isCollectionBase ? isArray_default(baseMark.attribute.stroke) ? baseMark.attribute.stroke.find((entry) => !!entry && true !== entry) : baseMark.attribute.stroke : baseMark.attribute.fill
      }, textStyle), textData), text2 = this._createLabelText(labelAttribute), textBounds = this.getGraphicBounds(text2), actualPosition = isFunction_default(position) ? position(textData) : position, graphicBounds = this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(textData.id), actualPosition) : this.getGraphicBounds(baseMark, {
        x: textData.x,
        y: textData.y
      }, actualPosition), textLocation = this.labeling(textBounds, graphicBounds, actualPosition, offset);
      textLocation && (labelAttribute.x = textLocation.x, labelAttribute.y = textLocation.y, text2.setAttributes(textLocation)), labels.push(text2);
    }
    return labels;
  }
  _overlapping(labels) {
    var _a, _b, _c, _d;
    if (0 === labels.length) return [];
    const option = isObject_default(this.attribute.overlap) ? this.attribute.overlap : {}, result2 = [], baseMarkGroup = this.getBaseMarkGroup(), size = null !== (_a = option.size) && void 0 !== _a ? _a : {
      width: null !== (_b = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.width()) && void 0 !== _b ? _b : 0,
      height: null !== (_c = null == baseMarkGroup ? void 0 : baseMarkGroup.AABBBounds.height()) && void 0 !== _c ? _c : 0
    };
    if (0 === size.width || 0 === size.height) return labels;
    const { avoidBaseMark, strategy = [], hideOnHit = true, clampForce = true, avoidMarks = [], overlapPadding } = option, bmpTool = this._bmpTool || bitmapTool(size.width, size.height), bitmap2 = this._bitmap || bmpTool.bitmap(), checkBounds = strategy.some((s3) => "bound" === s3.type);
    avoidBaseMark && (null === (_d = this._baseMarks) || void 0 === _d || _d.forEach((mark) => {
      mark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, mark.AABBBounds, true));
    })), avoidMarks.length > 0 && avoidMarks.forEach((avoid) => {
      isString_default(avoid) ? getNoneGroupMarksByName(this.getRootNode(), avoid).forEach((avoidMark) => {
        avoidMark.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoidMark.AABBBounds, true));
      }) : avoid.AABBBounds && bitmap2.setRange(boundToRange(bmpTool, avoid.AABBBounds, true));
    });
    for (let i2 = 0; i2 < labels.length; i2++) {
      if (false === labels[i2].visible) continue;
      const text2 = labels[i2], baseMark = this.getRelatedGraphic(text2.attribute);
      if (text2.update(), !isRectIntersect(baseMark.AABBBounds, {
        x1: 0,
        x2: bmpTool.width,
        y1: 0,
        y2: bmpTool.height
      }, true)) continue;
      if (canPlace(bmpTool, bitmap2, text2.AABBBounds, clampForce, overlapPadding)) {
        if (!checkBounds) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
        if (checkBounds && baseMark && baseMark.AABBBounds && this._canPlaceInside(text2.AABBBounds, baseMark.AABBBounds)) {
          bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
      }
      let hasPlace = false;
      for (let j2 = 0; j2 < strategy.length; j2++) if (hasPlace = place(bmpTool, bitmap2, strategy[j2], this.attribute, text2, this._isCollectionBase ? this.getGraphicBounds(null, this._idToPoint.get(labels[i2].attribute.id)) : this.getGraphicBounds(baseMark, labels[i2].attribute), this.labeling), false !== hasPlace) {
        text2.setAttributes({
          x: hasPlace.x,
          y: hasPlace.y
        }), result2.push(text2);
        break;
      }
      if (!hasPlace && clampForce) {
        const { dx = 0, dy = 0 } = clampText(text2, bmpTool.width, bmpTool.height);
        if (0 === dx && 0 === dy) {
          if (canPlace(bmpTool, bitmap2, text2.AABBBounds)) {
            bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
            continue;
          }
        } else if (canPlace(bmpTool, bitmap2, {
          x1: text2.AABBBounds.x1 + dx,
          x2: text2.AABBBounds.x2 + dx,
          y1: text2.AABBBounds.y1 + dy,
          y2: text2.AABBBounds.y2 + dy
        })) {
          text2.setAttributes({
            x: text2.attribute.x + dx,
            y: text2.attribute.y + dy
          }), bitmap2.setRange(boundToRange(bmpTool, text2.AABBBounds, true)), result2.push(text2);
          continue;
        }
      }
      !hasPlace && !hideOnHit && result2.push(text2);
    }
    return isFunction_default(this.onAfterLabelOverlap) && this.onAfterLabelOverlap(bitmap2), result2;
  }
  getBaseMarkGroup() {
    const { baseMarkGroupName } = this.attribute;
    if (baseMarkGroupName) return this.getRootNode().find((node) => node.name === baseMarkGroupName, true);
  }
  getGraphicBounds(graphic, point6 = {}) {
    if (graphic) {
      if (false !== graphic.attribute.visible) return graphic.AABBBounds;
      const { x: x4, y: y4 } = graphic.attribute;
      return {
        x1: x4,
        x2: x4,
        y1: y4,
        y2: y4
      };
    }
    const { x: x3, y: y3 } = point6;
    return {
      x1: x3,
      x2: x3,
      y1: y3,
      y2: y3
    };
  }
  _renderLabels(labels) {
    false === this._enableAnimation || false === this.attribute.animation ? this._renderWithOutAnimation(labels) : this._renderWithAnimation(labels);
  }
  _renderWithAnimation(labels) {
    var _a;
    const currentTextMap = /* @__PURE__ */ new Map(), prevTextMap = this._graphicToText || /* @__PURE__ */ new Map(), texts = [], labelLines = [], { visible: showLabelLine } = null !== (_a = this.attribute.line) && void 0 !== _a ? _a : {};
    labels.forEach((text2, index) => {
      const relatedGraphic = this.getRelatedGraphic(text2.attribute), textId = text2.attribute.id, textKey = this._isCollectionBase ? textId : relatedGraphic, state = (null == prevTextMap ? void 0 : prevTextMap.get(textKey)) ? "update" : "enter";
      let labelLine;
      if (showLabelLine && (labelLine = this._createLabelLine(text2, relatedGraphic)), "enter" === state) {
        if (texts.push(text2), currentTextMap.set(textKey, labelLine ? {
          text: text2,
          labelLine
        } : {
          text: text2
        }), relatedGraphic) {
          const { from, to } = getAnimationAttributes(text2.attribute, "fadeIn");
          this.add(text2), labelLine && (labelLines.push(labelLine), this.add(labelLine)), this._syncStateWithRelatedGraphic(relatedGraphic), this._animationConfig.enter.duration > 0 && relatedGraphic.once("animate-bind", (a4) => {
            text2.setAttributes(from), labelLine && labelLine.setAttributes(from);
            const listener = this._afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, this._animationConfig.enter);
            relatedGraphic.on("afterAttributeUpdate", listener);
          });
        }
      } else if ("update" === state) {
        const prevLabel = prevTextMap.get(textKey);
        prevTextMap.delete(textKey), currentTextMap.set(textKey, prevLabel);
        const prevText = prevLabel.text, { duration, easing } = this._animationConfig.update;
        updateAnimation(prevText, text2, this._animationConfig.update), prevLabel.labelLine && labelLine && prevLabel.labelLine.animate().to(labelLine.attribute, duration, easing);
      }
    }), prevTextMap.forEach((label) => {
      var _a2;
      null === (_a2 = label.text) || void 0 === _a2 || _a2.animate().to(getAnimationAttributes(label.text.attribute, "fadeOut").to, this._animationConfig.exit.duration, this._animationConfig.exit.easing).onEnd(() => {
        this.removeChild(label.text), label.labelLine && this.removeChild(label.labelLine);
      });
    }), this._graphicToText = currentTextMap;
  }
  _renderWithOutAnimation(labels) {
    var _a;
    const currentTextMap = /* @__PURE__ */ new Map(), prevTextMap = this._graphicToText || /* @__PURE__ */ new Map(), texts = [], { visible: showLabelLine } = null !== (_a = this.attribute.line) && void 0 !== _a ? _a : {};
    labels.forEach((text2) => {
      const relatedGraphic = this.getRelatedGraphic(text2.attribute), state = (null == prevTextMap ? void 0 : prevTextMap.get(relatedGraphic)) ? "update" : "enter", textKey = this._isCollectionBase ? text2.attribute.id : relatedGraphic;
      let labelLine;
      if (showLabelLine && (labelLine = this._createLabelLine(text2, relatedGraphic)), "enter" === state) texts.push(text2), currentTextMap.set(textKey, labelLine ? {
        text: text2,
        labelLine
      } : {
        text: text2
      }), this.add(text2), labelLine && this.add(labelLine), this._syncStateWithRelatedGraphic(relatedGraphic);
      else if ("update" === state) {
        const prevLabel = prevTextMap.get(textKey);
        prevTextMap.delete(textKey), currentTextMap.set(textKey, prevLabel), prevLabel.text.setAttributes(text2.attribute), prevLabel.labelLine && labelLine && prevLabel.labelLine.setAttributes(labelLine.attribute);
      }
    }), prevTextMap.forEach((label) => {
      this.removeChild(label.text), label.labelLine && this.removeChild(label.labelLine);
    }), this._graphicToText = currentTextMap;
  }
  _syncStateWithRelatedGraphic(relatedGraphic) {
    this.attribute.syncState && relatedGraphic.on("afterAttributeUpdate", this._handleRelatedGraphicSetState);
  }
  _afterRelatedGraphicAttributeUpdate(text2, texts, labelLine, labelLines, index, relatedGraphic, to, { mode: mode2, duration, easing, delay }) {
    const listener = (event) => {
      var _a, _b, _c;
      const { detail } = event;
      if (!detail) return {};
      const step = null === (_a = detail.animationState) || void 0 === _a ? void 0 : _a.step;
      if (!(detail.type === AttributeUpdateType.ANIMATE_UPDATE && step && !("wait" === step.type && null == (null === (_b = step.prev) || void 0 === _b ? void 0 : _b.type)))) return {};
      if (detail.type === AttributeUpdateType.ANIMATE_END) return text2.setAttributes(to), void (labelLine && labelLine.setAttributes(to));
      const onStart = () => {
        relatedGraphic && (relatedGraphic.onAnimateBind = void 0, relatedGraphic.removeEventListener("afterAttributeUpdate", listener));
      };
      switch (mode2) {
        case "after":
          detail.animationState.end && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          break;
        case "after-all":
          index === texts.length - 1 && detail.animationState.end && (texts.forEach((t2) => {
            t2.animate({
              onStart
            }).wait(delay).to(to, duration, easing);
          }), labelLines.forEach((t2) => {
            t2.animate().wait(delay).to(to, duration, easing);
          }));
          break;
        default:
          if (this._isCollectionBase) {
            const point6 = this._idToPoint.get(text2.attribute.id);
            !point6 || text2.animates && text2.animates.has("label-animate") || !relatedGraphic.containsPoint(point6.x, point6.y, IContainPointMode.LOCAL, null === (_c = this.stage) || void 0 === _c ? void 0 : _c.pickerService) || (text2.animate({
              onStart
            }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
          } else detail.animationState.isFirstFrameOfStep && (text2.animate({
            onStart
          }).wait(delay).to(to, duration, easing), labelLine && labelLine.animate().wait(delay).to(to, duration, easing));
      }
    };
    return listener;
  }
  _smartInvert(labels) {
    var _a, _b, _c, _d, _e;
    const option = isObject_default(this.attribute.smartInvert) ? this.attribute.smartInvert : {}, { textType, contrastRatiosThreshold, alternativeColors, mode: mode2 } = option, fillStrategy = null !== (_a = option.fillStrategy) && void 0 !== _a ? _a : "invertBase", strokeStrategy = null !== (_b = option.strokeStrategy) && void 0 !== _b ? _b : "base", brightColor = null !== (_c = option.brightColor) && void 0 !== _c ? _c : "#ffffff", darkColor = null !== (_d = option.darkColor) && void 0 !== _d ? _d : "#000000", outsideEnable = null !== (_e = option.outsideEnable) && void 0 !== _e && _e;
    if ("null" !== fillStrategy || "null" !== strokeStrategy) for (let i2 = 0; i2 < labels.length; i2++) {
      const label = labels[i2];
      if (!label) continue;
      const baseMark = this.getRelatedGraphic(label.attribute), backgroundColor = baseMark.attribute.fill, foregroundColor = label.attribute.fill, baseColor = backgroundColor, invertColor = labelSmartInvert(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode2), similarColor = contrastAccessibilityChecker(invertColor, brightColor) ? brightColor : darkColor;
      if (outsideEnable) {
        const fill = smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor);
        if (fill && label.setAttributes({
          fill
        }), 0 === label.attribute.lineWidth) continue;
        const stroke2 = smartInvertStrategy(strokeStrategy, baseColor, invertColor, similarColor);
        stroke2 && label.setAttributes({
          stroke: stroke2
        });
      } else {
        if (this._canPlaceInside(label.AABBBounds, baseMark.AABBBounds)) {
          const fill = smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor);
          if (fill && label.setAttributes({
            fill
          }), 0 === label.attribute.lineWidth) continue;
          const stroke2 = smartInvertStrategy(strokeStrategy, baseColor, invertColor, similarColor);
          stroke2 && label.setAttributes({
            stroke: stroke2
          });
        } else {
          if (0 === label.attribute.lineWidth) continue;
          if (label.attribute.stroke) {
            label.setAttributes({
              fill: labelSmartInvert(label.attribute.fill, label.attribute.stroke, textType, contrastRatiosThreshold, alternativeColors, mode2)
            });
            continue;
          }
          const fill = smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor);
          fill && label.setAttributes({
            fill
          });
          const stroke2 = smartInvertStrategy(strokeStrategy, baseColor, invertColor, similarColor);
          stroke2 && label.setAttributes({
            stroke: stroke2
          });
        }
      }
    }
  }
  _canPlaceInside(textBound, shapeBound) {
    return !(!textBound || !shapeBound) && shapeBound.encloses(textBound);
  }
  setLocation(point6) {
    this.translateTo(point6.x, point6.y);
  }
  disableAnimation() {
    this._enableAnimation = false;
  }
  enableAnimation() {
    this._enableAnimation = true;
  }
};
LabelBase.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  offset: 0,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/symbol.js
var SymbolLabel = class _SymbolLabel extends LabelBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SymbolLabel.defaultAttributes, attributes)), this.name = "symbol-label";
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    return labelingPoint(textBounds, graphicBounds, position, offset);
  }
};
SymbolLabel.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  position: "top",
  offset: 5,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/rect.js
var RectLabel = class _RectLabel extends LabelBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _RectLabel.defaultAttributes, attributes));
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    if (!textBounds || !graphicBounds) return;
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = textBounds, width = Math.abs(x23 - x14), height = Math.abs(y23 - y14), rectWidth = Math.abs(graphicBounds.x2 - graphicBounds.x1), rectHeight = Math.abs(graphicBounds.y2 - graphicBounds.y1);
    let anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2, anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2, sx = 0, sy = 0;
    switch (position) {
      case "top":
      case "inside-top":
        sy = -0.5;
        break;
      case "bottom":
      case "inside-bottom":
        sy = 0.5;
        break;
      case "left":
      case "inside-left":
        sx = -0.5;
        break;
      case "right":
      case "inside-right":
        sx = 0.5;
        break;
      case "top-right":
        sx = 0.5, sy = -0.5;
        break;
      case "top-left":
        sx = -0.5, sy = -0.5;
        break;
      case "bottom-right":
        sx = 0.5, sy = 0.5;
        break;
      case "bottom-left":
        sx = -0.5, sy = 0.5;
    }
    anchorX += sx * rectWidth, anchorY += sy * rectHeight;
    let vx = 0, vy = 0;
    const isInside = position.includes("inside");
    switch (position.includes("top") ? vy = isInside ? 1 : -1 : position.includes("bottom") ? vy = isInside ? -1 : 1 : position.includes("left") ? vx = isInside ? 1 : -1 : position.includes("right") && (vx = isInside ? -1 : 1), position) {
      case "top-right":
      case "bottom-right":
        vx = -1;
        break;
      case "top-left":
      case "bottom-left":
        vx = 1;
    }
    return {
      x: anchorX + vx * offset + vx * width / 2,
      y: anchorY + vy * offset + vy * height / 2
    };
  }
};
RectLabel.tag = "rect-label", RectLabel.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  position: "top",
  offset: 5,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/line.js
var LineLabel = class _LineLabel extends LabelBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineLabel.defaultAttributes, attributes)), this.name = "line-label";
  }
  getGraphicBounds(graphic, point6 = {}, position = "end") {
    if (!graphic || "line" !== graphic.type) return super.getGraphicBounds(graphic, point6);
    const points = graphic.attribute.points || [point6], index = "start" === position ? 0 : points.length - 1;
    return points[index] ? {
      x1: points[index].x,
      x2: points[index].x,
      y1: points[index].y,
      y2: points[index].y
    } : void 0;
  }
  labeling(textBounds, graphicBounds, position = "end", offset = 0) {
    return labelingLineOrArea(textBounds, graphicBounds, position, offset);
  }
};
LineLabel.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  position: "end",
  offset: 6,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/arc.js
var ArcInfo = class {
  constructor(refDatum, center2, outerCenter, quadrant, radian, middleAngle, innerRadius, outerRadius, circleCenter) {
    this.refDatum = refDatum, this.center = center2, this.outerCenter = outerCenter, this.quadrant = quadrant, this.radian = radian, this.middleAngle = middleAngle, this.innerRadius = innerRadius, this.outerRadius = outerRadius, this.circleCenter = circleCenter, this.labelVisible = true, this.labelLimit = 0;
  }
  getLabelBounds() {
    return this.labelPosition && this.labelSize ? {
      x1: this.labelPosition.x - this.labelSize.width / 2,
      y1: this.labelPosition.y - this.labelSize.height / 2,
      x2: this.labelPosition.x + this.labelSize.width / 2,
      y2: this.labelPosition.y + this.labelSize.height / 2
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
};
var ArcLabel = class _ArcLabel extends LabelBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ArcLabel.defaultAttributes, attributes)), this.name = "arc-label", this._ellipsisWidth = 0, this._arcLeft = /* @__PURE__ */ new Map(), this._arcRight = /* @__PURE__ */ new Map();
  }
  _overlapping(labels) {
    return labels;
  }
  labeling(textBounds, graphicBounds, position = "outside", offset = 0) {
    if (textBounds && graphicBounds) return {
      x: 0,
      y: 0
    };
  }
  _layout(data = []) {
    const labels = super._layout(data), textBoundsArray = labels.map((label) => this.getGraphicBounds(label)), ellipsisLabelAttribute = Object.assign(Object.assign({}, this.attribute.textStyle), {
      text: "…"
    }), ellipsisText = this._createLabelText(ellipsisLabelAttribute), ellipsisTextBounds = this.getGraphicBounds(ellipsisText), ellipsisWidth = ellipsisTextBounds.x2 - ellipsisTextBounds.x1, arcs = this.layoutArcLabels(this.attribute.position, this.attribute, Array.from(this._idToGraphic.values()), data, textBoundsArray, ellipsisWidth);
    for (let i2 = 0; i2 < data.length; i2++) {
      const textData = data[i2], basedArc = arcs.find((arc) => {
        var _a;
        return (null === (_a = arc.refDatum) || void 0 === _a ? void 0 : _a.id) === textData.id;
      });
      if (basedArc) {
        const labelAttribute = {
          visible: basedArc.labelVisible,
          x: basedArc.labelPosition.x,
          y: basedArc.labelPosition.y,
          angle: basedArc.angle,
          maxLineWidth: basedArc.labelLimit,
          points: basedArc.pointA && basedArc.pointB && basedArc.pointC ? [basedArc.pointA, basedArc.pointB, basedArc.pointC] : void 0,
          line: basedArc.labelLine
        };
        labels[i2].setAttributes(labelAttribute);
      }
    }
    return labels;
  }
  layoutArcLabels(position, attribute, currentMarks, data, textBoundsArray, ellipsisWidth) {
    this._arcLeft.clear(), this._arcRight.clear(), this._ellipsisWidth = ellipsisWidth;
    let maxRadius = 0;
    currentMarks.forEach((currentMarks2) => {
      currentMarks2.attribute.outerRadius > maxRadius && (maxRadius = currentMarks2.attribute.outerRadius);
    }), data.forEach((d2, index) => {
      var _a, _b;
      const graphicAttribute = this._idToGraphic.get(d2.id).attribute, center2 = {
        x: null !== (_a = null == graphicAttribute ? void 0 : graphicAttribute.x) && void 0 !== _a ? _a : 0,
        y: null !== (_b = null == graphicAttribute ? void 0 : graphicAttribute.y) && void 0 !== _b ? _b : 0
      };
      if (!isNil_default(data[index]) && !isNil_default(textBoundsArray[index])) {
        const item = data[index] ? data[index] : null, textBounds = textBoundsArray[index] ? textBoundsArray[index] : {
          x1: 0,
          x2: 0,
          y1: 0,
          y2: 0
        }, arcMiddleAngle = (graphicAttribute.startAngle + graphicAttribute.endAngle) / 2, intervalAngle = graphicAttribute.endAngle - graphicAttribute.startAngle, arcQuadrant = computeQuadrant2(graphicAttribute.endAngle - intervalAngle / 2), arcMiddle = circlePoint(center2.x, center2.y, graphicAttribute.outerRadius, arcMiddleAngle), outerArcMiddle = circlePoint(center2.x, center2.y, maxRadius + attribute.line.line1MinLength, arcMiddleAngle), arc = new ArcInfo(item, arcMiddle, outerArcMiddle, arcQuadrant, intervalAngle, arcMiddleAngle, graphicAttribute.innerRadius, graphicAttribute.outerRadius, center2);
        arc.pointA = circlePoint(center2.x, center2.y, this.computeDatumRadius(2 * center2.x, 2 * center2.y, graphicAttribute.outerRadius), arc.middleAngle), arc.labelSize = {
          width: textBounds.x2 - textBounds.x1,
          height: textBounds.y2 - textBounds.y1
        }, isQuadrantRight(arc.quadrant) ? this._arcRight.set(arc.refDatum, arc) : isQuadrantLeft(arc.quadrant) && this._arcLeft.set(arc.refDatum, arc);
      }
    });
    const leftArcs = Array.from(this._arcLeft.values()), rightArcs = Array.from(this._arcRight.values()), arcs = [];
    switch (position) {
      case "inside":
      case "inside-inner":
      case "inside-outer":
        arcs.push(...this._layoutInsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutInsideLabels(leftArcs, attribute, currentMarks));
        break;
      default:
        arcs.push(...this._layoutOutsideLabels(rightArcs, attribute, currentMarks)), arcs.push(...this._layoutOutsideLabels(leftArcs, attribute, currentMarks));
    }
    return arcs;
  }
  _layoutInsideLabels(arcs, attribute, currentMarks) {
    var _a, _b;
    const labelConfig = attribute, spaceWidth = labelConfig.spaceWidth, position = null !== (_a = labelConfig.position) && void 0 !== _a ? _a : "inside", offsetRadius = null !== (_b = labelConfig.offsetRadius) && void 0 !== _b ? _b : -spaceWidth;
    return arcs.forEach((arc) => {
      var _a2, _b2, _c;
      const { labelSize, radian } = arc, innerRadius = arc.innerRadius, outerRadius = arc.outerRadius;
      let limit;
      if (radian < connectLineRadian(outerRadius, labelSize.height)) limit = 0;
      else {
        let minRadius;
        minRadius = radian >= Math.PI ? innerRadius : Math.max(innerRadius, labelSize.height / 2 / Math.tan(radian / 2)), limit = outerRadius - minRadius - spaceWidth;
      }
      true !== labelConfig.rotate && (limit = outerRadius - spaceWidth);
      const text2 = this._getFormatLabelText(arc.refDatum, limit);
      arc.labelText = text2;
      const labelWidth = Math.min(limit, arc.labelSize.width), align = this._computeAlign(arc, attribute);
      let labelRadius, alignOffset = 0;
      "inside" === position && (alignOffset = "left" === align ? labelWidth : "right" === align ? 0 : labelWidth / 2), labelRadius = "inside-inner" === position ? innerRadius - offsetRadius + alignOffset : outerRadius + offsetRadius - alignOffset, arc.labelPosition = circlePoint(arc.circleCenter.x, arc.circleCenter.y, labelRadius, arc.middleAngle), arc.labelLimit = labelWidth, isGreater(labelWidth, 0) || (arc.labelVisible = false), arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : arc.middleAngle;
      let offsetAngle = null !== (_c = labelConfig.offsetAngle) && void 0 !== _c ? _c : 0;
      ["inside-inner", "inside-outer"].includes(position) && (offsetAngle += Math.PI / 2), arc.angle += offsetAngle;
    }), arcs;
  }
  _layoutOutsideLabels(arcs, attribute, currentMarks) {
    var _a, _b, _c;
    const center_x = null !== (_a = currentMarks[0].attribute.x) && void 0 !== _a ? _a : 0, height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), line2MinLength = attribute.line.line2MinLength, labelLayout = attribute.layout, spaceWidth = attribute.spaceWidth;
    if (arcs.forEach((arc) => {
      const direction2 = isQuadrantLeft(arc.quadrant) ? -1 : 1;
      arc.labelPosition = {
        x: arc.outerCenter.x + direction2 * (arc.labelSize.width / 2 + line2MinLength + spaceWidth),
        y: arc.outerCenter.y
      };
    }), arcs.sort((a4, b2) => a4.labelPosition.y - b2.labelPosition.y), false !== attribute.coverEnable || "none" === labelLayout.strategy) {
      for (const arc of arcs) {
        const { labelPosition, labelSize } = arc;
        arc.labelLimit = labelSize.width, arc.pointB = isQuadrantLeft(arc.quadrant) ? {
          x: labelPosition.x + labelSize.width / 2 + line2MinLength + spaceWidth,
          y: labelPosition.y
        } : {
          x: labelPosition.x - labelSize.width / 2 - line2MinLength - spaceWidth,
          y: labelPosition.y
        }, this._computeX(arc, attribute, currentMarks);
      }
      false === attribute.coverEnable && "none" === labelLayout.strategy && this._coverLabels(arcs);
    } else {
      const maxLabels = height / ((null === (_c = attribute.textStyle) || void 0 === _c ? void 0 : _c.fontSize) || 16);
      this._adjustY(arcs, maxLabels, attribute, currentMarks);
      const { minY, maxY: maxY2 } = arcs.reduce((yInfo, arc) => {
        const { y1: y14, y2: y23 } = arc.getLabelBounds();
        return yInfo.minY = Math.max(0, Math.min(y14, yInfo.minY)), yInfo.maxY = Math.min(height, Math.max(y23, yInfo.maxY)), yInfo;
      }, {
        minY: 1 / 0,
        maxY: -1 / 0
      }), halfY = Math.max(Math.abs(height / 2 - minY), Math.abs(maxY2 - height / 2)), r2 = this._computeLayoutRadius(halfY, attribute, currentMarks);
      for (const arc of arcs) this._computePointB(arc, r2, attribute, currentMarks), this._computeX(arc, attribute, currentMarks);
    }
    const width = 2 * center_x;
    return arcs.forEach((arc) => {
      var _a2, _b2;
      arc.labelVisible && (isLess(arc.pointB.x, line2MinLength + spaceWidth) || isGreater(arc.pointB.x, width - line2MinLength - spaceWidth)) && (arc.labelVisible = false), arc.angle = null !== (_b2 = null === (_a2 = attribute.textStyle) || void 0 === _a2 ? void 0 : _a2.angle) && void 0 !== _b2 ? _b2 : 0, attribute.offsetAngle && (arc.angle += attribute.offsetAngle), arc.labelLine = Object.assign({}, attribute.line);
    }), arcs;
  }
  _computeX(arc, attribute, currentMarks) {
    var _a;
    const center2 = arc.circleCenter, plotLayout_width = 2 * center2.x;
    center2.y;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, line2MinLength = attribute.line.line2MinLength, labelLayoutAlign = null === (_a = attribute.layout) || void 0 === _a ? void 0 : _a.align, spaceWidth = attribute.spaceWidth, { labelPosition, quadrant, pointB } = arc;
    isValidNumber_default(pointB.x * pointB.y) || (arc.pointC = {
      x: NaN,
      y: NaN
    }, labelPosition.x = NaN, arc.labelLimit = 0);
    const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), flag = isQuadrantLeft(quadrant) ? -1 : 1;
    let cx = 0;
    let limit = (flag > 0 ? plotLayout_width - pointB.x : pointB.x) - line2MinLength - spaceWidth;
    "labelLine" === labelLayoutAlign && (cx = (radius + line1MinLength + line2MinLength) * flag + center2.x, limit = (flag > 0 ? plotLayout_width - cx : cx) - spaceWidth);
    const text2 = this._getFormatLabelText(arc.refDatum, limit);
    arc.labelText = text2;
    let labelWidth = Math.min(limit, arc.labelSize.width);
    switch (labelLayoutAlign) {
      case "labelLine":
        break;
      case "edge":
        cx = flag > 0 ? plotLayout_width - labelWidth - spaceWidth : labelWidth + spaceWidth;
        break;
      default:
        cx = pointB.x + flag * line2MinLength;
    }
    labelWidth = Math.max(this._ellipsisWidth, labelWidth), arc.labelLimit = labelWidth, arc.pointC = {
      x: cx,
      y: labelPosition.y
    };
    const targetCenterOffset = 0.5 * (arc.labelLimit < arc.labelSize.width ? arc.labelLimit : arc.labelSize.width);
    if ("edge" === labelLayoutAlign) {
      const alignOffset = 0;
      labelPosition.x = (flag > 0 ? plotLayout_width + alignOffset : alignOffset) - flag * targetCenterOffset;
    } else {
      const alignOffset = 0;
      labelPosition.x = cx + alignOffset + flag * (spaceWidth + targetCenterOffset);
    }
  }
  _computeAlign(arc, attribute) {
    var _a, _b, _c, _d, _e, _f;
    const labelConfig = attribute, textAlign = null !== (_b = null === (_a = labelConfig.textStyle) || void 0 === _a ? void 0 : _a.textAlign) && void 0 !== _b ? _b : null === (_c = labelConfig.textStyle) || void 0 === _c ? void 0 : _c.align, layoutAlign = null !== (_e = null === (_d = labelConfig.layout) || void 0 === _d ? void 0 : _d.textAlign) && void 0 !== _e ? _e : null === (_f = labelConfig.layout) || void 0 === _f ? void 0 : _f.align;
    return "inside" !== labelConfig.position ? isNil_default(textAlign) || "auto" === textAlign ? "edge" === layoutAlign ? isQuadrantLeft(arc.quadrant) ? "left" : "right" : isQuadrantLeft(arc.quadrant) ? "right" : "left" : textAlign : isNil_default(textAlign) || "auto" === textAlign ? "center" : textAlign;
  }
  _getFormatLabelText(value, limit) {
    var _a;
    return null !== (_a = null == value ? void 0 : value.text) && void 0 !== _a ? _a : "";
  }
  _adjustY(arcs, maxLabels, attribute, currentMarks) {
    var _a, _b;
    _a = currentMarks[0].attribute.x;
    const plotRect_height = 2 * (null !== (_b = currentMarks[0].attribute.y) && void 0 !== _b ? _b : 0), labelLayout = attribute.layout;
    if ("vertical" === labelLayout.strategy) {
      let delta, lastY = 0;
      const len = arcs.length;
      if (len <= 0) return;
      for (let i2 = 0; i2 < len; i2++) {
        const { y1: y14 } = arcs[i2].getLabelBounds();
        if (delta = y14 - lastY, isLess(delta, 0)) {
          const index = this._shiftY(arcs, i2, len - 1, -delta);
          this._shiftY(arcs, index, 0, delta / 2);
        }
        const { y2: y23 } = arcs[i2].getLabelBounds();
        lastY = y23;
      }
      const { y1: firstY1 } = arcs[0].getLabelBounds();
      delta = firstY1 - 0, isLess(delta, 0) && this._shiftY(arcs, 0, len - 1, -delta);
      for (let i2 = arcs.length - 1; i2 >= 0 && arcs[i2].getLabelBounds().y2 > plotRect_height; i2--) arcs[i2].labelVisible = false;
    } else if ("none" !== labelLayout.strategy) {
      const priorityArcs = arcs.map((arc, i2) => ({
        arc,
        originIndex: i2,
        priorityIndex: 0
      }));
      priorityArcs.sort((a4, b2) => b2.arc.radian - a4.arc.radian), priorityArcs.forEach((priorityArc, i2) => {
        priorityArc.priorityIndex = i2, priorityArc.arc.labelVisible = false;
      });
      let topLabelIndex = 1 / 0, bottomLabelIndex = -1 / 0;
      for (let i2 = 0; i2 < maxLabels && i2 < arcs.length; i2++) {
        this._storeY(arcs);
        const arc = priorityArcs[i2].arc;
        this._computeYRange(arc, attribute, currentMarks), arc.labelVisible = true;
        const curY = arc.labelPosition.y, { lastIndex, nextIndex } = this._findNeighborIndex(arcs, priorityArcs[i2]), lastArc = arcs[lastIndex], nextArc = arcs[nextIndex];
        if (-1 === lastIndex && -1 !== nextIndex) {
          const nextY = nextArc.labelPosition.y;
          curY > nextY ? arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2 : this._twoWayShift(arcs, arc, nextArc, nextIndex);
        } else if (-1 !== lastIndex && -1 === nextIndex) {
          const lastY = lastArc.labelPosition.y;
          curY < lastY ? arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2 : this._twoWayShift(arcs, lastArc, arc, priorityArcs[i2].originIndex);
        } else if (-1 !== lastIndex && -1 !== nextIndex) {
          const lastY = lastArc.labelPosition.y, nextY = nextArc.labelPosition.y;
          curY > nextY ? (arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2, this._twoWayShift(arcs, lastArc, arc, priorityArcs[i2].originIndex)) : curY < lastY ? (arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2, this._twoWayShift(arcs, arc, nextArc, nextIndex)) : (this._twoWayShift(arcs, lastArc, arc, priorityArcs[i2].originIndex), this._twoWayShift(arcs, arc, nextArc, nextIndex));
        }
        const nextTopIndex = Math.min(topLabelIndex, priorityArcs[i2].originIndex), nextBottomIndex = Math.max(bottomLabelIndex, priorityArcs[i2].originIndex);
        let delta;
        if (delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0) && this._shiftY(arcs, nextBottomIndex, 0, -delta), delta = arcs[nextTopIndex].getLabelBounds().y1 - 0, isLess(delta, 0) && this._shiftY(arcs, nextTopIndex, arcs.length - 1, -delta), delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect_height, isGreater(delta, 0)) {
          arc.labelVisible = false, this._restoreY(arcs);
          break;
        }
        labelLayout.tangentConstraint && !this._checkYRange(arcs) ? (arc.labelVisible = false, this._restoreY(arcs)) : (topLabelIndex = nextTopIndex, bottomLabelIndex = nextBottomIndex);
      }
    }
  }
  _shiftY(arcs, start, end, delta) {
    const direction2 = start < end ? 1 : -1;
    let index = start;
    for (; -1 !== index; ) {
      arcs[index].labelPosition.y += delta;
      const nextIndex = this._findNextVisibleIndex(arcs, index, end, direction2);
      if (nextIndex >= 0 && nextIndex < arcs.length) {
        const { y1: curY1, y2: curY2 } = arcs[index].getLabelBounds(), { y1: nextY1, y2: nextY2 } = arcs[nextIndex].getLabelBounds();
        if (direction2 > 0 && curY2 < nextY1 || direction2 < 0 && curY1 > nextY2) return index;
      }
      index = nextIndex;
    }
    return end;
  }
  _findNextVisibleIndex(arcs, start, end, direction2) {
    const diff = (end - start) * direction2;
    for (let i2 = 1; i2 <= diff; i2++) {
      const index = start + i2 * direction2;
      if (arcs[index].labelVisible) return index;
    }
    return -1;
  }
  _computePointB(arc, r2, attribute, currentMarks) {
    const labelConfig = attribute;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = labelConfig.line.line1MinLength;
    if ("none" === labelConfig.layout.strategy) arc.pointB = {
      x: arc.outerCenter.x,
      y: arc.outerCenter.y
    };
    else {
      const center2 = arc.circleCenter, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), { labelPosition, quadrant } = arc, rd = r2 - Math.max(radius + line1MinLength, arc.outerRadius), x3 = Math.sqrt(r2 ** 2 - Math.abs(center2.y - labelPosition.y) ** 2) - rd;
      isValidNumber_default(x3) ? arc.pointB = {
        x: center2.x + x3 * (isQuadrantLeft(quadrant) ? -1 : 1),
        y: labelPosition.y
      } : arc.pointB = {
        x: NaN,
        y: NaN
      };
    }
  }
  _storeY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.lastLabelY = arc.labelPosition.y);
  }
  _computeYRange(arc, attribute, currentMarks) {
    const center2 = arc.circleCenter, plotRect = {
      width: 2 * center2.x,
      height: 2 * center2.y
    };
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), line1MinLength = attribute.line.line1MinLength, { width, height } = plotRect, radius = this.computeRadius(radiusRatio, attribute.width, attribute.height), r2 = this._computeLayoutRadius(height / 2, attribute, currentMarks), cx = Math.abs(arc.center.x - width / 2), cy = arc.center.y - height / 2;
    let a4, b2, c4;
    if (isNumberClose(width / 2, cx)) a4 = 0, b2 = 1, c4 = -cy;
    else if (isNumberClose(height / 2, cy)) a4 = 1, b2 = 0, c4 = -cx;
    else {
      const k3 = -1 / (cy / cx);
      a4 = k3, b2 = -1, c4 = cy - k3 * cx;
    }
    const points = lineCirclePoints(a4, b2, c4, line1MinLength + radius - r2, 0, r2);
    if (points.length < 2) return;
    let min4, max4;
    points[0].x > points[1].x && points.reverse(), points[0].x < 0 ? isNumberClose(points[0].y, points[1].y) ? isGreater(arc.middleAngle, -Math.PI) && isLess(arc.middleAngle, 0) || isGreater(arc.middleAngle, Math.PI) && isLess(arc.middleAngle, 2 * Math.PI) ? (min4 = 0, max4 = points[1].y + height / 2) : (min4 = points[1].y + height / 2, max4 = height) : points[0].y < points[1].y ? (min4 = 0, max4 = points[1].y + height / 2) : (min4 = points[1].y + height / 2, max4 = plotRect.height) : (min4 = Math.min(points[0].y, points[1].y) + height / 2, max4 = Math.max(points[0].y, points[1].y) + height / 2), arc.labelYRange = [min4, max4];
  }
  _computeLayoutRadius(halfYLength, attribute, currentMarks) {
    const labelConfig = attribute, layoutArcGap = labelConfig.layoutArcGap, line1MinLength = labelConfig.line.line1MinLength;
    let maxRadius = 0;
    currentMarks.forEach((currentMark) => {
      currentMark.attribute.outerRadius > maxRadius && (maxRadius = currentMark.attribute.outerRadius);
    });
    const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height), outerR = this.computeRadius(radiusRatio, attribute.width, attribute.height) + line1MinLength, a4 = outerR - layoutArcGap;
    return Math.max((a4 ** 2 + halfYLength ** 2) / (2 * a4), outerR);
  }
  _findNeighborIndex(arcs, priorityArc) {
    const index = priorityArc.originIndex;
    let lastIndex = -1, nextIndex = -1;
    for (let i2 = index - 1; i2 >= 0; i2--) if (arcs[i2].labelVisible) {
      lastIndex = i2;
      break;
    }
    for (let i2 = index + 1; i2 < arcs.length; i2++) if (arcs[i2].labelVisible) {
      nextIndex = i2;
      break;
    }
    return {
      lastIndex,
      nextIndex
    };
  }
  _twoWayShift(arcs, lastArc, nextArc, nextIndex) {
    const delta = nextArc.getLabelBounds().y1 - lastArc.getLabelBounds().y2;
    if (isLess(delta, 0)) {
      const i2 = this._shiftY(arcs, nextIndex, arcs.length - 1, -delta);
      this._shiftY(arcs, i2, 0, delta / 2);
    }
  }
  _restoreY(arcs) {
    for (const arc of arcs) arc.labelVisible && (arc.labelPosition.y = arc.lastLabelY);
  }
  _checkYRange(arcs) {
    for (const arc of arcs) {
      const { labelYRange, labelPosition } = arc;
      if (arc.labelVisible && labelYRange && (isLess(labelPosition.y, labelYRange[0]) || isGreater(labelPosition.y, labelYRange[1]))) return false;
    }
    return true;
  }
  _coverLabels(arcs) {
    if (arcs.length <= 1) return;
    let lastBounds = arcs[0].getLabelBounds();
    for (let i2 = 1; i2 < arcs.length; i2++) {
      const bounds = arcs[i2].getLabelBounds();
      checkBoundsOverlap(lastBounds, bounds) ? arcs[i2].labelVisible = false : lastBounds = bounds;
    }
  }
  _createLabelLine(text2, baseMark) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { points, line: line2 = {}, visible, fill } = text2.attribute, labelLine = text2.attribute.points ? graphicCreator.line({
      visible: null === (_c = null !== (_a = line2.visible && visible) && void 0 !== _a ? _a : null === (_b = text2.attribute) || void 0 === _b ? void 0 : _b.visible) || void 0 === _c || _c,
      stroke: null !== (_e = null === (_d = line2.style) || void 0 === _d ? void 0 : _d.stroke) && void 0 !== _e ? _e : fill,
      lineWidth: null !== (_g = null === (_f = line2.style) || void 0 === _f ? void 0 : _f.lineWidth) && void 0 !== _g ? _g : 1,
      points,
      curveType: line2.smooth ? "basis" : null
    }) : void 0;
    return labelLine && this._setStatesOfLabelLine(labelLine), labelLine;
  }
  computeRadius(r2, width, height, k3) {
    return this.computeLayoutRadius(width || 0, height || 0) * r2 * (isNil_default(k3) ? 1 : k3);
  }
  computeLayoutRadius(width, height) {
    return Math.min(width / 2, height / 2);
  }
  _canPlaceInside(textBound, shapeBound) {
    return "inside" === this.attribute.position;
  }
  computeLayoutOuterRadius(r2, width, height) {
    return r2 / (Math.min(width, height) / 2);
  }
  computeDatumRadius(width, height, outerRadius) {
    const outerRadiusRatio = this.computeLayoutOuterRadius(outerRadius, width, height);
    return this.computeLayoutRadius(width || 0, height || 0) * outerRadiusRatio;
  }
};
ArcLabel.defaultAttributes = {
  coverEnable: false,
  spaceWidth: 5,
  layoutArcGap: 6,
  textStyle: {
    visible: true,
    fontSize: 14,
    fontWeight: "normal",
    fillOpacity: 1,
    textAlign: "center",
    textBaseline: "middle"
  },
  position: "outside",
  offset: 0,
  line: {
    visible: true,
    line1MinLength: 20,
    line2MinLength: 10
  },
  layout: {
    align: "arc",
    strategy: "priority",
    tangentConstraint: true
  },
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/area.js
var AreaLabel = class _AreaLabel extends LabelBase {
  constructor(attributes) {
    super(merge({}, _AreaLabel.defaultAttributes, attributes)), this.name = "line-label";
  }
  getGraphicBounds(graphic, point6 = {}, position = "end") {
    var _a;
    if ("area" !== graphic.type) return super.getGraphicBounds(graphic, point6);
    const points = (null === (_a = null == graphic ? void 0 : graphic.attribute) || void 0 === _a ? void 0 : _a.points) || [point6], index = "start" === position ? 0 : points.length - 1;
    return {
      x1: points[index].x,
      x2: points[index].x,
      y1: points[index].y,
      y2: points[index].y
    };
  }
  labeling(textBounds, graphicBounds, position = "end", offset = 0) {
    return labelingLineOrArea(textBounds, graphicBounds, position, offset);
  }
};
AreaLabel.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  position: "end",
  offset: 6,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/line-data.js
var LineDataLabel = class _LineDataLabel extends LabelBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineDataLabel.defaultAttributes, attributes)), this.name = "line-data-label";
  }
  labeling(textBounds, graphicBounds, position = "top", offset = 0) {
    return labelingPoint(textBounds, graphicBounds, position, offset);
  }
};
LineDataLabel.defaultAttributes = {
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "center",
    textBaseline: "middle",
    boundsPadding: [-1, 0, -1, 0]
  },
  position: "top",
  offset: 5,
  pickable: false
};

// node_modules/@visactor/vrender-components/es/label/dataLabel.js
var labelComponentMap = {
  rect: RectLabel,
  symbol: SymbolLabel,
  arc: ArcLabel,
  line: LineLabel,
  area: AreaLabel,
  "line-data": LineDataLabel
};
var DataLabel = class _DataLabel extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DataLabel.defaultAttributes, attributes)), this.name = "data-label";
  }
  render() {
    var _a;
    const { dataLabels, size } = this.attribute;
    if (!dataLabels || 0 === dataLabels.length) return;
    const { width = 0, height = 0 } = size || {};
    if (!width || !height || !isValidNumber_default(height * width)) return;
    this._componentMap || (this._componentMap = /* @__PURE__ */ new Map());
    const tool = bitmapTool(width, height), bitmap2 = tool.bitmap(), currentComponentMap = /* @__PURE__ */ new Map(), prevComponentMap = this._componentMap;
    for (let i2 = 0; i2 < dataLabels.length; i2++) {
      const dataLabel2 = dataLabels[i2], labelComponent = labelComponentMap[dataLabel2.type] || LabelBase;
      if (labelComponent) {
        const { baseMarkGroupName, type } = dataLabel2, id2 = null !== (_a = dataLabel2.id) && void 0 !== _a ? _a : `${baseMarkGroupName}-${type}-${i2}`;
        let component2 = this._componentMap.get(id2);
        component2 ? (component2.setBitmapTool(tool), component2.setBitmap(bitmap2), component2.setAttributes(dataLabel2), currentComponentMap.set(id2, component2)) : (component2 = new labelComponent(dataLabel2), component2.setBitmap(bitmap2), component2.setBitmapTool(tool), this.add(component2), currentComponentMap.set(id2, component2));
      }
    }
    prevComponentMap.forEach((cp, key) => {
      currentComponentMap.get(key) || this.removeChild(cp);
    }), this._componentMap = currentComponentMap;
  }
  setLocation(point6) {
    this.translateTo(point6.x, point6.y);
  }
  disableAnimation() {
    this._componentMap.forEach((component2) => {
      component2.disableAnimation();
    });
  }
  enableAnimation() {
    this._componentMap.forEach((component2) => {
      component2.enableAnimation();
    });
  }
};
DataLabel.defaultAttributes = {
  pickable: false
};

// node_modules/@visactor/vrender-components/es/segment/register.js
function loadSegmentComponent() {
  registerGroup(), registerLine(), registerPolygon(), registerSymbol();
}

// node_modules/@visactor/vrender-components/es/segment/segment.js
loadSegmentComponent();
var Segment = class _Segment extends AbstractComponent {
  getStartAngle() {
    return this._startAngle;
  }
  getEndAngle() {
    return this._endAngle;
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Segment.defaultAttributes, attributes)), this.name = "segment";
  }
  render() {
    this.removeAllChild(), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, multiSegment, mainSegmentIndex } = this.attribute;
    if (!visible) return;
    this._computeLineAngle();
    const startSymbolShape = this._renderSymbol(startSymbol, "start"), endSymbolShape = this._renderSymbol(endSymbol, "end");
    if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
      const points = [...this.attribute.points];
      if (isValidNumber_default(mainSegmentIndex)) points[mainSegmentIndex] = this._clipPoints(points[mainSegmentIndex]);
      else {
        const clipPoints = this._clipPoints(flattenArray(points));
        points[0][0] = clipPoints[0], points[points.length - 1][points[points.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
      }
      points.forEach((point6, index) => {
        var _a, _b;
        const line2 = graphicCreator.line(Object.assign(Object.assign({
          points: point6
        }, isArray_default(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
          fill: false
        }));
        line2.name = `${this.name}-line`, line2.id = this._getNodeId("line" + index), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = isArray_default(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line2);
      });
    } else {
      const line2 = graphicCreator.polygon(Object.assign(Object.assign({
        points: this._clipPoints(this.attribute.points)
      }, array(lineStyle)[0]), {
        fill: false,
        closePath: false
      }));
      line2.name = `${this.name}-line`, line2.id = this._getNodeId("line"), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = [].concat(state.line)[0]), this.add(line2);
    }
  }
  _renderSymbol(attribute, dim) {
    const points = this._getMainSegmentPoints();
    if (!points.length) return;
    const { autoRotate: autoRotate2 = true } = attribute;
    let symbol;
    if (attribute && attribute.visible) {
      const startAngle = this._startAngle, endAngle = this._endAngle, { state } = this.attribute, start = points[0], end = points[points.length - 1], { refX = 0, refY = 0, refAngle = 0, style, symbolType, size = 12 } = attribute;
      let position, rotate3;
      "start" === dim ? (position = {
        x: start.x + (isValidNumber_default(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
        y: start.y + (isValidNumber_default(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
      }, rotate3 = startAngle + Math.PI / 2) : (position = {
        x: end.x + (isValidNumber_default(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
        y: end.y + (isValidNumber_default(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
      }, rotate3 = endAngle + Math.PI / 2), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
        symbolType,
        size,
        angle: autoRotate2 ? rotate3 + refAngle : 0,
        strokeBoundsBuffer: 0
      }), style)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty_default(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), this.add(symbol);
    }
    return symbol;
  }
  _getMainSegmentPoints() {
    if (this._mainSegmentPoints) return this._mainSegmentPoints;
    const { points: originPoints, multiSegment, mainSegmentIndex } = this.attribute;
    let points;
    return points = multiSegment ? isValidNumber_default(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
  }
  _clipPoints(points) {
    const { startSymbol = {}, endSymbol = {} } = this.attribute;
    let pointsAfterClip = points;
    if (startSymbol.visible) {
      const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
      pointsAfterClip = [{
        x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
        y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
      }, ...pointsAfterClip.slice(1)];
    }
    if (endSymbol.visible) {
      const endSize = endSymbol.clip ? endSymbol.size || 10 : 0, pointsEnd = {
        x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
        y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
      };
      pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
    }
    return pointsAfterClip;
  }
  _computeLineAngle() {
    const points = this._getMainSegmentPoints();
    if (points.length <= 1) return;
    const start = points[0], startInside = points[1], endInside = points[points.length - 2], end = points[points.length - 1], startVector = [start.x - startInside.x, start.y - startInside.y], startAngle = Math.atan2(startVector[1], startVector[0]), endVector = [end.x - endInside.x, end.y - endInside.y], endAngle = Math.atan2(endVector[1], endVector[0]);
    this._startAngle = startAngle, this._endAngle = endAngle;
  }
  _reset() {
    this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
  }
};
Segment.defaultAttributes = {
  visible: true,
  lineStyle: {
    lineWidth: 1,
    stroke: "#000"
  },
  startSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  },
  endSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  }
};

// node_modules/@visactor/vrender-components/es/axis/constant.js
var AXIS_ELEMENT_NAME;
!function(AXIS_ELEMENT_NAME2) {
  AXIS_ELEMENT_NAME2.innerView = "inner-view", AXIS_ELEMENT_NAME2.axisContainer = "axis-container", AXIS_ELEMENT_NAME2.labelContainer = "axis-label-container", AXIS_ELEMENT_NAME2.tickContainer = "axis-tick-container", AXIS_ELEMENT_NAME2.tick = "axis-tick", AXIS_ELEMENT_NAME2.subTick = "axis-sub-tick", AXIS_ELEMENT_NAME2.label = "axis-label", AXIS_ELEMENT_NAME2.title = "axis-title", AXIS_ELEMENT_NAME2.gridContainer = "axis-grid-container", AXIS_ELEMENT_NAME2.grid = "axis-grid", AXIS_ELEMENT_NAME2.gridRegion = "axis-grid-region", AXIS_ELEMENT_NAME2.line = "axis-line", AXIS_ELEMENT_NAME2.background = "axis-background", AXIS_ELEMENT_NAME2.axisLabelBackground = "axis-label-background";
}(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
var AxisStateValue;
!function(AxisStateValue2) {
  AxisStateValue2.selected = "selected", AxisStateValue2.selectedReverse = "selected_reverse", AxisStateValue2.hover = "hover", AxisStateValue2.hoverReverse = "hover_reverse";
}(AxisStateValue || (AxisStateValue = {}));
var DEFAULT_STATES2 = {
  [AxisStateValue.selectedReverse]: {},
  [AxisStateValue.selected]: {},
  [AxisStateValue.hover]: {},
  [AxisStateValue.hoverReverse]: {}
};

// node_modules/@visactor/vrender-components/es/axis/config.js
var DEFAULT_AXIS_THEME = {
  title: {
    space: 4,
    padding: 0,
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    padding: 0,
    style: {
      fontSize: 12,
      fill: "#333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  }
};

// node_modules/@visactor/vrender-components/es/axis/base.js
var AxisBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis", this.data = [], this.tickLineItems = [], this.subTickLineItems = [], this.axisLabelLayerSize = {}, this.axisLabelsContainer = null, this._onHover = (e3) => {
      const target = e3.target;
      target !== this._lastHover && target.name && !isEmpty_default(target.states) && (target.addState(StateValue.hover, true), traverseGroup(this.axisContainer, (node) => {
        node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.hoverReverse, true);
      }), this._lastHover = target);
    }, this._onUnHover = (e3) => {
      this._lastHover && (traverseGroup(this.axisContainer, (node) => {
        node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
      }), this._lastHover = null);
    }, this._onClick = (e3) => {
      const target = e3.target;
      if (this._lastSelect === target && target.hasState(StateValue.selected)) return this._lastSelect = null, void traverseGroup(this.axisContainer, (node) => {
        node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
      });
      target.name && !isEmpty_default(target.states) && (target.addState(StateValue.selected, true), traverseGroup(this.axisContainer, (node) => {
        node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.selectedReverse, true);
      }), this._lastSelect = target);
    };
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  getBoundsWithoutRender(attributes) {
    const currentAttribute = cloneDeep(this.attribute);
    merge(this.attribute, attributes);
    const offscreenGroup = graphicCreator.group({
      x: this.attribute.x,
      y: this.attribute.y
    });
    return this.add(offscreenGroup), this._renderInner(offscreenGroup), this.removeChild(offscreenGroup), this.attribute = currentAttribute, offscreenGroup.AABBBounds;
  }
  render() {
    this.removeAllChild(), this._prevInnerView = this._innerView, this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView), this._renderInner(this._innerView), this._bindEvent();
  }
  _bindEvent() {
    if (this.attribute.disableTriggerEvent) return;
    const { hover, select } = this.attribute;
    hover && (this._innerView.addEventListener("pointermove", this._onHover), this._innerView.addEventListener("pointerout", this._onUnHover)), select && this._innerView.addEventListener("pointerdown", this._onClick);
  }
  _renderInner(container2) {
    const { title: title3, label, tick, line: line2, items } = this.attribute, axisContainer = graphicCreator.group({
      x: 0,
      y: 0,
      zIndex: 1
    });
    if (axisContainer.name = AXIS_ELEMENT_NAME.axisContainer, axisContainer.id = this._getNodeId("container"), axisContainer.setMode(this.mode), this.axisContainer = axisContainer, container2.add(axisContainer), line2 && line2.visible && this.renderLine(axisContainer), items && items.length && (this.data = this._transformItems(items[0]), tick && tick.visible && this.renderTicks(axisContainer), label && label.visible)) {
      const labelGroup = graphicCreator.group({
        x: 0,
        y: 0,
        pickable: false
      });
      labelGroup.name = AXIS_ELEMENT_NAME.labelContainer, labelGroup.id = this._getNodeId("label-container"), this.axisLabelsContainer = labelGroup, axisContainer.add(labelGroup), items.forEach((axisItems, layer) => {
        const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer), labels = layerLabelGroup.getChildren();
        this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
        let maxTextWidth = 0, maxTextHeight = 0, textAlign = "center", textBaseline = "middle";
        labels.forEach((label2) => {
          var _a;
          const labelStyle = label2.attribute, angle2 = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textBounds = label2.AABBBounds;
          let textWidth = textBounds.width(), textHeight = textBounds.height();
          angle2 && (textWidth = Math.abs(textWidth * Math.cos(angle2)), textHeight = Math.abs(textHeight * Math.sin(angle2))), maxTextWidth = Math.max(maxTextWidth, textWidth), maxTextHeight = Math.max(maxTextHeight, textHeight), textAlign = labelStyle.textAlign, textBaseline = labelStyle.textBaseline;
        }), this.axisLabelLayerSize[layer] = {
          width: maxTextWidth,
          height: maxTextHeight,
          textAlign,
          textBaseline
        };
      });
    }
    title3 && title3.visible && this.renderTitle(axisContainer);
  }
  renderTicks(container2) {
    const tickLineItems = this.getTickLineItems(), tickLineGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer, tickLineGroup.id = this._getNodeId("tick-container"), container2.add(tickLineGroup), tickLineItems.forEach((item, index) => {
      var _a;
      const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("tick", item, index, tickLineItems)));
      if (line2.name = AXIS_ELEMENT_NAME.tick, line2.id = this._getNodeId(item.id), isEmpty_default(null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.state)) line2.states = DEFAULT_STATES;
      else {
        const data = this.data[index], tickLineState = merge({}, DEFAULT_STATES, this.attribute.tick.state);
        Object.keys(tickLineState).forEach((key) => {
          isFunction_default(tickLineState[key]) && (tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data));
        }), line2.states = tickLineState;
      }
      tickLineGroup.add(line2);
    }), this.tickLineItems = tickLineItems;
    const { subTick } = this.attribute;
    if (subTick && subTick.visible) {
      const subTickLineItems = this.getSubTickLineItems();
      subTickLineItems.length && subTickLineItems.forEach((item, index) => {
        const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("subTick", item, index, tickLineItems)));
        if (line2.name = AXIS_ELEMENT_NAME.subTick, line2.id = this._getNodeId(`${index}`), isEmpty_default(subTick.state)) line2.states = DEFAULT_STATES;
        else {
          const subTickLineState = merge({}, DEFAULT_STATES, subTick.state);
          Object.keys(subTickLineState).forEach((key) => {
            isFunction_default(subTickLineState[key]) && (subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems));
          }), line2.states = subTickLineState;
        }
        tickLineGroup.add(line2);
      }), this.subTickLineItems = subTickLineItems;
    }
  }
  renderLabels(container2, items, layer) {
    const { dataFilter } = this.attribute.label;
    dataFilter && isFunction_default(dataFilter) && (items = dataFilter(items, layer));
    const data = this._transformItems(items), labelGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    return labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`, labelGroup.id = this._getNodeId(`label-container-layer-${layer}`), container2.add(labelGroup), data.forEach((item, index) => {
      var _a, _b, _c;
      const labelStyle = this._getLabelAttribute(item, index, data, layer);
      let text2;
      if ("rich" === labelStyle.type ? (labelStyle.textConfig = labelStyle.text, labelStyle.width = null !== (_a = labelStyle.width) && void 0 !== _a ? _a : 0, labelStyle.height = null !== (_b = labelStyle.height) && void 0 !== _b ? _b : 0, text2 = graphicCreator.richtext(labelStyle)) : "html" === labelStyle.type ? (labelStyle.textConfig = [], labelStyle.html = Object.assign(Object.assign({
        dom: labelStyle.text
      }, DEFAULT_HTML_TEXT_SPEC), labelStyle), text2 = graphicCreator.richtext(labelStyle)) : text2 = graphicCreator.text(labelStyle), text2.name = AXIS_ELEMENT_NAME.label, text2.id = this._getNodeId(`layer${layer}-label-${item.id}`), isEmpty_default(null === (_c = this.attribute.label) || void 0 === _c ? void 0 : _c.state)) text2.states = DEFAULT_STATES;
      else {
        const labelState = merge({}, DEFAULT_STATES, this.attribute.label.state);
        Object.keys(labelState).forEach((key) => {
          isFunction_default(labelState[key]) && (labelState[key] = labelState[key](item, index, data, layer));
        }), text2.states = labelState;
      }
      labelGroup.add(text2);
    }), labelGroup;
  }
  renderTitle(container2) {
    const titleAttributes = this.getTitleAttribute(), axisTitle = new Tag(Object.assign({}, titleAttributes));
    axisTitle.name = AXIS_ELEMENT_NAME.title, axisTitle.id = this._getNodeId("title"), container2.add(axisTitle);
  }
  getVerticalCoord(point6, offset, inside) {
    const vector = this.getVerticalVector(offset, inside, point6);
    return {
      x: point6.x + vector[0],
      y: point6.y + vector[1]
    };
  }
  getTextAlign(vector) {
    let align = "center";
    return isNumberClose(vector[0], 0) ? isNumberClose(vector[1], 0) ? Object.is(vector[1], -0) ? align = "start" : Object.is(vector[0], -0) && (align = "end") : align = "center" : vector[0] > 0 ? align = "start" : vector[0] < 0 && (align = "end"), align;
  }
  getTickLineItems() {
    const { tick } = this.attribute, data = this.data, tickLineItems = [], { alignWithLabel, inside = false, length: length2, dataFilter } = tick;
    let tickSegment = 1;
    return data.length >= 2 && (tickSegment = data[1].value - data[0].value), (dataFilter && isFunction_default(dataFilter) ? dataFilter(data) : data).forEach((item) => {
      let point6 = item.point, tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value)) return;
        point6 = this.getTickCoord(value), tickValue = value;
      }
      const endPoint = this.getVerticalCoord(point6, length2, inside);
      if ("3d" === this.mode) {
        const vec = this.getVerticalVector(length2, inside, point6);
        let alpha = 0, beta = 0;
        abs(vec[0]) > abs(vec[1]) ? alpha = pi / 2 * (endPoint.x > point6.x ? 1 : -1) : beta = pi / 2 * (endPoint.y > point6.y ? -1 : 1), tickLineItems.push({
          start: point6,
          end: endPoint,
          value: tickValue,
          id: `tick-${item.id}`,
          anchor: [point6.x, point6.y],
          alpha,
          beta
        });
      } else tickLineItems.push({
        start: point6,
        end: endPoint,
        value: tickValue,
        id: `tick-${item.id}`
      });
    }), tickLineItems;
  }
  getSubTickLineItems() {
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) for (let i2 = 0; i2 < tickLineCount - 1; i2++) {
      const pre = tickLineItems[i2], next = tickLineItems[i2 + 1];
      for (let j2 = 0; j2 < subCount; j2++) {
        const percent = (j2 + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, inside);
        subTickLineItems.push({
          start: point6,
          end: endPoint,
          value,
          id: `sub-tick-${value}`
        });
      }
    }
    return subTickLineItems;
  }
  _getTickLineAttribute(type, tickItem, index, tickItems) {
    let style = get_default(this.attribute, `${type}.style`);
    const data = this.data[index];
    style = isFunction_default(style) ? merge({}, get_default(DEFAULT_AXIS_THEME, `${type}.style`), "tick" === type ? style(data.rawValue, index, data, this.data) : style(tickItem.value, index, tickItem, tickItems)) : style;
    const { start, end, anchor, alpha, beta } = tickItem;
    return Object.assign({
      points: [start, end],
      anchor,
      alpha,
      beta
    }, style);
  }
  _getLabelAttribute(tickDatum, index, tickData, layer) {
    var _a, _b;
    const { space = 4, inside = false, formatMethod, type = "text", text: text2 } = this.attribute.label;
    let offset = space, tickLength = 0;
    (null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.visible) && this.attribute.tick.inside === inside && (tickLength = this.attribute.tick.length || 4), (null === (_b = this.attribute.subTick) || void 0 === _b ? void 0 : _b.visible) && this.attribute.subTick.inside === inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2)), offset += tickLength;
    const axisVector = this.getRelativeVector(tickDatum.point);
    layer > 0 && (0 === axisVector[1] ? offset += (this.axisLabelLayerSize[layer - 1].height + get_default(this.attribute, "label.space", 4)) * layer : offset += (this.axisLabelLayerSize[layer - 1].width + get_default(this.attribute, "label.space", 4)) * layer);
    const point6 = this.getVerticalCoord(tickDatum.point, offset, inside), vector = this.getVerticalVector(offset || 1, inside, point6), textContent = formatMethod ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer) : tickDatum.label;
    let { style: textStyle } = this.attribute.label;
    textStyle = isFunction_default(textStyle) ? merge({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer)) : textStyle;
    const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
    return textStyle = merge(labelAlign, textStyle), isFunction_default(textStyle.text) && (textStyle.text = textStyle.text({
      label: tickDatum.label,
      value: tickDatum.rawValue,
      index: tickDatum.index,
      layer
    })), Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point6, vector, textContent, textStyle)), {
      text: null != text2 ? text2 : textContent,
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize,
      type
    }), textStyle);
  }
  getLabelPosition(point6, vector, text2, style) {
    return point6;
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
};

// node_modules/@visactor/vrender-components/es/axis/overlap/util.js
function rotate2(x3, y3, deg, originX, originY) {
  return {
    x: (x3 - originX) * Math.cos(deg) + (y3 - originY) * Math.sin(deg) + originX,
    y: (x3 - originX) * Math.sin(deg) + (originY - y3) * Math.cos(deg) + originY
  };
}
function genNormalBounds(item) {
  const bounds = item.AABBBounds;
  return {
    x1: bounds.x1,
    x2: bounds.x2,
    y1: bounds.y1,
    y2: bounds.y2,
    centerX: item.attribute.x,
    centerY: item.attribute.y,
    angle: item.attribute.angle
  };
}
function genRotateBounds(items) {
  items.forEach((item) => {
    if (item.rotatedBounds || !item.attribute.angle) return;
    const bounds = genNormalBounds(item), rotatedCenter = rotate2(bounds.centerX, bounds.centerY, bounds.angle, item.attribute.x, item.attribute.y), deltaX = rotatedCenter.x - bounds.centerX, deltaY = rotatedCenter.y - bounds.centerY;
    bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
  });
}
function itemIntersect(item1, item2) {
  return isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) && (!item1.rotatedBounds || !item2.rotatedBounds || isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true));
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-hide.js
var methods2 = {
  parity: function(items) {
    return items.filter((item, i2) => i2 % 2 ? item.setAttribute("opacity", 0) : 1);
  },
  greedy: function(items, sep) {
    let a4;
    return items.filter((b2, i2) => i2 && intersect3(a4, b2, sep) ? b2.setAttribute("opacity", 0) : (a4 = b2, 1));
  }
};
function intersect3(textA, textB, sep) {
  const a4 = textA.AABBBounds, b2 = textB.AABBBounds;
  return sep > Math.max(b2.x1 - a4.x2, a4.x1 - b2.x2, b2.y1 - a4.y2, a4.y1 - b2.y2) && (!textA.rotatedBounds || !textB.rotatedBounds || sep > Math.max(textB.rotatedBounds.x1 - textA.rotatedBounds.x2, textA.rotatedBounds.x1 - textB.rotatedBounds.x2, textB.rotatedBounds.y1 - textA.rotatedBounds.y2, textA.rotatedBounds.y1 - textB.rotatedBounds.y2));
}
function hasOverlap2(items, pad) {
  for (let b2, i2 = 1, n2 = items.length, a4 = items[0]; i2 < n2; a4 = b2, ++i2) if (intersect3(a4, b2 = items[i2], pad)) return true;
}
function hasBounds(item) {
  const b2 = item.AABBBounds;
  return b2.width() > 1 && b2.height() > 1;
}
function reset(items) {
  return items.forEach((item) => item.setAttribute("opacity", 1)), items;
}
function autoHide(labels, config2) {
  if (isEmpty_default(labels)) return;
  const source = labels.filter(hasBounds);
  if (isEmpty_default(source)) return;
  let items;
  items = reset(source), genRotateBounds(items);
  const { method = "parity", separation: sep = 0 } = config2, reduce = isFunction_default(method) ? method : methods2[method] || methods2.parity;
  if (items.length >= 3 && hasOverlap2(items, sep)) {
    do {
      items = reduce(items, sep);
    } while (items.length >= 3 && hasOverlap2(items, sep));
    if (items.length < 3 || config2.lastVisible) {
      const lastSourceItem = last(source);
      if (!lastSourceItem.attribute.opacity) {
        const remainLength = items.length;
        if (remainLength > 1) {
          lastSourceItem.setAttribute("opacity", 1);
          for (let i2 = remainLength - 1; i2 >= 0 && intersect3(items[i2], lastSourceItem, sep); i2--) items[i2].setAttribute("opacity", 0);
        }
      }
    }
  }
  source.forEach((item) => {
    item.setAttribute("visible", !!item.attribute.opacity);
  });
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-rotate.js
function autoRotate(items, rotateConfig) {
  if (isEmpty_default(items)) return;
  const { orient, labelRotateAngle = [0, 45, 90] } = rotateConfig;
  if (0 === labelRotateAngle.length || items.some((item) => !!item.attribute.angle)) return;
  let i2 = 0, n2 = 0;
  for (labelRotateAngle && labelRotateAngle.length > 0 && (n2 = labelRotateAngle.length); i2 < n2; ) {
    const angle2 = labelRotateAngle[i2++];
    if (items.forEach((item) => {
      item.attribute.angle = degreeToRadian(angle2);
    }), tryRotate(orient, items), !hasIntersect(items)) break;
  }
}
function hasIntersect(items) {
  for (let i2 = 1; i2 < items.length; i2++) if (itemIntersect(items[i2 - 1], items[i2])) return true;
  return false;
}
function tryRotate(orient, items) {
  "bottom" !== orient && "top" !== orient || rotateXAxis(orient, items), "left" !== orient && "right" !== orient || rotateYAxis(orient, items), genRotateBounds(items);
}
function clampAngle(angle2 = 0) {
  if (angle2 < 0) for (; angle2 < 0; ) angle2 += 2 * Math.PI;
  if (angle2 > 0) for (; angle2 >= 2 * Math.PI; ) angle2 -= 2 * Math.PI;
  return angle2;
}
function rotateYAxis(orient, items) {
  items.forEach((item, i2) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function rotateXAxis(orient, items) {
  items.forEach((item) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function getXAxisLabelAlign(orient, angle2 = 0) {
  let align = ["center", "left", "left", "left", "center", "right", "right", "right", "left"], baseline = ["top", "top", "middle", "bottom", "bottom", "bottom", "middle", "top", "top"];
  "top" === orient && (align = ["center", "right", "right", "right", "center", "left", "left", "left", "right"], baseline = ["bottom", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}
function getYAxisLabelAlign(orient, angle2 = 0) {
  let align = ["right", "right", "center", "left", "center", "left", "center", "right", "right"], baseline = ["middle", "middle", "top", "top", "middle", "middle", "bottom", "bottom", "middle"];
  "right" === orient && (align = ["left", "right", "right", "right", "left", "left", "left", "left", "right"], baseline = ["middle", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}

// node_modules/@visactor/vrender-components/es/axis/overlap/auto-limit.js
function autoLimit(labels, config2) {
  const { limitLength, verticalLimitLength, ellipsis = "...", orient } = config2;
  !isEmpty_default(labels) && isValidNumber_default(limitLength) && labels.forEach((label) => {
    if (("top" === orient || "bottom" === orient) && Math.floor(label.AABBBounds.height()) <= limitLength) return;
    const direction2 = label.attribute.direction;
    if (("left" === orient || "right" === orient) && ("vertical" === direction2 && Math.floor(label.AABBBounds.height()) <= verticalLimitLength || "vertical" !== direction2 && Math.floor(label.AABBBounds.width()) <= limitLength)) return;
    const angle2 = label.attribute.angle;
    let limitLabelLength = 0 === angle2 || isNil_default(angle2) ? "top" === orient || "bottom" === orient ? null : "vertical" === direction2 ? verticalLimitLength : limitLength : Math.abs(limitLength / Math.sin(angle2));
    isValidNumber_default(label.attribute.maxLineWidth) && (limitLabelLength = isValidNumber_default(limitLabelLength) ? Math.min(label.attribute.maxLineWidth, limitLabelLength) : label.attribute.maxLineWidth), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: label.attribute.ellipsis || ellipsis
    });
  });
}

// node_modules/@visactor/vrender-components/es/util/align.js
function alignAxisLabels(labels, start, containerSize, orient, align) {
  if ("right" === orient || "left" === orient) {
    if ("left" === align) {
      const flag = "right" === orient ? 0 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + containerSize * flag,
          textAlign: "left"
        });
      });
    } else if ("right" === align) {
      const flag = "right" === orient ? 1 : 0;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + containerSize * flag,
          textAlign: "right"
        });
      });
    } else if ("center" === align) {
      const flag = "right" === orient ? 1 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + 0.5 * containerSize * flag,
          textAlign: "center"
        });
      });
    }
  } else if ("bottom" === orient || "top" === orient) {
    if ("top" === align) {
      const flag = "bottom" === orient ? 0 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + containerSize * flag,
          textBaseline: "top"
        });
      });
    } else if ("bottom" === align) {
      const flag = "bottom" === orient ? 1 : 0;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + containerSize * flag,
          textBaseline: "bottom"
        });
      });
    } else if ("middle" === align) {
      const flag = "bottom" === orient ? 1 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + 0.5 * containerSize * flag,
          textBaseline: "middle"
        });
      });
    }
  }
}

// node_modules/@visactor/vrender-components/es/axis/mixin/line.js
var LineAxisMixin = class {
  isInValidValue(value) {
    return value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { start } = this.attribute, axisVector = this.getRelativeVector();
    return {
      x: start.x + axisVector[0] * tickValue,
      y: start.y + axisVector[1] * tickValue
    };
  }
  getRelativeVector(point6) {
    const { start, end } = this.attribute;
    return [end.x - start.x, end.y - start.y];
  }
  getVerticalVector(offset, inside = false, point6) {
    const { verticalFactor = 1 } = this.attribute, axisVector = this.getRelativeVector(), normalizedAxisVector = normalize2(axisVector), verticalVector = [normalizedAxisVector[1], -1 * normalizedAxisVector[0]];
    return scale3(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
  }
};

// node_modules/@visactor/vrender-components/es/axis/register.js
function loadBasicAxis() {
  registerGroup(), registerLine(), registerRichtext(), registerText();
}
function loadLineAxisComponent() {
  loadBasicAxis(), registerRect();
}
function loadCircleAxisComponent() {
  loadBasicAxis(), registerCircle();
}
function loadLineAxisGridComponent() {
  registerGroup(), registerPath();
}
function loadCircleAxisGridComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vrender-components/es/axis/line.js
var __rest3 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
loadLineAxisComponent();
var LineAxis = class _LineAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineAxis.defaultAttributes, attributes), options);
  }
  _renderInner(container2) {
    var _a;
    super._renderInner(container2);
    const { panel } = this.attribute;
    if (panel && panel.visible) {
      const axisContainer = this.axisContainer, axisContainerBounds = axisContainer.AABBBounds, bgRect = graphicCreator.rect(Object.assign({
        x: axisContainerBounds.x1,
        y: axisContainerBounds.y1,
        width: axisContainerBounds.width(),
        height: axisContainerBounds.height()
      }, panel.style));
      bgRect.name = AXIS_ELEMENT_NAME.background, bgRect.id = this._getNodeId("background"), bgRect.states = merge({}, DEFAULT_STATES2, null !== (_a = panel.state) && void 0 !== _a ? _a : {}), axisContainer.insertBefore(bgRect, axisContainer.firstChild);
    }
  }
  renderLine(container2) {
    const { start, end, line: line2 } = this.attribute, _a = line2, { startSymbol, endSymbol, style, breakRange, breakShape, breakShapeStyle, state } = _a, restLineAttrs = __rest3(_a, ["startSymbol", "endSymbol", "style", "breakRange", "breakShape", "breakShapeStyle", "state"]), lineAttrs = Object.assign({
      points: [start, end],
      startSymbol,
      endSymbol,
      lineStyle: style
    }, restLineAttrs);
    isEmpty_default(state) || (lineAttrs.state = {
      line: merge({}, DEFAULT_STATES2, state),
      symbol: merge({}, DEFAULT_STATES2, state)
    });
    const axisLineGroup = new Segment(lineAttrs);
    axisLineGroup.name = AXIS_ELEMENT_NAME.line, axisLineGroup.id = this._getNodeId("line"), container2.add(axisLineGroup);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const _d = this.attribute.title, { position = "middle", space = 4, textStyle = {}, autoRotate: autoRotate2 = true, shape, background, state = {} } = _d, restAttrs = __rest3(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state"]);
    let percent = 0.5;
    "start" === position ? percent = 0 : "end" === position && (percent = 1);
    const { verticalFactor = 1 } = this.attribute, factor = -1 * verticalFactor, point6 = this.getTickCoord(percent), axisVector = this.getRelativeVector();
    let labelLength = 0;
    if ((null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside) {
      const space2 = +get_default(this.attribute, "label.space", 4);
      labelLength += space2;
      const layerCount = Object.keys(this.axisLabelLayerSize).length;
      if (0 === axisVector[1]) {
        const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
        isFinite(labelBoundsHeight) ? labelLength += labelBoundsHeight + (layerCount - 1) * space2 : labelLength = 0;
      } else {
        if (0 === axisVector[0]) {
          const boundsWidth = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.width() : 0;
          isFinite(boundsWidth) ? labelLength += boundsWidth + (layerCount - 1) * space2 : labelLength = 0;
        } else Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
          labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space2 : 0);
        });
        const textAlign2 = this.axisLabelLayerSize[0].textAlign, isTextAlignStart = "start" === textAlign2 || "left" === textAlign2, isTextCenter = "center" === textAlign2, isReverse = axisVector[1] > 0;
        labelLength = 1 === factor ? isReverse ? isTextAlignStart ? labelLength : isTextCenter ? labelLength / 2 : space2 : isTextAlignStart ? space2 : isTextCenter ? labelLength / 2 : labelLength : isReverse ? isTextAlignStart ? space2 : isTextCenter ? labelLength / 2 : labelLength : isTextAlignStart ? labelLength : isTextCenter ? labelLength / 2 : space2;
      }
    }
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = tickLength + labelLength + space, titlePoint = this.getVerticalCoord(point6, offset, false), vector = this.getVerticalVector(offset, false, {
      x: 0,
      y: 0
    });
    let textAlign, textBaseline, { angle: angle2 } = restAttrs;
    if (textAlign = "start" === position ? "start" : "end" === position ? "end" : "center", isNil_default(angle2) && autoRotate2) {
      angle2 = angleTo(axisVector, [1, 0], true);
      const { verticalFactor: verticalFactor2 = 1 } = this.attribute;
      textBaseline = 1 === -1 * verticalFactor2 ? "bottom" : "top";
    } else textAlign = this.getTextAlign(vector), textBaseline = this.getTextBaseline(vector, false);
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      textStyle: Object.assign({
        textAlign,
        textBaseline
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    });
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getTextBaseline(vector, inside) {
    let base = "middle";
    const { verticalFactor = 1 } = this.attribute, factor = (inside ? 1 : -1) * verticalFactor;
    return isNumberClose(vector[1], 0) ? base = !isNumberClose(vector[0], 0) || Object.is(vector[0], -0) || Object.is(vector[1], -0) ? "middle" : 1 === factor ? "bottom" : "top" : vector[1] > 0 ? base = "top" : vector[1] < 0 && (base = "bottom"), base;
  }
  getLabelAlign(vector, inside, angle2) {
    const orient = this.attribute.orient;
    if (isValidNumber_default(angle2) || 0 === vector[0] && 0 === vector[1]) {
      if ("top" === orient || "bottom" === orient) return getXAxisLabelAlign(orient, angle2);
      if ("left" === orient || "right" === orient) return getYAxisLabelAlign(orient, angle2);
    }
    return {
      textAlign: this.getTextAlign(vector),
      textBaseline: this.getTextBaseline(vector, inside)
    };
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    var _a, _b, _c, _d;
    const { flush = false } = this.attribute.label || {};
    if (flush && labelShapes.length) {
      const { orient, start: axisStart, end: axisEnd } = this.attribute, isX = "bottom" === orient || "top" === orient, first = labelShapes[0], last2 = last(labelShapes), isInverse = isX ? first.attribute.x > last2.attribute.x : first.attribute.y < last2.attribute.y;
      if (isX) {
        const leftMostLabel = isInverse ? last2 : first, rightMostLabel = isInverse ? first : last2, left2 = axisStart.x, right2 = axisEnd.x, leftBound = leftMostLabel.AABBBounds.x1, rightBound = rightMostLabel.AABBBounds.x2;
        if (leftBound < left2) {
          leftMostLabel.attribute.angle ? leftMostLabel.setAttributes({
            dx: (null !== (_a = leftMostLabel.attribute.dx) && void 0 !== _a ? _a : 0) + left2 - leftBound
          }) : leftMostLabel.setAttributes({
            x: left2,
            textAlign: "left"
          });
        }
        if (rightBound > right2) {
          rightMostLabel.attribute.angle ? rightMostLabel.setAttributes({
            dx: (null !== (_b = rightMostLabel.attribute.dx) && void 0 !== _b ? _b : 0) + right2 - rightBound
          }) : rightMostLabel.setAttributes({
            x: right2,
            textAlign: "right"
          });
        }
      } else {
        const bottomMostLabel = isInverse ? last2 : first, topMostLabel = isInverse ? first : last2, bottomBound = bottomMostLabel.AABBBounds.y2, topBound = topMostLabel.AABBBounds.y1, top = axisStart.y, bottom = axisEnd.y;
        if (topBound < top) {
          topMostLabel.attribute.angle ? topMostLabel.setAttributes({
            dy: (null !== (_c = topMostLabel.attribute.dy) && void 0 !== _c ? _c : 0) + top - topBound
          }) : topMostLabel.setAttributes({
            y: top,
            textBaseline: "top"
          });
        }
        if (bottomBound > bottom) {
          bottomMostLabel.attribute.angle ? bottomMostLabel.setAttributes({
            dy: (null !== (_d = bottomMostLabel.attribute.dy) && void 0 !== _d ? _d : 0) + bottom - bottomBound
          }) : bottomMostLabel.setAttributes({
            y: bottom,
            textBaseline: "bottom"
          });
        }
      }
    }
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes)) return;
    const { verticalLimitSize, label, orient } = this.attribute, limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount), { layoutFunc, autoRotate: autoRotate2, autoRotateAngle, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, lastVisible } = label;
    if (isFunction_default(layoutFunc)) layoutFunc(labelShapes, labelData, layer, this);
    else {
      if (autoRotate2 && autoRotate(labelShapes, {
        labelRotateAngle: autoRotateAngle,
        orient
      }), autoLimit2 && isValidNumber_default(limitLength) && limitLength > 0) {
        const verticalLimitLength = "left" !== orient && "right" !== orient || !labelShapes.some((label2) => "vertical" === label2.attribute.direction) ? 1 / 0 : Math.abs(this.attribute.start.y - this.attribute.end.y) / labelShapes.length;
        autoLimit(labelShapes, {
          limitLength,
          verticalLimitLength,
          ellipsis: limitEllipsis,
          orient
        });
      }
      autoHide2 && autoHide(labelShapes, {
        orient,
        method: autoHideMethod,
        separation: autoHideSeparation,
        lastVisible
      });
    }
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    const { verticalLimitSize, orient } = this.attribute, isHorizontal4 = "bottom" === orient || "top" === orient, axisLabelContainerBounds = labelContainer.AABBBounds;
    let axisLabelContainerSize = isHorizontal4 ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
    const { verticalMinSize } = this.attribute;
    if (isValidNumber_default(verticalMinSize) && (!isValidNumber_default(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
      const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
      let x3, y3;
      axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize), "left" === orient ? (x3 = axisLabelContainerBounds.x2 - axisLabelContainerSize, y3 = axisLabelContainerBounds.y1) : "right" === orient ? (x3 = axisLabelContainerBounds.x1, y3 = axisLabelContainerBounds.y1) : "top" === orient ? (x3 = axisLabelContainerBounds.x1, y3 = axisLabelContainerBounds.y2 - axisLabelContainerSize) : "bottom" === orient && (x3 = axisLabelContainerBounds.x1, y3 = axisLabelContainerBounds.y1);
      const bgRect = graphicCreator.rect({
        x: x3,
        y: y3,
        width: isHorizontal4 ? axisLabelContainerBounds.width() : axisLabelContainerSize,
        height: isHorizontal4 ? axisLabelContainerSize : axisLabelContainerBounds.height(),
        pickable: false
      });
      bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground, bgRect.id = this._getNodeId("axis-label-background"), labelContainer.insertBefore(bgRect, labelContainer.firstChild);
    }
    if (isValid_default(this.attribute.label.containerAlign)) {
      let start;
      "left" === orient ? start = axisLabelContainerBounds.x2 : "right" === orient ? start = axisLabelContainerBounds.x1 : "top" === orient ? start = axisLabelContainerBounds.y2 : "bottom" === orient && (start = axisLabelContainerBounds.y1), alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
    }
  }
  _getAxisLabelLimitLength(limitSize, layerCount) {
    var _a, _b, _c, _d;
    const { label, title: title3, line: line2, tick } = this.attribute, labelSpace = null !== (_a = label.space) && void 0 !== _a ? _a : 4;
    let limitLength = limitSize, titleHeight = 0, titleSpacing = 0;
    const axisLineWidth = line2 && line2.visible ? null !== (_b = line2.style.lineWidth) && void 0 !== _b ? _b : 1 : 0, tickLength = tick && tick.visible ? null !== (_c = tick.length) && void 0 !== _c ? _c : 4 : 0;
    if (title3 && title3.visible && "string" == typeof title3.text) {
      titleHeight = measureTextSize(title3.text, title3.textStyle, null === (_d = this.stage) || void 0 === _d ? void 0 : _d.getTheme().text.fontFamily).height;
      const padding = normalizePadding(title3.padding);
      titleSpacing = title3.space + padding[0] + padding[2];
    }
    return limitLength && (limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount), limitLength;
  }
};
LineAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(LineAxis, LineAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/mixin/circle.js
var CircleAxisMixin = class {
  isInValidValue(value) {
    const { startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2 } = this.attribute;
    return Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? value > 1 : value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2, center: center2, radius, inside = false, innerRadius = 0 } = this.attribute;
    return polarToCartesian(center2, inside && innerRadius > 0 ? innerRadius : radius, startAngle + (endAngle - startAngle) * tickValue);
  }
  getVerticalVector(offset, inside = false, point6) {
    const { inside: axisInside = false } = this.attribute, { center: center2 } = this.attribute, vector = [point6.x - center2.x, point6.y - center2.y];
    return scale3(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / length(vector));
  }
  getRelativeVector(point6) {
    const { center: center2 } = this.attribute;
    return [point6.y - center2.y, -1 * (point6.x - center2.x)];
  }
};

// node_modules/@visactor/vrender-components/es/axis/util.js
var clampRadian2 = (angle2 = 0) => {
  if (angle2 < 0) for (; angle2 < 0; ) angle2 += tau;
  else if (angle2 > 0) for (; angle2 > tau; ) angle2 -= tau;
  return angle2;
};
function isInRange(a4, min4, max4) {
  return !isLess(a4, min4, 0, 1e-6) && !isGreater(a4, max4, 0, 1e-6);
}
function getLabelPosition(tickPosition, tickVector, text2, style) {
  const labelBounds = getTextBounds(Object.assign({
    text: text2
  }, style)), width = labelBounds.width(), height = labelBounds.height(), angle2 = clampRadian2(Math.atan2(tickVector[1], tickVector[0])) - Math.PI, PI_3_4 = 3 * Math.PI / 4, PI_1_4 = Math.PI / 4, PI_1_2 = Math.PI / 2, baseX = tickPosition.x;
  let dx = 0;
  dx = isInRange(angle2, -PI_3_4, -PI_1_4) ? ((angle2 + PI_3_4) / PI_1_2 - 0.5) * width : isInRange(angle2, PI_1_4, PI_3_4) ? (0.5 - (angle2 - PI_1_4) / PI_1_2) * width : Math.cos(angle2) >= 0 ? 0.5 * width : 0.5 * -width;
  const x3 = baseX - dx, baseY = tickPosition.y;
  let dy = 0;
  dy = isInRange(angle2, -PI_3_4, -PI_1_4) ? 0.5 * -height : isInRange(angle2, PI_1_4, PI_3_4) ? 0.5 * height : Math.cos(angle2) >= 0 ? (0.5 - (PI_1_4 - angle2) / PI_1_2) * height : (0.5 - clampRadian2(angle2 - PI_3_4) / PI_1_2) * height;
  return {
    x: x3,
    y: baseY - dy
  };
}

// node_modules/@visactor/vrender-components/es/axis/circle.js
var __rest4 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
loadCircleAxisComponent();
var CircleAxis = class _CircleAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleAxis.defaultAttributes, attributes));
  }
  renderLine(container2) {
    const { startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2, radius, center: center2, innerRadius = 0, line: line2 = {}, inside = false } = this.attribute;
    let arcRadius = radius, arcInnerRadius = innerRadius;
    inside && innerRadius > 0 && (arcRadius = innerRadius, arcInnerRadius = 0);
    const arcAttrs = Object.assign(Object.assign(Object.assign({}, center2), {
      startAngle,
      endAngle,
      radius: arcRadius,
      innerRadius: arcInnerRadius
    }), line2.style), axisLine = graphicCreator.circle(arcAttrs);
    axisLine.name = AXIS_ELEMENT_NAME.line, axisLine.id = this._getNodeId("line"), isEmpty_default(line2.state) || (axisLine.states = merge({}, DEFAULT_STATES2, line2.state)), container2.add(axisLine);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const { center: center2, radius, innerRadius = 0 } = this.attribute, _d = this.attribute.title, { space = 4, textStyle = {}, shape, background, state = {} } = _d, restAttrs = __rest4(_d, ["space", "textStyle", "shape", "background", "state"]);
    let titlePoint = center2, labelHeight = 0;
    (null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside && (labelHeight = get_default(this.attribute.label, "style.fontSize", 12) + get_default(this.attribute.label, "space", 4));
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = radius + tickLength + labelHeight + space;
    let textBaseline = "middle", { position } = this.attribute.title;
    isNil_default(position) && (position = 0 === innerRadius ? "end" : "middle"), "start" === position ? (textBaseline = "bottom", titlePoint = {
      x: center2.x,
      y: center2.y - offset
    }) : "end" === position && (textBaseline = "top", titlePoint = {
      x: center2.x,
      y: center2.y + offset
    });
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      textStyle: Object.assign({
        textBaseline,
        textAlign: "center"
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    }), { angle: angle2 } = restAttrs;
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getSubTickLineItems() {
    var _a, _b;
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      const tickSegment = this.data[1].value - this.data[0].value, isAlignWithLable = null === (_b = null === (_a = this.attribute) || void 0 === _a ? void 0 : _a.tick) || void 0 === _b ? void 0 : _b.alignWithLabel;
      for (let i2 = 0; i2 < tickLineCount; i2++) {
        const pre = tickLineItems[i2], next = tickLineItems[i2 + 1];
        for (let j2 = 0; j2 < subCount; j2++) {
          const percent = (j2 + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : isAlignWithLable ? 1 : pre.value + tickSegment), point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, inside);
          subTickLineItems.push({
            start: point6,
            end: endPoint,
            value
          });
        }
      }
    }
    return subTickLineItems;
  }
  getTextBaseline(vector) {
    let base = "middle";
    return isNumberClose(vector[1], 0) ? base = "middle" : vector[1] > 0 && vector[1] > Math.abs(vector[0]) ? base = "top" : vector[1] < 0 && Math.abs(vector[1]) > Math.abs(vector[0]) && (base = "bottom"), base;
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  getLabelAlign(vector, inside, angle2) {
    return {
      textAlign: "center",
      textBaseline: "middle"
    };
  }
  getLabelPosition(point6, vector, text2, style) {
    return getLabelPosition(point6, vector, text2, style);
  }
};
CircleAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(CircleAxis, CircleAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/animate/group-transition.js
function getElMap(g3) {
  const elMap = {};
  return traverseGroup(g3, (el) => {
    "group" !== el.type && el.id && (elMap[el.id] = el);
  }), elMap;
}
var GroupTransition = class extends ACustomAnimate {
  constructor() {
    super(...arguments), this.mode = AnimateMode.NORMAL;
  }
  onBind() {
    const currentInnerView = this.target.getInnerView(), prevInnerView = this.target.getPrevInnerView();
    prevInnerView && (this._oldElementMap = getElMap(prevInnerView), this._newElementAttrMap = {}, traverseGroup(currentInnerView, (el) => {
      var _a, _b, _c, _d, _e, _f;
      if ("group" !== el.type && el.id) {
        const oldEl = this._oldElementMap[el.id];
        if (oldEl) {
          if (!isEqual(el.attribute, oldEl.attribute)) {
            const newProps = cloneDeep(el.attribute);
            this._newElementAttrMap[el.id] = {
              state: "update",
              node: el,
              attrs: Object.assign(Object.assign({}, newProps), {
                opacity: null !== (_a = newProps.opacity) && void 0 !== _a ? _a : 1,
                fillOpacity: null !== (_b = newProps.fillOpacity) && void 0 !== _b ? _b : 1,
                strokeOpacity: null !== (_c = newProps.strokeOpacity) && void 0 !== _c ? _c : 1
              })
            }, el.setAttributes(oldEl.attribute);
          }
        } else {
          const finalOpacityAttrs = {
            opacity: null !== (_d = el.attribute.opacity) && void 0 !== _d ? _d : 1,
            fillOpacity: null !== (_e = el.attribute.fillOpacity) && void 0 !== _e ? _e : 1,
            strokeOpacity: null !== (_f = el.attribute.strokeOpacity) && void 0 !== _f ? _f : 1
          };
          this._newElementAttrMap[el.id] = {
            state: "enter",
            node: el,
            attrs: finalOpacityAttrs
          }, el.setAttributes({
            opacity: 0,
            fillOpacity: 0,
            strokeOpacity: 0
          });
        }
      }
    }));
  }
  onStart() {
    let duration = this.duration, easing = this.easing;
    Object.keys(this._newElementAttrMap).forEach((id2) => {
      var _a;
      const { node, attrs, state } = this._newElementAttrMap[id2];
      if ("enter" === state) {
        const { enter = {} } = null !== (_a = this.params) && void 0 !== _a ? _a : {};
        duration = isValidNumber_default(enter.duration) ? enter.duration : duration, easing = enter.easing ? enter.easing : easing;
      }
      "path" === node.type ? node.animate({
        interpolate: (key, ratio, from, to, nextAttributes) => "path" === key && (nextAttributes.path = interpolateString(from, to)(ratio), true)
      }).to(attrs, duration, easing) : node.animate().to(attrs, duration, easing);
    });
  }
  onUpdate(end, ratio, out) {
  }
};

// node_modules/@visactor/vrender-components/es/axis/animate/group-fade.js
var GroupFadeIn = class extends ACustomAnimate {
  constructor(from, to, duration, easing) {
    super(null, null, duration, easing);
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: ratio
      }
    });
  }
};

// node_modules/@visactor/vrender-components/es/axis/grid/base.js
function getLinePath(points, closed) {
  let path = "";
  return 0 === points.length || (points.forEach((point6, index) => {
    0 === index ? path = `M${point6.x},${point6.y}` : path += `L${point6.x},${point6.y}`;
  }), closed && (path += "Z")), path;
}
function getArcPath(center2, points, reverse2, closed) {
  let path = "";
  if (!center2 || 0 === points.length) return path;
  const firstPoint = points[0], radius = PointService.distancePP(center2, firstPoint), sweepFlag = reverse2 ? 0 : 1;
  return closed ? path += `M${center2.x},${center2.y - radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y + radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y - radius}Z` : points.forEach((point6, index) => {
    0 === index ? path = `M${point6.x},${point6.y}` : path += `A${radius},${radius},0,0,${sweepFlag},${point6.x},${point6.y}`;
  }), path;
}
function getRegionPath(from, to, attribute) {
  const { type, closed } = attribute, reversePoints = to.slice(0).reverse();
  let regionPath = "", nextPath = "";
  if ("line" === type && attribute.smoothLink && attribute.center) {
    const fromStart = from[0], toEnd = reversePoints[0], center2 = attribute.center;
    regionPath = getLinePath(from, !!closed), nextPath = getLinePath(reversePoints, !!closed);
    const toEndRadius = PointService.distancePP(toEnd, center2), fromStartRadius = PointService.distancePP(fromStart, center2);
    regionPath += `A${toEndRadius},${toEndRadius},0,0,1,${toEnd.x},${toEnd.y}L${toEnd.x},${toEnd.y}`, nextPath += `A${fromStartRadius},${fromStartRadius},0,0,0,${fromStart.x},${fromStart.y}`;
  } else if ("circle" === type) {
    const { center: center2 } = attribute;
    regionPath = getArcPath(center2, from, false, !!closed), nextPath = getArcPath(center2, reversePoints, true, !!closed);
  } else "line" !== type && "polygon" !== type || (regionPath = getLinePath(from, !!closed), nextPath = getLinePath(reversePoints, !!closed));
  return closed ? regionPath += nextPath : (nextPath = "L" + nextPath.substring(1), regionPath += nextPath, regionPath += "Z"), regionPath;
}
var BaseGrid = class _BaseGrid extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis-grid", this.data = [];
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  render() {
    this.removeAllChild(), this._prevInnerView = this._innerView, this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView);
    const { items, visible } = this.attribute;
    items && items.length && false !== visible && (this.data = this._transformItems(items), this._renderGrid(this._innerView));
  }
  getVerticalCoord(point6, offset, inside) {
    const vector = this.getVerticalVector(offset, inside, point6);
    return {
      x: point6.x + vector[0],
      y: point6.y + vector[1]
    };
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  _renderGrid(container2) {
    const { visible } = this.attribute.subGrid || {};
    visible && this._renderGridByType(true, container2), this._renderGridByType(false, container2);
  }
  _renderGridByType(isSubGrid, container2) {
    const gridAttrs = merge({}, this.attribute, this.getGridAttribute(isSubGrid)), { type, items, style, closed, alternateColor, depth = 0 } = gridAttrs, name = isSubGrid ? `${AXIS_ELEMENT_NAME.grid}-sub` : `${AXIS_ELEMENT_NAME.grid}`;
    if (items.forEach((item, index) => {
      const { id: id2, points } = item;
      let path = "";
      if ("line" === type || "polygon" === type) path = getLinePath(points, !!closed);
      else if ("circle" === type) {
        const { center: center2 } = this.attribute;
        path = getArcPath(center2, points, false, !!closed);
      }
      const shape = graphicCreator.path(Object.assign({
        path,
        z: depth
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id2}`), container2.add(shape);
    }), depth && "line" === type && items.forEach((item, index) => {
      const { id: id2, points } = item, nextPoints = [];
      nextPoints.push(points[0]);
      const dir_x = points[1].x - points[0].x, dir_y = points[1].y - points[0].y, dirLen = Math.sqrt(dir_x * dir_x + dir_y * dir_y), ratio = depth / dirLen;
      nextPoints.push({
        x: points[0].x + dir_x * ratio,
        y: points[0].y + dir_y * ratio
      });
      const path = getLinePath(nextPoints, !!closed), deltaX = abs(nextPoints[0].x - nextPoints[1].x), deltaY = abs(nextPoints[0].y - nextPoints[1].y), shape = graphicCreator.path(Object.assign({
        path,
        z: 0,
        alpha: deltaX > deltaY ? (points[1].x - points[0].x > 0 ? -1 : 1) * pi / 2 : 0,
        beta: deltaX < deltaY ? -pi / 2 : 0,
        anchor3d: deltaX > deltaY ? [nextPoints[0].x, 0] : [0, nextPoints[0].y]
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id2}`), container2.add(shape);
    }), items.length > 1 && alternateColor) {
      const colors = isArray_default(alternateColor) ? alternateColor : [alternateColor, "transparent"], getColor = (index) => colors[index % colors.length];
      for (let index = 0; index < items.length - 1; index++) {
        const [prev, curr] = [items[index].points, items[index + 1].points], path = getRegionPath(prev, curr, gridAttrs), shape = graphicCreator.path({
          path,
          fill: getColor(index)
        });
        shape.name = `${name}-region`, shape.id = this._getNodeId(`${name}-region-${index}`), container2.add(shape);
      }
    }
  }
  _getNodeId(id2) {
    return `${this.id}-${id2}`;
  }
};
BaseGrid.defaultAttributes = {
  style: {
    lineWidth: 1,
    stroke: "#999",
    strokeOpacity: 1,
    lineDash: [4, 4]
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  }
};

// node_modules/@visactor/vrender-components/es/axis/grid/line.js
function getCirclePoints(center2, count, radius, startAngle, endAngle) {
  const points = [], range2 = endAngle - startAngle;
  for (let i2 = 0; i2 < count; i2++) {
    const angle2 = startAngle + i2 * range2 / count;
    points.push(polarToCartesian(center2, radius, angle2));
  }
  return points;
}
loadLineAxisGridComponent();
var LineAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  _getGridPoint(gridType, point6) {
    let gridPoints;
    if ("line" === gridType) {
      const { length: length2 } = this.attribute;
      gridPoints = [point6, this.getVerticalCoord(point6, length2, true)];
    } else if ("circle" === gridType || "polygon" === gridType) {
      const { center: center2, sides = 6, startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2 } = this.attribute;
      gridPoints = getCirclePoints(center2, sides, PointService.distancePP(center2, point6), startAngle, endAngle);
    }
    return gridPoints;
  }
  getGridAttribute(isSubGrid) {
    const { type: gridType, alignWithLabel = true } = this.attribute;
    let tickSegment = 1;
    let gridAttribute;
    this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value);
    let items = [];
    if (isSubGrid) {
      gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
      const subGridItems = [], { count: subCount = 4 } = this.attribute.subGrid || {};
      if (this.data.length >= 2) {
        const points = [];
        this.data.forEach((item) => {
          let tickValue = item.value;
          if (!alignWithLabel) {
            const value = item.value - tickSegment / 2;
            if (this.isInValidValue(value)) return;
            tickValue = value;
          }
          points.push({
            value: tickValue
          });
        });
        for (let i2 = 0; i2 < points.length - 1; i2++) {
          const pre = points[i2], next = points[i2 + 1];
          subGridItems.push({
            id: `sub-${i2}-0`,
            points: this._getGridPoint(gridType, this.getTickCoord(pre.value)),
            datum: {}
          });
          for (let j2 = 0; j2 < subCount; j2++) {
            const percent = (j2 + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point6 = this.getTickCoord(value);
            subGridItems.push({
              id: `sub-${i2}-${j2 + 1}`,
              points: this._getGridPoint(gridType, point6),
              datum: {}
            });
          }
          i2 === points.length - 2 && subGridItems.push({
            id: `sub-${i2}-${subCount + 1}`,
            points: this._getGridPoint(gridType, this.getTickCoord(next.value)),
            datum: {}
          });
        }
        items = subGridItems;
      }
    } else {
      gridAttribute = this.attribute;
      const gridItems = [];
      this.data.forEach((item) => {
        let { point: point6 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point6 = this.getTickCoord(value);
        }
        gridItems.push({
          id: item.label,
          datum: item,
          points: this._getGridPoint(gridType, point6)
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items
    });
  }
};
mixin(LineAxisGrid, LineAxisMixin);

// node_modules/@visactor/vrender-components/es/axis/grid/circle.js
var __rest5 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
loadCircleAxisGridComponent();
var CircleAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  getGridAttribute(isSubGrid) {
    let gridAttribute, items = [];
    const _a = this.attribute, { radius, innerRadius = 0, startAngle = POLAR_START_ANGLE2, endAngle = POLAR_END_ANGLE2, center: center2, subGrid } = _a, grid2 = __rest5(_a, ["radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid"]), { alignWithLabel = true } = grid2 || {}, length2 = radius - innerRadius;
    let tickSegment = 1;
    if (this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value), isSubGrid) {
      gridAttribute = merge({}, grid2, subGrid);
      const subGridItems = [], { count: subCount = 4 } = subGrid || {}, tickLineCount = this.data.length;
      if (tickLineCount >= 2) {
        const points = [];
        this.data.forEach((item) => {
          let tickValue = item.value;
          if (!alignWithLabel) {
            const value = item.value - tickSegment / 2;
            if (this.isInValidValue(value)) return;
            tickValue = value;
          }
          points.push({
            value: tickValue
          });
        });
        for (let i2 = 0; i2 < tickLineCount; i2++) {
          const pre = points[i2], next = points[i2 + 1];
          subGridItems.push({
            id: `sub-${i2}-0`,
            points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length2, true)],
            datum: {}
          });
          for (let j2 = 0; j2 < subCount; j2++) {
            const percent = (j2 + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment), point6 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point6, length2, true);
            subGridItems.push({
              id: `sub-${i2}-${j2 + 1}`,
              points: [point6, endPoint],
              datum: {}
            });
          }
        }
        Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 && subGridItems.push(subGridItems[0]), items = subGridItems;
      }
    } else {
      gridAttribute = grid2;
      const gridItems = [];
      let data;
      data = Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? [...this.data].concat(this.data[0]) : this.data, data.forEach((item) => {
        let { point: point6 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value)) return;
          point6 = this.getTickCoord(value);
        }
        const endPoint = this.getVerticalCoord(point6, length2, true);
        gridItems.push({
          id: item.id,
          points: [point6, endPoint],
          datum: item
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items,
      center: center2,
      type: "line"
    });
  }
};
mixin(CircleAxisGrid, CircleAxisMixin);

// node_modules/@visactor/vrender-components/es/data-zoom/config.js
var DEFAULT_HANDLER_PATH = "M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z";
var DEFAULT_DATA_ZOOM_ATTRIBUTES = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  zoomLock: false,
  minSpan: 0,
  maxSpan: 1,
  delayType: "throttle",
  delayTime: 0,
  realTime: true,
  backgroundStyle: {
    fill: "white",
    stroke: "#D1DBEE",
    lineWidth: 1,
    cornerRadius: 2
  },
  dragMaskStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2
  },
  backgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1,
      fill: "#F6F8FC"
    },
    line: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1
    }
  },
  selectedBackgroundStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.5
  },
  selectedBackgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#B0C8F9",
      lineWidth: 1,
      fill: "#fbb934"
    },
    line: {
      visible: true,
      stroke: "#fbb934",
      lineWidth: 1
    }
  },
  middleHandlerStyle: {
    visible: true,
    background: {
      size: 8,
      style: {
        fill: "white",
        stroke: "#B0C8F9",
        cornerRadius: 2
      }
    },
    icon: {
      size: 6,
      fill: "white",
      stroke: "#B0C8F9",
      symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
      lineWidth: 0.5
    }
  },
  startHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  endHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  startTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  },
  endTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  }
};
var DEFAULT_HANDLER_ATTR_MAP = {
  horizontal: {
    angle: 0,
    strokeBoundsBuffer: 0,
    boundsPadding: 2,
    pickMode: "imprecise",
    cursor: "ew-resize"
  },
  vertical: {
    angle: Math.PI / 180 * 90,
    cursor: "ns-resize",
    boundsPadding: 2,
    pickMode: "imprecise",
    strokeBoundsBuffer: 0
  }
};

// node_modules/@visactor/vrender-components/es/data-zoom/type.js
var DataZoomActiveTag;
!function(DataZoomActiveTag2) {
  DataZoomActiveTag2.startHandler = "startHandler", DataZoomActiveTag2.endHandler = "endHandler", DataZoomActiveTag2.middleHandler = "middleHandler", DataZoomActiveTag2.background = "background";
}(DataZoomActiveTag || (DataZoomActiveTag = {}));

// node_modules/@visactor/vrender-components/es/data-zoom/register.js
function loadDataZoomComponent() {
  loadTagComponent(), registerRect(), registerSymbol(), registerArea(), registerLine();
}

// node_modules/@visactor/vrender-components/es/data-zoom/data-zoom.js
var __rest6 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var delayMap2 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadDataZoomComponent();
var DataZoom = class _DataZoom extends AbstractComponent {
  setPropsFromAttrs() {
    const { start, end, orient, previewData, previewPointsX, previewPointsY, previewPointsX1, previewPointsY1 } = this.attribute;
    start && (this.state.start = start), end && (this.state.end = end);
    const { width, height } = this.getLayoutAttrFromConfig();
    this._spanCache = this.state.end - this.state.start, this._isHorizontal = "top" === orient || "bottom" === orient, this._layoutCache.max = this._isHorizontal ? width : height, this._layoutCache.attPos = this._isHorizontal ? "x" : "y", this._layoutCache.attSize = this._isHorizontal ? "width" : "height", previewData && (this._previewData = previewData), isFunction_default(previewPointsX) && (this._previewPointsX = previewPointsX), isFunction_default(previewPointsY) && (this._previewPointsY = previewPointsY), isFunction_default(previewPointsX1) && (this._previewPointsX1 = previewPointsX1), isFunction_default(previewPointsY1) && (this._previewPointsY1 = previewPointsY1);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DataZoom.defaultAttributes, attributes)), this.name = "dataZoom", this._previewData = [], this._activeState = false, this._activeCache = {
      startPos: {
        x: 0,
        y: 0
      },
      lastPos: {
        x: 0,
        y: 0
      }
    }, this._layoutCache = {
      attPos: "x",
      attSize: "width",
      max: 0
    }, this.state = {
      start: 0,
      end: 1
    }, this._statePointToData = (state) => state, this._onHandlerPointerDown = (e3, tag) => {
      e3.stopPropagation(), "start" === tag ? (this._activeTag = DataZoomActiveTag.startHandler, this._activeItem = this._startHandlerMask) : "end" === tag ? (this._activeTag = DataZoomActiveTag.endHandler, this._activeItem = this._endHandlerMask) : "middleRect" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerRect) : "middleSymbol" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerSymbol) : "background" === tag && (this._activeTag = DataZoomActiveTag.background, this._activeItem = this._background), this._activeState = true, this._activeCache.startPos = this.eventPosToStagePos(e3), this._activeCache.lastPos = this.eventPosToStagePos(e3), "browser" === vglobal.env && (vglobal.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onHandlerPointerUp.bind(this))), this.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      });
    }, this._onHandlerPointerMove = delayMap2[this.attribute.delayType]((e3) => {
      e3.stopPropagation();
      const { start: startAttr, end: endAttr, brushSelect, realTime = true } = this.attribute, pos = this.eventPosToStagePos(e3), { attPos, max: max4 } = this._layoutCache, dis = (pos[attPos] - this._activeCache.lastPos[attPos]) / max4;
      let { start, end } = this.state;
      this._activeState && (this._activeTag === DataZoomActiveTag.middleHandler ? this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + dis) : this._activeTag === DataZoomActiveTag.startHandler ? start + dis > end ? (start = end, end = start + dis, this._activeTag = DataZoomActiveTag.endHandler) : start += dis : this._activeTag === DataZoomActiveTag.endHandler && (end + dis < start ? (end = start, start = end + dis, this._activeTag = DataZoomActiveTag.startHandler) : end += dis), this._activeCache.lastPos = pos, brushSelect && this.renderDragMask()), start = Math.min(Math.max(start, 0), 1), end = Math.min(Math.max(end, 0), 1), startAttr === start && endAttr === end || (this.setStateAttr(start, end, true), this._dispatchEvent("change", {
        start,
        end,
        tag: this._activeTag
      }));
    }, this.attribute.delayTime);
    const { position, showDetail } = attributes;
    this._activeCache.startPos = position, this._activeCache.lastPos = position, this._showText = "auto" !== showDetail && showDetail, this.setPropsFromAttrs();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this.setPropsFromAttrs();
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { showDetail, brushSelect } = this.attribute;
    this._startHandlerMask && this._startHandlerMask.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "start")), this._endHandlerMask && this._endHandlerMask.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "end")), this._middleHandlerSymbol && this._middleHandlerSymbol.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "middleSymbol")), this._middleHandlerRect && this._middleHandlerRect.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "middleRect"));
    const selectedTag = brushSelect ? "background" : "middleRect";
    this._selectedBackground && this._selectedBackground.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, selectedTag)), brushSelect && this._background && this._background.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "background")), brushSelect && this._previewGroup && this._previewGroup.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, "background")), this._selectedPreviewGroup && this._selectedPreviewGroup.addEventListener("pointerdown", (e3) => this._onHandlerPointerDown(e3, selectedTag)), this.addEventListener("pointerup", this._onHandlerPointerUp), this.addEventListener("pointerupoutside", this._onHandlerPointerUp), "auto" === showDetail && (this.addEventListener("pointerenter", this._onHandlerPointerEnter), this.addEventListener("pointerleave", this._onHandlerPointerLeave));
  }
  dragMaskSize() {
    const { position } = this.attribute, { attPos, max: max4 } = this._layoutCache;
    return this._activeCache.lastPos[attPos] - position[attPos] > max4 ? max4 + position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - position[attPos] < 0 ? position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - this._activeCache.startPos[attPos];
  }
  setStateAttr(start, end, shouldRender) {
    const { zoomLock = false, minSpan = 0, maxSpan = 1 } = this.attribute, span = end - start;
    span !== this._spanCache && (zoomLock || span < minSpan || span > maxSpan) || (this._spanCache = span, this.state.start = start, this.state.end = end, shouldRender && this.setAttributes({
      start,
      end
    }));
  }
  eventPosToStagePos(e3) {
    var _a, _b;
    const { x: x3, y: y3 } = vglobal.mapToCanvasPoint(e3);
    return {
      x: x3 - ((null === (_a = this.stage) || void 0 === _a ? void 0 : _a.x) || 0),
      y: y3 - ((null === (_b = this.stage) || void 0 === _b ? void 0 : _b.y) || 0)
    };
  }
  _onHandlerPointerUp(e3) {
    e3.preventDefault();
    const { start, end, brushSelect, realTime = true } = this.attribute;
    if (this._activeState && this._activeTag === DataZoomActiveTag.background) {
      const pos = this.eventPosToStagePos(e3);
      this.backgroundDragZoom(this._activeCache.startPos, pos);
    }
    this._activeState = false, brushSelect && this.renderDragMask(), realTime && start === this.state.start && end === this.state.end || (this.setStateAttr(this.state.start, this.state.end, true), this._dispatchEvent("change", {
      start: this.state.start,
      end: this.state.end,
      tag: this._activeTag
    })), "browser" === vglobal.env && (vglobal.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    }), vglobal.removeEventListener("pointerup", this._onHandlerPointerUp.bind(this))), this.removeEventListener("pointermove", this._onHandlerPointerMove, {
      capture: true
    });
  }
  _onHandlerPointerEnter(e3) {
    e3.stopPropagation(), this._showText = true, this.renderText();
  }
  _onHandlerPointerLeave(e3) {
    e3.stopPropagation(), this._showText = false, this.renderText();
  }
  backgroundDragZoom(startPos, endPos) {
    const { attPos, max: max4 } = this._layoutCache, { position } = this.attribute, startPosInComponent = startPos[attPos] - position[attPos], endPosInComponent = endPos[attPos] - position[attPos], start = Math.min(Math.max(Math.min(startPosInComponent, endPosInComponent) / max4, 0), 1), end = Math.min(Math.max(Math.max(startPosInComponent, endPosInComponent) / max4, 0), 1);
    Math.abs(start - end) < 0.01 ? this.moveZoomWithMiddle(start) : this.setStateAttr(start, end, false);
  }
  moveZoomWithMiddle(middle) {
    let offset = middle - (this.state.start + this.state.end) / 2;
    0 !== offset && (offset > 0 ? this.state.end + offset > 1 && (offset = 1 - this.state.end) : offset < 0 && this.state.start + offset < 0 && (offset = -this.state.start), this.setStateAttr(this.state.start + offset, this.state.end + offset, false));
  }
  renderDragMask() {
    const { dragMaskStyle } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    this._isHorizontal ? this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x, position.x, position.x + width),
      y: position.y,
      width: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0,
      height
    }, dragMaskStyle), "rect") : this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: position.x,
      y: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y, position.y, position.y + height),
      width,
      height: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0
    }, dragMaskStyle), "rect");
  }
  isTextOverflow(componentBoundsLike, textBounds, layout2) {
    if (!textBounds) return false;
    if (this._isHorizontal) {
      if ("start" === layout2) {
        if (textBounds.x1 < componentBoundsLike.x1) return true;
      } else if (textBounds.x2 > componentBoundsLike.x2) return true;
    } else if ("start" === layout2) {
      if (textBounds.y1 < componentBoundsLike.y1) return true;
    } else if (textBounds.y2 > componentBoundsLike.y2) return true;
    return false;
  }
  setTextAttr(startTextBounds, endTextBounds) {
    const { startTextStyle, endTextStyle } = this.attribute, { formatMethod: startTextFormat } = startTextStyle, restStartTextStyle = __rest6(startTextStyle, ["formatMethod"]), { formatMethod: endTextFormat } = endTextStyle, restEndTextStyle = __rest6(endTextStyle, ["formatMethod"]), { start, end } = this.state;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end);
    const { position, width, height } = this.getLayoutAttrFromConfig(), startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue, endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue, componentBoundsLike = {
      x1: position.x,
      y1: position.y,
      x2: position.x + width,
      y2: position.y + height
    };
    let startTextPosition, endTextPosition, startTextAlignStyle, endTextAlignStyle;
    this._isHorizontal ? (startTextPosition = {
      x: position.x + start * width,
      y: position.y + height / 2
    }, endTextPosition = {
      x: position.x + end * width,
      y: position.y + height / 2
    }, startTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "left" : "right",
      textBaseline: "middle"
    }, endTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "right" : "left",
      textBaseline: "middle"
    }) : (startTextPosition = {
      x: position.x + width / 2,
      y: position.y + start * height
    }, endTextPosition = {
      x: position.x + width / 2,
      y: position.y + end * height
    }, startTextAlignStyle = {
      textAlign: "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "top" : "bottom"
    }, endTextAlignStyle = {
      textAlign: "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "bottom" : "top"
    }), this._startText = this.maybeAddLabel(this._container, merge({}, restStartTextStyle, {
      text: startTextValue,
      x: startTextPosition.x,
      y: startTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: startTextAlignStyle
    }), `data-zoom-start-text-${position}`), this._endText = this.maybeAddLabel(this._container, merge({}, restEndTextStyle, {
      text: endTextValue,
      x: endTextPosition.x,
      y: endTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: endTextAlignStyle
    }), `data-zoom-end-text-${position}`);
  }
  renderText() {
    let startTextBounds = null, endTextBounds = null;
    this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds, this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds;
    const { x1: x14, x2: x23, y1: y14, y2: y23 } = startTextBounds, { dx: startTextDx = 0, dy: startTextDy = 0 } = this.attribute.startTextStyle;
    if (new Bounds().set(x14, y14, x23, y23).intersects(endTextBounds)) {
      const direction2 = "bottom" === this.attribute.orient || "right" === this.attribute.orient ? -1 : 1;
      this._isHorizontal ? this._startText.setAttribute("dy", startTextDy + direction2 * Math.abs(endTextBounds.y1 - endTextBounds.y2)) : this._startText.setAttribute("dx", startTextDx + direction2 * Math.abs(endTextBounds.x1 - endTextBounds.x2));
    } else this._isHorizontal ? this._startText.setAttribute("dy", startTextDy) : this._startText.setAttribute("dx", startTextDx);
  }
  getLayoutAttrFromConfig() {
    var _a, _b, _c, _d;
    if (this._layoutAttrFromConfig) return this._layoutAttrFromConfig;
    const { position: positionConfig, size, orient, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {} } = this.attribute, { width: widthConfig, height: heightConfig } = size, middleHandlerSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10;
    let width, height, position;
    middleHandlerStyle.visible ? this._isHorizontal ? (width = widthConfig, height = heightConfig - middleHandlerSize, position = {
      x: positionConfig.x,
      y: positionConfig.y + middleHandlerSize
    }) : (width = widthConfig - middleHandlerSize, height = heightConfig, position = {
      x: positionConfig.x + ("left" === orient ? middleHandlerSize : 0),
      y: positionConfig.y
    }) : (width = widthConfig, height = heightConfig, position = positionConfig);
    const startHandlerSize = null !== (_c = startHandlerStyle.size) && void 0 !== _c ? _c : this._isHorizontal ? height : width, endHandlerSize = null !== (_d = endHandlerStyle.size) && void 0 !== _d ? _d : this._isHorizontal ? height : width;
    return startHandlerStyle.visible && (this._isHorizontal ? (width -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x + startHandlerSize / 2,
      y: position.y
    }) : (height -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x,
      y: position.y + startHandlerSize
    })), this._layoutAttrFromConfig = {
      position,
      width,
      height
    }, this._layoutAttrFromConfig;
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    this._layoutAttrFromConfig = null;
    const { orient, backgroundStyle, backgroundChartStyle = {}, selectedBackgroundStyle = {}, selectedBackgroundChartStyle = {}, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, brushSelect, zoomLock } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig(), startHandlerMinSize = null !== (_a = startHandlerStyle.triggerMinSize) && void 0 !== _a ? _a : 40, endHandlerMinSize = null !== (_b = endHandlerStyle.triggerMinSize) && void 0 !== _b ? _b : 40, group = this.createOrUpdateChild("dataZoom-container", {}, "group");
    if (this._container = group, this._background = group.createOrUpdateChild("background", Object.assign(Object.assign({
      x: position.x,
      y: position.y,
      width,
      height,
      cursor: brushSelect ? "crosshair" : "auto"
    }, backgroundStyle), {
      pickable: !zoomLock
    }), "rect"), (null === (_c = backgroundChartStyle.line) || void 0 === _c ? void 0 : _c.visible) && this.setPreviewAttributes("line", group), (null === (_d = backgroundChartStyle.area) || void 0 === _d ? void 0 : _d.visible) && this.setPreviewAttributes("area", group), brushSelect && this.renderDragMask(), this._isHorizontal ? this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x + start * width,
      y: position.y,
      width: (end - start) * width,
      height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock
    }), "rect") : this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x,
      y: position.y + start * height,
      width,
      height: (end - start) * height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock
    }), "rect"), (null === (_e = selectedBackgroundChartStyle.line) || void 0 === _e ? void 0 : _e.visible) && this.setSelectedPreviewAttributes("line", group), (null === (_f = selectedBackgroundChartStyle.area) || void 0 === _f ? void 0 : _f.visible) && this.setSelectedPreviewAttributes("area", group), this._isHorizontal) {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_g = middleHandlerStyle.background) || void 0 === _g ? void 0 : _g.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: position.x + start * width,
          y: position.y - middleHandlerBackgroundSize,
          width: (end - start) * width,
          height: middleHandlerBackgroundSize
        }, null === (_h = middleHandlerStyle.background) || void 0 === _h ? void 0 : _h.style), {
          pickable: !zoomLock
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: position.x + (start + end) / 2 * width,
          y: position.y - middleHandlerBackgroundSize / 2,
          strokeBoundsBuffer: 0,
          angle: 0,
          symbolType: null !== (_k = null === (_j = middleHandlerStyle.icon) || void 0 === _j ? void 0 : _j.symbolType) && void 0 !== _k ? _k : "square"
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + start * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_l = startHandlerStyle.symbolType) && void 0 !== _l ? _l : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), {
        pickable: !zoomLock
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + end * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_m = endHandlerStyle.symbolType) && void 0 !== _m ? _m : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), {
        pickable: !zoomLock
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + start * width - startHandlerWidth / 2,
        y: position.y + height / 2 - startHandlerHeight / 2,
        width: startHandlerWidth,
        height: startHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + end * width - endHandlerWidth / 2,
        y: position.y + height / 2 - endHandlerHeight / 2,
        width: endHandlerWidth,
        height: endHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect");
    } else {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_o = middleHandlerStyle.background) || void 0 === _o ? void 0 : _o.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize : position.x + width,
          y: position.y + start * height,
          width: middleHandlerBackgroundSize,
          height: (end - start) * height
        }, null === (_p = middleHandlerStyle.background) || void 0 === _p ? void 0 : _p.style), {
          pickable: !zoomLock
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize / 2 : position.x + width + middleHandlerBackgroundSize / 2,
          y: position.y + (start + end) / 2 * height,
          angle: Math.PI / 180 * 90,
          symbolType: null !== (_r = null === (_q = middleHandlerStyle.icon) || void 0 === _q ? void 0 : _q.symbolType) && void 0 !== _r ? _r : "square",
          strokeBoundsBuffer: 0
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + start * height,
        size: width,
        symbolType: null !== (_s = startHandlerStyle.symbolType) && void 0 !== _s ? _s : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), {
        pickable: !zoomLock
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + end * height,
        size: width,
        symbolType: null !== (_t = endHandlerStyle.symbolType) && void 0 !== _t ? _t : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), {
        pickable: !zoomLock
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + startHandlerWidth / 2,
        y: position.y + start * height - startHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + endHandlerWidth / 2,
        y: position.y + end * height - endHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect");
    }
    this._showText && this.renderText();
  }
  computeBasePoints() {
    const { orient } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    let basePointStart, basePointEnd;
    return this._isHorizontal ? (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : "left" === orient ? (basePointStart = [{
      x: position.x + width,
      y: position.y
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x,
      y: position.y
    }]), {
      basePointStart,
      basePointEnd
    };
  }
  getPreviewLinePoints() {
    const previewPoints = this._previewData.map((d2) => ({
      x: this._previewPointsX && this._previewPointsX(d2),
      y: this._previewPointsY && this._previewPointsY(d2)
    }));
    if (0 === previewPoints.length) return previewPoints;
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  getPreviewAreaPoints() {
    const previewPoints = this._previewData.map((d2) => ({
      x: this._previewPointsX && this._previewPointsX(d2),
      y: this._previewPointsY && this._previewPointsY(d2),
      x1: this._previewPointsX1 && this._previewPointsX1(d2),
      y1: this._previewPointsY1 && this._previewPointsY1(d2)
    }));
    if (0 === previewPoints.length) return previewPoints;
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  setPreviewAttributes(type, group) {
    this._previewGroup || (this._previewGroup = group.createOrUpdateChild("previewGroup", {
      pickable: false
    }, "group")), "line" === type ? this._previewLine = this._previewGroup.createOrUpdateChild("previewLine", {}, "line") : this._previewArea = this._previewGroup.createOrUpdateChild("previewArea", {
      curveType: "basis"
    }, "area");
    const { backgroundChartStyle = {} } = this.attribute;
    "line" === type && this._previewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.line)), "area" === type && this._previewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.area));
  }
  setSelectedPreviewAttributes(type, group) {
    this._selectedPreviewGroupClip || (this._selectedPreviewGroupClip = group.createOrUpdateChild("selectedPreviewGroupClip", {
      pickable: false
    }, "group"), this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild("selectedPreviewGroup", {}, "group")), "line" === type ? this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewLine", {}, "line") : this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewArea", {
      curveType: "basis"
    }, "area");
    const { selectedBackgroundChartStyle = {} } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig();
    this._selectedPreviewGroupClip.setAttributes({
      x: this._isHorizontal ? position.x + start * width : position.x,
      y: this._isHorizontal ? position.y : position.y + start * height,
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      clip: true,
      pickable: false
    }), this._selectedPreviewGroup.setAttributes({
      x: -(this._isHorizontal ? position.x + start * width : position.x),
      y: -(this._isHorizontal ? position.y : position.y + start * height),
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      pickable: false
    }), "line" === type && this._selectedPreviewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.line)), "area" === type && this._selectedPreviewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.area));
  }
  maybeAddLabel(container2, attributes, name) {
    let labelShape = this.find((node) => node.name === name, true);
    return labelShape ? labelShape.setAttributes(attributes) : (labelShape = new Tag(attributes), labelShape.name = name), container2.add(labelShape), labelShape;
  }
  setStartAndEnd(start, end) {
    const { start: startAttr, end: endAttr } = this.attribute;
    isValid_default(start) && isValid_default(end) && (start !== this.state.start || end !== this.state.end) && (this.state.start = start, this.state.end = end, startAttr === this.state.start && endAttr === this.state.end || (this.setStateAttr(start, end, true), this._dispatchEvent("change", {
      start,
      end,
      tag: this._activeTag
    })));
  }
  setPreviewData(data) {
    this._previewData = data;
  }
  setText(text2, tag) {
    "start" === tag ? this._startText.setAttribute("text", text2) : this._endText.setAttribute("text", text2);
  }
  getStartValue() {
    return this._startValue;
  }
  getEndTextValue() {
    return this._endValue;
  }
  getMiddleHandlerSize() {
    var _a, _b, _c, _d;
    const { middleHandlerStyle = {} } = this.attribute, middleHandlerRectSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10, middleHandlerSymbolSize = null !== (_d = null === (_c = middleHandlerStyle.icon) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
    return Math.max(middleHandlerRectSize, ...array(middleHandlerSymbolSize));
  }
  setPreviewPointsX(callback) {
    isFunction_default(callback) && (this._previewPointsX = callback);
  }
  setPreviewPointsY(callback) {
    isFunction_default(callback) && (this._previewPointsY = callback);
  }
  setPreviewPointsX1(callback) {
    isFunction_default(callback) && (this._previewPointsX1 = callback);
  }
  setPreviewPointsY1(callback) {
    isFunction_default(callback) && (this._previewPointsY1 = callback);
  }
  setStatePointToData(callback) {
    isFunction_default(callback) && (this._statePointToData = callback);
  }
};
DataZoom.defaultAttributes = DEFAULT_DATA_ZOOM_ATTRIBUTES;

// node_modules/@visactor/vrender-components/es/marker/type.js
var IMarkLineLabelPosition;
!function(IMarkLineLabelPosition2) {
  IMarkLineLabelPosition2.start = "start", IMarkLineLabelPosition2.middle = "middle", IMarkLineLabelPosition2.end = "end", IMarkLineLabelPosition2.insideStartTop = "insideStartTop", IMarkLineLabelPosition2.insideStartBottom = "insideStartBottom", IMarkLineLabelPosition2.insideMiddleTop = "insideMiddleTop", IMarkLineLabelPosition2.insideMiddleBottom = "insideMiddleBottom", IMarkLineLabelPosition2.insideEndTop = "insideEndTop", IMarkLineLabelPosition2.insideEndBottom = "insideEndBottom";
}(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
var IMarkAreaLabelPosition;
!function(IMarkAreaLabelPosition2) {
  IMarkAreaLabelPosition2.left = "left", IMarkAreaLabelPosition2.right = "right", IMarkAreaLabelPosition2.top = "top", IMarkAreaLabelPosition2.bottom = "bottom", IMarkAreaLabelPosition2.middle = "middle", IMarkAreaLabelPosition2.insideLeft = "insideLeft", IMarkAreaLabelPosition2.insideRight = "insideRight", IMarkAreaLabelPosition2.insideTop = "insideTop", IMarkAreaLabelPosition2.insideBottom = "insideBottom";
}(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
var IMarkPointItemPosition;
!function(IMarkPointItemPosition2) {
  IMarkPointItemPosition2.top = "top", IMarkPointItemPosition2.bottom = "bottom", IMarkPointItemPosition2.middle = "middle", IMarkPointItemPosition2.insideTop = "insideTop", IMarkPointItemPosition2.insideBottom = "insideBottom", IMarkPointItemPosition2.insideMiddle = "insideMiddle";
}(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

// node_modules/@visactor/vrender-components/es/marker/base.js
var Marker = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "marker";
  }
  setAttribute(key, value, forceUpdateTag) {
    super.setAttribute(key, value, forceUpdateTag), "visible" === key && this.render();
  }
  _initContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    let group;
    if (clipInRange) {
      const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), {
        clip: true,
        pickable: false
      }));
      group = graphicCreator.group({
        x: -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0),
        y: -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0),
        pickable: false
      }), groupClip.add(group), this._containerClip = groupClip, this.add(groupClip);
    } else group = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(group);
    group.name = "marker-container", this._container = group;
  }
  _updateContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    this._containerClip && this._containerClip.setAttributes(Object.assign({}, limitRect)), this._container.setAttributes({
      x: clipInRange ? -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0) : 0,
      y: clipInRange ? -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0) : 0
    });
  }
  render() {
    var _a;
    this.setAttribute("pickable", false);
    const markerVisible = null === (_a = this.attribute.visible) || void 0 === _a || _a;
    false === this.attribute.interactive && this.setAttribute("childrenPickable", false), markerVisible && this.isValidPoints() ? this._container ? (this._updateContainer(), this.updateMarker()) : (this._initContainer(), this.initMarker(this._container)) : (this._container = null, this.removeAllChild());
  }
};

// node_modules/@visactor/vrender-components/es/marker/config.js
var DEFAULT_MARK_LINE_THEME = {
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    position: IMarkLineLabelPosition.end,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_MARK_LINE_TEXT_STYLE_MAP = {
  start: {
    textAlign: "right",
    textBaseline: "middle"
  },
  insideStartTop: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  insideStartBottom: {
    textAlign: "left",
    textBaseline: "top"
  },
  middle: {
    textAlign: "center",
    textBaseline: "middle"
  },
  insideMiddleTop: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  insideMiddleBottom: {
    textAlign: "center",
    textBaseline: "top"
  },
  end: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideEndTop: {
    textAlign: "right",
    textBaseline: "bottom"
  },
  insideEndBottom: {
    textAlign: "right",
    textBaseline: "top"
  }
};
var DEFAULT_MARK_AREA_THEME = {
  label: {
    position: IMarkAreaLabelPosition.right,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_MARK_AREA_TEXT_STYLE_MAP = {
  left: {
    textAlign: "right",
    textBaseline: "middle"
  },
  insideLeft: {
    textAlign: "left",
    textBaseline: "middle"
  },
  right: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideRight: {
    textAlign: "right",
    textBaseline: "middle"
  },
  top: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  insideTop: {
    textAlign: "center",
    textBaseline: "top"
  },
  bottom: {
    textAlign: "center",
    textBaseline: "top"
  },
  insideBottom: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  middle: {
    textAlign: "center",
    textBaseline: "middle"
  }
};
var DEFAULT_MARK_POINT_THEME = {
  itemLine: {
    visible: true,
    decorativeLine: {
      visible: false,
      length: 30
    },
    startSymbol: {
      visible: true,
      clip: true,
      symbolType: "circle",
      size: 20,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    endSymbol: {
      visible: false,
      clip: true,
      symbolType: "triangle",
      size: 12,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    lineStyle: {
      stroke: "#000",
      lineWidth: 1
    }
  },
  itemContent: {
    type: "text",
    position: "middle",
    refX: 10,
    symbolStyle: {
      symbolType: "star",
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8,
      size: 20
    },
    textStyle: {
      dx: 0,
      dy: 0
    },
    imageStyle: {
      width: 80,
      height: 80
    },
    richTextStyle: {
      width: 100,
      height: 100
    }
  }
};
var DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
  top: {
    textAlign: "left",
    textBaseline: "bottom"
  },
  bottom: {
    textAlign: "left",
    textBaseline: "top"
  },
  middle: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideTop: {
    textAlign: "right",
    textBaseline: "bottom"
  },
  insideBottom: {
    textAlign: "right",
    textBaseline: "top"
  },
  insideMiddle: {
    textAlign: "right",
    textBaseline: "middle"
  }
};

// node_modules/@visactor/vrender-components/es/util/limit-shape.js
function computeOffsetForlimit(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1: x14, y1: y14, x2: x23, y2: y23 } = shape.AABBBounds;
  let dx = 0, dy = 0;
  return x14 < regionMinX && (dx = regionMinX - x14), y14 < regionMinY && (dy = regionMinY - y14), x23 > regionMaxX && (dx = regionMaxX - x23), y23 > regionMaxY && (dy = regionMaxY - y23), {
    dx,
    dy
  };
}
function limitShapeInBounds(shape, bounds) {
  const { dx, dy } = computeOffsetForlimit(shape, bounds), { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}

// node_modules/@visactor/vrender-components/es/marker/register.js
function loadBaseMarker() {
  registerGroup(), loadTagComponent();
}
function loadMarkLineComponent() {
  loadBaseMarker(), loadSegmentComponent();
}
function loadMarkAreaComponent() {
  loadBaseMarker(), registerPolygon();
}
function loadMarkPointComponent() {
  loadBaseMarker(), loadSegmentComponent(), registerSymbol(), registerImage(), registerLine();
}

// node_modules/@visactor/vrender-components/es/marker/line.js
loadMarkLineComponent();
var MarkLine = class _MarkLine extends Marker {
  getLine() {
    return this._line;
  }
  getLabel() {
    return this._label;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkLine.defaultAttributes, attributes)), this.name = "markLine";
  }
  setLabelPos() {
    var _a, _b;
    const { label = {}, limitRect } = this.attribute, { position = "end", refX = 0, refY = 0, confine } = label, points = this._line.getMainSegmentPoints(), labelAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
    let labelPoint;
    if (labelPoint = position.includes("start") || position.includes("Start") ? {
      x: points[0].x + labelOffsetX,
      y: points[0].y + labelOffsetY
    } : position.includes("middle") || position.includes("Middle") ? {
      x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
      y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
    } : {
      x: points[points.length - 1].x + labelOffsetX,
      y: points[points.length - 1].y + labelOffsetY
    }, this._label.setAttributes(Object.assign(Object.assign({}, labelPoint), {
      angle: label.autoRotate ? labelAngle + (null !== (_b = label.refAngle) && void 0 !== _b ? _b : 0) : 0,
      textStyle: Object.assign(Object.assign({}, DEFAULT_MARK_LINE_TEXT_STYLE_MAP[position]), label.textStyle)
    })), limitRect && confine) {
      const { x: x3, y: y3, width, height } = limitRect;
      limitShapeInBounds(this._label, {
        x1: x3,
        y1: y3,
        x2: x3 + width,
        y2: y3 + height
      });
    }
  }
  initMarker(container2) {
    const { points, startSymbol, endSymbol, label, lineStyle, mainSegmentIndex, multiSegment } = this.attribute, line2 = new Segment({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      pickable: false
    });
    line2.name = "mark-line-line", this._line = line2, container2.add(line2);
    const markLabel = new Tag(Object.assign({}, label));
    markLabel.name = "mark-line-label", this._label = markLabel, container2.add(markLabel), this.setLabelPos();
  }
  updateMarker() {
    const { points, startSymbol, endSymbol, label, lineStyle, mainSegmentIndex, multiSegment } = this.attribute;
    this._line && this._line.setAttributes({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment
    }), this._label && this._label.setAttributes(Object.assign({
      dx: 0,
      dy: 0
    }, label)), this.setLabelPos();
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 2) return false;
    let validFlag = true;
    return points.forEach((point6) => {
      if (point6.length) point6.forEach((p2) => {
        isValidNumber_default(p2.x) && isValidNumber_default(p2.y) || (validFlag = false);
      });
      else if (!isValidNumber_default(point6.x) || !isValidNumber_default(point6.y)) return void (validFlag = false);
    }), validFlag;
  }
};
MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;

// node_modules/@visactor/vrender-components/es/marker/area.js
loadMarkAreaComponent();
var MarkArea = class _MarkArea extends Marker {
  getArea() {
    return this._area;
  }
  getLabel() {
    return this._label;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArea.defaultAttributes, attributes)), this.name = "markArea";
  }
  _getPositionByDirection(area2, direction2) {
    const { x1: x14, x2: x23, y1: y14, y2: y23 } = this._area.AABBBounds;
    return direction2.includes("left") || direction2.includes("Left") ? {
      x: x14,
      y: (y14 + y23) / 2
    } : direction2.includes("right") || direction2.includes("Right") ? {
      x: x23,
      y: (y14 + y23) / 2
    } : direction2.includes("top") || direction2.includes("Top") ? {
      x: (x14 + x23) / 2,
      y: y14
    } : direction2.includes("bottom") || direction2.includes("Bottom") ? {
      x: (x14 + x23) / 2,
      y: y23
    } : {
      x: (x14 + x23) / 2,
      y: (y14 + y23) / 2
    };
  }
  setLabelPos() {
    var _a;
    if (this._label && this._area) {
      const { label = {} } = this.attribute, labelPosition = null !== (_a = label.position) && void 0 !== _a ? _a : "middle", labelPoint = this._getPositionByDirection(this._area, labelPosition);
      if (this._label.setAttributes(Object.assign(Object.assign({}, labelPoint), {
        textStyle: Object.assign(Object.assign({}, DEFAULT_MARK_AREA_TEXT_STYLE_MAP[labelPosition]), label.textStyle)
      })), this.attribute.limitRect && label.confine) {
        const { x: x3, y: y3, width, height } = this.attribute.limitRect;
        limitShapeInBounds(this._label, {
          x1: x3,
          y1: y3,
          x2: x3 + width,
          y2: y3 + height
        });
      }
    }
  }
  initMarker(container2) {
    const { points, label, areaStyle } = this.attribute, area2 = graphicCreator.polygon(Object.assign({
      points
    }, areaStyle));
    area2.name = "mark-area-area", this._area = area2, container2.add(area2);
    const markLabel = new Tag(Object.assign({}, label));
    markLabel.name = "mark-area-label", this._label = markLabel, container2.add(markLabel), this.setLabelPos();
  }
  updateMarker() {
    const { points, label, areaStyle } = this.attribute;
    this._area && this._area.setAttributes(Object.assign({
      points
    }, areaStyle)), this._area && this._label.setAttributes(Object.assign({
      dx: 0,
      dy: 0
    }, label)), this.setLabelPos();
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 3) return false;
    let validFlag = true;
    return points.forEach((point6) => {
      isValidNumber_default(point6.x) && isValidNumber_default(point6.y) || (validFlag = false);
    }), validFlag;
  }
};
MarkArea.defaultAttributes = DEFAULT_MARK_AREA_THEME;

// node_modules/@visactor/vrender-components/es/marker/point.js
loadMarkPointComponent();
var MarkPoint = class _MarkPoint extends Marker {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkPoint.defaultAttributes, attributes)), this.name = "markPoint";
  }
  setLabelPos() {
  }
  setItemAttributes(item, itemContent, itemPosition, itemType) {
    var _a;
    if (!item) return;
    const { autoRotate: autoRotate2 = true, refX = 0, refY = 0, refAngle = 0, textStyle = {}, richTextStyle = {}, imageStyle = {}, position = IMarkPointItemPosition.middle } = itemContent, itemAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0, itemOffsetX = refX * Math.cos(itemAngle) + refY * Math.cos(itemAngle - Math.PI / 2), itemOffsetY = refX * Math.sin(itemAngle) + refY * Math.sin(itemAngle - Math.PI / 2);
    "text" === itemType ? item.setAttributes(Object.assign(Object.assign({}, textStyle), {
      textStyle: Object.assign(Object.assign({}, DEFAULT_MARK_POINT_TEXT_STYLE_MAP[(null == itemContent ? void 0 : itemContent.position) || "end"]), textStyle.textStyle)
    })) : "richText" === itemType ? item.setAttributes({
      dx: this.getItemDx(item, position, richTextStyle) + (richTextStyle.dx || 0),
      dy: this.getItemDy(item, position, richTextStyle) + (richTextStyle.dy || 0)
    }) : "image" === itemType && item.setAttributes({
      dx: this.getItemDx(item, position, imageStyle) + (imageStyle.dx || 0),
      dy: this.getItemDy(item, position, imageStyle) + (imageStyle.dy || 0)
    }), item.setAttributes({
      x: itemPosition.x + (itemOffsetX || 0),
      y: itemPosition.y + (itemOffsetY || 0),
      angle: autoRotate2 && itemAngle + refAngle
    });
  }
  getItemDx(item, position, style) {
    var _a, _b;
    const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style ? void 0 : style.width) || 0;
    return position.includes("inside") ? -width : 0;
  }
  getItemDy(item, position, style) {
    var _a, _b;
    const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style ? void 0 : style.height) || 0;
    return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
  }
  initItem(itemContent, itemPosition) {
    const { type = "text", symbolStyle, richTextStyle, imageStyle, renderCustomCallback } = itemContent;
    let item;
    return "symbol" === type ? item = graphicCreator.symbol(Object.assign(Object.assign({}, itemPosition), symbolStyle)) : "text" === type ? item = new Tag(Object.assign({}, itemPosition)) : "richText" === type ? item = graphicCreator.richtext(Object.assign(Object.assign({}, itemPosition), richTextStyle)) : "image" === type ? item = graphicCreator.image(Object.assign(Object.assign({}, itemPosition), imageStyle)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback()), this.setItemAttributes(item, itemContent, itemPosition, type), item;
  }
  getItemLineAttr(itemLine, position, itemPosition) {
    let points = [];
    const { type = "type-s" } = itemLine;
    return points = "type-do" === type ? [position, {
      x: (position.x + itemPosition.x) / 2,
      y: itemPosition.y
    }, itemPosition] : "type-po" === type ? [position, {
      x: itemPosition.x,
      y: position.y
    }, itemPosition] : "type-op" === type ? [position, {
      x: position.x,
      y: itemPosition.y
    }, itemPosition] : [position, itemPosition], points;
  }
  setItemLineAttr(itemLine, position, itemPosition, visible) {
    if (this._line) {
      const { startSymbol, endSymbol, lineStyle } = itemLine, points = this.getItemLineAttr(itemLine, position, itemPosition);
      this._line.setAttributes({
        points,
        startSymbol,
        endSymbol,
        lineStyle,
        visible
      });
    }
  }
  getDecorativeLineAttr(itemLine, itemPosition) {
    var _a;
    const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10, itemAngle = this._line.getEndAngle() || 0;
    return {
      startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
      endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
    };
  }
  setDecorativeLineAttr(itemLine, itemPosition, visible) {
    if (this._decorativeLine) {
      const { lineStyle } = itemLine, { startPointOffsetX, startPointOffsetY, endPointOffsetX, endPointOffsetY } = this.getDecorativeLineAttr(itemLine, itemPosition);
      this._decorativeLine.setAttributes(Object.assign(Object.assign({
        points: [{
          x: itemPosition.x + startPointOffsetX,
          y: itemPosition.y + startPointOffsetY
        }, {
          x: itemPosition.x + endPointOffsetX,
          y: itemPosition.y + endPointOffsetY
        }]
      }, lineStyle), {
        visible
      }));
    }
  }
  setAllOfItemsAttr(itemPosition) {
    var _a;
    const { position, itemLine = {}, itemContent = {}, limitRect } = this.attribute, { type = "text", confine } = itemContent;
    if (limitRect && confine) {
      const { x: x3, y: y3, width, height } = limitRect, { dx, dy } = computeOffsetForlimit(this._item, {
        x1: x3,
        y1: y3,
        x2: x3 + width,
        y2: y3 + height
      });
      itemPosition.x = itemPosition.x + dx, itemPosition.y = itemPosition.y + dy;
    }
    this.setItemAttributes(this._item, itemContent, itemPosition, type), this.setItemLineAttr(itemLine, position, itemPosition, itemLine.visible), this.setDecorativeLineAttr(itemLine, itemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
  }
  initMarker(container2) {
    const { position, itemContent = {} } = this.attribute, itemPosition = {
      x: position.x + (itemContent.offsetX || 0),
      y: position.y + (itemContent.offsetY || 0)
    }, line2 = new Segment({
      points: [],
      pickable: false
    });
    line2.name = "mark-point-line", this._line = line2, container2.add(line2);
    const decorativeLine = graphicCreator.line({
      points: []
    });
    decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, container2.add(decorativeLine);
    const item = this.initItem(itemContent, itemPosition);
    this._item = item, this.setAllOfItemsAttr(itemPosition), container2.add(item);
  }
  updateMarker() {
    const { position, itemContent = {} } = this.attribute, { type = "text" } = itemContent, itemPosition = {
      x: position.x + (itemContent.offsetX || 0),
      y: position.y + (itemContent.offsetY || 0)
    };
    this.setItemAttributes(this._item, itemContent, itemPosition, type), this.setAllOfItemsAttr(itemPosition);
  }
  isValidPoints() {
    const { position } = this.attribute;
    return !(!isValidNumber_default(position.x) || !isValidNumber_default(position.y));
  }
};
MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

// node_modules/@visactor/vrender-components/es/pager/register.js
function loadPagerComponent() {
  registerGroup(), registerSymbol(), registerText();
}

// node_modules/@visactor/vrender-components/es/pager/pager.js
var DEFAULT_HANDLER_STYLE = {
  space: 8,
  style: {
    fill: "rgb(47, 69, 84)",
    cursor: "pointer",
    size: 15
  },
  state: {
    disable: {
      fill: "rgb(170, 170, 170)",
      cursor: "not-allowed"
    },
    hover: {}
  }
};
loadPagerComponent();
var Pager = class _Pager extends AbstractComponent {
  getCurrent() {
    return this._current;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Pager.defaultAttributes, attributes)), this.name = "pager", this._current = 1, this._onHover = (e3) => {
      const target = e3.target;
      target.hasState("disable") || target.addState("hover");
    }, this._onUnHover = (e3) => {
      e3.target.removeState("hover");
    }, this._onClick = (e3) => {
      const target = e3.target;
      if ("preHandler" === target.name) {
        if (1 === this._current) return;
        this._current -= 1, 1 === this._current ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toPrev", {
          current: this._current,
          total: this._total,
          direction: "pre",
          event: e3
        });
      }
      if ("nextHandler" === target.name) {
        if (this._current === this._total) return;
        this._current += 1, this._current === this._total ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toNext", {
          current: this._current,
          total: this._total,
          direction: "next",
          event: e3
        });
      }
      this._current > 1 && this.preHandler.removeState("disable"), this._current < this._total && this.nextHandler.removeState("disable"), this.text.setAttribute("text", `${this._current}/${this._total}`);
    };
  }
  render() {
    var _a, _b;
    this._reset();
    const { layout: layout2 = "horizontal", handler = DEFAULT_HANDLER_STYLE, total, defaultCurrent = 1, textStyle, padding = 0 } = this.attribute;
    this._current = defaultCurrent;
    const parsedPadding = normalizePadding(padding), isHorizontal4 = "horizontal" === layout2, container2 = graphicCreator.group({
      x: 0,
      y: 0
    }), handlerStyle = handler.style || {}, handlerSize = handlerStyle.size || 15, handlerSpace = null !== (_a = handler.space) && void 0 !== _a ? _a : 8, handlerState = handler.state || {};
    let { preShape, nextShape } = handler;
    preShape || (preShape = isHorizontal4 ? "triangleLeft" : "triangleUp"), nextShape || (nextShape = isHorizontal4 ? "triangleRight" : "triangleDown");
    const preHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: 0,
      y: 0,
      symbolType: preShape,
      size: handlerSize
    }));
    preHandler.states = handlerState, preHandler.name = "preHandler", this.preHandler = preHandler, container2.add(preHandler);
    const { width: maxTextWidth, height: maxTextHeight } = measureTextSize(`${total}/${total}`, Object.assign({
      textAlign: "center",
      textBaseline: "middle"
    }, textStyle), null === (_b = this.stage) || void 0 === _b ? void 0 : _b.getTheme().text.fontFamily), handlerSizeX = isNumber_default(handlerSize) ? handlerSize : handlerSize[0], handlerSizeY = isNumber_default(handlerSize) ? handlerSize : handlerSize[1], text2 = graphicCreator.text(Object.assign({
      x: isHorizontal4 ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0,
      y: isHorizontal4 ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2,
      text: `${defaultCurrent}/${total}`,
      textAlign: "center",
      textBaseline: "middle",
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize
    }, textStyle));
    this.text = text2, container2.add(text2);
    const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: isHorizontal4 ? handlerSizeX + 2 * handlerSpace + maxTextWidth : 0,
      y: isHorizontal4 ? 0 : handlerSizeY + 2 * handlerSpace + maxTextHeight,
      symbolType: nextShape,
      size: handlerSize
    }));
    nextHandler.name = "nextHandler", nextHandler.states = handlerState, this.nextHandler = nextHandler, container2.add(nextHandler), 1 === this._total ? (preHandler.addState("disable"), nextHandler.addState("disable")) : 1 === this._current ? preHandler.addState("disable") : this._current === total && nextHandler.addState("disable");
    const containerBounds = container2.AABBBounds, width = containerBounds.width(), height = containerBounds.height();
    container2.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]), this.add(container2), this.attribute.width = width + parsedPadding[1] + parsedPadding[3], this.attribute.height = height + parsedPadding[0] + parsedPadding[2], this._bindEvents();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || (this.preHandler && (this.preHandler.addEventListener("pointerenter", this._onHover), this.preHandler.addEventListener("pointerleave", this._onUnHover), this.preHandler.addEventListener("pointerdown", this._onClick)), this.nextHandler && (this.nextHandler.addEventListener("pointerenter", this._onHover), this.nextHandler.addEventListener("pointerleave", this._onUnHover), this.nextHandler.addEventListener("pointerdown", this._onClick)));
  }
  _reset() {
    this.removeAllChild(), this._current = 1, this._total = this.attribute.total, this.preHandler = this.nextHandler = this.text = null;
  }
};
Pager.defaultAttributes = {
  handler: DEFAULT_HANDLER_STYLE,
  textStyle: {
    fill: "rgb(51, 51, 51)",
    fontSize: 12
  }
};

// node_modules/@visactor/vrender-components/es/legend/constant.js
var DEFAULT_SHAPE_SIZE = 10;
var DEFAULT_SHAPE_SPACE = 8;
var DEFAULT_LABEL_SPACE = 8;
var DEFAULT_VALUE_SPACE = 8;
var DEFAULT_ITEM_SPACE_COL = 16;
var DEFAULT_ITEM_SPACE_ROW = 8;
var DEFAULT_TITLE_SPACE = 12;
var DEFAULT_PAGER_SPACE = 12;
var LegendStateValue;
!function(LegendStateValue2) {
  LegendStateValue2.selected = "selected", LegendStateValue2.unSelected = "unSelected", LegendStateValue2.selectedHover = "selectedHover", LegendStateValue2.unSelectedHover = "unSelectedHover", LegendStateValue2.focus = "focus";
}(LegendStateValue || (LegendStateValue = {}));
var LegendEvent;
!function(LegendEvent2) {
  LegendEvent2.legendItemHover = "legendItemHover", LegendEvent2.legendItemUnHover = "legendItemUnHover", LegendEvent2.legendItemClick = "legendItemClick", LegendEvent2.legendItemAttributeUpdate = "legendItemAttributeUpdate";
}(LegendEvent || (LegendEvent = {}));
var LEGEND_ELEMENT_NAME;
!function(LEGEND_ELEMENT_NAME2) {
  LEGEND_ELEMENT_NAME2.innerView = "innerView", LEGEND_ELEMENT_NAME2.title = "legendTitle", LEGEND_ELEMENT_NAME2.item = "legendItem", LEGEND_ELEMENT_NAME2.itemShape = "legendItemShape", LEGEND_ELEMENT_NAME2.itemLabel = "legendItemLabel", LEGEND_ELEMENT_NAME2.itemValue = "legendItemValue", LEGEND_ELEMENT_NAME2.focus = "legendItemFocus";
}(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

// node_modules/@visactor/vrender-components/es/legend/base.js
var LegendBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "legend", this._title = null;
  }
  render() {
    this.removeAllChild();
    const { interactive = true, title: title3, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), innerView = graphicCreator.group({
      x: parsedPadding[3],
      y: parsedPadding[0],
      pickable: interactive,
      childrenPickable: interactive
    });
    innerView.name = LEGEND_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView, (null == title3 ? void 0 : title3.visible) && this._renderTitle(title3), this._renderContent(), this._adjustLayout(), interactive && this._bindEvents();
    const viewBounds = this._innerView.AABBBounds;
    this.attribute.width = viewBounds.width() + parsedPadding[1] + parsedPadding[3], this.attribute.height = viewBounds.height() + parsedPadding[0] + parsedPadding[2];
  }
  _renderTitle(title3) {
    const { text: text2 = "", textStyle, padding = 0, background, minWidth, maxWidth, shape } = title3, tagAttrs = {
      x: 0,
      y: 0,
      text: text2,
      textStyle,
      padding: normalizePadding(padding),
      minWidth,
      maxWidth
    };
    shape && shape.visible && (tagAttrs.shape = Object.assign({
      visible: true
    }, shape.style), isValid_default(shape.space) && (tagAttrs.space = shape.space)), background && background.visible && (tagAttrs.panel = Object.assign({
      visible: true
    }, background.style));
    const titleTag = new Tag(tagAttrs);
    titleTag.name = LEGEND_ELEMENT_NAME.title, this._title = titleTag, this._innerView.add(titleTag);
  }
  _adjustLayout() {
    var _a;
    if (this._title) {
      const innerViewWidth = this._innerView.AABBBounds.width(), titleWidth = this._title.AABBBounds.width(), align = null === (_a = this.attribute.title) || void 0 === _a ? void 0 : _a.align;
      "center" === align ? this._title.setAttribute("x", (innerViewWidth - titleWidth) / 2) : "end" === align && this._title.setAttribute("x", innerViewWidth - titleWidth);
    }
  }
};

// node_modules/@visactor/vrender-components/es/slider/register.js
function loadSliderComponent() {
  registerGroup(), registerText(), registerRect(), registerSymbol();
}

// node_modules/@visactor/vrender-components/es/legend/register.js
function loadBaseLegend() {
  registerGroup(), loadTagComponent();
}
function loadDiscreteLegendComponent() {
  loadBaseLegend(), loadPagerComponent();
}
function loadColorContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent();
}
function loadSizeContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent(), registerPath();
}

// node_modules/@visactor/vrender-components/es/legend/discrete/discrete.js
var __rest7 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var DEFAULT_STATES3 = {
  [LegendStateValue.focus]: {},
  [LegendStateValue.selected]: {},
  [LegendStateValue.selectedHover]: {},
  [LegendStateValue.unSelected]: {},
  [LegendStateValue.unSelectedHover]: {}
};
loadDiscreteLegendComponent();
var DiscreteLegend = class _DiscreteLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DiscreteLegend.defaultAttributes, attributes)), this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, this._itemHeight = 0, this._itemMaxWidth = 0, this._onHover = (e3) => {
      const target = e3.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate;
        if (this._lastActiveItem) {
          if (this._lastActiveItem.id === legendItem.id) return;
          this._unHover(this._lastActiveItem, e3);
        }
        this._hover(legendItem, e3);
      } else this._lastActiveItem && (this._unHover(this._lastActiveItem, e3), this._lastActiveItem = null);
    }, this._onUnHover = (e3) => {
      this._lastActiveItem && (this._unHover(this._lastActiveItem, e3), this._lastActiveItem = null);
    }, this._onClick = (e3) => {
      var _a, _b, _c, _d;
      const target = e3.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate;
        if (target.name === LEGEND_ELEMENT_NAME.focus) {
          const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
          legendItem.toggleState(LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
            this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e3), this._setLegendItemState(item, LegendStateValue.selected, e3);
          }) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e3), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e3), null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e3), this._setLegendItemState(item, LegendStateValue.unSelected, e3));
          }));
        } else {
          null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach((item) => {
            item.removeState(LegendStateValue.focus);
          });
          const { selectMode = "multiple", allowAllCanceled = true } = this.attribute, isSelected = legendItem.hasState(LegendStateValue.selected), currentSelectedItems = this._getSelectedLegends();
          if ("multiple" === selectMode) {
            if (false === allowAllCanceled && isSelected && 1 === currentSelectedItems.length) return void this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e3);
            isSelected ? (this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e3), this._setLegendItemState(legendItem, LegendStateValue.unSelected, e3)) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e3), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e3));
          } else this._setLegendItemState(legendItem, LegendStateValue.selected, e3), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e3), null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e3), this._setLegendItemState(item, LegendStateValue.unSelected, e3));
          });
        }
        this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e3);
      }
    };
  }
  setSelected(selectedData) {
    var _a;
    (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach((item) => {
      const itemData = item.data;
      selectedData.includes(itemData.label) ? (this._setLegendItemState(item, LegendStateValue.selected), this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover])) : (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]), this._setLegendItemState(item, LegendStateValue.unSelected));
    });
  }
  _renderContent() {
    const { item = {}, items, reversed, maxCol = 1, maxRow = 2 } = this.attribute;
    if (false === item.visible || isEmpty_default(items)) return;
    let legendItems = items;
    reversed && (legendItems = null == items ? void 0 : items.reverse());
    const itemsContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._itemsContainer = itemsContainer;
    const { layout: layout2, maxWidth, maxHeight, defaultSelected = [], autoPage } = this.attribute, isHorizontal4 = "horizontal" === layout2, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW, maxWidth: maxItemWidth, width: itemWidth, height: itemHeight } = item;
    isValid_default(maxItemWidth) ? isValid_default(itemWidth) ? this._itemWidthByUser = Math.min(maxItemWidth, itemWidth) : this._itemWidthByUser = maxItemWidth : isValid_default(itemWidth) && (this._itemWidthByUser = itemWidth), isValid_default(itemHeight) && (this._itemHeightByUser = itemHeight);
    let doWrap = false, maxWidthInCol = 0, startX = 0, startY = 0, maxPages = 1, pages = 1;
    legendItems.forEach((item2, index) => {
      item2.id || (item2.id = item2.label), item2.index = index;
      const itemGroup = this._renderEachItem(item2, !!isEmpty_default(defaultSelected) || (null == defaultSelected ? void 0 : defaultSelected.includes(item2.label)), index, legendItems), itemWidth2 = itemGroup.attribute.width, itemHeight2 = itemGroup.attribute.height;
      this._itemHeight = Math.max(this._itemHeight, itemHeight2), maxWidthInCol = Math.max(itemWidth2, maxWidthInCol), this._itemMaxWidth = Math.max(itemWidth2, this._itemMaxWidth), isHorizontal4 ? (maxPages = maxRow, isValid_default(maxWidth) && (itemWidth2 >= maxWidth ? (doWrap = true, index > 0 && (startX = 0, startY += itemHeight2 + spaceRow, pages += 1)) : maxWidth < startX + itemWidth2 && (doWrap = true, startX = 0, startY += itemHeight2 + spaceRow, pages += 1)), index > 0 && itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startX += spaceCol + itemWidth2) : (maxPages = maxCol, isValid_default(maxHeight) && maxHeight < startY + itemHeight2 && (doWrap = true, startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0, pages += 1), index > 0 && itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startY += spaceRow + itemHeight2), itemsContainer.add(itemGroup);
    });
    let pagerRendered = false;
    doWrap && autoPage && pages > maxPages && (pagerRendered = this._renderPager(isHorizontal4)), pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    if (!this._itemsContainer) return;
    const { hover = true, select = true } = this.attribute;
    hover && (this._itemsContainer.addEventListener("pointermove", this._onHover), this._itemsContainer.addEventListener("pointerleave", this._onUnHover)), select && this._itemsContainer.addEventListener("pointerdown", this._onClick);
  }
  _renderEachItem(item, isSelected, index, items) {
    var _a, _b;
    const { id: id2, label, value, shape } = item, { padding = 0, focus, focusIconStyle } = this.attribute.item, { shape: shapeAttr, label: labelAttr, value: valueAttr, background } = this.attribute.item, shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items), labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items), valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items), backgroundStyle = this._handleStyle(background, item, isSelected, index, items), parsedPadding = normalizePadding(padding);
    let itemGroup;
    false === background.visible ? (itemGroup = graphicCreator.group({
      x: 0,
      y: 0,
      cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
    }), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = graphicCreator.group(Object.assign({
      x: 0,
      y: 0
    }, backgroundStyle.style)), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), itemGroup.id = `${null != id2 ? id2 : label}-${index}`, itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
    const innerGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    itemGroup.add(innerGroup);
    let focusShape, focusStartX = 0, shapeSize = 0, shapeSpace = 0;
    if (shapeAttr && false !== shapeAttr.visible) {
      const s3 = get_default(shapeStyle, "style.size", DEFAULT_SHAPE_SIZE);
      shapeSize = isArray_default(s3) ? s3[0] || 0 : s3, shapeSpace = get_default(shapeAttr, "space", DEFAULT_SHAPE_SPACE);
      const itemShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: 0,
        symbolType: "circle",
        strokeBoundsBuffer: 0
      }, shape), shapeStyle.style));
      Object.keys(shapeStyle.state || {}).forEach((key) => {
        const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
        shape.fill && isNil_default(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), shape.stroke && isNil_default(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
      }), this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(itemShape);
    }
    let focusSpace = 0;
    if (focus) {
      const focusSize = get_default(focusIconStyle, "size", DEFAULT_SHAPE_SIZE);
      focusShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: -focusSize / 2 - 1,
        strokeBoundsBuffer: 0
      }, focusIconStyle), {
        visible: true,
        pickMode: "imprecise",
        boundsPadding: parsedPadding
      })), this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup), focusSpace = focusSize;
    }
    const labelShape = graphicCreator.text(Object.assign(Object.assign({
      x: shapeSize / 2 + shapeSpace,
      y: 0,
      textAlign: "start",
      textBaseline: "middle",
      lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
    }, labelStyle.style), {
      text: labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label
    }));
    this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(labelShape);
    const labelSpace = get_default(labelAttr, "space", DEFAULT_LABEL_SPACE);
    if (isValid_default(value)) {
      const valueSpace = get_default(valueAttr, "space", focus ? DEFAULT_VALUE_SPACE : 0), valueShape = graphicCreator.text(Object.assign(Object.assign({
        x: 0,
        y: 0,
        textAlign: "start",
        textBaseline: "middle",
        lineHeight: valueStyle.style.fontSize
      }, valueStyle.style), {
        text: valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value
      }));
      if (this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), this._itemWidthByUser) {
        const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace, valueBounds = valueShape.AABBBounds, labelBounds = labelShape.AABBBounds, valueWidth = valueBounds.width(), labelWidth = labelBounds.width();
        labelWidth > layoutWidth ? (layoutWidth - valueWidth) / labelWidth > 0.4 ? labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : (valueShape.setAttribute("maxLineWidth", 0.5 * layoutWidth), labelShape.setAttribute("maxLineWidth", 0.5 * layoutWidth)) : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth), valueAttr.alignRight ? valueShape.setAttributes({
          textAlign: "right",
          x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
        }) : valueShape.setAttribute("x", labelShape.AABBBounds.x2 + valueSpace);
      } else valueShape.setAttribute("x", labelShape.AABBBounds.x2 + valueSpace);
      focusStartX = valueShape.AABBBounds.x2 + valueSpace, innerGroup.add(valueShape);
    } else this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), focusStartX = labelShape.AABBBounds.x2 + labelSpace) : focusStartX = labelShape.AABBBounds.x2 + labelSpace;
    focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
    const innerGroupBounds = innerGroup.AABBBounds, innerGroupWidth = innerGroupBounds.width(), innerGroupHeight = innerGroupBounds.height(), itemGroupWidth = isValid_default(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3], itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
    return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, focusShape && focusShape.setAttribute("visible", false), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), itemGroup;
  }
  _renderPager(isHorizontal4) {
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, maxHeight, maxCol = 1, maxRow = 2, item = {}, pager = {}, disableTriggerEvent } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { animation = true, animationDuration = 450, animationEasing = "quadIn", space: pagerSpace = DEFAULT_PAGER_SPACE, position = "middle" } = pager, pageStyle = __rest7(pager, ["animation", "animationDuration", "animationEasing", "space", "position"]);
    let pagerComp, pageHeight = 0, pageWidth = 0, startX = 0, startY = 0, pages = 1;
    if (isHorizontal4) {
      if (pagerComp = new Pager(Object.assign(Object.assign({
        layout: 1 === maxRow ? "horizontal" : "vertical",
        total: 99
      }, merge({
        handler: {
          preShape: "triangleUp",
          nextShape: "triangleDown"
        }
      }, pageStyle)), {
        disableTriggerEvent
      })), this._pager = pagerComp, this._innerView.add(pagerComp), pageHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, pageWidth = maxWidth - pagerComp.AABBBounds.width() - pagerSpace, pageWidth <= 0) return this._innerView.removeChild(pagerComp), false;
      let y3;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { width, height } = item2.attribute;
        pageWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startX += spaceCol + width;
      }), pagerComp.setAttribute("total", Math.ceil(pages / maxRow)), y3 = "start" === position ? renderStartY : "end" === position ? renderStartY + pageHeight - pagerComp.AABBBounds.height() / 2 : renderStartY + pageHeight / 2 - pagerComp.AABBBounds.height() / 2, pagerComp.setAttributes({
        x: pageWidth,
        y: y3
      });
    } else {
      if (pagerComp = new Pager(Object.assign({
        layout: "horizontal",
        total: 99,
        disableTriggerEvent
      }, pageStyle)), this._pager = pagerComp, this._innerView.add(pagerComp), pageWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, pageHeight = maxHeight - pagerComp.AABBBounds.height() - pagerSpace - renderStartY, pageHeight <= 0) return this._innerView.removeChild(pagerComp), false;
      let x3;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { height } = item2.attribute;
        pageHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startY += spaceRow + height;
      }), pagerComp.setAttribute("total", Math.ceil(pages / maxCol)), x3 = "start" === position ? 0 : "end" === position ? pageWidth - pagerComp.AABBBounds.width() : (pageWidth - pagerComp.AABBBounds.width()) / 2, pagerComp.setAttributes({
        x: x3,
        y: maxHeight - pagerComp.AABBBounds.height()
      });
    }
    pager.defaultCurrent > 1 && (isHorizontal4 ? itemsContainer.setAttribute("y", -(pager.defaultCurrent - 1) * (pageHeight + spaceRow)) : itemsContainer.setAttribute("x", -(pager.defaultCurrent - 1) * (pageWidth + spaceCol)));
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: pageWidth,
      height: pageHeight,
      clip: true,
      pickable: false
    });
    clipGroup.add(itemsContainer), this._innerView.add(clipGroup);
    const onPaging = (e3) => {
      const { current } = e3.detail;
      animation ? itemsContainer.animate().to(isHorizontal4 ? {
        y: -(current - 1) * (pageHeight + spaceRow)
      } : {
        x: -(current - 1) * (pageWidth + spaceCol)
      }, animationDuration, animationEasing) : isHorizontal4 ? itemsContainer.setAttribute("y", -(current - 1) * (pageHeight + spaceRow)) : itemsContainer.setAttribute("x", -(current - 1) * (pageWidth + spaceCol));
    };
    return this._pager.addEventListener("toPrev", onPaging), this._pager.addEventListener("toNext", onPaging), true;
  }
  _hover(legendItem, e3) {
    this._lastActiveItem = legendItem;
    legendItem.hasState(LegendStateValue.selected) ? this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e3) : this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e3);
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", true), this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e3);
  }
  _unHover(legendItem, e3) {
    let attributeUpdate = false;
    (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) && (attributeUpdate = true), legendItem.removeState(LegendStateValue.unSelectedHover), legendItem.removeState(LegendStateValue.selectedHover), legendItem.getChildren()[0].getChildren().forEach((child) => {
      attributeUpdate || !child.hasState(LegendStateValue.unSelectedHover) && !child.hasState(LegendStateValue.selectedHover) || (attributeUpdate = true), child.removeState(LegendStateValue.unSelectedHover), child.removeState(LegendStateValue.selectedHover);
    });
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", false), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e3), this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e3);
  }
  _setLegendItemState(legendItem, stateName, e3) {
    let attributeUpdate = false;
    legendItem.hasState(stateName) || (attributeUpdate = true), legendItem.addState(stateName, true), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = true), child.addState(stateName, true));
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e3);
  }
  _removeLegendItemState(legendItem, stateNames, e3) {
    let attributeUpdate = false;
    stateNames.forEach((name) => {
      !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = true), legendItem.removeState(name);
    }), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && stateNames.forEach((name) => {
        !attributeUpdate && child.hasState(name) && (attributeUpdate = true), child.removeState(name);
      });
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e3);
  }
  _getSelectedLegends() {
    var _a;
    const selectedData = [];
    return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
      item.hasState(LegendStateValue.selected) && selectedData.push(item.data);
    }), selectedData;
  }
  _appendDataToShape(shape, name, data, delegateShape, states = {}) {
    shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = merge({}, DEFAULT_STATES3, states);
  }
  _dispatchLegendEvent(eventName, legendItem, event) {
    const currentSelectedItems = this._getSelectedLegends();
    currentSelectedItems.sort((pre, next) => pre.index - next.index);
    const currentSelected = currentSelectedItems.map((obj) => obj.label);
    this._dispatchEvent(eventName, {
      item: legendItem,
      data: legendItem.data,
      selected: legendItem.hasState(LegendStateValue.selected),
      currentSelectedItems,
      currentSelected,
      event
    });
  }
  _handleStyle(config2, item, isSelected, index, items) {
    const newConfig = {};
    return config2.style && (isFunction_default(config2.style) ? newConfig.style = config2.style(item, isSelected, index, items) : newConfig.style = config2.style), config2.state && (newConfig.state = {}, Object.keys(config2.state).forEach((key) => {
      config2.state[key] && (isFunction_default(config2.state[key]) ? newConfig.state[key] = config2.state[key](item, isSelected, index, items) : newConfig.state[key] = config2.state[key]);
    })), newConfig;
  }
};
DiscreteLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: DEFAULT_ITEM_SPACE_COL,
    spaceRow: DEFAULT_ITEM_SPACE_ROW,
    shape: {
      space: DEFAULT_SHAPE_SPACE,
      style: {
        size: DEFAULT_SHAPE_SIZE,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          opacity: 0.5
        }
      }
    },
    label: {
      space: DEFAULT_LABEL_SPACE,
      style: {
        fontSize: 12,
        fill: "#2C3542",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      }
    },
    focus: false,
    focusIconStyle: {
      size: DEFAULT_SHAPE_SIZE,
      symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
      fill: "#333",
      cursor: "pointer"
    }
  },
  autoPage: true,
  pager: {
    space: DEFAULT_PAGER_SPACE,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: true
};

// node_modules/@visactor/vrender-components/es/slider/constant.js
var SLIDER_ELEMENT_NAME;
!function(SLIDER_ELEMENT_NAME2) {
  SLIDER_ELEMENT_NAME2.innerView = "innerView", SLIDER_ELEMENT_NAME2.railContainer = "sliderRailContainer", SLIDER_ELEMENT_NAME2.rail = "sliderRail", SLIDER_ELEMENT_NAME2.startText = "sliderStartText", SLIDER_ELEMENT_NAME2.endText = "sliderEndText", SLIDER_ELEMENT_NAME2.startHandler = "sliderStartHandler", SLIDER_ELEMENT_NAME2.startHandlerText = "startHandlerText", SLIDER_ELEMENT_NAME2.endHandler = "sliderEndHandler", SLIDER_ELEMENT_NAME2.endHandlerText = "sliderEndHandlerText", SLIDER_ELEMENT_NAME2.track = "sliderTrack", SLIDER_ELEMENT_NAME2.trackContainer = "sliderTrackContainer";
}(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

// node_modules/@visactor/vrender-components/es/slider/slider.js
function convertValueToRange(value) {
  return isArray_default(value) ? value : [value, value];
}
function getDefaultCursor(isHorizontal4) {
  return isHorizontal4 ? "ew-resize" : "ns-resize";
}
loadSliderComponent();
var Slider = class _Slider extends AbstractComponent {
  get track() {
    return this._track;
  }
  get currentValue() {
    return this._currentValue;
  }
  get startHandler() {
    return this._startHandler;
  }
  get endHandler() {
    return this._endHandler;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Slider.defaultAttributes, attributes)), this.name = "slider", this._isHorizontal = true, this._startHandler = null, this._endHandler = null, this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, this._currentValue = {}, this._onHandlerPointerdown = (e3) => {
      e3.stopPropagation(), this._currentHandler = e3.target, this._prePos = this._isHorizontal ? e3.clientX : e3.clientY, "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onHandlerPointerUp), this.stage.addEventListener("pointerupoutside", this._onHandlerPointerUp));
    }, this._onHandlerPointerMove = (e3) => {
      var _a, _b;
      e3.stopPropagation();
      const { railWidth, railHeight, min: min4, max: max4 } = this.attribute;
      if (max4 === min4) return;
      let currentPos, originPos, railLen, delta = 0;
      this._isHorizontal ? (currentPos = e3.clientX, delta = currentPos - this._prePos, originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, railLen = railWidth) : (currentPos = e3.clientY, delta = currentPos - this._prePos, originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, railLen = railHeight);
      const newPos = clamp_default(originPos + delta, 0, railLen), currentValue = newPos / railLen * (max4 - min4) + min4;
      "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onHandlerPointerUp = (e3) => {
      e3.preventDefault(), this._currentHandler = null, "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onHandlerPointerUp), this.stage.removeEventListener("pointerupoutside", this._onHandlerPointerUp));
    }, this._onTrackPointerdown = (e3) => {
      e3.stopPropagation(), this._prePos = this._isHorizontal ? e3.clientX : e3.clientY, "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onTrackPointerUp), this.stage.addEventListener("pointerupoutside", this._onTrackPointerUp));
    }, this._onTrackPointerMove = (e3) => {
      e3.stopPropagation();
      const { railWidth, railHeight, min: min4, max: max4 } = this.attribute;
      if (max4 === min4) return;
      const { startHandler, endHandler } = this._getHandlers();
      let currentPos, trackLen, railLen;
      this._isHorizontal ? (currentPos = e3.clientX, trackLen = this._track.attribute.width, railLen = railWidth) : (currentPos = e3.clientY, trackLen = this._track.attribute.height, railLen = railHeight);
      const delta = currentPos - this._prePos;
      if (startHandler) {
        const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y, newPos = clamp_default(originPos + delta, 0, railLen - trackLen), currentValue = newPos / railLen * (max4 - min4) + min4;
        this._updateHandler(startHandler, newPos, currentValue);
      }
      if (endHandler) {
        const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y, newPos = clamp_default(originPos + delta, trackLen, railLen), currentValue = newPos / railLen * (max4 - min4) + min4, startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
        this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
          x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
          width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
        } : {
          y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
          height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
        });
      }
      this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onTrackPointerUp = (e3) => {
      e3.preventDefault(), "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.removeEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onTrackPointerUp), this.stage.removeEventListener("pointerupoutside", this._onTrackPointerUp));
    }, this._onRailPointerDown = (e3) => {
      e3.stopPropagation();
      const { railWidth, railHeight, min: min4, max: max4 } = this.attribute;
      if (max4 === min4) return;
      const startHandler = this._startHandler, endHandler = this._endHandler;
      let currentPos, startHandlerPos, endHandlerPos, railLen;
      this._isHorizontal ? (currentPos = e3.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railLen = railWidth) : (currentPos = e3.viewY - this._rail.globalAABBBounds.y1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, railLen = railHeight);
      const currentValue = currentPos / railLen * (max4 - min4) + min4;
      if (isValid_default(endHandlerPos)) {
        const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
        this._updateHandler(updateHandler, currentPos, currentValue);
      } else this._updateHandler(startHandler, currentPos, currentValue);
      this._updateTrack(), this._dispatchChangeEvent();
    };
  }
  setValue(value) {
    const { layout: layout2, railWidth, railHeight, min: min4, max: max4 } = this.attribute;
    if (max4 === min4) return;
    const [startValue, endValue] = array(value), { startHandler, endHandler } = this._getHandlers(), railLen = "vertical" === layout2 ? railHeight : railWidth, startPos = (startValue - min4) / (max4 - min4) * railLen;
    if (startHandler && this._updateHandler(startHandler, startPos, startValue), endHandler) {
      const endPos = (endValue - min4) / (max4 - min4) * railLen;
      this._updateHandler(endHandler, endPos, endValue);
    }
    this._updateTrack();
  }
  render() {
    var _a, _b;
    this.removeAllChild();
    const { layout: layout2 = "horizontal", railWidth, railHeight, startText, endText, min: min4, max: max4, showHandler = true } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min4, max4]), this._currentValue = {
      startValue: convertValueToRange(value)[0],
      endValue: convertValueToRange(value)[1]
    };
    const isHorizontal4 = "horizontal" === layout2;
    this._isHorizontal = isHorizontal4;
    const innerView = graphicCreator.group({
      x: 0,
      y: 0
    });
    innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
    let startTextShape, startLen = 0;
    if (startText && startText.visible) {
      startTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal4 ? 0 : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : 0,
        textAlign: isHorizontal4 ? "start" : "center",
        textBaseline: isHorizontal4 ? "middle" : "top",
        text: startText.text,
        lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
      }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
      const space = isValid_default(startText.space) ? startText.space : 0;
      startLen += (isHorizontal4 ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
    }
    const mainContainer = graphicCreator.group({
      x: isHorizontal4 ? startLen : 0,
      y: isHorizontal4 ? 0 : startLen
    });
    innerView.add(mainContainer);
    const railContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    let endTextShape;
    if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, mainContainer.add(railContainer), this._renderRail(railContainer), startLen += isHorizontal4 ? railWidth : railHeight, endText && endText.visible) {
      const space = isValid_default(endText.space) ? endText.space : 0;
      endTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal4 ? startLen + space : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : startLen + space,
        textAlign: isHorizontal4 ? "start" : "center",
        textBaseline: isHorizontal4 ? "middle" : "top",
        text: endText.text,
        lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
      }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
    }
    this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), this._bindEvents());
  }
  _renderRail(container2) {
    const { railWidth, railHeight, railStyle, slidable } = this.attribute;
    let cursor = "default";
    false !== slidable && (cursor = "pointer");
    const railShape = graphicCreator.rect(Object.assign({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cursor
    }, railStyle));
    return railShape.name = SLIDER_ELEMENT_NAME.rail, container2.add(railShape), this._rail = railShape, railShape;
  }
  _renderHandlers(container2) {
    const { range: range2, min: min4, max: max4, handlerSize = 14, handlerStyle, handlerText, railHeight, railWidth, slidable } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min4, max4]);
    const handlerTextVisible = handlerText && handlerText.visible, isHorizontal4 = this._isHorizontal, railLen = isHorizontal4 ? railWidth : railHeight, [startValue, endValue] = convertValueToRange(value), handlerStart = max4 === min4 ? range2 ? 0 : railLen : (startValue - min4) / (max4 - min4) * railLen, startHandler = this._renderHandler(Object.assign({
      x: isHorizontal4 ? handlerStart : railWidth / 2,
      y: isHorizontal4 ? railHeight / 2 : handlerStart,
      size: handlerSize,
      strokeBoundsBuffer: 0,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
    }, handlerStyle));
    if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, container2.add(startHandler), this._currentValue.startPos = handlerStart, handlerTextVisible) {
      const startHandlerText = this._renderHandlerText(startValue, range2 ? "start" : "end");
      startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container2.add(startHandlerText), this._startHandlerText = startHandlerText;
    }
    if (range2) {
      const handlerEnd = max4 === min4 ? railLen : (endValue - min4) / (max4 - min4) * railLen, endHandler = this._renderHandler(Object.assign({
        x: isHorizontal4 ? handlerEnd : railWidth / 2,
        y: isHorizontal4 ? railHeight / 2 : handlerEnd,
        size: handlerSize,
        strokeBoundsBuffer: 0,
        cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
      }, handlerStyle));
      if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, container2.add(endHandler), this._currentValue.endPos = handlerEnd, handlerTextVisible) {
        const endHandlerText = this._renderHandlerText(endValue, "end");
        endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container2.add(endHandlerText), this._endHandlerText = endHandlerText;
      }
    }
  }
  _renderTrack(container2) {
    const { range: range2, min: min4, max: max4, railHeight, railWidth, trackStyle, railStyle, slidable, value } = this.attribute;
    let startValue, endValue;
    if (isNil_default(value)) range2 ? (startValue = min4, endValue = max4) : startValue = endValue = min4;
    else if (range2) {
      const clampValue = clampRange_default(value, min4, max4);
      startValue = clampValue[0], endValue = clampValue[1];
    } else startValue = min4, endValue = clamp_default(value, min4, max4);
    const isHorizontal4 = this._isHorizontal, railLen = isHorizontal4 ? railWidth : railHeight;
    range2 || (startValue = min4);
    const trackContainer = graphicCreator.group({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
      clip: true,
      pickable: false
    });
    trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
    const draggableTrack = isObject_default(range2) && true === range2.draggableTrack;
    let cursor;
    cursor = false === slidable ? "default" : false === range2 || false === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal4);
    const trackWidth = max4 === min4 ? railLen : (endValue - startValue) / (max4 - min4) * railLen, startPos = max4 === min4 ? 0 : (startValue - min4) / (max4 - min4) * railLen, track = graphicCreator.rect(Object.assign({
      x: isHorizontal4 ? startPos : 0,
      y: isHorizontal4 ? 0 : startPos,
      width: isHorizontal4 ? trackWidth : railWidth,
      height: isHorizontal4 ? railHeight : trackWidth,
      cursor
    }, trackStyle));
    track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), container2.add(trackContainer);
  }
  _renderHandler(style) {
    return graphicCreator.symbol(style);
  }
  _renderHandlerText(value, position) {
    var _a, _b, _c;
    const { align, min: min4, max: max4, handlerSize = 14, handlerText = {}, railHeight, railWidth, slidable } = this.attribute, isHorizontal4 = this._isHorizontal, railLen = isHorizontal4 ? railWidth : railHeight, handlerStart = max4 === min4 ? "start" === position ? 0 : railLen : (value - min4) / (max4 - min4) * railLen, textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4, textStyle = {
      text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
      lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal4)
    };
    isHorizontal4 ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", textStyle.x = handlerStart, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", textStyle.textAlign = "center", textStyle.x = handlerStart, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, textStyle.y = handlerStart) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = handlerStart);
    return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { slidable, range: range2 } = this.attribute;
    slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), isObject_default(range2) && range2.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), this._railContainer.addEventListener("pointerdown", this._onRailPointerDown));
  }
  _updateTrack() {
    const startHandler = this._startHandler, endHandler = this._endHandler;
    if (this._isHorizontal) {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
        this._track.setAttributes({
          x: Math.min(startHandlerPos, endHandlerPos),
          width: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else this._track.setAttributes({
        width: startHandlerPos
      });
    } else {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
        this._track.setAttributes({
          y: Math.min(startHandlerPos, endHandlerPos),
          height: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else this._track.setAttributes({
        height: startHandlerPos
      });
    }
  }
  _updateHandler(handler, position, value) {
    var _a;
    const isHorizontal4 = this._isHorizontal;
    handler.setAttribute(isHorizontal4 ? "x" : "y", position);
    const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
    if (updateHandlerText) {
      const { handlerText = {} } = this.attribute;
      updateHandlerText.setAttributes({
        text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
        [isHorizontal4 ? "x" : "y"]: position
      });
    }
    handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _updateHandlerText(handlerText, position, value) {
    var _a;
    const isHorizontal4 = this._isHorizontal, { handlerText: handlerTextAttr = {} } = this.attribute;
    handlerText.setAttributes({
      [isHorizontal4 ? "x" : "y"]: position,
      text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
    });
    const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
    updateHandler && updateHandler.setAttributes({
      [isHorizontal4 ? "x" : "y"]: position
    }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _dispatchChangeEvent() {
    const isRange = !!this.attribute.range, currentValue = this._currentValue;
    this._dispatchEvent("change", {
      value: isRange ? [Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue)] : currentValue.startValue,
      position: isRange ? [Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos)] : currentValue.startPos
    });
  }
  _getHandlers() {
    let temp3, startHandler = this._startHandler, endHandler = this._endHandler;
    return this._isHorizontal ? endHandler && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) && (temp3 = startHandler, startHandler = endHandler, endHandler = temp3) : endHandler && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) && (temp3 = startHandler, startHandler = endHandler, endHandler = temp3), {
      startHandler,
      endHandler
    };
  }
};
Slider.defaultAttributes = {
  slidable: true,
  layout: "horizontal",
  align: "bottom",
  height: 8,
  showHandler: true,
  handlerSize: 14,
  handlerStyle: {
    symbolType: "circle",
    fill: "#fff",
    stroke: "#91caff",
    lineWidth: 2
  },
  railStyle: {
    fill: "rgba(0,0,0,.04)"
  },
  trackStyle: {
    fill: "#91caff"
  },
  showValue: true,
  valueStyle: {
    fill: "#2C3542",
    fontSize: 12
  },
  startText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  endText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  handlerText: {
    visible: true,
    space: 4,
    precision: 0,
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  }
};

// node_modules/@visactor/vrender-components/es/legend/color/color.js
loadColorContinuousLegendComponent();
var ColorContinuousLegend = class _ColorContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ColorContinuousLegend.defaultAttributes, attributes)), this.name = "colorLegend", this._onSliderChange = (e3) => {
      this._updateColor(), this.dispatchEvent(e3);
    };
  }
  setSelected(value) {
    this._slider && (this._slider.setValue(value), this._updateColor());
  }
  _renderContent() {
    const { colors, slidable, layout: layout2, align, min: min4, max: max4, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, disableTriggerEvent } = this.attribute, domain = [], step = (max4 - min4) / (colors.length - 1);
    for (let i2 = 0; i2 < colors.length; i2++) domain.push(min4 + step * i2);
    this._colorScale = new LinearScale().domain(domain, true).range(colors), this._color = this._getTrackColor();
    const slider2 = new Slider({
      x: 0,
      y: 0,
      range: {
        draggableTrack: true
      },
      slidable,
      layout: layout2,
      align,
      min: min4,
      max: max4,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle,
      railStyle,
      trackStyle: Object.assign({
        fill: this._color
      }, trackStyle),
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent
    });
    this._innerView.add(slider2), this._slider = slider2, slider2.translateTo(0 - slider2.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0) - slider2.AABBBounds.y1), this._updateColor();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && this._slider.addEventListener("change", this._onSliderChange);
  }
  _getTrackColor() {
    const { colors, layout: layout2 } = this.attribute;
    if (isEmpty_default(colors)) return;
    const count = colors.length;
    if (1 === count) return colors[0];
    const stops = [];
    for (let i2 = 0; i2 < count; i2++) {
      const percent = i2 / (count - 1);
      stops.push({
        offset: percent,
        color: colors[i2]
      });
    }
    const isHorizontal4 = "horizontal" === layout2;
    return {
      gradient: "linear",
      stops,
      x0: 0,
      y0: 0,
      x1: isHorizontal4 ? 1 : 0,
      y1: isHorizontal4 ? 0 : 1
    };
  }
  _updateColor() {
    const { layout: layout2 = "horizontal", colors, railWidth, railHeight } = this.attribute, { startHandler, endHandler, track } = this._slider, { startValue, endValue, startPos, endPos } = this._slider.currentValue, startHandlerColor = this._colorScale.scale(startValue), endHandlerColor = this._colorScale.scale(endValue);
    null == startHandler || startHandler.setAttribute("fill", startHandlerColor), null == endHandler || endHandler.setAttribute("fill", endHandlerColor);
    const railLen = "horizontal" === layout2 ? railWidth : railHeight;
    if (Math.abs(startPos - endPos) !== railLen && colors && colors.length > 1) {
      const stops = this._color.stops, start = Math.min(startPos, endPos), end = Math.max(startPos, endPos), startRatio = start / railLen, endRatio = end / railLen, range2 = endRatio - startRatio, betweenStops = stops.filter((stop) => stop.offset > startRatio && stop.offset < endRatio), minValue = Math.min(startValue, endValue), maxValue = Math.max(startValue, endValue), startColor = this._colorScale.scale(minValue), endColor = this._colorScale.scale(maxValue), newStops = [{
        offset: 0,
        color: startColor
      }];
      betweenStops.forEach((stop) => {
        newStops.push({
          offset: (stop.offset - startRatio) / range2,
          color: stop.color
        });
      }), newStops.push({
        offset: 1,
        color: endColor
      }), track.setAttribute("fill", Object.assign(Object.assign({}, this._color), {
        stops: newStops
      }));
    }
  }
};
ColorContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    lineWidth: 4,
    stroke: "#fff",
    outerBorder: {
      distance: 2,
      lineWidth: 1,
      stroke: "#ccc"
    }
  }
};

// node_modules/@visactor/vrender-components/es/legend/util.js
function getSizeHandlerPath(align = "bottom") {
  let centerX = 0;
  return "top" === align ? `
    M${centerX},-6L${centerX - 3.5},-2.5
    v5
    h7
    v-5
    Z
` : "left" === align ? (centerX = 1, `
    M${centerX - 6},0L${centerX - 6 + 2.5},-3.5
    h5
    v7
    h-5
    Z
`) : "right" === align ? (centerX = -1, `
    M${centerX + 6},0L${centerX + 6 - 2.5},-3.5
    h-5
    v7
    h5
    Z
  `) : `
    M${centerX},6L${centerX - 3.5},2.5
    v-5
    h7
    v5
    Z
`;
}

// node_modules/@visactor/vrender-components/es/legend/size/size.js
loadSizeContinuousLegendComponent();
var SizeContinuousLegend = class _SizeContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SizeContinuousLegend.defaultAttributes, attributes)), this.name = "sizeLegend", this._onSliderChange = (e3) => {
      this.dispatchEvent(e3);
    };
  }
  setSelected(value) {
    this._slider && this._slider.setValue(value);
  }
  _renderContent() {
    const { slidable, layout: layout2, align, min: min4, max: max4, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, sizeBackground, disableTriggerEvent } = this.attribute, mainContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._innerView.add(mainContainer);
    const slider2 = new Slider({
      x: 0,
      y: 0,
      zIndex: 1,
      range: {
        draggableTrack: true
      },
      slidable,
      layout: layout2,
      align,
      min: min4,
      max: max4,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle: Object.assign({
        symbolType: getSizeHandlerPath(align)
      }, handlerStyle),
      railStyle,
      trackStyle,
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent
    });
    mainContainer.add(slider2);
    let path, start = 0;
    "horizontal" === layout2 ? "top" === align ? (path = `M0,0L${railWidth},0L${railWidth},12Z`, start = railHeight) : (path = `M0,12L${railWidth},12L${railWidth},0Z`, slider2.setAttribute("y", 12)) : "left" === align ? path = `M${railWidth},0L${railWidth},0L${railWidth + 12},${railHeight}L${railWidth},${railHeight}Z` : (path = `M0,${railHeight}L12,${railHeight}L12,0Z`, slider2.setAttribute("x", 12));
    const background = graphicCreator.path(Object.assign(Object.assign({
      x: 0,
      y: start,
      path
    }, sizeBackground), {
      zIndex: 0
    }));
    mainContainer.add(background);
    const titleSpace = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0;
    mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1), this._slider = slider2;
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && this._slider.addEventListener("change", this._onSliderChange);
  }
};
SizeContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    lineWidth: 1,
    stroke: "#ccc",
    fill: "#fff"
  },
  sizeBackground: {
    fill: "rgba(20,20,20,0.1)"
  }
};

// node_modules/@visactor/vrender-components/es/title/register.js
function loadTitleComponent() {
  registerGroup(), registerWrapText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/title/title.js
loadTitleComponent();
var Title = class _Title extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Title.defaultAttributes, attributes)), this.name = "title";
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
    const { textType, text: text2, subtextType, textStyle = {}, subtext, subtextStyle = {}, width, height, minWidth, maxWidth, minHeight, maxHeight, align, verticalAlign, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("title-container", {
      x: parsedPadding[3],
      y: parsedPadding[0],
      zIndex: 1
    }, "group");
    if (false !== this.attribute.visible && false !== textStyle.visible) if ("rich" === textType || isValid_default(textStyle.character)) {
      const attr = Object.assign({
        x: null !== (_a = textStyle.x) && void 0 !== _a ? _a : 0,
        y: null !== (_b = textStyle.y) && void 0 !== _b ? _b : 0,
        width: null !== (_d = null !== (_c = textStyle.width) && void 0 !== _c ? _c : width) && void 0 !== _d ? _d : 0,
        height: null !== (_f = null !== (_e = textStyle.height) && void 0 !== _e ? _e : height) && void 0 !== _f ? _f : 0,
        ellipsis: null === (_g = textStyle.ellipsis) || void 0 === _g || _g,
        wordBreak: null !== (_h = textStyle.wordBreak) && void 0 !== _h ? _h : "break-word",
        maxHeight: textStyle.maxHeight,
        maxWidth: textStyle.maxWidth,
        textConfig: null !== (_j = textStyle.character) && void 0 !== _j ? _j : text2
      }, textStyle);
      this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
    } else if ("html" === textType) {
      const attr = Object.assign({
        html: Object.assign(Object.assign({
          dom: text2
        }, DEFAULT_HTML_TEXT_SPEC), textStyle),
        x: null !== (_k = textStyle.x) && void 0 !== _k ? _k : 0,
        y: null !== (_l = textStyle.y) && void 0 !== _l ? _l : 0,
        width: null !== (_o = null !== (_m = textStyle.width) && void 0 !== _m ? _m : width) && void 0 !== _o ? _o : 0,
        height: null !== (_q = null !== (_p = textStyle.height) && void 0 !== _p ? _p : height) && void 0 !== _q ? _q : 0,
        ellipsis: null === (_r = textStyle.ellipsis) || void 0 === _r || _r,
        wordBreak: null !== (_s = textStyle.wordBreak) && void 0 !== _s ? _s : "break-word",
        maxHeight: textStyle.maxHeight,
        maxWidth: textStyle.maxWidth,
        textConfig: []
      }, textStyle);
      this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
    } else isValid_default(text2) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
      text: isArray_default(text2) ? text2 : [text2]
    }, textStyle), {
      maxLineWidth: null !== (_t = textStyle.maxLineWidth) && void 0 !== _t ? _t : width,
      heightLimit: textStyle.heightLimit,
      lineClamp: textStyle.lineClamp,
      ellipsis: null === (_u = textStyle.ellipsis) || void 0 === _u || _u,
      x: 0,
      y: 0
    }), "wrapText"));
    const maintextHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0, maintextWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
    if (false !== this.attribute.visible && false !== subtextStyle.visible) if ("rich" === subtextType || isValid_default(subtextStyle.character)) {
      const attr = Object.assign({
        x: null !== (_v = subtextStyle.x) && void 0 !== _v ? _v : 0,
        y: null !== (_w = subtextStyle.y) && void 0 !== _w ? _w : 0,
        width: null !== (_y = null !== (_x = subtextStyle.width) && void 0 !== _x ? _x : width) && void 0 !== _y ? _y : 0,
        height: null !== (_0 = null !== (_z = subtextStyle.height) && void 0 !== _z ? _z : height) && void 0 !== _0 ? _0 : 0,
        ellipsis: null === (_1 = subtextStyle.ellipsis) || void 0 === _1 || _1,
        wordBreak: null !== (_2 = subtextStyle.wordBreak) && void 0 !== _2 ? _2 : "break-word",
        maxHeight: subtextStyle.maxHeight,
        maxWidth: subtextStyle.maxWidth,
        textConfig: null !== (_3 = subtextStyle.character) && void 0 !== _3 ? _3 : subtext
      }, subtextStyle);
      this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
    } else if ("html" === subtextType) {
      const attr = Object.assign({
        html: Object.assign(Object.assign({
          dom: subtext
        }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
        x: null !== (_4 = subtextStyle.x) && void 0 !== _4 ? _4 : 0,
        y: null !== (_5 = subtextStyle.y) && void 0 !== _5 ? _5 : 0,
        width: null !== (_7 = null !== (_6 = subtextStyle.width) && void 0 !== _6 ? _6 : width) && void 0 !== _7 ? _7 : 0,
        height: null !== (_9 = null !== (_8 = subtextStyle.height) && void 0 !== _8 ? _8 : height) && void 0 !== _9 ? _9 : 0,
        ellipsis: null === (_10 = subtextStyle.ellipsis) || void 0 === _10 || _10,
        wordBreak: null !== (_11 = subtextStyle.wordBreak) && void 0 !== _11 ? _11 : "break-word",
        maxHeight: subtextStyle.maxHeight,
        maxWidth: subtextStyle.maxWidth,
        textConfig: []
      }, subtextStyle);
      this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
    } else isValid_default(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
      text: isArray_default(subtext) ? subtext : [subtext]
    }, subtextStyle), {
      maxLineWidth: null !== (_12 = subtextStyle.maxLineWidth) && void 0 !== _12 ? _12 : width,
      heightLimit: subtextStyle.heightLimit,
      lineClamp: subtextStyle.lineClamp,
      ellipsis: null === (_13 = subtextStyle.ellipsis) || void 0 === _13 || _13,
      x: 0,
      y: maintextHeight
    }), "wrapText"));
    const subtextHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0, subtextWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
    let titleWidth = Math.max(maintextWidth, subtextWidth), titleHeight = maintextHeight + (null !== (_14 = subtextStyle.height) && void 0 !== _14 ? _14 : subtextHeight);
    if (isValid_default(width) && (titleWidth = width, this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", width), this._subTitle && this._subTitle.setAttribute("maxLineWidth", width)), isValid_default(height) && (titleHeight = height), isValid_default(minWidth) && titleWidth < minWidth && (titleWidth = minWidth), isValid_default(maxWidth) && (this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", maxWidth), this._subTitle && this._subTitle.setAttribute("maxLineWidth", maxWidth), this._mainTitle && this._mainTitle.setAttribute("maxWidth", maxWidth), this._subTitle && this._subTitle.setAttribute("maxWidth", maxWidth), titleWidth > maxWidth && (titleWidth = maxWidth)), isValid_default(minHeight) && titleHeight < minHeight && (titleHeight = minHeight), isValid_default(maxHeight) && (this._mainTitle && this._mainTitle.setAttribute("maxHeight", maxHeight), this._subTitle && this._subTitle.setAttribute("maxHeight", maxHeight - maintextHeight), titleHeight > maxHeight && (titleHeight = maxHeight)), group.attribute.width = titleWidth, group.attribute.height = titleHeight, group.attribute.boundsPadding = parsedPadding, this._mainTitle) {
      if (isValid_default(align) || isValid_default(textStyle.align)) {
        const mainTitleAlign = textStyle.align ? textStyle.align : align, mainTitleWidth = null !== (_15 = textStyle.width) && void 0 !== _15 ? _15 : maintextWidth;
        "left" === mainTitleAlign ? (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left")) : "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign && (this._mainTitle.setAttribute("x", mainTitleWidth), this._mainTitle.setAttribute("textAlign", "right"));
      }
      if (isValid_default(verticalAlign) || isValid_default(textStyle.verticalAlign)) {
        const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign, mainTitleHeight = textStyle.height ? textStyle.height : titleHeight;
        "top" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top")) : "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign && (this._mainTitle.setAttribute("y", mainTitleHeight), this._mainTitle.setAttribute("textBaseline", "bottom"));
      }
    }
    if (this._subTitle) {
      if (isValid_default(align) || isValid_default(subtextStyle.align)) {
        const subTitleAlign = subtextStyle.align ? subtextStyle.align : align, subTitleWidth = null !== (_16 = subtextStyle.width) && void 0 !== _16 ? _16 : subtextWidth;
        "left" === subTitleAlign ? (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left")) : "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign && (this._subTitle.setAttribute("x", subTitleWidth), this._subTitle.setAttribute("textAlign", "right"));
      }
      if (isValid_default(verticalAlign) || isValid_default(textStyle.verticalAlign)) {
        const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign, subTitleYStart = maintextHeight, subTitleHeight = null !== (_17 = subtextStyle.height) && void 0 !== _17 ? _17 : 0;
        "top" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart), this._subTitle.setAttribute("textBaseline", "top")) : "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign && (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), this._subTitle.setAttribute("textBaseline", "bottom"));
      }
    }
  }
};
Title.defaultAttributes = {
  textStyle: {
    ellipsis: "...",
    fill: "#333",
    fontSize: 20,
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "top"
  },
  subtextStyle: {
    ellipsis: "...",
    fill: "#6F6F6F",
    fontSize: 16,
    fontWeight: "normal",
    textAlign: "left",
    textBaseline: "top"
  }
};

// node_modules/@visactor/vrender-components/es/indicator/config.js
var DEFAULT_INDICATOR_THEME = {
  title: {
    style: {
      text: "",
      fontSize: 20,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  },
  content: {
    style: {
      text: "",
      fontSize: 16,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  }
};

// node_modules/@visactor/vrender-components/es/indicator/register.js
function loadIndicatorComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/indicator/indicator.js
loadIndicatorComponent();
var Indicator = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "indicator";
  }
  render() {
    var _a, _b, _c;
    const { visible, title: title3 = {}, content, size, limitRatio = 1 / 0 } = this.attribute, limit = Math.min(size.width, size.height) * limitRatio, group = this.createOrUpdateChild("indicator-container", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    if (true !== visible) return void (group && group.hideAll());
    if (isValid_default(title3)) if (false !== title3.visible) {
      const titleStyle = merge({}, get_default(DEFAULT_INDICATOR_THEME, "title.style"), title3.style);
      "rich" === titleStyle.type ? this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({
        textConfig: titleStyle.text
      }, titleStyle), {
        visible: title3.visible,
        x: 0,
        y: 0,
        width: null !== (_a = titleStyle.width) && void 0 !== _a ? _a : 0,
        height: null !== (_b = titleStyle.height) && void 0 !== _b ? _b : 0
      }), "richtext") : "html" === titleStyle.type ? this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({
        textConfig: [],
        html: Object.assign(Object.assign({
          dom: titleStyle.text
        }, DEFAULT_HTML_TEXT_SPEC), titleStyle)
      }, titleStyle), {
        visible: title3.visible,
        x: 0,
        y: 0
      }), "richtext") : this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({}, titleStyle), {
        lineHeight: isValid_default(titleStyle.lineHeight) ? titleStyle.lineHeight : titleStyle.fontSize,
        visible: title3.visible,
        x: 0,
        y: 0
      }), "text"), title3.autoFit && isValidNumber_default(limit) && this._setLocalAutoFit(limit, this._title, title3), title3.autoLimit && isValidNumber_default(limitRatio) && this._title.setAttribute("maxLineWidth", limit);
    } else {
      const titleNode = group.find((node) => "indicator-title" === node.name, false);
      titleNode && group.removeChild(titleNode), this._title = void 0;
    }
    if (isValid_default(content)) {
      const contents = array(content), contentComponents = [];
      contents.forEach((contentItem, i2) => {
        var _a2, _b2;
        if (false !== contentItem.visible) {
          const contentStyle = merge({}, get_default(DEFAULT_INDICATOR_THEME, "content.style"), contentItem.style);
          let contentComponent;
          contentComponent = "rich" === contentStyle.type ? group.createOrUpdateChild("indicator-content-" + i2, Object.assign(Object.assign({
            textConfig: contentStyle.text
          }, contentStyle), {
            visible: title3.visible,
            x: 0,
            y: 0,
            width: null !== (_a2 = contentStyle.width) && void 0 !== _a2 ? _a2 : 0,
            height: null !== (_b2 = contentStyle.height) && void 0 !== _b2 ? _b2 : 0
          }), "richtext") : "html" === contentStyle.type ? group.createOrUpdateChild("indicator-content-" + i2, Object.assign(Object.assign({
            textConfig: [],
            html: Object.assign(Object.assign({
              dom: contentStyle.text
            }, DEFAULT_HTML_TEXT_SPEC), contentStyle)
          }, contentStyle), {
            visible: title3.visible,
            x: 0,
            y: 0
          }), "richtext") : group.createOrUpdateChild("indicator-content-" + i2, Object.assign(Object.assign({}, contentStyle), {
            lineHeight: isValid_default(contentStyle.lineHeight) ? contentStyle.lineHeight : contentStyle.fontSize,
            visible: contentItem.visible,
            x: 0,
            y: 0
          }), "text"), contentItem.autoFit && isValidNumber_default(limit) && this._setLocalAutoFit(limit, contentComponent, contentItem), contentItem.autoLimit && isValidNumber_default(limitRatio) && contentComponent.setAttribute("maxLineWidth", limit), contentComponents.push(contentComponent);
        } else {
          const contentItemNode = group.find((node) => node.name === "indicator-content-" + i2, false);
          contentItemNode && group.removeChild(contentItemNode);
        }
      }), this._content = contentComponents;
    }
    this._setGlobalAutoFit(limit), this._setYPosition();
    const totalHeight = null !== (_c = null == group ? void 0 : group.AABBBounds.height()) && void 0 !== _c ? _c : 0;
    group.setAttribute("y", size.height / 2 - totalHeight / 2), group.setAttribute("x", size.width / 2);
  }
  _setLocalAutoFit(limit, indicatorItem, indicatorItemSpec) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ("default" !== (null !== (_a = indicatorItemSpec.fitStrategy) && void 0 !== _a ? _a : "default")) return;
    const originWidth = measureTextSize(null !== (_c = null === (_b = indicatorItemSpec.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "", null !== (_d = indicatorItemSpec.style) && void 0 !== _d ? _d : {}, null === (_e = this.stage) || void 0 === _e ? void 0 : _e.getTheme().text.fontFamily).width;
    if (originWidth > 0) {
      const ratio = limit * (null !== (_f = indicatorItemSpec.fitPercent) && void 0 !== _f ? _f : 0.5) / originWidth, fontSize = Math.floor((null !== (_h = null === (_g = indicatorItemSpec.style) || void 0 === _g ? void 0 : _g.fontSize) && void 0 !== _h ? _h : 20) * ratio);
      indicatorItem.setAttribute("fontSize", fontSize), indicatorItem.setAttribute("lineHeight", isValid_default(indicatorItemSpec.style.lineHeight) ? indicatorItemSpec.style.lineHeight : fontSize);
    }
  }
  _setGlobalAutoFit(limit) {
    var _a, _b, _c, _d, _e, _f, _g;
    const r2 = limit / 2, autoFitTexts = [];
    let otherHeight = 0;
    const titleSpec = null !== (_a = this.attribute.title) && void 0 !== _a ? _a : {};
    titleSpec.autoFit && "inscribed" === titleSpec.fitStrategy ? (this._title.setAttribute("fontSize", 12), autoFitTexts.push({
      text: this._title,
      spec: null !== (_b = this.attribute.title) && void 0 !== _b ? _b : {}
    })) : otherHeight += null !== (_f = null === (_e = null === (_d = null === (_c = this._title) || void 0 === _c ? void 0 : _c.AABBBounds) || void 0 === _d ? void 0 : _d.height) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : 0;
    const titleSpace = null !== (_g = titleSpec.space) && void 0 !== _g ? _g : 0;
    if (otherHeight += titleSpace, array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2, _b2, _c2, _d2;
      const contentText = this._content[index];
      contentSpec.autoFit && "inscribed" === contentSpec.fitStrategy ? (contentText.setAttribute("fontSize", 12), autoFitTexts.push({
        text: contentText,
        spec: contentSpec
      })) : otherHeight += null !== (_c2 = null === (_b2 = null === (_a2 = null == contentText ? void 0 : contentText.AABBBounds) || void 0 === _a2 ? void 0 : _a2.height) || void 0 === _b2 ? void 0 : _b2.call(_a2)) && void 0 !== _c2 ? _c2 : 0;
      const contentSpace = null !== (_d2 = contentSpec.space) && void 0 !== _d2 ? _d2 : 0;
      otherHeight += contentSpace;
    }), autoFitTexts.length <= 0) return;
    const ra = 12 / autoFitTexts.reduce((width, textItem) => Math.max(width, textItem.text.AABBBounds.width()), 0) * autoFitTexts.length, h2 = otherHeight / 2, a4 = ra ** 2 + 1, b2 = 2 * h2 * ra, c4 = h2 ** 2 - r2 ** 2, y3 = 2 * (ra * ((-b2 + Math.sqrt(b2 ** 2 - 4 * a4 * c4)) / (2 * a4)) + h2), lineHeight = (y3 - otherHeight) / autoFitTexts.length;
    isValidNumber_default(y3) && autoFitTexts.forEach((textItem) => {
      var _a2;
      const specLineHeight = null === (_a2 = textItem.spec.style) || void 0 === _a2 ? void 0 : _a2.lineHeight;
      textItem.text.setAttribute("fontSize", lineHeight), textItem.text.setAttribute("lineHeight", isValid_default(specLineHeight) ? specLineHeight : lineHeight);
    });
  }
  _setYPosition() {
    var _a, _b, _c, _d, _e, _f;
    let lastContentHeight = 0;
    const titleHeight = null !== (_d = null === (_c = null === (_b = null === (_a = this._title) || void 0 === _a ? void 0 : _a.AABBBounds) || void 0 === _b ? void 0 : _b.height) || void 0 === _c ? void 0 : _c.call(_b)) && void 0 !== _d ? _d : 0, titleSpace = null !== (_f = null === (_e = this.attribute.title) || void 0 === _e ? void 0 : _e.space) && void 0 !== _f ? _f : 0;
    array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2;
      const contentText = this._content[index];
      contentText.setAttribute("y", titleHeight + titleSpace + lastContentHeight);
      const contentSpace = null !== (_a2 = contentSpec.space) && void 0 !== _a2 ? _a2 : 0;
      lastContentHeight += contentText.AABBBounds.height() + contentSpace;
    });
  }
};

// node_modules/@visactor/vrender-components/es/link-path/register.js
function loadLinkPathComponent() {
  registerGroup(), registerPath();
}

// node_modules/@visactor/vrender-components/es/link-path/link-path.js
var getHorizontalPath = (options, ratio) => {
  let x05 = options.x0, x14 = options.x1;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let y004 = options.y0 - options.thickness / 2, y10 = options.y1 - options.thickness / 2;
  "center" === options.align ? (y004 = options.y0 - thickness / 2, y10 = options.y1 - thickness / 2) : "end" === options.align && (y004 = options.y0 + options.thickness / 2 - thickness, y10 = options.y1 + options.thickness / 2 - thickness);
  let midX = (x05 + x14) / 2, y01 = y004 + thickness, y112 = y10 + thickness;
  options.round && (x05 = Math.round(x05), x14 = Math.round(x14), y004 = Math.round(y004), y10 = Math.round(y10), y01 = Math.round(y01), y112 = Math.round(y112), midX = Math.round(midX));
  const hasLength = Math.abs(x14 - x05) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x14},${y10 - thickness / 2}L${x14 + thickness},${(y10 + y112) / 2}L${x14},${y112 + thickness / 2}` : "", startArrowPath = options.startArrow && hasLength ? `L${x05},${y01 + thickness / 2}L${x05 - thickness},${(y004 + y01) / 2}L${x05},${y004 - thickness / 2}` : "";
  return false === options.isSmooth ? `M${x05},${y004}L${x14},${y10}${endArrowPath}L${x14},${y112}L${x05},${y01}${startArrowPath}Z` : `M${x05},${y004}
  C${midX},${y004},${midX},${y10},${x14},${y10}
  ${endArrowPath}
  L${x14},${y112}
  C${midX},${y112},${midX},${y01},${x05},${y01}
  ${startArrowPath}
  Z`;
};
var getVerticalPath = (options, ratio) => {
  let y05 = options.y0, y14 = options.y1, x004 = options.x0 - options.thickness / 2, x10 = options.x1 - options.thickness / 2;
  const thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  "center" === options.align ? (x004 = options.x0 - thickness / 2, x10 = options.x1 - thickness / 2) : "end" === options.align && (x004 = options.x0 + options.thickness / 2 - thickness, x10 = options.x1 + options.thickness / 2 - thickness);
  let midY = (y05 + y14) / 2, x01 = x004 + thickness, x112 = x10 + thickness;
  options.round && (y05 = Math.round(y05), y14 = Math.round(y14), x004 = Math.round(x004), x10 = Math.round(x10), x01 = Math.round(x01), x112 = Math.round(x112), midY = Math.round(midY));
  const hasLength = Math.abs(y14 - y05) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x10 - thickness / 2},${y14}L${(x10 + x112) / 2},${y14 + thickness}L${x112 + thickness / 2},${y14}` : "", startArrowPath = options.startArrow && hasLength ? `L${x01 + thickness / 2},${y05}L${(x01 + x004) / 2},${y05 - thickness}L${x004 - thickness / 2},${y05}` : "";
  return false === options.isSmooth ? `M${x004},${y05}L${x10},${y14}${endArrowPath}L${x112},${y14}L${x01},${y05}${startArrowPath}Z` : `M${x004},${y05}
  C${x004},${midY},${x10},${midY},${x10},${y14}
  ${endArrowPath}
  L${x112},${y14}
  C${x112},${midY},${x01},${midY},${x01},${y05}
  ${startArrowPath}
  Z`;
};
loadLinkPathComponent();
var LinkPath = class _LinkPath extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LinkPath.defaultAttributes, attributes));
  }
  render() {
    const { direction: direction2 = "horizontal" } = this.attribute, parsePath = "vertical" === direction2 ? getVerticalPath : getHorizontalPath, isRatioShow = "number" == typeof this.attribute.ratio && this.attribute.ratio >= 0 && this.attribute.ratio <= 1, groupAttrKeys = ["direction", "x0", "x1", "y0", "y1", "thickness", "round", "ratio", "align", "isSmooth", "backgroudStyle"], commonStyle = {};
    if (Object.keys(this.attribute).forEach((key) => {
      groupAttrKeys.includes(key) || (commonStyle[key] = this.attribute[key]);
    }), isRatioShow) {
      const background = this.createOrUpdateChild("sankey-link-background", Object.assign({}, commonStyle, this.attribute.backgroudStyle, {
        path: parsePath(this.attribute, 1),
        visible: true,
        pickable: false,
        zIndex: -1
      }), "path");
      this._backPath = background;
    } else this._backPath && this._backPath.setAttribute("visible", false);
    const front = this.createOrUpdateChild("sankey-link-front", Object.assign({}, commonStyle, {
      path: parsePath(this.attribute, isRatioShow ? this.attribute.ratio : 1),
      pickable: false
    }), "path");
    this._frontPath = front;
  }
};
LinkPath.defaultAttributes = {
  direction: "horizontal",
  align: "start"
};

// node_modules/@visactor/vrender-components/es/player/controller/assets/index.js
var iconPlay = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z";
var iconPause = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z";
var iconLeft = "M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z";
var iconDown = "M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z";
var iconUp = "m 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z";
var iconRight = "M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z";

// node_modules/@visactor/vrender-components/es/player/controller/icon/icon.js
var PlayerIcon = class extends Symbol2 {
  constructor(params2) {
    super(params2);
  }
};

// node_modules/@visactor/vrender-components/es/player/controller/constant.js
var ControllerEventEnum;
!function(ControllerEventEnum2) {
  ControllerEventEnum2.OnPlay = "onPlay", ControllerEventEnum2.OnPause = "onPause", ControllerEventEnum2.OnForward = "onForward", ControllerEventEnum2.OnBackward = "onBackward";
}(ControllerEventEnum || (ControllerEventEnum = {}));
var ControllerTypeEnum;
!function(ControllerTypeEnum2) {
  ControllerTypeEnum2.Start = "start", ControllerTypeEnum2.Pause = "pause", ControllerTypeEnum2.Forward = "forward", ControllerTypeEnum2.Backward = "backward";
}(ControllerTypeEnum || (ControllerTypeEnum = {}));

// node_modules/@visactor/vrender-components/es/player/controller/controller.js
var Controller = class _Controller extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Controller.defaultAttributes, attributes)), this._isPaused = true, this.updateAttributes = () => {
      this._startAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPlay
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.start.visible
        }), this.attribute.start.style)
      }, this._pauseAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPause
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.pause.visible
        }), this.attribute.pause.style)
      }, this._forwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.forward.visible
        }), this.attribute.forward.style)
      }, this._backwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.backward.visible
        }), this.attribute.backward.style)
      }, this.updateLayout();
    }, this.updateLayout = () => {
      var _a, _b, _c, _d;
      this._layout = this.attribute.layout, "horizontal" === this._layout ? (this._backwardAttr.style.symbolType = null !== (_a = this._backwardAttr.style.symbolType) && void 0 !== _a ? _a : iconLeft, this._forwardAttr.style.symbolType = null !== (_b = this._forwardAttr.style.symbolType) && void 0 !== _b ? _b : iconRight) : "vertical" === this._layout && (this._backwardAttr.style.symbolType = null !== (_c = this._backwardAttr.style.symbolType) && void 0 !== _c ? _c : iconUp, this._forwardAttr.style.symbolType = null !== (_d = this._forwardAttr.style.symbolType) && void 0 !== _d ? _d : iconDown);
    }, this._initPlay = () => {
      isNil_default(this._playController) && (this._playController = new PlayerIcon(Object.assign({}, this._startAttr.style)), this.add(this._playController));
    }, this._initBackward = () => {
      isNil_default(this._backwardController) && (this._backwardController = new PlayerIcon(Object.assign({}, this._backwardAttr.style)), this.add(this._backwardController));
    }, this._initForward = () => {
      isNil_default(this._forwardController) && (this._forwardController = new PlayerIcon(Object.assign({}, this._forwardAttr.style)), this.add(this._forwardController));
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._playController.addEventListener("pointerdown", (e3) => {
        e3.stopPropagation(), true === this._isPaused ? this.play() : this.pause();
      }), this._backwardController.addEventListener("pointerdown", (e3) => {
        e3.stopPropagation(), this.backward();
      }), this._forwardController.addEventListener("pointerdown", (e3) => {
        e3.stopPropagation(), this.forward();
      }));
    }, this.renderPlay = () => {
      this._isPaused ? this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._startAttr.style)) : this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._pauseAttr.style));
    }, this.renderBackward = () => {
      this._backwardController.setAttributes(this._backwardAttr.style);
    }, this.renderForward = () => {
      this._forwardController.setAttributes(this._forwardAttr.style);
    }, this.play = () => {
      this._dispatchEvent("ControllerEventEnum.OnPlay");
    }, this.pause = () => {
      this._dispatchEvent("ControllerEventEnum.OnPause");
    }, this.forward = () => {
      this._dispatchEvent("ControllerEventEnum.OnForward");
    }, this.backward = () => {
      this._dispatchEvent("ControllerEventEnum.OnBackward");
    }, this.togglePlay = () => {
      this._playController.setAttributes(this._startAttr.style), this._isPaused = true;
    }, this.togglePause = () => {
      this._playController.setAttributes(this._pauseAttr.style), this._isPaused = false;
    }, this.updateAttributes(), this._initPlay(), this._initBackward(), this._initForward(), this._initEvents();
  }
  render() {
    this.updateAttributes(), this.renderPlay(), this.renderBackward(), this.renderForward();
  }
};
Controller.defaultControllerAttr = {
  visible: true,
  x: 0,
  y: 0,
  size: 20,
  fill: "#91caff",
  pickMode: "imprecise",
  cursor: "pointer"
}, Controller.defaultAttributes = {
  [ControllerTypeEnum.Start]: {},
  [ControllerTypeEnum.Pause]: {},
  [ControllerTypeEnum.Backward]: {},
  [ControllerTypeEnum.Forward]: {}
};

// node_modules/@visactor/vrender-components/es/player/constant.js
var defaultControllerAttributes = {
  visible: true,
  style: {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    size: 20
  },
  order: 0,
  space: 10
};
var RailDefaultSize = [200, 10];

// node_modules/@visactor/vrender-components/es/player/type/direction.js
var DirectionEnum;
!function(DirectionEnum2) {
  DirectionEnum2.Default = "default", DirectionEnum2.Reverse = "reverse";
}(DirectionEnum || (DirectionEnum = {}));

// node_modules/@visactor/vrender-components/es/player/type/event.js
var PlayerEventEnum;
!function(PlayerEventEnum2) {
  PlayerEventEnum2.change = "change", PlayerEventEnum2.play = "play", PlayerEventEnum2.pause = "pause", PlayerEventEnum2.backward = "backward", PlayerEventEnum2.forward = "forward", PlayerEventEnum2.end = "end", PlayerEventEnum2.OnChange = "change", PlayerEventEnum2.OnPlay = "play", PlayerEventEnum2.OnPause = "pause", PlayerEventEnum2.OnBackward = "backward", PlayerEventEnum2.OnForward = "forward", PlayerEventEnum2.OnEnd = "end";
}(PlayerEventEnum || (PlayerEventEnum = {}));

// node_modules/@visactor/vrender-components/es/player/utils.js
var isReachEndByDefault = ({ direction: direction2, maxIndex, dataIndex }) => direction2 === DirectionEnum.Default && dataIndex === maxIndex;
var isReachEndByReverse = ({ direction: direction2, minIndex, dataIndex }) => direction2 === DirectionEnum.Reverse && dataIndex === minIndex;
var isReachEnd = ({ direction: direction2, maxIndex, minIndex, dataIndex }) => isReachEndByDefault({
  direction: direction2,
  maxIndex,
  dataIndex
}) || isReachEndByReverse({
  direction: direction2,
  minIndex,
  dataIndex
});
var isReachStartByDefault = ({ direction: direction2, minIndex, dataIndex }) => direction2 === DirectionEnum.Default && dataIndex === minIndex;
var isReachStartByReverse = ({ direction: direction2, maxIndex, dataIndex }) => direction2 === DirectionEnum.Reverse && dataIndex === maxIndex;
var isReachStart = ({ direction: direction2, maxIndex, minIndex, dataIndex }) => isReachStartByDefault({
  direction: direction2,
  minIndex,
  dataIndex
}) || isReachStartByReverse({
  direction: direction2,
  maxIndex,
  dataIndex
});
var isHorizontal2 = (orient) => "top" === orient || "bottom" === orient;
var forwardStep = (direction2, currentIndex, min4, max4) => "default" === direction2 ? Math.min(currentIndex + 1, max4) : Math.max(currentIndex - 1, min4);

// node_modules/@visactor/vrender-components/es/player/base-player.js
var BasePlayer = class _BasePlayer extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _BasePlayer.defaultAttributes, attributes)), this._data = [], this._layoutInfo = {}, this._updateSliderAttrs = () => {
      var _a, _b, _c;
      let handlerSize;
      isValidNumber_default(this._handlerStyle.size) ? handlerSize = this._handlerStyle.size : this._handlerStyle.size && this._handlerStyle.size.length && (handlerSize = max(this._handlerStyle.size[0], this._handlerStyle.size[1]));
      const attrs = {
        visible: this._sliderVisible,
        min: this._minIndex,
        max: this._maxIndex,
        value: null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0,
        railWidth: this._railStyle.width,
        railHeight: this._railStyle.height,
        railStyle: this._railStyle,
        trackStyle: this._trackStyle,
        handlerSize: isValidNumber_default(handlerSize) ? handlerSize : void 0,
        handlerStyle: this._handlerStyle,
        dy: this.attribute.slider.dy,
        dx: this.attribute.slider.dx,
        slidable: true,
        range: false,
        handlerText: {
          visible: false
        },
        startText: {
          visible: false
        },
        endText: {
          visible: false
        },
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      if (isHorizontal2(this._orient)) {
        const railWidth = Math.max(0, this._layoutInfo.slider.size), railHeight = null !== (_b = this._railStyle.height) && void 0 !== _b ? _b : RailDefaultSize[1];
        attrs.layout = "horizontal", attrs.railHeight = railHeight, attrs.railWidth = railWidth, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      } else {
        const railHeight = Math.max(0, this._layoutInfo.slider.size), railWidth = null !== (_c = this._railStyle.width) && void 0 !== _c ? _c : RailDefaultSize[1];
        attrs.layout = "vertical", attrs.railWidth = railWidth, attrs.railHeight = railHeight, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      }
      return attrs;
    }, this._initSlider = () => {
      const attrs = this._updateSliderAttrs();
      this._slider = new Slider(attrs), this._sliderVisible && this.add(this._slider);
    }, this._updateControllerAttrs = () => {
      const attrs = {
        start: this._start,
        pause: this._pause,
        forward: this._forward,
        backward: this._backward,
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      return isHorizontal2(this._orient) ? (attrs.layout = "horizontal", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      })) : (attrs.layout = "vertical", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      })), attrs;
    }, this._initController = () => {
      const attrs = this._updateControllerAttrs();
      this._controller = new Controller(attrs), this._controllerVisible && this.add(this._controller);
    }, this._initAttributes(), this._initLayoutInfo(), this._initController(), this._initSlider();
  }
  _initAttributes() {
    this._size = this.attribute.size, this._orient = this.attribute.orient, this._data = this.attribute.data, this._minIndex = 0, this._maxIndex = this._data.length - 1;
    const { slider: slider2 = {}, controller = {} } = this.attribute;
    this._sliderVisible = slider2.visible, this._railStyle = Object.assign({}, slider2.railStyle), this._trackStyle = Object.assign({}, slider2.trackStyle), this._handlerStyle = Object.assign({}, slider2.handlerStyle), this._controllerVisible = controller.visible, this._start = Object.assign({}, controller.start), this._pause = Object.assign({}, controller.pause), this._forward = Object.assign({}, controller.forward), this._backward = Object.assign({}, controller.backward);
  }
  _initLayoutInfo() {
    var _a, _b, _c;
    const controllers = [this._start, this._backward, this._forward].sort((a4, b2) => a4.order - b2.order), startControllers = controllers.filter((d2) => "end" !== d2.position), endControllers = controllers.filter((d2) => "end" === d2.position), railSectionLength = null !== (_a = isHorizontal2(this._orient) ? this._railStyle.height : this._railStyle.width) && void 0 !== _a ? _a : RailDefaultSize[1], controllerPx = controllers.reduce((len, controller) => {
      const size = controller.style.size, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return len + controller.space + maxSize;
    }, 0), sliderPx = this._sliderVisible ? (isHorizontal2(this._orient) ? null === (_b = this._size) || void 0 === _b ? void 0 : _b.width : null === (_c = this._size) || void 0 === _c ? void 0 : _c.height) - controllerPx : 0, railPx = sliderPx - this.attribute.slider.space, startPx = startControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal2(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal2(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, 0);
    this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), {
      size: railPx,
      x: isHorizontal2(this._orient) ? startPx + this.attribute.slider.space : (this._size.width - railSectionLength) / 2,
      y: isHorizontal2(this._orient) ? (this._size.height - railSectionLength) / 2 : startPx + this.attribute.slider.space
    }), endControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal2(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal2(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, startPx + sliderPx);
  }
  render() {
    this._initLayoutInfo(), this.renderSlider(), this.renderController();
  }
  renderSlider() {
    const attrs = this._updateSliderAttrs();
    this._slider.setAttributes(attrs);
  }
  renderController() {
    const attrs = this._updateControllerAttrs();
    this._controller.setAttributes(attrs);
  }
  dispatchCustomEvent(eventType, dataIndex) {
    this._dispatchEvent(eventType, {
      eventType,
      index: dataIndex,
      value: this._data[dataIndex]
    });
  }
};
BasePlayer.defaultAttributes = {
  visible: true,
  data: [],
  interval: 1e3,
  orient: "bottom",
  align: "center",
  size: {
    height: 20,
    width: 300
  },
  slider: {
    visible: true,
    space: 10,
    dx: 0,
    dy: 0,
    railStyle: {
      cornerRadius: 5
    },
    trackStyle: {},
    handlerStyle: {}
  },
  controller: {
    visible: true,
    start: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "start",
      position: "start",
      space: 0
    }),
    pause: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "pause",
      position: "start"
    }),
    forward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "forward",
      position: "end"
    }),
    backward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "backward",
      position: "start"
    })
  }
};

// node_modules/@visactor/vrender-components/es/player/register.js
function loadBasePlayer() {
  loadSliderComponent(), registerGroup(), registerSymbol();
}
function loadDiscretePlayerComponent() {
  loadBasePlayer();
}
function loadContinuousPlayerComponent() {
  loadBasePlayer();
}

// node_modules/@visactor/vrender-components/es/player/discrete-player.js
loadDiscretePlayerComponent();
var DiscretePlayer = class extends BasePlayer {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, attributes)), this._activeIndex = -1, this._isReachEnd = false, this._initAttributes = () => {
      var _a, _b, _c, _d;
      super._initAttributes(), this._alternate = null !== (_a = this.attribute.alternate) && void 0 !== _a && _a, this._interval = null !== (_b = this.attribute.interval) && void 0 !== _b ? _b : 1e3, this._direction = null !== (_c = this.attribute.direction) && void 0 !== _c ? _c : DirectionEnum.Default, this._dataIndex = isNil_default(this.attribute.dataIndex) ? "default" === this._direction ? this._minIndex : this._maxIndex : null !== (_d = this.attribute.dataIndex) && void 0 !== _d ? _d : 0, this._slider.setAttribute("value", this._dataIndex);
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e3) => {
        e3.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e3) => {
        e3.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e3) => {
        e3.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e3) => {
        e3.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e3) => {
        const middle = Math.floor(e3.detail.value) + 0.5;
        this._dataIndex = e3.detail.value >= middle ? Math.ceil(e3.detail.value) : Math.floor(e3.detail.value), this._slider.setValue(this._dataIndex), this.dispatchCustomEvent(PlayerEventEnum.change);
      }));
    }, this.play = () => {
      this._isPlaying || 1 !== this._data.length && (this._controller.togglePause(), this._isPlaying = true, (isReachEnd({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      }) || isReachStart({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      })) && (this._direction === DirectionEnum.Default ? this._updateDataIndex(this._minIndex) : this._updateDataIndex(this._maxIndex)), this.dispatchCustomEvent(PlayerEventEnum.play), this._isReachEnd = false, this._tickTime = Date.now(), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, true)));
    }, this._play = (isFirstPlay) => {
      const now = Date.now();
      if (this._isReachEnd && now - this._tickTime >= this._interval) return this._isReachEnd = false, void this._playEnd();
      isFirstPlay && this._activeIndex !== this._dataIndex ? (this.dispatchCustomEvent(PlayerEventEnum.change), this._activeIndex = this._dataIndex) : now - this._tickTime >= this._interval && (this._tickTime = now, this._updateDataIndex(forwardStep(this._direction, this._dataIndex, this._minIndex, this._maxIndex)), this._activeIndex = this._dataIndex, this.dispatchCustomEvent(PlayerEventEnum.change)), ("default" === this._direction && this._dataIndex >= this._maxIndex || "reverse" === this._direction && this._dataIndex <= this._minIndex) && (this._isReachEnd = true), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, false));
    }, this._updateDataIndex = (dataIndex) => {
      this._dataIndex = dataIndex, this._slider.setValue(this._dataIndex);
    }, this._playEnd = () => {
      this._isPlaying = false, this._controller.togglePlay(), vglobal.getCancelAnimationFrame()(this._rafId), this._activeIndex = -1, this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const index = Math.max(this._dataIndex - 1, this._minIndex);
      this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const index = Math.min(this._dataIndex + 1, this._maxIndex);
      this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initEvents();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this._initAttributes();
  }
  dispatchCustomEvent(event) {
    super.dispatchCustomEvent(event, this._dataIndex);
  }
};

// node_modules/@visactor/vrender-components/es/player/continuous-player.js
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
loadContinuousPlayerComponent();
var ContinuousPlayer = class extends BasePlayer {
  constructor(attributes) {
    super(attributes), this._isPlaying = false, this._startTime = Date.now(), this._initAttributes = () => {
      var _a, _b;
      super._initAttributes(), this._maxIndex = this._data.length, this._slider.setAttribute("max", this._maxIndex), this._isPlaying = false, this._elapsed = 0, this._interval = null !== (_a = this.attribute.interval) && void 0 !== _a ? _a : 1e3, this._dataIndex = null !== (_b = this.attribute.dataIndex) && void 0 !== _b ? _b : this._minIndex;
      const frames = this._data.length;
      this.attribute.totalDuration && this._data.length ? (this._totalDuration = this.attribute.totalDuration, this._interval = this._totalDuration / (null != frames ? frames : 1)) : (this._totalDuration = this._interval * frames, this._interval = this.attribute.interval);
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e3) => {
        e3.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e3) => {
        e3.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e3) => {
        e3.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e3) => {
        e3.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e3) => {
        var _a;
        e3.stopPropagation();
        const value = null === (_a = e3.detail) || void 0 === _a ? void 0 : _a.value, progress = value / this._maxIndex;
        this._elapsed = progress * this._totalDuration, this._startTime = Date.now() - this._elapsed, this._dispatchChange(value);
      }));
    }, this._getSliderValue = () => {
      const progress = this._elapsed / this._totalDuration;
      return Math.min(progress * this._maxIndex, this._maxIndex);
    }, this._updateSlider = () => {
      const value = this._getSliderValue();
      this._dataIndex = Math.floor(value), this._slider.setValue(Math.min(value, this._maxIndex)), this._dispatchChange(Math.floor(value));
    }, this._dispatchChange = (value) => {
      const index = Math.floor(value);
      index !== this._activeIndex && (this._dataIndex = index, this._activeIndex = index, index !== this._maxIndex && this.dispatchCustomEvent(PlayerEventEnum.change));
    }, this.play = () => __awaiter6(this, void 0, void 0, function* () {
      this._isPlaying || (this._controller.togglePause(), this._isPlaying = true, this._elapsed >= this._totalDuration && (this._elapsed = 0), this._startTime = Date.now() - this._elapsed, this.dispatchCustomEvent(PlayerEventEnum.play), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this)));
    }), this._play = () => {
      this._elapsed = Date.now() - this._startTime;
      const value = this._getSliderValue();
      this._updateSlider(), value >= this._maxIndex ? this._playEnd() : this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this));
    }, this._playEnd = () => {
      this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, this._elapsed = Date.now() - this._startTime, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed - interval;
      elapsed <= 0 ? (this._elapsed = 0, this._startTime = now) : (this._elapsed = elapsed, this._startTime = this._startTime + this._interval), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed + interval;
      elapsed >= this._totalDuration ? (this._startTime = now - this._totalDuration, this._elapsed = this._totalDuration) : (this._startTime = this._startTime - interval, this._elapsed = elapsed), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initEvents();
  }
  dispatchCustomEvent(eventType) {
    super.dispatchCustomEvent(eventType, this._dataIndex);
  }
  render() {
    super.render();
  }
};

// node_modules/@visactor/vrender-components/es/brush/type.js
var IOperateType;
!function(IOperateType2) {
  IOperateType2.drawStart = "drawStart", IOperateType2.drawEnd = "drawEnd", IOperateType2.drawing = "drawing", IOperateType2.moving = "moving", IOperateType2.moveStart = "moveStart", IOperateType2.moveEnd = "moveEnd", IOperateType2.brushClear = "brushClear";
}(IOperateType || (IOperateType = {}));

// node_modules/@visactor/vrender-components/es/brush/config.js
var DEFAULT_BRUSH_ATTRIBUTES = {
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: "pointerup",
  resetTrigger: "pointerupoutside",
  hasMask: true,
  brushMode: "single",
  brushType: "rect",
  brushStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    strokeWidth: 2
  },
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 10,
  interactiveRange: {
    y1: -1 / 0,
    y2: 1 / 0,
    x1: -1 / 0,
    x2: 1 / 0
  }
};
var DEFAULT_SIZE_THRESHOLD = 5;

// node_modules/@visactor/vrender-components/es/brush/register.js
function loadBrushComponent() {
  registerGroup(), registerPolygon();
}

// node_modules/@visactor/vrender-components/es/brush/brush.js
var delayMap3 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadBrushComponent();
var Brush = class _Brush extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Brush.defaultAttributes, attributes)), this.name = "brush", this._activeDrawState = false, this._cacheDrawPoints = [], this._isDrawedBeforeEnd = false, this._activeMoveState = false, this._operatingMaskMoveDx = 0, this._operatingMaskMoveDy = 0, this._operatingMaskMoveRangeX = [-1 / 0, 1 / 0], this._operatingMaskMoveRangeY = [-1 / 0, 1 / 0], this._brushMaskAABBBoundsDict = {}, this._onBrushStart = (e3) => {
      var _a;
      if (this._outOfInteractiveRange(e3)) return;
      e3.stopPropagation();
      const brushMoved = null === (_a = this.attribute.brushMoved) || void 0 === _a || _a;
      this._activeMoveState = brushMoved && this._isPosInBrushMask(e3), this._activeDrawState = !this._activeMoveState, this._activeDrawState && this._initDraw(e3), this._activeMoveState && this._initMove(e3);
    }, this._onBrushing = (e3) => {
      this._outOfInteractiveRange(e3) || ((this._activeDrawState || this._activeMoveState) && e3.stopPropagation(), this._activeDrawState && this._drawing(e3), this._activeMoveState && this._moving(e3));
    }, this._onBrushEnd = (e3) => {
      e3.preventDefault();
      const { removeOnClick = true } = this.attribute;
      this._activeDrawState && !this._isDrawedBeforeEnd && removeOnClick ? (this._container.incrementalClearChild(), this._brushMaskAABBBoundsDict = {}, this._dispatchEvent(IOperateType.brushClear, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e3
      })) : (this._activeDrawState && this._dispatchEvent(IOperateType.drawEnd, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e3
      }), this._activeMoveState && this._dispatchEvent(IOperateType.moveEnd, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e3
      })), this._activeDrawState = false, this._activeMoveState = false, this._isDrawedBeforeEnd = false, this._operatingMask && this._operatingMask.setAttribute("pickable", false);
    };
  }
  _bindBrushEvents() {
    if (this.attribute.disableTriggerEvent) return;
    const { delayType = "throttle", delayTime = 0, trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    this.stage.addEventListener(trigger, this._onBrushStart), this.stage.addEventListener(updateTrigger, delayMap3[delayType](this._onBrushing, delayTime)), this.stage.addEventListener(endTrigger, this._onBrushEnd), this.stage.addEventListener(resetTrigger, this._onBrushEnd);
  }
  _isPosInBrushMask(e3) {
    const pos = this.eventPosToStagePos(e3), brushMasks = this._container.getChildren();
    for (let i2 = 0; i2 < brushMasks.length; i2++) {
      const { points = [], dx = 0, dy = 0 } = brushMasks[i2].attribute, pointsConsiderOffset = points.map((point6) => ({
        x: point6.x + dx,
        y: point6.y + dy
      }));
      if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y)) return this._operatingMask = brushMasks[i2], true;
    }
    return false;
  }
  _initDraw(e3) {
    const { brushMode } = this.attribute, pos = this.eventPosToStagePos(e3);
    this._cacheDrawPoints = [pos], this._isDrawedBeforeEnd = false, "single" === brushMode && (this._brushMaskAABBBoundsDict = {}, this._container.incrementalClearChild()), this._addBrushMask(), this._dispatchEvent(IOperateType.drawStart, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e3
    });
  }
  _initMove(e3) {
    var _a, _b;
    this._cacheMovePoint = this.eventPosToStagePos(e3), this._operatingMaskMoveDx = null !== (_a = this._operatingMask.attribute.dx) && void 0 !== _a ? _a : 0, this._operatingMaskMoveDy = null !== (_b = this._operatingMask.attribute.dy) && void 0 !== _b ? _b : 0;
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY: maxY2 = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, { x1: x14, x2: x23, y1: y14, y2: y23 } = this._operatingMask.globalAABBBounds, minMoveStepX = minX - x14, maxMoveStepX = maxX - x23, minMoveStepY = minY - y14, maxMoveStepY = maxY2 - y23;
    this._operatingMaskMoveRangeX = [minMoveStepX, maxMoveStepX], this._operatingMaskMoveRangeY = [minMoveStepY, maxMoveStepY], this._operatingMask.setAttribute("pickable", true), this._dispatchEvent(IOperateType.moveStart, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e3
    });
  }
  _drawing(e3) {
    var _a, _b;
    const pos = this.eventPosToStagePos(e3), { x1: x14 = 0, x2: x23 = 0, y1: y14 = 0, y2: y23 = 0 } = null === (_a = this._operatingMask) || void 0 === _a ? void 0 : _a._AABBBounds, { sizeThreshold = DEFAULT_SIZE_THRESHOLD, brushType } = this.attribute, cacheLength = this._cacheDrawPoints.length;
    if (this._isDrawedBeforeEnd = !!(Math.abs(x23 - x14) > sizeThreshold || Math.abs(y14 - y23) > sizeThreshold), cacheLength > 0) {
      const lastPos = null !== (_b = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) && void 0 !== _b ? _b : {};
      if (pos.x === lastPos.x && pos.y === lastPos.y) return;
    }
    "polygon" === brushType || cacheLength <= 1 ? this._cacheDrawPoints.push(pos) : this._cacheDrawPoints[cacheLength - 1] = pos;
    const maskPoints = this._computeMaskPoints();
    this._operatingMask.setAttribute("points", maskPoints), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchEvent(IOperateType.drawing, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e3
    });
  }
  _moving(e3) {
    const startPos = this._cacheMovePoint, pos = this.eventPosToStagePos(e3);
    if (pos.x === (null == startPos ? void 0 : startPos.x) && pos.y === (null == startPos ? void 0 : startPos.y)) return;
    const moveStepX = pos.x - startPos.x, moveStepY = pos.y - startPos.y, moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) + this._operatingMaskMoveDx, moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) + this._operatingMaskMoveDy;
    this._operatingMask.setAttributes({
      dx: moveX,
      dy: moveY
    }), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchEvent(IOperateType.moving, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e3
    });
  }
  _computeMaskPoints() {
    const { brushType, xRange = [0, 0], yRange = [0, 0] } = this.attribute;
    let maskPoints = [];
    const startPoint = this._cacheDrawPoints[0], endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
    return maskPoints = "rect" === brushType ? [startPoint, {
      x: endPoint.x,
      y: startPoint.y
    }, endPoint, {
      x: startPoint.x,
      y: endPoint.y
    }] : "x" === brushType ? [{
      x: startPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[1]
    }, {
      x: startPoint.x,
      y: yRange[1]
    }] : "y" === brushType ? [{
      x: xRange[0],
      y: startPoint.y
    }, {
      x: xRange[0],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: startPoint.y
    }] : cloneDeep(this._cacheDrawPoints), maskPoints;
  }
  _addBrushMask() {
    var _a;
    const { brushStyle, hasMask } = this.attribute, brushMask = graphicCreator.polygon(Object.assign(Object.assign({
      points: cloneDeep(this._cacheDrawPoints),
      cursor: "move",
      pickable: false
    }, brushStyle), {
      opacity: hasMask ? null !== (_a = brushStyle.opacity) && void 0 !== _a ? _a : 1 : 0
    }));
    brushMask.name = `brush-${Date.now()}`, this._operatingMask = brushMask, this._container.add(brushMask), this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
  }
  _outOfInteractiveRange(e3) {
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY: maxY2 = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, pos = this.eventPosToStagePos(e3);
    return pos.x > maxX || pos.x < minX || pos.y > maxY2 || pos.y < minY;
  }
  eventPosToStagePos(e3) {
    var _a, _b;
    const { x: x3, y: y3 } = vglobal.mapToCanvasPoint(e3);
    return {
      x: x3 - ((null === (_a = this.stage) || void 0 === _a ? void 0 : _a.x) || 0),
      y: y3 - ((null === (_b = this.stage) || void 0 === _b ? void 0 : _b.y) || 0)
    };
  }
  render() {
    this._bindBrushEvents();
    const group = this.createOrUpdateChild("brush-container", {}, "group");
    this._container = group;
  }
  releaseBrushEvents() {
    const { delayType = "throttle", delayTime = 0, trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    this.stage.removeEventListener(trigger, this._onBrushStart), this.stage.removeEventListener(updateTrigger, delayMap3[delayType](this._onBrushing, delayTime)), this.stage.removeEventListener(endTrigger, this._onBrushEnd), this.stage.removeEventListener(resetTrigger, this._onBrushEnd);
  }
};
Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;

// node_modules/@visactor/vrender-components/es/tooltip/util.js
var mergeRowAttrs = (target, ...sources) => {
  const shapeList = [target.shape, ...sources.map((s3) => null == s3 ? void 0 : s3.shape)], keyList = [target.key, ...sources.map((s3) => null == s3 ? void 0 : s3.key)], valueList = [target.value, ...sources.map((s3) => null == s3 ? void 0 : s3.value)];
  return merge(target, ...sources, {
    shape: shapeList.every(isNil_default) ? void 0 : merge({}, ...shapeList),
    key: keyList.every(isNil_default) ? void 0 : merge({}, ...keyList),
    value: valueList.every(isNil_default) ? void 0 : merge({}, ...valueList)
  });
};
var getRichTextAttribute = (attr) => {
  const { width, height, wordBreak = "break-word", textAlign, textBaseline, text: text2 } = attr;
  return Array.isArray(text2) ? {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: array(text2).map((text3) => Object.assign(Object.assign({}, attr), {
      text: text3
    }))
  } : {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: text2.text
  };
};

// node_modules/@visactor/vrender-components/es/tooltip/config.js
var defaultAttributes = {
  panel: {
    visible: true,
    cornerRadius: [3, 3, 3, 3],
    fill: "white",
    shadow: true,
    shadowBlur: 12,
    shadowColor: "rgba(0, 0, 0, 0.1)",
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowSpread: 0,
    stroke: "white"
  },
  titleStyle: {
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 14,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle"
    },
    spaceRow: 6
  },
  contentStyle: {
    shape: {
      fill: "black",
      size: 8,
      symbolType: "circle",
      spacing: 6
    },
    key: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle",
      spacing: 26
    },
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "right",
      textBaseline: "middle",
      spacing: 0
    },
    spaceRow: 6
  },
  padding: 10,
  positionX: "right",
  positionY: "bottom",
  offsetX: 10,
  offsetY: 10,
  parentBounds: new AABBBounds().setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
  autoCalculatePosition: true,
  autoMeasure: true,
  pickable: false,
  childrenPickable: false,
  zIndex: 500
};
var TOOLTIP_POSITION_ATTRIBUTES = ["pointerX", "pointerY", "offsetX", "offsetY", "positionX", "positionY", "parentBounds"];

// node_modules/@visactor/vrender-components/es/tooltip/register.js
function loadTooltipComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerText(), registerRichtext();
}

// node_modules/@visactor/vrender-components/es/tooltip/tooltip.js
loadTooltipComponent();
var Tooltip = class _Tooltip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tooltip.defaultAttributes, attributes), options), this.name = "tooltip";
  }
  render() {
    var _a;
    const { visible, content, panel, keyWidth, valueWidth, hasContentShape, autoCalculatePosition, autoMeasure } = this.attribute;
    if (!visible) return void this.hideAll();
    autoMeasure && _Tooltip.measureTooltip(this.attribute), autoCalculatePosition && _Tooltip.calculateTooltipPosition(this.attribute);
    const padding = normalizePadding(this.attribute.padding);
    this._tooltipPanel = this.createOrUpdateChild("tooltip-background", Object.assign({
      visible: true
    }, panel), "rect"), this._tooltipTitleContainer = this.createOrUpdateChild("tooltip-title", {
      visible: true,
      x: padding[3],
      y: padding[0]
    }, "group");
    const titleAttr = _Tooltip.getTitleAttr(this.attribute);
    this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-shape", merge({
      symbolType: "circle"
    }, titleAttr.shape, {
      visible: isVisible(titleAttr) && isVisible(titleAttr.shape)
    }), "symbol"), "object" != typeof titleAttr.value.text || null === titleAttr.value.text || "rich" !== titleAttr.value.text.type && "html" !== titleAttr.value.text.type ? titleAttr.value.multiLine ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      text: null !== (_a = titleAttr.value.text) && void 0 !== _a ? _a : "",
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, titleAttr.value), "text") : "rich" === titleAttr.value.text.type ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : "html" === titleAttr.value.text.type && (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      html: Object.assign(Object.assign({
        dom: titleAttr.value.text.text
      }, DEFAULT_HTML_TEXT_SPEC), titleAttr.value),
      visible: isVisible(titleAttr) && isVisible(titleAttr.value),
      width: titleAttr.value.width,
      height: titleAttr.value.height,
      wordBreak: titleAttr.value.wordBreak,
      textAlign: titleAttr.value.textAlign,
      textBaseline: titleAttr.value.textBaseline,
      singleLine: false,
      textConfig: []
    }, titleAttr.value), "richtext"));
    const titlePaddingLeft = isVisible(titleAttr.shape) ? titleAttr.shape.size + titleAttr.shape.spacing : 0, { textAlign, textBaseline } = titleAttr.value, contentWidth = panel.width - padding[3] - padding[0] - titlePaddingLeft;
    "center" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth / 2) : "right" === textAlign || "end" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth) : this._tooltipTitle.setAttribute("x", titlePaddingLeft), "bottom" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height) : "middle" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height / 2) : this._tooltipTitle.setAttribute("y", 0);
    const titleHeight = isVisible(titleAttr) ? titleAttr.height + titleAttr.spaceRow : 0;
    if (this._tooltipContent = this.createOrUpdateChild("tooltip-content", {
      visible: true
    }, "group"), this._tooltipContent.removeAllChild(), content && content.length) {
      this._tooltipContent.setAttribute("x", padding[3]), this._tooltipContent.setAttribute("y", padding[0] + titleHeight);
      let lastYPos = 0;
      content.forEach((item, i2) => {
        var _a2, _b, _c;
        const itemAttr = _Tooltip.getContentAttr(this.attribute, i2);
        if (!isVisible(itemAttr)) return;
        const itemGroupName = `tooltip-content-${i2}`, itemGroup = this._tooltipContent.createOrUpdateChild(itemGroupName, {
          visible: true,
          x: 0,
          y: lastYPos
        }, "group");
        let x3 = 0;
        if (isVisible(itemAttr.shape) && itemGroup.createOrUpdateChild(`${itemGroupName}-shape`, Object.assign({
          visible: true,
          x: itemAttr.shape.size / 2,
          y: itemAttr.shape.size / 2 + ((null !== (_a2 = calculateLineHeight(itemAttr.key.lineHeight, itemAttr.key.fontSize)) && void 0 !== _a2 ? _a2 : itemAttr.key.fontSize) - itemAttr.shape.size) / 2
        }, itemAttr.shape), "symbol"), hasContentShape && (x3 += itemAttr.shape.size + itemAttr.shape.spacing), isVisible(itemAttr.key)) {
          let element;
          element = itemAttr.key.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.key)), {
            textBaseline: "top"
          }), "richtext") : "object" != typeof itemAttr.key.text || null === itemAttr.key.text || "rich" !== itemAttr.key.text.type && "html" !== itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
            visible: true,
            text: null !== (_b = itemAttr.key.text) && void 0 !== _b ? _b : ""
          }, itemAttr.key), {
            textBaseline: "top"
          }), "text") : "rich" === itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.key)), {
            textBaseline: "top"
          }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
            html: Object.assign(Object.assign({
              dom: itemAttr.key.text.text
            }, DEFAULT_HTML_TEXT_SPEC), itemAttr.key)
          }, "richtext");
          const { textAlign: textAlign2 } = itemAttr.key;
          "center" === textAlign2 ? element.setAttribute("x", x3 + keyWidth / 2) : "right" === textAlign2 || "end" === textAlign2 ? element.setAttribute("x", x3 + keyWidth) : element.setAttribute("x", x3), element.setAttribute("y", 0), x3 += keyWidth + itemAttr.key.spacing;
        }
        if (isVisible(itemAttr.value)) {
          let element;
          element = itemAttr.value.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.value)), {
            textBaseline: "top"
          }), "richtext") : "object" != typeof itemAttr.value.text || null === itemAttr.value.text || "rich" !== itemAttr.value.text.type && "html" !== itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true,
            text: null !== (_c = itemAttr.value.text) && void 0 !== _c ? _c : ""
          }, itemAttr.value), {
            textBaseline: "top"
          }), "text") : "rich" === itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.value)), {
            textBaseline: "top"
          }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
            html: Object.assign({
              dom: itemAttr.value.text.text,
              container: "",
              width: 30,
              height: 30,
              style: {}
            }, itemAttr.value)
          }, "richtext");
          let textAlign2 = "right";
          isValid_default(itemAttr.value.textAlign) ? textAlign2 = itemAttr.value.textAlign : isVisible(itemAttr.key) || (textAlign2 = "left"), element.setAttribute("textAlign", textAlign2), "center" === textAlign2 ? element.setAttribute("x", x3 + valueWidth / 2) : "right" === textAlign2 || "end" === textAlign2 ? element.setAttribute("x", x3 + valueWidth) : element.setAttribute("x", x3), x3 += valueWidth, element.setAttribute("y", 0), itemGroup.add(element);
        }
        lastYPos += itemAttr.height + itemAttr.spaceRow;
      });
    }
  }
  setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this.attribute.autoCalculatePosition && keys2.every((key) => TOOLTIP_POSITION_ATTRIBUTES.includes(key)) ? (this._mergeAttributes(params2, keys2), isNil_default(this.attribute.panel.width) && this.attribute.autoMeasure && _Tooltip.measureTooltip(this.attribute), _Tooltip.calculateTooltipPosition(this.attribute), super.setAttributes({
      x: this.attribute.x,
      y: this.attribute.y
    }, forceUpdateTag)) : super.setAttributes(params2, forceUpdateTag);
  }
  static calculateTooltipPosition(attribute) {
    const { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = attribute.panel, { offsetX, offsetY, pointerX, pointerY, positionX, positionY, parentBounds } = attribute;
    let x3 = pointerX, y3 = pointerY;
    return "left" === positionX ? x3 -= tooltipBoxWidth + offsetX : "center" === positionX ? x3 -= tooltipBoxWidth / 2 : x3 += offsetX, "top" === positionY ? y3 -= tooltipBoxHeight + offsetY : "middle" === positionY ? y3 -= tooltipBoxHeight / 2 : y3 += offsetY, x3 + tooltipBoxWidth > parentBounds.x2 && (x3 -= tooltipBoxWidth + offsetX), y3 + tooltipBoxHeight > parentBounds.y2 && (y3 -= tooltipBoxHeight + offsetY), x3 < parentBounds.x1 && (x3 = parentBounds.x1), y3 < parentBounds.y1 && (y3 = parentBounds.y1), attribute.x = x3, attribute.y = y3, attribute;
  }
  static measureTooltip(attribute) {
    const { content, contentStyle } = attribute, padding = normalizePadding(attribute.padding), titleAttr = _Tooltip.getTitleAttr(attribute);
    let maxWidth = 0, containerHeight = padding[0] + padding[2], titleMaxHeight = 0;
    const { value: titleValue, shape: titleShape } = titleAttr, { visible: titleHasShape = false, symbolType: titleShapeType = "" } = null != titleShape ? titleShape : {};
    if (isValid_default(titleValue) && "object" != typeof titleAttr.value.text) {
      const { width, height } = initTextMeasure2(titleValue).quickMeasure(titleValue.text);
      maxWidth = width, titleMaxHeight = height;
    }
    if (titleHasShape && builtinSymbolsMap[titleShapeType] && (maxWidth += titleShape.size + titleShape.spacing, titleMaxHeight = Math.max(titleShape.size, titleMaxHeight)), attribute.title && (attribute.title.width = maxWidth, attribute.title.height = titleMaxHeight), isVisible(titleAttr) && (containerHeight += titleMaxHeight + titleAttr.spaceRow), content && content.length) {
      const filteredContent = [];
      if (content.forEach((item, i2) => {
        const itemAttr = _Tooltip.getContentAttr(attribute, i2);
        (item.key || item.value) && isVisible(itemAttr) && filteredContent.push([item, itemAttr]);
      }), filteredContent.length) {
        let hasContentShape = false;
        const shapeWidths = [], keyWidths = [], valueWidths = [];
        filteredContent.forEach(([item, itemAttr], i2) => {
          var _a;
          const { key, value, shape, spaceRow } = itemAttr, itemHasShape = isVisible(shape), itemShapeType = null !== (_a = null == shape ? void 0 : shape.symbolType) && void 0 !== _a ? _a : "", keyTextMeasure = initTextMeasure2(key), valueTextMeasure = initTextMeasure2(value);
          let itemHeight = 0;
          if (isVisible(key)) {
            const { width, height } = keyTextMeasure.quickMeasure(key.text);
            keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          if (isVisible(value)) {
            const { width, height } = valueTextMeasure.quickMeasure(value.text);
            valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          itemHasShape && builtinSymbolsMap[itemShapeType] && (hasContentShape = true, shapeWidths.push(shape.size), itemHeight = Math.max(shape.size, itemHeight)), item.height = itemHeight, containerHeight += itemHeight, i2 < filteredContent.length - 1 && (containerHeight += null != spaceRow ? spaceRow : contentStyle.spaceRow);
        });
        const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : 0, maxKeyWidth = keyWidths.length ? Math.max(...keyWidths) : 0, maxValueWidth = valueWidths.length ? Math.max(...valueWidths) : 0;
        maxWidth = Math.max(maxKeyWidth + maxValueWidth + contentStyle.key.spacing + contentStyle.value.spacing + (hasContentShape ? maxShapeWidth + contentStyle.shape.spacing : 0), maxWidth), content.forEach((item) => {
          item.width = maxWidth;
        }), attribute.hasContentShape = hasContentShape, attribute.keyWidth = maxKeyWidth, attribute.valueWidth = maxValueWidth;
      }
    }
    return attribute.panel.width = maxWidth + padding[1] + padding[3], attribute.panel.height = containerHeight, attribute;
  }
  static getTitleAttr(attribute) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.titleStyle, _Tooltip.defaultAttributes.title, attribute.titleStyle, attribute.title);
  }
  static getContentAttr(attribute, index) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.contentStyle, attribute.contentStyle, attribute.content[index]);
  }
};
Tooltip.defaultAttributes = defaultAttributes;

// node_modules/@visactor/vrender-components/es/checkbox/register.js
function loadCheckBoxComponent() {
  registerGroup(), registerRect(), registerWrapText(), registerImage();
}

// node_modules/@visactor/vrender-components/es/checkbox/checkbox.js
var checkSvg = '<svg width="200" height="200" viewBox="0 0 1024 1024" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z"></path></svg>';
var indeterminateSvg = '<svg width="200" height="200" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none"><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="5" d="M5 12h14"/></svg>';
loadCheckBoxComponent();
var CheckBox = class _CheckBox extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CheckBox.defaultAttributes, attributes)), this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes2, key) => {
      "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
    }, this.addEventListener("click", this.handleClick);
  }
  render() {
    this.removeAllChild(), this.renderBox(), this.renderIcon(), this.renderText(), this.layout();
  }
  renderBox() {
    this._box = new Rect(merge({}, this.attribute.box));
    const isCheckedOrIndeterminate = this.attribute.checked || this.attribute.indeterminate;
    isCheckedOrIndeterminate && this.attribute.disabled ? this._box.setAttributes({
      fill: this.attribute.box.disableCheckedFill,
      stroke: this.attribute.box.disableCheckedStroke
    }) : isCheckedOrIndeterminate && this._box.setAttributes({
      fill: this.attribute.box.checkedFill,
      stroke: this.attribute.box.checkedStroke
    }), this.appendChild(this._box);
  }
  renderIcon() {
    this._checkIcon = new Image(merge({
      image: this.attribute.icon.checkIconImage
    }, this.attribute.icon)), this.appendChild(this._checkIcon), this._indeterminateIcon = new Image(merge({
      image: this.attribute.icon.indeterminateIconImage
    }, this.attribute.icon)), this.appendChild(this._indeterminateIcon), this.attribute.checked ? (this._checkIcon.setAttribute("visible", true), this._indeterminateIcon.setAttribute("visible", false)) : this.attribute.indeterminate ? (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", true)) : (this._checkIcon.setAttribute("visible", false), this._indeterminateIcon.setAttribute("visible", false));
  }
  renderText() {
    this._text = new WrapText(merge({}, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
  }
  renderGroup() {
    this.attribute.interactive || this.setAttribute("pickable", false), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
  }
  layout() {
    const boxHeight = this.attribute.box.height, iconHeight = this.attribute.icon.height, textHeight = this._text.AABBBounds.height(), maxHeight = Math.max(boxHeight, iconHeight, textHeight), boxY = maxHeight / 2 - boxHeight / 2, iconY = maxHeight / 2 - iconHeight / 2, textY = maxHeight / 2 - textHeight / 2, boxWidth = this.attribute.box.width, iconWidth = this.attribute.icon.width, maxWidth = Math.max(boxWidth, iconWidth), boxX = maxWidth / 2 - boxWidth / 2, iconX = maxWidth / 2 - iconWidth / 2, textX = maxWidth + this.attribute.spaceBetweenTextAndIcon;
    this._box.setAttributes({
      x: boxX,
      y: boxY
    }), this._checkIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._indeterminateIcon.setAttributes({
      x: iconX,
      y: iconY
    }), this._text.setAttributes({
      x: textX,
      y: textY
    });
  }
  handleClick() {
    this.attribute.disabled || (this.attribute.checked ? (this.setAttribute("checked", false), this.setAttribute("indeterminate", false)) : (this.setAttribute("checked", true), this.setAttribute("indeterminate", false)), this._dispatchEvent("checkbox_state_change", {
      eventType: "checkbox_state_change",
      checked: this.attribute.checked
    }));
  }
};
CheckBox.defaultAttributes = {
  interactive: true,
  disabled: false,
  checked: false,
  indeterminate: false,
  cursor: "pointer",
  disableCursor: "not-allowed",
  spaceBetweenTextAndIcon: 8,
  text: {
    text: "text",
    fontSize: 14,
    fill: "#000",
    disableFill: "rgb(201,205,212)",
    textBaseline: "top",
    pickable: false
  },
  icon: {
    checkIconImage: checkSvg,
    indeterminateIconImage: indeterminateSvg,
    width: 10,
    height: 10,
    pickable: false
  },
  box: {
    width: 14,
    height: 14,
    cornerRadius: 2,
    fill: "#fff",
    stroke: "rgb(229,230,235)",
    disableFill: "rgb(242,243,245)",
    checkedFill: "rgb(22, 93, 255)",
    checkedStroke: "rgb(22, 93, 255)",
    disableCheckedFill: "rgb(148, 191, 255)",
    disableCheckedStroke: "rgb(148, 191, 255)",
    pickable: false
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-active-by-legend.js
var ElementActiveByLegend = class _ElementActiveByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActiveByLegend.type, this.handleStart = (e3, element) => {
      var _a, _b;
      const itemKey = null === (_b = null === (_a = e3.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id;
      if (isNil_default(itemKey)) return;
      const filterValue = generateFilterValue(this.options);
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          filterValue(el) === itemKey ? el.addState(this.options.state) : el.removeState(this.options.state);
        });
      });
    }, this.handleReset = (e3) => {
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.removeState(this.options.state);
        });
      });
    }, this.options = Object.assign({}, _ElementActiveByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
};
ElementActiveByLegend.type = "element-active-by-legend", ElementActiveByLegend.defaultOptions = {
  state: InteractionStateEnum.active,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-legend.js
var ElementHighlightByLegend = class _ElementHighlightByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByLegend.type, this.handleStart = (e3, element) => {
      var _a, _b;
      const itemKey = null === (_b = null === (_a = e3.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id;
      if (isNil_default(itemKey)) return;
      const filterValue = generateFilterValue(this.options);
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          filterValue(el) === itemKey ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
        });
      });
    }, this.handleReset = (e3) => {
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.removeState(this.options.blurState), el.removeState(this.options.highlightState);
        });
      });
    }, this.options = Object.assign({}, _ElementHighlightByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
};
ElementHighlightByLegend.type = "element-highlight-by-legend", ElementHighlightByLegend.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/element-highlight-by-name.js
var ElementHighlightByName = class _ElementHighlightByName extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByName.type, this.handleStart = (e3, element) => {
      if (this.options.shouldStart ? this.options.shouldStart(e3) : this._filterByName(e3)) {
        const itemKey = this._parseTargetKey(e3, element);
        if (isNil_default(itemKey)) return;
        const filterValue = generateFilterValue(this.options);
        this._marks.forEach((mark) => {
          mark.elements.forEach((el) => {
            filterValue(el) === itemKey ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
          });
        });
      }
    }, this.handleReset = (e3) => {
      (this.options.shouldReset ? this.options.shouldReset(e3) : this._filterByName(e3)) && this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.removeState(this.options.blurState), el.removeState(this.options.highlightState);
        });
      });
    }, this.options = Object.assign({}, _ElementHighlightByName.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  _filterByName(e3) {
    var _a;
    const names = array(this.options.graphicName);
    return (null === (_a = null == e3 ? void 0 : e3.target) || void 0 === _a ? void 0 : _a.name) && names.includes(e3.target.name);
  }
  _parseTargetKey(e3, element) {
    return this.options.parseData ? this.options.parseData(e3) : "text" === e3.target.type ? e3.target.attribute.text : null;
  }
};
ElementHighlightByName.type = "element-highlight-by-name", ElementHighlightByName.defaultOptions = {
  trigger: "pointerover",
  resetTrigger: "pointerout",
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-base.js
var BrushBase = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.handleAfterDraw = () => {
      var _a, _b, _c, _d;
      const stage = this.view.renderer.stage();
      if (this._brushComp || !stage) return;
      const viewBox = this.view.getViewBox();
      this._brushComp = new Brush({
        interactiveRange: null !== (_a = this.options.interactiveRange) && void 0 !== _a ? _a : {
          minX: viewBox.x1,
          maxX: viewBox.x2,
          minY: viewBox.y1,
          maxY: viewBox.y2
        },
        xRange: null !== (_b = this.options.xRange) && void 0 !== _b ? _b : [viewBox.x1, viewBox.x2],
        yRange: null !== (_c = this.options.yRange) && void 0 !== _c ? _c : [viewBox.y1, viewBox.y2],
        brushMode: null !== (_d = this.options.brushMode) && void 0 !== _d ? _d : "single",
        brushType: this.options.brushType,
        brushStyle: this.options.brushStyle,
        brushMoved: this.options.brushMoved,
        removeOnClick: this.options.removeOnClick,
        sizeThreshold: this.options.sizeThreshold,
        delayType: this.options.delayType,
        delayTime: this.options.delayTime
      }), this._brushComp.addEventListener(IOperateType.brushClear, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moveEnd, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawEnd, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawStart, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moveStart, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.drawing, this.handleBrushUpdate), this._brushComp.addEventListener(IOperateType.moving, this.handleBrushUpdate), stage.defaultLayer.appendChild(this._brushComp);
    }, this.options = options, this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: HOOK_EVENT.BEFORE_DO_RENDER,
      handler: this.handleAfterDraw
    }];
  }
  isPolygonBrushContainGraphicItem(brushMask, graphicItem, offset) {
    const points = brushMask.attribute.points, { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = brushMask.globalTransMatrix, { x: dx = 0, y: dy = 0 } = null != offset ? offset : {}, pointsCoord = points.map((p2) => ({
      x: a4 * p2.x + c4 * p2.y + e3 + dx,
      y: b2 * p2.x + d2 * p2.y + f2 + dy
    })), globalAABBBoundsOffset = brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy), x3 = graphicItem.globalTransMatrix.e, y3 = graphicItem.globalTransMatrix.f;
    if ("symbol" === graphicItem.type || "circle" === graphicItem.type) return globalAABBBoundsOffset.contains(x3, y3) && polygonContainPoint(pointsCoord, x3, y3);
    if ("rect" === graphicItem.type) {
      const { width = 0, height = 0 } = null == graphicItem ? void 0 : graphicItem.attribute;
      return polygonIntersectPolygon(pointsCoord, [{
        x: x3,
        y: y3
      }, {
        x: x3 + width,
        y: y3
      }, {
        x: x3 + width,
        y: y3 + height
      }, {
        x: x3,
        y: y3 + height
      }]);
    }
    return brushMask.globalAABBBounds.intersects(graphicItem.globalAABBBounds);
  }
  isRectBrushContainGraphicItem(brushMask, graphicItem, offset) {
    const { x: dx = 0, y: dy = 0 } = null != offset ? offset : {}, globalAABBBoundsOffset = brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy), x3 = graphicItem.globalTransMatrix.e, y3 = graphicItem.globalTransMatrix.f;
    if ("symbol" === graphicItem.type || "circle" === graphicItem.type) return globalAABBBoundsOffset.contains(x3, y3);
    if ("rect" === graphicItem.type) {
      const { width = 0, height = 0 } = graphicItem.attribute;
      return isRectIntersect(globalAABBBoundsOffset, {
        x1: x3,
        y1: y3,
        x2: x3 + width,
        y2: y3 + height
      }, false);
    }
    return brushMask.globalAABBBounds.intersects(graphicItem.globalAABBBounds);
  }
  isBrushContainGraphicItem(brushMask, graphicItem, offset) {
    var _a;
    return !(!((null == brushMask ? void 0 : brushMask.globalTransMatrix) && brushMask.globalAABBBounds && !brushMask.globalAABBBounds.empty() && graphicItem && (null === (_a = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _a ? void 0 : _a.points)) || brushMask.attribute.points.length <= 1) && ("polygon" === this.options.brushType ? this.isPolygonBrushContainGraphicItem(brushMask, graphicItem, offset) : this.isRectBrushContainGraphicItem(brushMask, graphicItem, offset));
  }
  unbind() {
    super.unbind(), this._brushComp && (this._brushComp.releaseBrushEvents(), this._brushComp.release(), this._brushComp = null);
  }
  _dispatchEvent(event, activeElements) {
    const params2 = {
      operateType: event.type,
      operateMask: event.detail.operateMask,
      activeElements
    };
    event.type === IOperateType.drawStart || event.type === IOperateType.moveStart ? this.dispatchEvent("start", params2) : event.type === IOperateType.drawing || event.type === IOperateType.moving ? this.dispatchEvent("update", params2) : event.type === IOperateType.drawEnd || event.type === IOperateType.moveEnd ? this.dispatchEvent("end", params2) : this.dispatchEvent("reset", params2);
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-highlight.js
var BrushHighlight = class _BrushHighlight extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushHighlight.defaultOptions, option)), this.type = _BrushHighlight.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      event.type === IOperateType.brushClear ? this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.removeState(this.options.blurState), el.removeState(this.options.highlightState);
        });
      }) : this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) ? (elements.push(el), el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
        });
      }), this._dispatchEvent(event, elements);
    };
  }
};
BrushHighlight.type = "brush-highlight", BrushHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-active.js
var BrushActive = class _BrushActive extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushActive.defaultOptions, option)), this.type = _BrushActive.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) ? (elements.push(el), el.addState(this.options.state)) : el.removeState(this.options.state);
        });
      }), this._dispatchEvent(event, elements);
    };
  }
};
BrushActive.type = "brush-active", BrushActive.defaultOptions = {
  state: InteractionStateEnum.active
};

// node_modules/@visactor/vgrammar-core/es/interactions/brush-filter.js
var BrushFilter = class _BrushFilter extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _BrushFilter.defaultOptions, option)), this.type = _BrushFilter.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      let filterValue = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) && (elements.push(el), filterValue = filterValue.concat(array(el.getDatum())));
        });
      }), this._data && (filterValue = Array.from(new Set(filterValue)), this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter())), this._dispatchEvent(event, elements);
    }, this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._data) return [];
    const transform29 = this.options.target.transform;
    return this._filterData(this._data, null, DataFilterRank.brush, null, void 0, (data, filterValue) => {
      const nextData = filterValue || data;
      return transform29 ? transform29(data, filterValue) : nextData;
    }), super.getEvents();
  }
};
BrushFilter.type = "brush-filter", BrushFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/interactions/drill-down.js
var DrillDown = class _DrillDown extends BrushBase {
  constructor(view, option) {
    super(view, Object.assign({}, _DrillDown.defaultOptions, option)), this.type = _DrillDown.type, this.handleBrushUpdate = (event) => {
      const elements = [];
      let filterValue = [];
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          this.isBrushContainGraphicItem(event.detail.operateMask, el.getGraphicItem()) && (elements.push(el), filterValue = filterValue.concat(array(el.getDatum())));
        });
      }), this._data && (filterValue = Array.from(new Set(filterValue)), this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter())), this._dispatchEvent(event, elements);
    }, this.handleTrigger = (event) => {
      const element = event.element;
      if (element && this._marks && this._marks.includes(element.mark)) {
        const filterValue = array(element.getDatum());
        this._filterValue && filterValue.length === this._filterValue.length && !filterValue.some((datum) => !this._filterValue.includes(datum)) || (this._filterValue = filterValue, this.handleFilter());
      }
    }, this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._data) return [];
    const transform29 = this.options.target.transform;
    return this._filterData(this._data, null, DataFilterRank.drillDown, null, void 0, (data, filterValue) => {
      const nextData = filterValue || data;
      return transform29 ? transform29(data, filterValue) : nextData;
    }), this.options.brush ? super.getEvents() : [{
      type: this.options.trigger,
      handler: this.handleTrigger
    }];
  }
};
DrillDown.type = "drill-down", DrillDown.defaultOptions = {
  brush: false,
  trigger: "click"
};

// node_modules/@visactor/vgrammar-core/es/interactions/filter.js
var Filter = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), options.target && (this._data = isString_default(options.target.data) ? view.getDataById(options.target.data) : options.target.data);
  }
};
Filter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/interactions/roll-up.js
var RollUp = class _RollUp extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _RollUp.type, this._isToggle = false, this.handleStart = (event) => {
      var _a, _b;
      const element = event.element;
      if (element && this._marks && this._marks.includes(element.mark)) {
        const filterValue = null === (_b = null === (_a = event.element) || void 0 === _a ? void 0 : _a.getDatum) || void 0 === _b ? void 0 : _b.call(_a);
        filterValue === this._filterData || isArray_default(filterValue) && isArray_default(this._filterValue) && filterValue.length === this._filterValue.length && filterValue.every((datum) => !this._filterValue.includes(datum)) ? this._isToggle && (this._filterValue = null, this.handleFilter(event)) : this.handleFilter(event);
      }
    }, this.handleReset = (event) => {
      this._filterValue && (this._filterValue = null, this.handleFilter(event));
    }, this.options = Object.assign({}, _RollUp.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    if (!this._data) return [];
    const transform29 = this.options.target.transform;
    this._filterData(this._data, null, DataFilterRank.rollUp, (event) => {
      var _a, _b;
      return null === (_b = null === (_a = null == event ? void 0 : event.element) || void 0 === _a ? void 0 : _a.getDatum) || void 0 === _b ? void 0 : _b.call(_a);
    }, void 0, (data, filterValue) => transform29(data, filterValue));
    const events = [{
      type: this.options.trigger,
      handler: this.handleStart
    }], eventName = "empty" === this.options.resetTrigger ? this.options.trigger : this.options.resetTrigger.includes("view:") ? this.options.resetTrigger.replace("view:", "") : this.options.resetTrigger;
    return eventName !== this.options.trigger ? (events.push({
      type: eventName,
      handler: this.handleReset
    }), this._isToggle = false) : this._isToggle = true, events;
  }
};
RollUp.type = "roll-up", RollUp.defaultOptions = {
  trigger: "click",
  resetTrigger: "empty"
};

// node_modules/@visactor/vgrammar-core/es/interactions/base-tooltip.js
var generateTooltipAttributes = (point6, title3, content, bounds, theme2, addition) => {
  var _a;
  const tooltipTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.tooltip;
  return merge({}, tooltipTheme, {
    visible: true,
    pointerX: point6.x,
    pointerY: point6.y,
    title: title3,
    content,
    parentBounds: bounds
  }, null != addition ? addition : {});
};
var BaseTooltip = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this._marks = view.getMarksBySelector(options.selector);
  }
  bind() {
    super.bind();
    const stage = this.view.renderer.stage();
    !this._tooltipComponent && stage && (this._tooltipComponent = new Tooltip({}), stage.defaultLayer.appendChild(this._tooltipComponent));
  }
  unbind() {
    super.unbind(), this._tooltipComponent && (this._tooltipComponent.release(), this._tooltipComponent = null);
  }
  _computeTooltipRow(row, datum) {
    let key, value, symbol, visible = invokeFunctionType(row.visible, this.parameters(), datum);
    if (visible = !!isNil_default(visible) || !!visible, isFieldEncode(row.key)) {
      key = field(row.key.field)(datum);
    } else key = invokeFunctionType(row.key, this.parameters(), datum);
    if (key = isNil_default(key) ? void 0 : isObjectLike_default(key) ? key : {
      text: key
    }, isFieldEncode(row.value)) {
      value = field(row.value.field)(datum);
    } else value = invokeFunctionType(row.value, this.parameters(), datum);
    if (value = isNil_default(value) ? void 0 : isObjectLike_default(value) ? value : {
      text: value
    }, isFieldEncode(row.symbol)) {
      symbol = field(row.symbol.field)(datum);
    } else symbol = invokeFunctionType(row.symbol, this.parameters(), datum);
    return symbol = isNil_default(symbol) ? void 0 : isObjectLike_default(symbol) ? symbol : {
      symbolType: symbol
    }, {
      visible,
      key,
      value,
      shape: symbol
    };
  }
  _computeTitleContent(datum) {
    const title3 = isValid_default(this.options.title) ? isFunction_default(this.options.title) ? this.options.title.call(null, datum, null, {}) : this._computeTooltipRow(isString_default(this.options.title) ? {
      value: this.options.title
    } : this.options.title, datum) : void 0, content = isValid_default(this.options.content) ? isFunction_default(this.options.content) ? array(this.options.content.call(null, datum, null, {})) : array(datum).reduce((content2, datumRow) => content2.concat(array(this.options.content).map((row) => this._computeTooltipRow(row, datumRow))), []) : void 0;
    return {
      title: isArray_default(title3) ? title3[0] : title3,
      content
    };
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/tooltip.js
var Tooltip2 = class _Tooltip extends BaseTooltip {
  constructor(view, options) {
    super(view, options), this.type = _Tooltip.type, this.handleTooltipShow = throttle_default((event) => {
      const element = event.element;
      if (!this._marks.includes(null == element ? void 0 : element.mark)) return void this._tooltipComponent.hideAll();
      this._tooltipComponent.showAll();
      const groupGraphicItem = this.view.rootMark.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      };
      if (groupGraphicItem.globalTransMatrix.transformPoint(event.canvas, point6), element === this._lastElement) return void this._tooltipComponent.setAttributes({
        pointerX: point6.x,
        pointerY: point6.y
      });
      const boundsStart = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: 0,
        y: 0
      }, boundsStart);
      const boundsEnd = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: this.view.getSignalById("width").getValue(),
        y: this.view.getSignalById("height").getValue()
      }, boundsEnd);
      const bounds = new AABBBounds().set(boundsStart.x, boundsStart.y, boundsEnd.x, boundsEnd.y), { title: title3, content } = this._computeTitleContent(element.getDatum()), theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), element.getDatum()), attributes = generateTooltipAttributes(point6, title3, content, bounds, theme2, addition);
      this._tooltipComponent.setAttributes(attributes);
    }, 10), this.handleTooltipHide = (event) => {
      this._tooltipComponent.hideAll();
    }, this.options = Object.assign({}, _Tooltip.defaultOptions, options);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleTooltipShow
    }, {
      type: this.options.resetTrigger,
      handler: this.handleTooltipHide
    }];
  }
};
Tooltip2.type = "tooltip", Tooltip2.defaultOptions = {
  trigger: "pointermove",
  resetTrigger: "pointerleave"
};

// node_modules/@visactor/vgrammar-core/es/interactions/dimension-tooltip.js
var isEqualTooltipDatum = (current, previous) => {
  const currentDatum = array(current), previousDatum = array(previous);
  return currentDatum.length === previousDatum.length && (currentDatum.every((datum) => previousDatum.includes(datum)) && previousDatum.every((datum) => currentDatum.includes(datum)));
};
var computeTooltipFilterValue = (point6, scale4, type, groupSize, tooltipCenter) => {
  if ("x" === type) return scale4.invert(point6.x);
  if ("y" === type) return scale4.invert(point6.y);
  if ("radius" === type) {
    const center2 = null != tooltipCenter ? tooltipCenter : {
      x: groupSize.width / 2,
      y: groupSize.height / 2
    }, radius = Math.sqrt((center2.x - point6.x) ** 2 + (center2.y - point6.y) ** 2);
    return scale4.invert(radius);
  }
  if ("angle" === type) {
    const center2 = null != tooltipCenter ? tooltipCenter : {
      x: groupSize.width / 2,
      y: groupSize.height / 2
    }, angle2 = getAngleByPoint(center2, point6);
    return scale4.invert(angle2 < 0 ? angle2 + 2 * Math.PI : angle2);
  }
  return scale4.invert(point6.x);
};
var DimensionTooltip = class _DimensionTooltip extends BaseTooltip {
  constructor(view, options) {
    var _a, _b, _c;
    super(view, options), this.type = _DimensionTooltip.type, this._avoidMarks = [], this._tooltipDataFilter = null, this.handleTooltipShow = throttle_default((event) => {
      var _a2, _b2, _c2;
      const scale4 = (isString_default(this.options.scale) ? this.view.getScaleById(this.options.scale) : this.options.scale).getScale(), groupGraphicItem = this._container.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint(event.canvas, point6);
      const groupSize = {
        width: groupGraphicItem.attribute.width,
        height: groupGraphicItem.attribute.height
      };
      if (point6.x < 0 || point6.x > groupGraphicItem.attribute.width || point6.y < 0 || point6.y > groupGraphicItem.attribute.height) return void this._tooltipComponent.hideAll();
      const eventTargetMark = null === (_b2 = null === (_a2 = event.target) || void 0 === _a2 ? void 0 : _a2[BridgeElementKey]) || void 0 === _b2 ? void 0 : _b2.mark;
      if (this._avoidMarks.includes(eventTargetMark)) return void this._tooltipComponent.hideAll();
      const target = null === (_c2 = this.options.target) || void 0 === _c2 ? void 0 : _c2.data, lastDataGrammar = target ? isString_default(target) ? this.view.getDataById(target) : target : null, data = lastDataGrammar ? lastDataGrammar.getValue() : [], filterValue = computeTooltipFilterValue(point6, scale4, this.options.tooltipType, groupSize, this.options.center), tooltipDatum = this._tooltipDataFilter ? data.filter((datum) => this._tooltipDataFilter(datum, filterValue)) : [];
      if (this._tooltipComponent.showAll(), isEqualTooltipDatum(tooltipDatum, this._lastDatum)) return void this._tooltipComponent.setAttributes({
        pointerX: point6.x,
        pointerY: point6.y
      });
      this._lastDatum = tooltipDatum;
      const boundsStart = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: 0,
        y: 0
      }, boundsStart);
      const boundsEnd = {
        x: 0,
        y: 0
      };
      groupGraphicItem.globalTransMatrix.transformPoint({
        x: this.view.getSignalById("width").getValue(),
        y: this.view.getSignalById("height").getValue()
      }, boundsEnd);
      const bounds = new AABBBounds().set(boundsStart.x, boundsStart.y, boundsEnd.x, boundsEnd.y), { title: title3, content } = this._computeTitleContent(tooltipDatum), theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), {}), attributes = generateTooltipAttributes(point6, title3, content, bounds, theme2, addition);
      this._tooltipComponent.setAttributes(attributes);
    }, 10), this.handleTooltipHide = (event) => {
      this._tooltipComponent.hideAll();
    }, this.options = Object.assign({}, _DimensionTooltip.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._avoidMarks = null !== (_a = view.getMarksBySelector(this.options.avoidMark)) && void 0 !== _a ? _a : [], this._container = null !== (_c = null === (_b = view.getMarksBySelector(this.options.container)) || void 0 === _b ? void 0 : _b[0]) && void 0 !== _c ? _c : view.rootMark;
  }
  getEvents() {
    const filter2 = this.options.target.filter;
    return this._tooltipDataFilter = isString_default(filter2) ? (datum, filterValue) => filterValue === datum[filter2] : filter2, [{
      type: this.options.trigger,
      handler: this.handleTooltipShow
    }, {
      type: this.options.resetTrigger,
      handler: this.handleTooltipHide
    }];
  }
};
DimensionTooltip.type = "dimension-tooltip", DimensionTooltip.defaultOptions = {
  trigger: "pointermove",
  resetTrigger: "pointerleave"
};

// node_modules/@visactor/vgrammar-core/es/interactions/crosshair.js
var computeCrosshairStartEnd = (point6, scale4, type, groupSize, config2, offset = 0) => {
  var _a, _b;
  const start = {
    x: 0,
    y: 0
  }, end = {
    x: 0,
    y: 0
  }, radius = "angle" === type ? null !== (_a = null == config2 ? void 0 : config2.radius) && void 0 !== _a ? _a : Math.min(groupSize.width, groupSize.height) / 2 : null, center2 = "angle" === type ? null !== (_b = null == config2 ? void 0 : config2.center) && void 0 !== _b ? _b : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  } : null;
  let current = 0;
  if (isDiscrete(scale4.type)) {
    if ("x" === type) current = scale4.scale(scale4.invert(point6.x));
    else if ("y" === type) current = scale4.scale(scale4.invert(point6.y));
    else if ("angle" === type) {
      const angle2 = clampRadian(getAngleByPoint(center2, point6) + 2 * Math.PI);
      current = scale4.scale(scale4.invert(angle2));
    }
  } else isContinuous(scale4.type) && ("x" === type ? current = point6.x : "y" === type ? current = point6.y : "angle" === type && (current = getAngleByPoint(center2, point6)));
  switch (current += offset, type) {
    case "x":
      start.x = current, start.y = 0, end.x = current, end.y = groupSize.height;
      break;
    case "y":
      start.x = 0, start.y = current, end.x = groupSize.width, end.y = current;
      break;
    case "angle":
      start.x = center2.x, start.y = center2.y, end.x = center2.x + radius * Math.cos(current), end.y = center2.y + radius * Math.sin(current);
  }
  return {
    start,
    end
  };
};
var computeRadiusOfTangential = (point6, scale4, type, groupSize, config2, addition) => {
  var _a, _b, _c;
  const center2 = null !== (_b = null !== (_a = null == addition ? void 0 : addition.center) && void 0 !== _a ? _a : null == config2 ? void 0 : config2.center) && void 0 !== _b ? _b : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  };
  let currentRadius = 0;
  if (isDiscrete(scale4.type)) {
    const offset = "band" === scale4.type ? scale4.bandwidth() / 2 : 0, radius = Math.sqrt((point6.x - center2.x) ** 2 + (point6.y - center2.y) ** 2);
    currentRadius = scale4.scale(scale4.invert(radius)) + offset;
  } else if (isContinuous(scale4.type)) {
    const maxRadius = null !== (_c = null == config2 ? void 0 : config2.radius) && void 0 !== _c ? _c : Math.min(groupSize.width, groupSize.height) / 2;
    currentRadius = Math.min(maxRadius, Math.sqrt((point6.x - center2.x) ** 2 + (point6.y - center2.y) ** 2));
  }
  return {
    radius: currentRadius,
    center: center2
  };
};
var generateLineCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.lineCrosshair, offset = "band" === scale4.type ? scale4.bandwidth() / 2 : 0, points = computeCrosshairStartEnd(point6, scale4, type, groupSize, {
    radius: null !== (_b = null == addition ? void 0 : addition.radius) && void 0 !== _b ? _b : null == config2 ? void 0 : config2.radius,
    center: null !== (_c = null == addition ? void 0 : addition.center) && void 0 !== _c ? _c : null == config2 ? void 0 : config2.center
  }, offset);
  return merge({}, crosshairTheme, points, null != addition ? addition : {});
};
var generateRectCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.rectCrosshair, defaultSize = "band" === scale4.type || "point" === scale4.type ? scale4.step() : void 0, customRectStyle = null == addition ? void 0 : addition.rectStyle, size = null != defaultSize ? defaultSize : "y" === type ? null !== (_b = null == customRectStyle ? void 0 : customRectStyle.width) && void 0 !== _b ? _b : crosshairTheme.rectStyle.width : null !== (_c = null == customRectStyle ? void 0 : customRectStyle.height) && void 0 !== _c ? _c : crosshairTheme.rectStyle.height, points = computeCrosshairStartEnd(point6, scale4, type, groupSize, config2, "band" === scale4.type ? 0 : -size / 2), rectStyle = {};
  "x" === type ? rectStyle.width = size : rectStyle.height = size;
  const attribute = merge({}, crosshairTheme, {
    start: points.start,
    end: points.end,
    rectStyle
  }, null != addition ? addition : {});
  return "x" === type ? attribute.rectStyle.height = attribute.end.y - attribute.start.y : attribute.rectStyle.width = attribute.end.x - attribute.start.x, attribute;
};
var generateRingCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle, deltaRadius = "band" === scale4.type || "point" === scale4.type ? scale4.step() : 0;
  return merge({}, crosshairTheme, {
    center: center2,
    innerRadius: radius - deltaRadius / 2,
    radius: radius + deltaRadius / 2,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var generateSectorCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a, _b, _c, _d, _e;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.sectorCrosshair, radius = null !== (_c = null !== (_b = null == addition ? void 0 : addition.radius) && void 0 !== _b ? _b : null == config2 ? void 0 : config2.radius) && void 0 !== _c ? _c : Math.min(groupSize.width, groupSize.height) / 2, center2 = null !== (_e = null !== (_d = null == addition ? void 0 : addition.center) && void 0 !== _d ? _d : null == config2 ? void 0 : config2.center) && void 0 !== _e ? _e : {
    x: groupSize.width / 2,
    y: groupSize.height / 2
  }, defaultAngle = crosshairTheme.endAngle - crosshairTheme.startAngle, angle2 = "band" === scale4.type || "point" === scale4.type ? scale4.step() : defaultAngle;
  let currentAngle = 0;
  if (isDiscrete(scale4.type)) {
    const angle3 = clampRadian(getAngleByPoint(center2, point6) + 2 * Math.PI);
    currentAngle = scale4.scale(scale4.invert(angle3)) + ("band" === scale4.type ? scale4.bandwidth() / 2 : 0);
  } else isContinuous(scale4.type) && (currentAngle = getAngleByPoint(center2, point6));
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle: currentAngle - angle2 / 2,
    endAngle: currentAngle + angle2 / 2
  }, null != addition ? addition : {});
};
var generateCircleCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle;
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var generatePolygonCrosshairAttributes = (point6, scale4, type, groupSize, config2, theme2, addition) => {
  var _a;
  const crosshairTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleCrosshair, { center: center2, radius } = computeRadiusOfTangential(point6, scale4, 0, groupSize, config2, addition), startAngle = crosshairTheme.startAngle, endAngle = crosshairTheme.endAngle;
  return merge({}, crosshairTheme, {
    center: center2,
    radius,
    startAngle,
    endAngle
  }, null != addition ? addition : {});
};
var Crosshair = class _Crosshair extends BaseInteraction {
  constructor(view, options) {
    var _a, _b;
    super(view, options), this.type = _Crosshair.type, this.handleCrosshairShow = (event) => {
      var _a2;
      if (!this._crosshairComponent) return;
      const groupGraphicItem = this._container.getGroupGraphicItem(), point6 = {
        x: 0,
        y: 0
      }, globalTransMatrix = groupGraphicItem.globalTransMatrix, containerPoint = {
        x: globalTransMatrix.e,
        y: globalTransMatrix.f
      };
      if (globalTransMatrix.transformPoint(event.canvas, point6), point6.x < 0 || point6.x > groupGraphicItem.attribute.width || point6.y < 0 || point6.y > groupGraphicItem.attribute.height) return void this._crosshairComponent.hideAll();
      const crosshairType = null !== (_a2 = this.options.crosshairType) && void 0 !== _a2 ? _a2 : "x", groupSize = {
        width: groupGraphicItem.attribute.width,
        height: groupGraphicItem.attribute.height
      }, scale4 = (isString_default(this.options.scale) ? this.view.getScaleById(this.options.scale) : this.options.scale).getScale(), config2 = {
        center: this.options.center,
        radius: this.options.radius
      }, theme2 = this.view.getCurrentTheme(), addition = invokeFunctionType(this.options.attributes, this.parameters(), {}, {});
      let attributes = {};
      switch (this.getCrosshairComponentType()) {
        case CrosshairEnum.lineCrosshair:
          attributes = generateLineCrosshairAttributes(point6, scale4, crosshairType, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.rectCrosshair:
          attributes = generateRectCrosshairAttributes(point6, scale4, crosshairType, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.sectorCrosshair:
          attributes = generateSectorCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.circleCrosshair:
          attributes = generateCircleCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.polygonCrosshair:
          attributes = generatePolygonCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
          break;
        case CrosshairEnum.ringCrosshair:
          attributes = generateRingCrosshairAttributes(point6, scale4, 0, groupSize, config2, theme2, addition);
      }
      this.getCrosshairComponentType() !== CrosshairEnum.circleCrosshair && (attributes.x = containerPoint.x, attributes.y = containerPoint.y), this._crosshairComponent.showAll(), this._crosshairComponent.setAttributes(attributes);
    }, this.handleCrosshairHide = () => {
      this._crosshairComponent.hideAll();
    }, this.options = Object.assign({}, _Crosshair.defaultOptions, options), this._container = null !== (_b = null === (_a = view.getMarksBySelector(this.options.container)) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : view.rootMark;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleCrosshairShow
    }, {
      type: this.options.resetTrigger,
      handler: this.handleCrosshairHide
    }];
  }
  getCrosshairComponentType() {
    var _a, _b;
    if (this._crosshairComponentType) return this._crosshairComponentType;
    const shape = null !== (_a = this.options.crosshairShape) && void 0 !== _a ? _a : "line", type = null !== (_b = this.options.crosshairType) && void 0 !== _b ? _b : "x";
    return this._crosshairComponentType = "rect" === shape ? "angle" === type ? CrosshairEnum.sectorCrosshair : "radius" === type ? CrosshairEnum.ringCrosshair : "radius-polygon" === type ? CrosshairEnum.polygonCrosshair : CrosshairEnum.rectCrosshair : "radius" === type ? CrosshairEnum.circleCrosshair : "radius-polygon" === type ? CrosshairEnum.polygonCrosshair : CrosshairEnum.lineCrosshair, this._crosshairComponentType;
  }
  getDefaultCrosshairAttribute() {
    var _a;
    const type = null !== (_a = this.options.crosshairType) && void 0 !== _a ? _a : "x";
    return "radius" === type || "radius-polygon" === type ? {
      center: {
        x: 0,
        y: 0
      },
      zIndex: -1
    } : {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      },
      zIndex: -1
    };
  }
  bind() {
    super.bind();
    const stage = this.view.renderer.stage();
    if (!this._crosshairComponent && stage) {
      switch (this.getCrosshairComponentType()) {
        case CrosshairEnum.lineCrosshair:
          this._crosshairComponent = new LineCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.rectCrosshair:
          this._crosshairComponent = new RectCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.sectorCrosshair:
          this._crosshairComponent = new SectorCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.circleCrosshair:
          this._crosshairComponent = new CircleCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.polygonCrosshair:
          this._crosshairComponent = new PolygonCrosshair(this.getDefaultCrosshairAttribute());
          break;
        case CrosshairEnum.ringCrosshair:
          this._crosshairComponent = new SectorCrosshair(this.getDefaultCrosshairAttribute());
      }
      stage.defaultLayer.appendChild(this._crosshairComponent);
    }
  }
  unbind() {
    super.unbind(), this._crosshairComponent && (this._crosshairComponent.release(), this._crosshairComponent = null);
  }
};
Crosshair.type = "crosshair", Crosshair.defaultOptions = {
  trigger: "pointermove",
  resetTrigger: "pointerleave",
  crosshairType: "x",
  crosshairShape: "line"
};

// node_modules/@visactor/vgrammar-core/es/util/scale.js
function getBandWidthOfScale(scale4) {
  if (scale4) return scale4.type === ScaleEnum.Band ? scale4.bandwidth() : scale4.type === ScaleEnum.Point ? scale4.step() : void 0;
}
function getScaleRangeRatio(scale4, input) {
  const range2 = scale4.range();
  return (scale4.scale(input) - range2[0]) / (range2[range2.length - 1] - range2[0]);
}

// node_modules/@visactor/vgrammar-core/es/interactions/view-navigation-base.js
var ViewNavigationBase = class extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.options = options;
  }
  _parseLinkedComponent(option) {
    if (!option) return null;
    const comp = isString_default(option) ? this.view.getMarkById(option) : option;
    return !comp || comp.markType !== GrammarMarkType.component || comp.componentType !== ComponentEnum.datazoom && comp.componentType !== ComponentEnum.scrollbar ? null : comp;
  }
  _initStateByDim(dim, linkedComponent, scale4, dataTarget) {
    const comp = this._parseLinkedComponent(linkedComponent);
    if (comp) return void (this._state[dim] = {
      linkedComponent: comp
    });
    const scaleGrammar = isNil_default(scale4) ? null : isString_default(scale4) ? this.view.getScaleById(scale4) : scale4, dataGrammar = isNil_default(null == dataTarget ? void 0 : dataTarget.data) ? null : isString_default(dataTarget.data) ? this.view.getDataById(dataTarget.data) : dataTarget.data;
    if (!scaleGrammar || !dataGrammar) return void (this._state[dim] = {
      data: dataGrammar,
      scale: scaleGrammar
    });
    dataGrammar.attach(scaleGrammar);
    const filterByScale = isString_default(dataTarget.filter) ? (datum, filterValue) => {
      const scale5 = scaleGrammar.getScale(), ratio = getScaleRangeRatio(scale5, datum[dataTarget.filter]);
      return ratio >= filterValue[0] && ratio <= filterValue[1];
    } : dataTarget.filter, dataFilter = {
      source: `${scaleGrammar.uid}`,
      rank: DataFilterRank.normal,
      filter: (data) => {
        var _a, _b, _c, _d;
        const filterValue = "x" === dim ? null === (_b = null === (_a = this._state) || void 0 === _a ? void 0 : _a.x) || void 0 === _b ? void 0 : _b.filterValue : null === (_d = null === (_c = this._state) || void 0 === _c ? void 0 : _c.y) || void 0 === _d ? void 0 : _d.filterValue;
        if (!filterValue) return data;
        const filteredData = data.filter((datum) => filterByScale(datum, filterValue));
        return dataTarget.transform ? dataTarget.transform(filteredData, filterValue) : filteredData;
      }
    };
    "x" === dim ? this._dataFilterX = dataFilter : this._dataFilterY = dataFilter, dataGrammar.addDataFilter(dataFilter), this._state[dim] = {
      data: dataGrammar,
      scale: scaleGrammar
    };
  }
  _initGrammars() {
    const { enableX, enableY, scaleX, scaleY, dataTargetX, dataTargetY, linkedComponentX, linkedComponentY } = this.options;
    this._state = {}, false !== enableX && this._initStateByDim("x", linkedComponentX, scaleX, dataTargetX), false !== enableY && this._initStateByDim("y", linkedComponentY, scaleY, dataTargetY), this._inited = true;
  }
  _updateLinkedComponent(comp, newRange) {
    comp.componentType === ComponentEnum.datazoom ? comp.setStartEndValue(newRange[0], newRange[1]) : comp.setScrollStart(newRange[0]);
  }
  updateView(type, newRange, e3) {
    var _a, _b, _c, _d;
    newRange && newRange.x && (null === (_b = null === (_a = this._state) || void 0 === _a ? void 0 : _a.x) || void 0 === _b ? void 0 : _b.linkedComponent) && this._updateLinkedComponent(this._state.x.linkedComponent, newRange.x), newRange && newRange.y && (null === (_d = null === (_c = this._state) || void 0 === _c ? void 0 : _c.y) || void 0 === _d ? void 0 : _d.linkedComponent) && this._updateLinkedComponent(this._state.y.linkedComponent, newRange.y), newRange && newRange.needUpdate && this.view.runAsync(), this.dispatchEvent(type, {
      viewRange: newRange,
      event: e3
    });
  }
  unbind() {
    super.unbind(), this._state && Object.keys(this._state).forEach((dim) => {
      const { data, scale: scale4 } = this._state[dim];
      data && scale4 ? (data.detach(scale4), data.removeDataFilter("x" === dim ? this._dataFilterX : this._dataFilterY)) : scale4 && (scale4.setRangeFactor(null), scale4.commit());
    }), this._state = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-zoom.js
var ViewZoom = class _ViewZoom extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewZoom.defaultOptions, option)), this.type = _ViewZoom.type, this.handleStartInner = (e3) => {
      this.formatZoomEvent(e3), !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleZoomStart(e3, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      })));
    }, this.handleEnd = (e3) => {
      this.formatZoomEvent(e3), !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleZoomEnd(e3, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      }), e3);
    }, this.handleReset = (e3) => {
      !e3 || this.options.shouldReset && !this.options.shouldReset(e3) || this.updateView("reset", this.handleZoomReset(e3, this._state, {
        rate: this.options.rate,
        focus: this.options.focus
      }), e3);
    }, this.handleStart = throttle_default(this.handleStartInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
};
ViewZoom.type = "view-zoom", ViewZoom.defaultOptions = {
  realtime: true,
  focus: true,
  trigger: "wheel",
  endTrigger: "pointerup",
  resetTrigger: "dblclick",
  rate: 1,
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-scroll.js
var ViewScroll = class _ViewScroll extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewScroll.defaultOptions, option)), this.type = _ViewScroll.type, this.handleStartInner = (e3) => {
      this.formatScrollEvent(e3), !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleScrollStart(e3, this._state, this.options), e3));
    }, this.handleEnd = (e3) => {
      this.formatScrollEvent(e3), !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleScrollEnd(e3, this._state, this.options), e3);
    }, this.handleStart = throttle_default(this.handleStartInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }];
  }
};
ViewScroll.type = "view-scroll", ViewScroll.defaultOptions = {
  realtime: true,
  reversed: false,
  trigger: "wheel",
  endTrigger: "pointerup",
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-drag.js
var ViewDrag = class _ViewDrag extends ViewNavigationBase {
  constructor(view, option) {
    super(view, Object.assign({}, _ViewDrag.defaultOptions, option)), this.type = _ViewDrag.type, this.handleStart = (e3) => {
      !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleDragStart(e3, this._state, {
        reversed: this.options.reversed
      }), e3));
    }, this.handleUpdateInner = (e3) => {
      !e3 || this.options.shouldUpdate && !this.options.shouldUpdate(e3) || this.updateView("update", this.handleDragUpdate(e3, this._state, {
        reversed: this.options.reversed
      }), e3);
    }, this.handleEnd = (e3) => {
      !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleDragEnd(e3, this._state, {
        reversed: this.options.reversed
      }), e3);
    }, this.handleUpdate = throttle_default(this.handleUpdateInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.updateTrigger,
      handler: this.handleUpdate
    }];
  }
};
ViewDrag.type = "view-drag", ViewDrag.defaultOptions = {
  realtime: true,
  reversed: false,
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: "pointerup",
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/view-roam.js
var ViewRoam = class _ViewRoam extends ViewNavigationBase {
  constructor(view, option) {
    super(view, merge({}, _ViewRoam.defaultOptions, option)), this.type = _ViewRoam.type, this.handleRoamZoomStartInner = (e3) => {
      this.formatZoomEvent(e3), !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleZoomStart(e3, this._state, this.options.zoom), e3));
    }, this.handleRoamZoomEnd = (e3) => {
      this.formatZoomEvent(e3), !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleZoomEnd(e3, this._state, this.options.zoom), e3);
    }, this.handleRoamZoomReset = (e3) => {
      !e3 || this.options.shouldReset && !this.options.shouldReset(e3) || this.updateView("reset", this.handleZoomReset(e3, this._state, this.options.zoom), e3);
    }, this.handleRoamDragStart = (e3) => {
      !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleDragStart(e3, this._state, this.options.drag), e3));
    }, this.handleRoamDragUpdateInner = (e3) => {
      !e3 || this.options.shouldUpdate && !this.options.shouldUpdate(e3) || this.updateView("update", this.handleDragUpdate(e3, this._state, this.options.drag), e3);
    }, this.handleRoamDragEnd = (e3) => {
      !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleDragEnd(e3, this._state, this.options.drag), e3);
    }, this.handleRoamScrollStartInner = (e3) => {
      this.formatScrollEvent(e3), !e3 || this.options.shouldStart && !this.options.shouldStart(e3) || (this._inited || this._initGrammars(), this.updateView("start", this.handleScrollStart(e3, this._state, this.options.scroll), e3));
    }, this.handleRoamScrollEnd = (e3) => {
      this.formatScrollEvent(e3), !e3 || this.options.shouldEnd && !this.options.shouldEnd(e3) || this.updateView("end", this.handleScrollEnd(e3, this._state, this.options.scroll), e3);
    }, this.handleRoamZoomStart = throttle_default(this.handleRoamZoomStartInner, this.options.throttle), this.handleRoamDragUpdate = throttle_default(this.handleRoamDragUpdateInner, this.options.throttle), this.handleRoamScrollStart = throttle_default(this.handleRoamScrollStartInner, this.options.throttle);
  }
  getEvents() {
    var _a, _b, _c;
    const events = [];
    return (null === (_a = this.options.zoom) || void 0 === _a ? void 0 : _a.enable) && (this.options.zoom.trigger && events.push({
      type: this.options.zoom.trigger,
      handler: this.handleRoamZoomStart
    }), this.options.zoom.endTrigger && events.push({
      type: this.options.zoom.endTrigger,
      handler: this.handleRoamZoomEnd
    }), this.options.zoom.resetTrigger && events.push({
      type: this.options.zoom.resetTrigger,
      handler: this.handleRoamZoomReset
    })), (null === (_b = this.options.scroll) || void 0 === _b ? void 0 : _b.enable) && (this.options.scroll.trigger && events.push({
      type: this.options.scroll.trigger,
      handler: this.handleRoamScrollStart
    }), this.options.scroll.trigger && events.push({
      type: this.options.scroll.endTrigger,
      handler: this.handleRoamScrollEnd
    })), (null === (_c = this.options.drag) || void 0 === _c ? void 0 : _c.enable) && (this.options.drag.trigger && events.push({
      type: this.options.drag.trigger,
      handler: this.handleRoamDragStart
    }), this.options.drag.updateTrigger && events.push({
      type: this.options.drag.updateTrigger,
      handler: this.handleRoamDragUpdate
    }), this.options.drag.endTrigger && events.push({
      type: this.options.drag.endTrigger,
      handler: this.handleRoamDragEnd
    })), events;
  }
};
ViewRoam.type = "view-roam", ViewRoam.defaultOptions = {
  zoom: {
    realtime: true,
    enable: true,
    focus: true,
    trigger: "wheel",
    endTrigger: "pointerup",
    resetTrigger: "dblclick",
    rate: 1
  },
  scroll: {
    realtime: true,
    enable: false,
    reversed: false,
    trigger: "wheel",
    endTrigger: "pointerup"
  },
  drag: {
    realtime: true,
    enable: true,
    reversed: false,
    trigger: "pointerdown",
    updateTrigger: "pointermove",
    endTrigger: "pointerup"
  },
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/interactions/fish-eye.js
var FishEye = class _FishEye extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _FishEye.type, this.handleStart = (e3) => {
      e3 && (this.options.shouldStart ? this.options.shouldStart(e3) : this.shouldHandle(e3)) && (this._inited || this._initGrammars(), this._isActive || (this._isActive = true, this.updateView({
        x: e3.canvasX,
        y: e3.canvasY
      }, e3)));
    }, this.handleUpdateInner = (e3) => {
      e3 && (this.options.shouldUpdate ? this.options.shouldUpdate(e3) : this.shouldUpdate(e3)) && this._isActive && this.updateView({
        x: e3.canvasX,
        y: e3.canvasY
      }, e3);
    }, this.handleEnd = (e3) => {
      e3 && (this.options.shouldEnd ? this.options.shouldEnd(e3) : this.shouldHandle(e3)) && !this.options.resetTrigger && this._isActive && (this._isActive = false, this.updateView(null, e3));
    }, this.handleReset = (e3) => {
      e3 && (this.options.shouldReset ? this.options.shouldReset(e3) : this.shouldHandle(e3)) && this._isActive && (this.updateView(null, e3), this._isActive = false);
    }, this.options = Object.assign({}, _FishEye.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this.handleUpdate = throttle_default(this.handleUpdateInner, this.options.throttle);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.updateTrigger,
      handler: this.handleUpdate
    }, {
      type: this.options.endTrigger,
      handler: this.handleEnd
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  _initStateByDim(dim, distortion, scale4, radius, radiusRatio) {
    const scaleGrammar = isNil_default(scale4) ? null : isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
    this._state[dim] = {
      scale: scaleGrammar,
      distortion,
      radius,
      radiusRatio
    };
  }
  _initGrammars() {
    const { enableX, enableY, scaleX, scaleY, distortionX, distortionY, radiusRatioX, radiusRatioY, radiusX, radiusY } = this.options;
    this._state = {}, false !== enableX && this._initStateByDim("x", distortionX, scaleX, radiusX, radiusRatioX), false !== enableY && this._initStateByDim("y", distortionY, scaleY, radiusY, radiusRatioY), this._inited = true;
  }
  updateView(focus, e3) {
    let needUpdate = false;
    focus ? Object.keys(this._state).forEach((dim) => {
      const dimState = this._state[dim];
      dimState.scale && dimState.focus !== focus[dim] && (needUpdate = true, dimState.focus = focus[dim], dimState.scale.setFishEye({
        distortion: dimState.distortion,
        radius: dimState.radius,
        radiusRatio: dimState.radiusRatio,
        focus: focus[dim]
      }), dimState.scale.commit());
    }) : Object.keys(this._state).forEach((dim) => {
      const dimState = this._state[dim];
      dimState.scale && !isNil_default(dimState.focus) && (needUpdate = true, dimState.focus = null, dimState.scale.setFishEye(null), dimState.scale.commit());
    }), needUpdate && this.view.runSync();
  }
  shouldHandle(e3) {
    var _a, _b, _c;
    return this._marks ? e3.element && this._marks && this._marks.includes(e3.element.mark) : e3.target === (null === (_c = null === (_b = null === (_a = this.view) || void 0 === _a ? void 0 : _a.renderer) || void 0 === _b ? void 0 : _b.stage) || void 0 === _c ? void 0 : _c.call(_b));
  }
  shouldUpdate(e3) {
    if (this._marks) return e3.element && this._marks && this._marks.includes(e3.element.mark);
    const viewBox = this.view.getViewBox();
    return e3.canvasX >= viewBox.x1 && e3.canvasX <= viewBox.x2 && e3.canvasY >= viewBox.y1 && e3.canvasY <= viewBox.y2;
  }
  unbind() {
    super.unbind(), this._state && Object.keys(this._state).forEach((dim) => {
      const { scale: scale4 } = this._state[dim];
      scale4 && (scale4.setRangeFactor(null), scale4.commit());
    }), this._state = null;
  }
};
FishEye.type = "fish-eye", FishEye.defaultOptions = {
  trigger: "pointerenter",
  updateTrigger: "pointermove",
  endTrigger: "pointerleave",
  distortionX: 2,
  distortionY: 2,
  throttle: 100
};

// node_modules/@visactor/vgrammar-core/es/parse/option.js
var parseOptionValue = (value, params2) => isGrammar(value) ? value.output() : value && isObject_default(value) ? isFunction_default(value.callback) ? (datum) => value.callback(datum, params2) : isFunction_default(value.value) ? value.value(params2) : value : value;
var parseOptions = (options, params2) => options ? isObject_default(options) ? Object.keys(options).reduce((res, key) => {
  const option = options[key];
  return res[key] = parseOptionValue(option, params2), res;
}, {}) : options.map((option) => parseOptionValue(option, params2)) : options;

// node_modules/@visactor/vgrammar-core/es/view/grammar-base.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var grammarBaseId = -1;
var GrammarBase = class extends import_eventemitter3.default {
  constructor(view) {
    super(), this.spec = {}, this.references = /* @__PURE__ */ new Map(), this.targets = [], this.transforms = [], this.view = view, this.uid = ++grammarBaseId;
  }
  parse(spec) {
    return this.id(spec.id), this.name(spec.name), this.depend(spec.dependency), this;
  }
  depend(grammars) {
    var _a;
    if (null === (_a = this.spec) || void 0 === _a ? void 0 : _a.dependency) {
      const lastGrammars = array(this.spec.dependency).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
      this.detach(lastGrammars);
    }
    this.spec.dependency = grammars;
    const currentGrammars = array(grammars).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
    return this.attach(currentGrammars), this.commit(), this;
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  emit(event, ...args) {
    var _a, _b;
    return null === (_b = null === (_a = this.view) || void 0 === _a ? void 0 : _a.emit) || void 0 === _b || _b.call(_a, event, ...args), super.emit(event, ...args);
  }
  emitGrammarEvent(event, ...args) {
    return super.emit(event, ...args);
  }
  evaluateTransform(transforms, upstream, parameters) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!transforms || !transforms.length) return upstream;
      let currentUpstreamData = upstream, i2 = 0;
      const n2 = transforms.length;
      for (; i2 < n2; ) {
        const task = transforms[i2];
        this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type), currentUpstreamData = task.transform(task.isRawOptions ? task.options : parseOptions(task.options, parameters), currentUpstreamData, parameters, this.view), (null == currentUpstreamData ? void 0 : currentUpstreamData.then) && (currentUpstreamData = yield currentUpstreamData), i2++, this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);
      }
      return currentUpstreamData;
    });
  }
  evaluateTransformSync(transforms, upstream, parameters) {
    if (!transforms || !transforms.length) return upstream;
    let currentUpstreamData = upstream, i2 = 0;
    const n2 = transforms.length;
    for (; i2 < n2; ) {
      const task = transforms[i2];
      this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type), currentUpstreamData = task.transform(task.isRawOptions ? task.options : parseOptions(task.options, parameters), currentUpstreamData, parameters, this.view), i2++, this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);
    }
    return currentUpstreamData;
  }
  set(value) {
    return false;
  }
  id(id2) {
    return arguments.length ? (this.view.grammars.unrecord(this), this._id = id2, this.view.grammars.record(this), this) : this._id;
  }
  name(name) {
    return arguments.length ? (this._name = name, this) : this._name;
  }
  attach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      isNil_default(reference) || (ref.targets.includes(this) || ref.targets.push(this), this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + count));
    }), this;
  }
  detach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      const refCount = this.references.get(ref) - count;
      refCount > 0 ? this.references.set(ref, refCount - 1) : (this.references.delete(ref), ref.targets.includes(this) && (ref.targets = ref.targets.filter((target) => target !== this)));
    }), this;
  }
  detachAll() {
    this.references.forEach((count, ref) => {
      this.detach(ref, count);
    });
  }
  link(source) {
    this.grammarSource = source;
  }
  run() {
    var _a;
    const upstream = null === (_a = this.grammarSource) || void 0 === _a ? void 0 : _a.output(), parameters = this.parameters();
    return this.evaluate(upstream, parameters);
  }
  runSync() {
    var _a;
    const upstream = null === (_a = this.grammarSource) || void 0 === _a ? void 0 : _a.output(), parameters = this.parameters();
    return this.evaluateSync ? this.evaluateSync(upstream, parameters) : this.evaluate(upstream, parameters);
  }
  commit() {
    this.view.commit(this);
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  getSpec() {
    return this.spec;
  }
  reuse(grammar) {
    return this;
  }
  clear() {
    this.spec = null, this.view = null;
  }
  release() {
    this.clear();
  }
  setFunctionSpec(spec, specField) {
    return isNil_default(this.spec[specField]) || this.detach(parseFunctionType(this.spec[specField], this.view)), this.spec[specField] = spec, this.attach(parseFunctionType(spec, this.view)), this.commit(), this;
  }
};

// node_modules/@visactor/vgrammar-core/es/parse/transform.js
var parseSimpleOptionValue = (key, transformSpecValue, view) => {
  var _a;
  if ("callback" === key && isFunction_default(transformSpecValue)) return {
    references: [],
    value: {
      callback: transformSpecValue,
      dependency: []
    }
  };
  if (!isNil_default(transformSpecValue.data)) {
    const grammarInstance = view.getDataById(transformSpecValue.data);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.customized)) {
    const grammarInstance = view.getCustomizedById(transformSpecValue.customized);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.scale)) {
    const grammarInstance = view.getScaleById(transformSpecValue.scale);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (isSignal(transformSpecValue)) {
    const references = parseFunctionType(transformSpecValue, view);
    return {
      references,
      value: transformSpecValue.callback ? {
        value: transformSpecValue.callback,
        dependency: references
      } : null !== (_a = null == references ? void 0 : references[0]) && void 0 !== _a ? _a : transformSpecValue
    };
  }
  return {
    value: transformSpecValue
  };
};
var parseTransformOption = (key, transformSpecValue, view) => {
  if (isNil_default(transformSpecValue)) return {
    value: transformSpecValue
  };
  if (isArray_default(transformSpecValue)) {
    const values = transformSpecValue.map((v2) => parseSimpleOptionValue(key, v2, view));
    return {
      references: values.reduce((res, val) => (val.references && res.concat(val.references), res), []),
      value: values.map((entry) => entry.value)
    };
  }
  return parseSimpleOptionValue(key, transformSpecValue, view);
};
var parseTransform = (transformSpec, view) => {
  const transformDef = Factory.getTransform(transformSpec.type);
  if (!transformDef) return;
  const options = {};
  let references = [];
  return Object.keys(transformSpec).forEach((specKey) => {
    var _a;
    if ("type" === specKey) return;
    const specValue = transformSpec[specKey];
    if ("dependency" === specKey) return void ((null == specValue ? void 0 : specValue.length) && (references = references.concat(parseReference(specValue, view))));
    const res = parseTransformOption(specKey, specValue, view);
    res && ((null === (_a = res.references) || void 0 === _a ? void 0 : _a.length) && (references = references.concat(res.references)), options[specKey] = res.value);
  }), {
    markPhase: transformDef.markPhase,
    transform: transformDef.transform,
    canProgressive: transformDef.canProgressive,
    type: transformDef.type,
    options,
    references
  };
};
var parseTransformSpec = (spec, view) => {
  if (null == spec ? void 0 : spec.length) {
    const transforms = [];
    let refs = [];
    return spec.forEach((transformSpec) => {
      var _a;
      const transform29 = parseTransform(transformSpec, view);
      transform29 && ((null === (_a = transform29.references) || void 0 === _a ? void 0 : _a.length) && (refs = refs.concat(transform29.references)), transforms.push(transform29));
    }), {
      transforms,
      refs
    };
  }
  return null;
};

// node_modules/@visactor/vgrammar-core/es/util/data.js
var __awaiter8 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var jsonParser = (data, options = {}, dataView) => {
  if (!isString_default(data)) return array(data);
  try {
    return array(JSON.parse(data));
  } catch (e3) {
    return [];
  }
};
var parsers = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser,
  json: jsonParser
};
var parseFormat = (data, format) => {
  if (!format || !parsers[format.type]) return array(data);
  const options = "dsv" === format.type ? {
    delimiter: format.delimiter
  } : {};
  return parsers[format.type](data, options, new DataView(new DataSet()));
};
var load3 = (url) => __awaiter8(void 0, void 0, void 0, function* () {
  try {
    return (yield fetch(url)).text();
  } catch (error3) {
    return null;
  }
});

// node_modules/@visactor/vgrammar-core/es/view/data.js
var __awaiter9 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Data = class extends GrammarBase {
  constructor(view, values, format) {
    super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, this._loadTasks = [], this._postFilters = [], this.ingest = (options) => {
      const format2 = invokeParameterFunctionType(options.format, this.parameters());
      return this._input = parseFormat(options.values, format2), this._input;
    }, this.load = (options) => {
      var _a;
      if (options.values) return this.ingest(options);
      const url = invokeParameterFunctionType(options.url, this.parameters()), format2 = null !== (_a = invokeParameterFunctionType(options.format, this.parameters())) && void 0 !== _a ? _a : {
        type: "json"
      };
      return load3(url).then((data) => this.ingest({
        values: data,
        format: format2
      }));
    }, this.relay = (options) => options[0], this.evaluateSync = (upstream, parameters) => {
      this.view.emit(HOOK_EVENT.BEFORE_EVALUATE_DATA);
      const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms), values2 = this.evaluateTransformSync(tasks, this.grammarSource ? upstream : this._input, parameters), filteredValues = this._evaluateFilter(values2, parameters);
      return this.setValues(filteredValues), this._isLoaded = true, this.view.emit(HOOK_EVENT.AFTER_EVALUATE_DATA), this;
    }, this._loadTasks = [], isNil_default(values) || this.values(values, format);
  }
  parse(spec) {
    return super.parse(spec), this._isLoaded = false, this.source(spec.source, spec.format, false), this.url(spec.url, spec.format, false), this.values(spec.values, spec.format, false), this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
  }
  parseDataSource(spec) {
    const refs = [], transforms = [], formatRef = spec.format ? parseFunctionType(spec.format, this.view)[0] : null;
    if (formatRef && refs.push(formatRef), spec.values) {
      const valuesRef = parseFunctionType(spec.values, this.view)[0];
      valuesRef && refs.push(valuesRef), transforms.push({
        type: "ingest",
        transform: this.ingest,
        isRawOptions: true,
        options: {
          values: spec.values,
          format: spec.format
        }
      });
    } else if (spec.url) {
      const urlRef = parseFunctionType(spec.url, this.view)[0];
      urlRef && refs.push(urlRef), transforms.push({
        type: "load",
        transform: this.load,
        options: {
          url: null != urlRef ? urlRef : spec.url,
          format: null != formatRef ? formatRef : spec.format
        }
      });
    } else if (spec.source) {
      const upstreamData = [];
      array(spec.source).forEach((sourceId) => {
        const sourceData = isGrammar(sourceId) ? sourceId : this.view.getDataById(sourceId);
        sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
      }), upstreamData.length && (transforms.push({
        type: "relay",
        transform: this.relay,
        options: upstreamData
      }), this.grammarSource = upstreamData[0]);
    }
    return {
      transforms,
      refs
    };
  }
  evaluate(upstream, parameters) {
    return __awaiter9(this, void 0, void 0, function* () {
      this.view.emit(HOOK_EVENT.BEFORE_EVALUATE_DATA);
      const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
      this.grammarSource && (this._input = upstream);
      const values = yield this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
      return this.setValues(filteredValues), this._isLoaded = true, this.view.emit(HOOK_EVENT.AFTER_EVALUATE_DATA), this;
    });
  }
  output() {
    return this._values;
  }
  getDataIDKey() {
    return this._dataIDKey;
  }
  values(values, format, load4 = true) {
    const spec = Object.assign({}, this.spec, {
      values,
      format
    });
    return isNil_default(values) || (spec.url = void 0, spec.source = void 0), load4 ? this.parseLoad(spec) : this;
  }
  url(url, format, load4 = true) {
    const spec = Object.assign({}, this.spec, {
      url,
      format
    });
    return isNil_default(url) || (spec.values = void 0, spec.source = void 0), load4 ? this.parseLoad(spec) : this;
  }
  source(source, format, load4 = true) {
    const spec = Object.assign({}, this.spec, {
      source,
      format
    });
    return isNil_default(source) || (spec.values = void 0, spec.url = void 0), load4 ? this.parseLoad(spec) : this;
  }
  parseLoad(spec) {
    this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
    const dataSourceResult = this.parseDataSource(this.spec);
    return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, this._isLoaded = false, this.commit(), this;
  }
  setValues(data) {
    this._values = array(data).map((entry, index) => {
      const datum = entry === Object(entry) ? entry : {
        data: entry
      };
      return datum[this._dataIDKey] = index, datum;
    });
  }
  field(field5) {
    return this._values.map((value) => value[field5]);
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
    const nextTransforms = parseTransformSpec(this.spec.transform, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.commit(), this;
  }
  getValue() {
    return this._values;
  }
  getInput() {
    return this._input;
  }
  addDataFilter(filter2) {
    return this._postFilters = this._postFilters.concat(array(filter2)), this._postFilters.sort((filterA, filterB) => {
      var _a, _b;
      return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
    }), this;
  }
  removeDataFilter(filter2) {
    const filters = array(filter2);
    return this._postFilters = this._postFilters.filter((filter3) => !filters.includes(filter3)), this;
  }
  _evaluateFilter(value, parameters) {
    return this._postFilters.reduce((result2, filter2) => filter2.filter(result2, parameters), value);
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._isLoaded = false, this._values = grammar.output()), this;
  }
  clear() {
    super.clear(), this._input = null, this._values = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/view/constants.js
var EVENT_SOURCE_WINDOW = "window";
var EVENT_SOURCE_VIEW = "view";
var BROWSER = "browser";
var NO_TRAP = {
  trap: false
};
var SIGNAL_WIDTH = "width";
var SIGNAL_HEIGHT = "height";
var SIGNAL_VIEW_WIDTH = "viewWidth";
var SIGNAL_VIEW_HEIGHT = "viewHeight";
var SIGNAL_PADDING = "padding";
var SIGNAL_VIEW_BOX = "viewBox";
var SIGNAL_AUTOFIT = "autoFit";

// node_modules/@visactor/vgrammar-core/es/view/events.js
function initializeEventConfig(config2) {
  const eventsConfig = Object.assign({
    defaults: {}
  }, config2), unpack = (obj, keys2) => {
    keys2.forEach((k3) => {
      isArray_default(obj[k3]) && (obj[k3] = obj[k3].reduce((set2, key) => (set2[key] = true, set2), {}));
    });
  };
  return unpack(eventsConfig.defaults, ["prevent", "allow"]), unpack(eventsConfig, [EVENT_SOURCE_VIEW, EVENT_SOURCE_WINDOW]), eventsConfig;
}
function prevent(eventConfig, type) {
  const def = eventConfig.defaults, prevent2 = def.prevent, allow = def.allow;
  return false !== prevent2 && true !== allow && (true === prevent2 || false === allow || (prevent2 ? prevent2[type] : !!allow && !allow[type]));
}
function permit(eventConfig, key, type) {
  const rule = null == eventConfig ? void 0 : eventConfig[key];
  return !(false === rule || isObject_default(rule) && !rule[type]);
}

// node_modules/@visactor/vgrammar-core/es/util/grammar-heap.js
function moveToHead(array2, idx, start, cmp) {
  let parent, pidx;
  const item = array2[idx];
  for (; idx > start && (pidx = Math.floor((idx - 1) / 2), parent = array2[pidx], item && parent && cmp(item, parent) < 0); ) array2[idx] = parent, idx = pidx;
  return array2[idx] = item;
}
function moveToTail(array2, idx, end, cmp) {
  const start = idx, endIdx = null != end ? end : array2.length, item = array2[idx];
  let ridx, cidx = 2 * idx + 1;
  for (; cidx < endIdx; ) ridx = cidx + 1, ridx < endIdx && cmp(array2[cidx], array2[ridx]) >= 0 && (cidx = ridx), array2[idx] = array2[cidx], cidx = 2 * (idx = cidx) + 1;
  return array2[idx] = item, moveToHead(array2, idx, start, cmp);
}
var Heap = class {
  constructor(compare3) {
    this.compare = compare3, this.nodes = [];
  }
  size() {
    return this.nodes.length;
  }
  last() {
    return this.nodes[0];
  }
  validate() {
    for (let i2 = this.nodes.length - 1; i2 > 0; i2 -= 1) {
      const parentIndex = Math.floor((i2 - 1) / 2);
      if (this.compare(this.nodes[parentIndex], this.nodes[i2]) > 0) return false;
    }
    return true;
  }
  push(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      return moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
    return this.nodes.push(node), moveToHead(this.nodes, this.nodes.length - 1, 0, this.compare);
  }
  remove(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      this.nodes = this.nodes.slice(0, index).concat(this.nodes.slice(index + 1)), moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
  }
  pop() {
    const last2 = this.nodes.pop();
    let item;
    return this.nodes.length ? (item = this.nodes[0], this.nodes[0] = last2, moveToTail(this.nodes, 0, null, this.compare)) : item = last2, item;
  }
  clear() {
    this.nodes = [];
  }
};

// node_modules/@visactor/vgrammar-core/es/util/unique-list.js
var UniqueList = class {
  constructor(idFunc) {
    this.list = [], this.ids = {}, this.idFunc = idFunc || identity2;
  }
  add(element) {
    const id2 = this.idFunc(element);
    return this.ids[id2] || (this.ids[id2] = 1, this.list.push(element)), this;
  }
  remove(element) {
    const id2 = this.idFunc(element);
    return this.ids[id2] && (this.ids[id2] = 0, this.list = this.list.filter((entry) => entry !== element)), this;
  }
  forEach(callback, reverse2) {
    reverse2 ? this.list.slice().reverse().forEach(callback) : this.list.forEach(callback);
  }
  filter(callback) {
    return this.list.filter(callback);
  }
  get length() {
    return this.list.length;
  }
  getElementByIndex(index) {
    return this.list[index];
  }
};

// node_modules/@visactor/vgrammar-core/es/view/dataflow.js
var __awaiter10 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Dataflow = class {
  constructor() {
    this.grammars = [], this.logger = Logger.getInstance(), this._curRank = 0, this._committed = new UniqueList((grammar) => grammar.uid), this._heap = new Heap((a4, b2) => (null == a4 ? void 0 : a4.qrank) - (null == b2 ? void 0 : b2.qrank)), this._beforeRunner = null, this._afterRunner = null, this._isRunning = false, this._updateCounter = 0, this._finishFirstRender = false;
  }
  asyncCallback(callback) {
    return __awaiter10(this, void 0, void 0, function* () {
      try {
        yield callback(this);
      } catch (err) {
        this.logger.error(err);
      }
    });
  }
  add(grammar) {
    if (grammar) return this._setRankOfGrammar(grammar), this.commit(grammar), !this.grammars.includes(grammar) && (this.grammars.push(grammar), true);
  }
  remove(grammar) {
    grammar && (this._committed.remove(grammar), this._heap.remove(grammar), this.grammars = this.grammars.filter((storedGrammar) => storedGrammar !== grammar));
  }
  _setRankOfGrammar(grammar) {
    grammar && (grammar.rank = ++this._curRank);
  }
  _reRank(grammar) {
    const queue = [grammar];
    for (; queue.length; ) {
      const cur = queue.pop();
      this._setRankOfGrammar(cur);
      const list = cur.targets;
      list && list.forEach((entry) => {
        queue.push(entry), entry === grammar && this.logger.error("Cycle detected in dataflow graph.");
      });
    }
  }
  _enqueue(grammar) {
    grammar && (grammar.qrank = grammar.rank, this._heap.push(grammar));
  }
  _logGrammarRunInfo(grammar) {
    if (this.logger.canLogError()) {
      const debugStr = [{
        key: "id",
        value: grammar.id()
      }, {
        key: "name",
        value: grammar.name()
      }].reduce((str, entry, index) => isNil_default(entry.value) ? str : `${str}${index ? " , " : ""}${entry.key}: ${entry.value}`, "");
      this.logger.debug("Run Operator: ", grammar, debugStr);
    }
  }
  hasCommitted() {
    return !!this._committed.length;
  }
  commit(grammar) {
    return this._isRunning ? this._enqueue(grammar) : this._committed.add(grammar), this;
  }
  _beforeEvaluate() {
    this.grammars.forEach((grammar) => {
      grammar.targets.some((target) => (null == target ? void 0 : target.rank) < (null == grammar ? void 0 : grammar.rank)) && this._reRank(grammar);
    }), this._committed.forEach((grammar) => this._enqueue(grammar)), this._committed = new UniqueList((grammar) => grammar.uid);
  }
  _enqueueTargets(grammar) {
    grammar.targets && grammar.targets.length && this._finishFirstRender && grammar.targets.forEach((target) => this._enqueue(target));
  }
  evaluate() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this._isReleased) return;
      if (this._beforeRunner && (yield this.asyncCallback(this._beforeRunner)), !this._committed.length) return this.logger.info("Dataflow invoked, but nothing to do."), false;
      this._isRunning = true, this._updateCounter += 1;
      let grammar, next, dt, error3, count = 0;
      this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), this._beforeEvaluate();
      try {
        for (; this._heap.size() > 0 && !this._isReleased; ) if (grammar = this._heap.pop(), grammar) if (grammar.rank === grammar.qrank) {
          if (next = grammar.run(), next && next.then && (next = yield next), !this._isRunning) return false;
          this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1;
        } else this._enqueue(grammar);
      } catch (err) {
        this._heap.clear(), error3 = err;
      }
      return !this._isReleased && (this._isRunning = false, this.logger.canLogInfo() && (dt = Date.now() - dt, this.logger.info(`> ${count} grammars; ${dt} ms`)), error3 ? this.logger.error(error3) : this._afterRunner && (yield this.asyncCallback(this._afterRunner)), this._finishFirstRender = true, true);
    });
  }
  evaluateSync() {
    if (this._beforeRunner && this._beforeRunner(this), !this._committed.length) return this.logger.info("Dataflow invoked, but nothing to do."), false;
    this._isRunning = true, this._updateCounter += 1;
    let grammar, dt, count = 0;
    for (this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), this._beforeEvaluate(); this._heap.size() > 0; ) grammar = this._heap.pop(), grammar && (grammar.rank === grammar.qrank ? (grammar.runSync(), this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1) : this._enqueue(grammar));
    return this._isRunning = false, this.logger.canLogInfo() && (dt = Date.now() - dt, this.logger.info(`> ${count} grammars updated; ${dt} ms`)), this._afterRunner && this._afterRunner(this), this._finishFirstRender = true, true;
  }
  stop() {
    this._isRunning && (this._isRunning = false);
  }
  runBefore(callback) {
    this._beforeRunner = callback;
  }
  runAfter(callback) {
    this._afterRunner = callback;
  }
  release() {
    this.stop(), this._isReleased = true, this._heap && (this._heap.clear(), this._heap = null), this.logger = null, this._committed = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/mark-tree.js
var traverseMarkTree = (rootMark, childrenKey, apply, filter2, leafFirst) => {
  const traverse = (mark) => {
    if (leafFirst || !mark || filter2 && !filter2(mark) || apply.call(null, mark), mark.markType === GrammarMarkType.group) {
      const children = mark[childrenKey];
      children && children.forEach((child) => {
        traverse(child);
      });
    }
    leafFirst && (!mark || filter2 && !filter2(mark) || apply.call(null, mark));
  };
  traverse(rootMark);
};

// node_modules/@visactor/vgrammar-core/es/graph/canvas-renderer.js
var CanvasRenderer = class {
  constructor(view) {
    this.handleAfterNextRender = () => {
      this._stage && !this._viewOptions.disableDirtyBounds && this._stage.enableDirtyBounds(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW), this._view.emit(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER);
    }, this._view = view;
  }
  initialize(width, height, options, eventConfig) {
    return this._width = width, this._height = height, this._viewOptions = options, this._eventConfig = eventConfig, this.initStage(), this;
  }
  stage() {
    var _a;
    return null !== (_a = this._stage) && void 0 !== _a ? _a : null;
  }
  gestureController() {
    var _a;
    return null !== (_a = this._gestureController) && void 0 !== _a ? _a : null;
  }
  canvas() {
    return this._stage ? this._stage.window.getNativeHandler().nativeCanvas : null;
  }
  context() {
    return this._stage ? this._stage.window.getContext().nativeContext : null;
  }
  combineIncrementalLayers() {
    return this._stage && waitForAllSubLayers(this._stage).then(() => {
      this._stage && this._stage.defaultLayer.combineSubLayer();
    }), this;
  }
  background(color) {
    if (this._stage) return this._stage.background = color, this;
  }
  setDpr(resolution, redraw) {
    var _a, _b;
    return null === (_b = null === (_a = this._stage) || void 0 === _a ? void 0 : _a.setDpr) || void 0 === _b || _b.call(_a, resolution), redraw && this.renderNextFrame(), this;
  }
  shouldResize(width, height) {
    return width !== this._width || height !== this._height;
  }
  resize(width, height) {
    return this._view.emit(HOOK_EVENT.BEFORE_STAGE_RESIZE), this.shouldResize(width, height) && (this._width = width, this._height = height, this._stage && this._stage.resize(width, height)), this._view.emit(HOOK_EVENT.AFTER_STAGE_RESIZE), this;
  }
  setViewBox(viewBox, rerender = true) {
    return this._stage ? (!viewBox || this._viewBox && viewBox.x1 === this._viewBox.x1 && viewBox.x2 === this._viewBox.x2 && viewBox.y1 === this._viewBox.y1 && viewBox.y2 === this._viewBox.y2 || (this._viewBox = viewBox, this._stage.setViewBox(viewBox.x1, viewBox.y1, viewBox.x2 - viewBox.x1, viewBox.y2 - viewBox.y1, rerender)), this) : this;
  }
  render(immediately = false) {
    return this._view.emit(HOOK_EVENT.BEFORE_VRENDER_DRAW), this.initStage(), this._stage.disableDirtyBounds(), this._stage.afterNextRender(this.handleAfterNextRender), immediately && (this._stage.render(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW)), this;
  }
  renderNextFrame() {
    return this.initStage(), this._stage.renderNextFrame(), this;
  }
  toCanvas() {
    return this._stage ? this._stage.toCanvas() : null;
  }
  preventRender(tag) {
    this._stage && this._stage.preventRender(tag);
  }
  release() {
    var _a;
    this._view.traverseMarkTree((mark) => {
      mark.release();
    }), this._dragController && this._dragController.release(), this._gestureController && this._gestureController.release(), this._stage !== (null === (_a = this._viewOptions) || void 0 === _a ? void 0 : _a.stage) && this._stage.release(), this._stage = null, this._layer = null, this._dragController = null, this._gestureController = null;
  }
  createStage() {
    var _a, _b, _c, _d, _e;
    this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_STAGE);
    const viewOptions = this._viewOptions, stage = null !== (_a = viewOptions.stage) && void 0 !== _a ? _a : createStage({
      width: this._width,
      height: this._height,
      renderStyle: viewOptions.renderStyle,
      viewBox: viewOptions.viewBox,
      dpr: viewOptions.dpr,
      canvas: viewOptions.renderCanvas,
      canvasControled: viewOptions.canvasControled,
      container: viewOptions.container,
      title: viewOptions.rendererTitle,
      beforeRender: viewOptions.beforeRender,
      afterRender: viewOptions.afterRender,
      disableDirtyBounds: true,
      autoRender: true,
      pluginList: viewOptions.pluginList,
      enableHtmlAttribute: viewOptions.enableHtmlAttribute,
      optimize: viewOptions.optimize,
      supportsTouchEvents: viewOptions.supportsTouchEvents,
      supportsPointerEvents: viewOptions.supportsPointerEvents
    });
    (null === (_b = viewOptions.options3d) || void 0 === _b ? void 0 : _b.enable) && stage.set3dOptions(viewOptions.options3d), stage.enableIncrementalAutoRender(), this._viewBox = viewOptions.viewBox, this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_STAGE), this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_LAYER);
    const layer = null !== (_c = viewOptions.layer) && void 0 !== _c ? _c : stage.defaultLayer;
    if (this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_LAYER), (null === (_d = this._eventConfig) || void 0 === _d ? void 0 : _d.drag) && (this._dragController = new DragNDrop(stage)), null === (_e = this._eventConfig) || void 0 === _e ? void 0 : _e.gesture) {
      const gestureConfig = isObject_default(this._eventConfig.gesture) ? this._eventConfig.gesture : {};
      this._gestureController = new Gesture(stage, gestureConfig);
    }
    return {
      stage,
      layer
    };
  }
  initStage() {
    if (!this._stage) {
      const { stage, layer } = this.createStage();
      this._stage = stage, this._layer = layer;
      const background = this._view.background();
      this.background(background);
    }
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/util/point.js
function point5(event) {
  ["touches", "changedTouches", "targetTouches"].forEach((touchKey) => {
    event[touchKey] && event[touchKey].length && Array.from(event[touchKey]).forEach((touch) => {
      defineSrPosition(touch, clientToLocal(touch), false);
    });
  });
  const pos = clientToLocal(event);
  return defineSrPosition(event, pos);
}
function clientToLocal(e3) {
  return isNil_default(e3.offsetX) ? isNil_default(e3.x) ? e3.changedTouches && e3.changedTouches.length ? getChangedTouchesPos(e3) : {
    canvasX: 0,
    canvasY: 0
  } : getXYPos(e3) : getOffsetPos(e3);
}
function getOffsetPos(e3) {
  return {
    canvasX: e3.offsetX,
    canvasY: e3.offsetY
  };
}
function getXYPos(e3) {
  return {
    canvasX: e3.x,
    canvasY: e3.y
  };
}
function getChangedTouchesPos(e3) {
  return {
    canvasX: e3.changedTouches[0].x,
    canvasY: e3.changedTouches[0].y
  };
}
function defineSrPosition(event, pos, client = true) {
  return isValidNumber_default(pos.canvasX) && Object.defineProperty(event, "canvasX", {
    value: pos.canvasX,
    writable: true
  }), isValidNumber_default(pos.canvasY) && Object.defineProperty(event, "canvasY", {
    value: pos.canvasY,
    writable: true
  }), client && isValidNumber_default(pos.clientX) && Object.defineProperty(event, "clientX", {
    value: pos.clientX,
    writable: true
  }), client && isValidNumber_default(pos.clientY) && Object.defineProperty(event, "clientY", {
    value: pos.clientY,
    writable: true
  }), [pos.canvasX, pos.canvasY];
}

// node_modules/@visactor/vgrammar-core/es/graph/util/events-extend.js
function getExtendedEvents(view, event, item, type, source) {
  if (source === EVENT_SOURCE_WINDOW) {
    const e3 = event.changedTouches ? event.changedTouches[0] : event;
    point5(e3);
  }
  return event.element = item, event;
}

// node_modules/@visactor/vgrammar-core/es/view/signal.js
var Signal = class extends GrammarBase {
  constructor() {
    super(...arguments), this.grammarType = "signal", this.spec = {
      value: null,
      update: null
    };
  }
  parse(spec) {
    return super.parse(spec), this.value(spec.value), this.update(spec.update), this.commit(), this;
  }
  evaluate(upstream, parameters) {
    return this._signal = this.spec.update ? invokeFunctionType(this.spec.update, parameters, this._signal) : this.spec.value, this.spec.value = this._signal, this;
  }
  output() {
    return this._signal;
  }
  getValue() {
    return this.output();
  }
  set(value) {
    if (isArray_default(value) && isArray_default(this.value) && value.length === this.value.length) {
      for (let i2 = 0; i2 < value.length; i2++) if (this.value[i2] !== value[i2]) return this._signal = value, this.spec.value = value, true;
      return false;
    }
    return this._signal !== value && (this._signal = value, this.spec.value = value, true);
  }
  update(update3) {
    return isNil_default(update3) || this.value(void 0), this.setFunctionSpec(update3, "update");
  }
  value(value) {
    return isNil_default(value) || this.update(void 0), this.spec.value = value, this.commit(), this;
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._signal = grammar.output()), this;
  }
  clear() {
    super.clear(), this._signal = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/parse/view.js
var markBaseId = -1;
var BuiltInSignalID = [SIGNAL_WIDTH, SIGNAL_HEIGHT, SIGNAL_PADDING, SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_VIEW_BOX, SIGNAL_AUTOFIT];
var builtInSignals = (option, config2, theme2) => {
  var _a, _b, _c, _d, _e;
  return [{
    id: SIGNAL_WIDTH,
    value: null !== (_a = option[SIGNAL_WIDTH]) && void 0 !== _a ? _a : 0
  }, {
    id: SIGNAL_HEIGHT,
    value: null !== (_b = option[SIGNAL_HEIGHT]) && void 0 !== _b ? _b : 0
  }, {
    id: SIGNAL_PADDING,
    value: normalizePadding2(null !== (_d = null !== (_c = option[SIGNAL_PADDING]) && void 0 !== _c ? _c : config2[SIGNAL_PADDING]) && void 0 !== _d ? _d : null == theme2 ? void 0 : theme2.padding)
  }, {
    id: SIGNAL_VIEW_WIDTH,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_WIDTH] - padding.left - padding.right;
      },
      dependency: [SIGNAL_WIDTH, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_HEIGHT,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_HEIGHT] - padding.top - padding.bottom;
      },
      dependency: [SIGNAL_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_BOX,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return (signal || new Bounds()).setValue(padding.left, padding.top, padding.left + params2[SIGNAL_VIEW_WIDTH], padding.top + params2[SIGNAL_VIEW_HEIGHT]);
      },
      dependency: [SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_AUTOFIT,
    value: null !== (_e = option[SIGNAL_AUTOFIT]) && void 0 !== _e ? _e : config2[SIGNAL_AUTOFIT]
  }];
};
var normalizePadding2 = (value) => {
  var _a, _b, _c, _d;
  return isNumber_default(value) ? {
    top: value,
    bottom: value,
    left: value,
    right: value
  } : {
    top: null !== (_a = null == value ? void 0 : value.top) && void 0 !== _a ? _a : 0,
    bottom: null !== (_b = null == value ? void 0 : value.bottom) && void 0 !== _b ? _b : 0,
    left: null !== (_c = null == value ? void 0 : value.left) && void 0 !== _c ? _c : 0,
    right: null !== (_d = null == value ? void 0 : value.right) && void 0 !== _d ? _d : 0
  };
};
var normalizeMarkTree = (spec) => {
  var _a;
  const traverse = (spec2, group) => {
    var _a2, _b;
    spec2.group = group;
    const id2 = null !== (_a2 = spec2.id) && void 0 !== _a2 ? _a2 : "VGRAMMAR_MARK_" + ++markBaseId;
    spec2.id = id2, (null !== (_b = spec2.marks) && void 0 !== _b ? _b : []).forEach((child) => traverse(child, id2));
  };
  return (null !== (_a = spec.marks) && void 0 !== _a ? _a : []).forEach((mark) => traverse(mark, "root")), spec;
};
var normalizeRunningConfig = (runningConfig) => {
  var _a, _b, _c, _d, _e;
  const { reuse = DefaultReuse, morph = DefaultMorph, morphAll = DefaultMorphAll, animation = {}, enableExitAnimation = DefaultEnableExitAnimation } = null != runningConfig ? runningConfig : {};
  return {
    reuse,
    morph,
    morphAll,
    animation: {
      easing: null !== (_a = animation.easing) && void 0 !== _a ? _a : DefaultAnimationEasing,
      delay: null !== (_b = animation.delay) && void 0 !== _b ? _b : DefaultAnimationDelay,
      duration: null !== (_c = animation.duration) && void 0 !== _c ? _c : DefaultAnimationDuration,
      oneByOne: null !== (_d = animation.oneByOne) && void 0 !== _d ? _d : DefaultAnimationOneByOne,
      splitPath: null !== (_e = animation.splitPath) && void 0 !== _e ? _e : DefaultSplitPath
    },
    enableExitAnimation
  };
};

// node_modules/@visactor/vgrammar-core/es/parse/event.js
var generateFilterByMark = (evtSpec) => isNil_default(evtSpec.markId) ? (el) => el && el.mark.id() === evtSpec.markId : isNil_default(evtSpec.markName) ? (el) => el && el.mark.name() === evtSpec.markName : isNil_default(evtSpec.type) ? (el) => el && el.mark.markType === evtSpec.type : () => true;
var parseHandler = (callback, config2) => config2 && config2.debounce ? debounce_default(callback, config2.debounce) : config2 && config2.throttle ? throttle_default(callback, config2.throttle) : callback;
var NAME_PREFIX = "@";
var ID_PREFIX = "#";
var parseEventSelector = (selector, source = EVENT_SOURCE_VIEW) => {
  const spec = {}, splitArr = selector.split(":");
  if (2 === splitArr.length) {
    const [space, eventType] = splitArr;
    "#" === space[0] ? (spec.markId = space.slice(1), spec.source = source) : "@" === space[0] ? (spec.markName = space.slice(1), spec.source = source) : isMarkType(space) ? (spec.markType = space, spec.source = source) : spec.source = space === EVENT_SOURCE_WINDOW ? EVENT_SOURCE_WINDOW : source, spec.type = eventType;
  } else 1 === splitArr.length && (spec.type = selector, spec.source = source);
  return spec;
};

// node_modules/@visactor/vgrammar-core/es/graph/util/env.js
function configureEnvironment(options) {
  options.mode && vglobal.setEnv(options.mode, options.modeParams || {});
}

// node_modules/@visactor/vgrammar-core/es/graph/glyph-element.js
var GlyphElement = class extends Element2 {
  constructor(mark) {
    super(mark), this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder2 = isRuntimeState ? this.runtimeStatesEncoder[stateName] : null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName], glyphStateAttributes = {};
      if (!encoder2) return glyphStateAttributes;
      if (isFunction_default(encoder2)) return glyphStateAttributes.attributes = encoder2(this.getDatum(), this, stateName, nextStates), glyphStateAttributes;
      if (!isRuntimeState && (null === (_c = this.graphicItem.glyphStates) || void 0 === _c ? void 0 : _c[stateName])) return this.graphicItem.glyphStates[stateName];
      if (encoder2) {
        const item = this.items[0], targetItems = [Object.assign({}, item, {
          nextAttrs: {}
        })];
        return invokeEncoderToItems(this, targetItems, encoder2, this.mark.parameters()), this.coordinateTransformEncode(targetItems), glyphStateAttributes.attributes = targetItems[0].nextAttrs, this.graphicItem.glyphStates ? this.graphicItem.glyphStates[stateName] || (this.graphicItem.glyphStates[stateName] = glyphStateAttributes) : this.graphicItem.glyphStates = {
          [stateName]: glyphStateAttributes
        }, glyphStateAttributes;
      }
      return glyphStateAttributes;
    }, this.glyphMeta = this.mark.getGlyphMeta();
  }
  getGlyphGraphicItems() {
    return this.glyphGraphicItems;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem) return;
    this.graphicItem = this.mark.addGraphicItem(attributes, this.groupKey), this.graphicItem[BridgeElementKey] = this, this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false);
    const glyphMarks = this.glyphMeta.getMarks();
    this.glyphGraphicItems = {}, this.graphicItem.getSubGraphic().forEach((graphic) => {
      const markType = glyphMarks[graphic.name];
      this.glyphGraphicItems[graphic.name] = graphic, graphic.onBeforeAttributeUpdate = (attributes2) => {
        if (!this.mark) return attributes2;
        return transformAttributes(markType, attributes2, this, graphic.name);
      };
    }), this.clearGraphicAttributes();
  }
  useStates(states, hasAnimation) {
    if (!this.graphicItem) return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this), this.states = states.slice();
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    return this.graphicItem.glyphStateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  encodeGraphic() {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
    this.graphicItem || this.initGraphicItem(), this.diffState === DiffState.enter ? (this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(true), this.applyGraphicAttributes(graphicAttributes), this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false)) : this.applyGraphicAttributes(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem.states = {};
    }), this.useStates(this.states)), this.items.map((item) => {
      item.nextAttrs = {};
    });
  }
  encodeCustom(nextAttrs) {
    var _a;
    let customEncodeValues = {};
    const channelEncoder = this.glyphMeta.getChannelEncoder(), functionEncoder = this.glyphMeta.getFunctionEncoder();
    if (functionEncoder && (customEncodeValues = functionEncoder.call(null, Object.assign({}, null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, nextAttrs), this.getDatum(), this, this.mark.getGlyphConfig())), channelEncoder) {
      let allAttrs;
      Object.keys(channelEncoder).forEach((channel) => {
        var _a2;
        if (!isNil_default(nextAttrs[channel])) {
          allAttrs || (allAttrs = Object.assign({}, null === (_a2 = this.graphicItem) || void 0 === _a2 ? void 0 : _a2.attribute, nextAttrs));
          const encodeResult = channelEncoder[channel].call(null, channel, nextAttrs[channel], allAttrs, this.getDatum(), this, this.mark.getGlyphConfig());
          Object.keys(null != encodeResult ? encodeResult : {}).forEach((markName) => {
            var _a3;
            customEncodeValues[markName] = Object.assign(null !== (_a3 = customEncodeValues[markName]) && void 0 !== _a3 ? _a3 : {}, encodeResult[markName]);
          });
        }
      });
    }
    return customEncodeValues;
  }
  encodeDefault() {
    const defaultEncodeValues = {};
    if (this.diffState === DiffState.enter && this.glyphMeta.getDefaultEncoder()) {
      const defaultEncodeResult = this.glyphMeta.getDefaultEncoder().call(null, this.getDatum(), this, this.mark.getGlyphConfig());
      Object.assign(defaultEncodeValues, defaultEncodeResult);
    }
    return defaultEncodeValues;
  }
  _onGlyphAttributeUpdate(first = false) {
    return (attributes) => {
      if (!this.mark) return attributes;
      const glyphMarks = this.glyphMeta.getMarks(), graphicAttributes = transformAttributes(this.mark.getAttributeTransforms(), attributes, this), defaultEncodeValues = first ? this.encodeDefault() : null, customEncodeValues = this.encodeCustom(attributes);
      return Object.keys(glyphMarks).forEach((markName) => {
        const markType = glyphMarks[markName], graphicItem = this.glyphGraphicItems[markName], customAttributes = null == customEncodeValues ? void 0 : customEncodeValues[markName], additionalAttributes = Object.assign({}, customAttributes);
        if (first) {
          const defaultAttributes2 = null == defaultEncodeValues ? void 0 : defaultEncodeValues[markName];
          Object.keys(null != defaultAttributes2 ? defaultAttributes2 : {}).forEach((key) => {
            has_default(this.items[0].nextAttrs, key) || has_default(additionalAttributes, key) || (additionalAttributes[key] = defaultAttributes2[key]);
          });
        }
        const glyphAttributes = Object.assign({}, cloneTransformAttributes(markType, attributes), additionalAttributes), glyphItems = this._generateGlyphItems(markType, this.items, glyphAttributes);
        this.coordinateTransformEncode(glyphItems);
        const graphicAttributes2 = this.transformElementItems(glyphItems, markType);
        this.applyGlyphGraphicAttributes(graphicAttributes2, markName, graphicItem), markType === GrammarMarkType.shape && (graphicItem.datum = glyphItems[0].datum);
      }), graphicAttributes;
    };
  }
  _generateGlyphItems(markType, items, additionalAttributes) {
    const glyphItems = items.map((item) => Object.assign({}, item, {
      nextAttrs: additionalAttributes
    }));
    return CollectionMarkType.includes(markType) && this.mark.getSpec().enableSegments && glyphItems.forEach((glyphItem, index) => {
      glyphItem.nextAttrs = Object.assign({}, items[index].nextAttrs, additionalAttributes);
    }), glyphItems;
  }
  getGraphicAttribute(channel, prev = false, markName) {
    if (!this.graphicItem) return;
    const prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    if (prev && has_default(prevGraphicAttributes, channel)) return prevGraphicAttributes[channel];
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).attribute[channel];
  }
  setGraphicAttribute(channel, value, final = true, markName) {
    if (!this.graphicItem) return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    final && (finalGraphicAttributes[channel] = value), has_default(prevGraphicAttributes, channel) || (prevGraphicAttributes[channel] = graphicItem.attribute[channel]), graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true, markName) {
    if (!this.graphicItem) return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    Object.keys(attributes).forEach((key) => {
      final && (finalGraphicAttributes[key] = attributes[key]), has_default(prevGraphicAttributes, key) || (prevGraphicAttributes[key] = graphicItem.attribute[key]);
    }), graphicItem.setAttributes(attributes);
  }
  diffAttributes(graphicAttributes, markName) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes(markName);
    for (const key in graphicAttributes) isEqual2(key, finalGraphicAttributes, graphicAttributes) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  applyGlyphGraphicAttributes(graphicAttributes, markName, graphicItem) {
    var _a, _b;
    if (this.mark.needAnimate()) {
      const nextGraphicAttributes = this.diffAttributes(graphicAttributes, markName), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes(markName)) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes(markName)) && void 0 !== _b ? _b : {};
      Object.keys(nextGraphicAttributes).forEach((channel) => {
        prevGraphicAttributes[channel] = graphicItem.attribute[channel], finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
      }), this.setNextGraphicAttributes(nextGraphicAttributes, markName), this.setPrevGraphicAttributes(prevGraphicAttributes, markName), this.setFinalGraphicAttributes(finalGraphicAttributes, markName), graphicItem.setAttributes(nextGraphicAttributes);
    } else graphicItem.setAttributes(graphicAttributes);
  }
  getFinalGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs;
  }
  setFinalGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs = attributes;
  }
  getPrevGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs;
  }
  setPrevGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs = attributes;
  }
  getNextGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs;
  }
  setNextGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName);
    });
  }
  clearGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), this.setFinalGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName), this.setFinalGraphicAttributes(null, markName);
    });
  }
  remove() {
    this.glyphGraphicItems = null, super.remove();
  }
  release() {
    this.glyphGraphicItems && (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem[BridgeElementKey] = null;
    }), this.glyphGraphicItems = null), super.release();
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/util/element.js
var createElement = (mark) => mark.markType === GrammarMarkType.glyph ? new GlyphElement(mark) : new Element2(mark);

// node_modules/@visactor/vgrammar-core/es/graph/mark/differ.js
function groupData(data, key, sort) {
  const groupedData = /* @__PURE__ */ new Map();
  if (!data || 0 === data.length) return {
    keys: [],
    data: groupedData
  };
  if (!key) return groupedData.set(DefaultKey, sort ? data.slice().sort(sort) : data.slice()), {
    keys: DefaultGroupKeys,
    data: groupedData
  };
  const keyGetter = parseField(key);
  if (1 === data.length) {
    const key2 = keyGetter(data[0]);
    return groupedData.set(key2, [data[0]]), {
      keys: [key2],
      data: groupedData
    };
  }
  const keys2 = /* @__PURE__ */ new Set();
  return data.forEach((entry) => {
    var _a;
    const key2 = keyGetter(entry), lastData = null !== (_a = groupedData.get(key2)) && void 0 !== _a ? _a : [];
    lastData.push(entry), groupedData.set(key2, lastData), keys2.add(key2);
  }), sort && keys2.forEach((key2) => {
    groupedData.get(key2).sort(sort);
  }), {
    keys: Array.from(keys2),
    data: groupedData
  };
}
var Differ = class {
  constructor(data, key, sort) {
    this.prevData = (null == data ? void 0 : data.length) ? groupData(data, null != key ? key : null, sort) : null;
  }
  setCurrentData(currentData) {
    this.currentData = currentData;
  }
  getCurrentData() {
    return this.currentData;
  }
  doDiff() {
    if (this.callback) if (this.currentData && this.prevData) {
      const prevMap = new Map(this.prevData.data);
      this.currentData.keys.forEach((key) => {
        this.callback(key, this.currentData.data.get(key), prevMap.get(key)), prevMap.delete(key);
      }), this.prevData.keys.forEach((key) => {
        prevMap.has(key) && this.callback(key, null, prevMap.get(key));
      });
    } else if (this.currentData) {
      this.currentData.keys.forEach((key) => {
        this.callback(key, this.currentData.data.get(key), null);
      });
    } else this.prevData && this.prevData.keys.forEach((key) => {
      this.callback(key, null, this.prevData.data.get(key));
    });
  }
  setCallback(callback) {
    this.callback = callback;
  }
  updateToCurrent() {
    this.prevData = this.currentData, this.currentData = null;
  }
  reset() {
    this.prevData = null;
  }
};
function diffSingle(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData[0]
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data[0]
    }) : result2.update.push({
      next: data[0],
      prev: prevData[0]
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}
function diffMultiple(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data
    }) : result2.update.push({
      next: data,
      prev: prevData
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}

// node_modules/@visactor/vgrammar-core/es/graph/animation/attribute.js
var transformAnimationAttributes = (attributes, element) => {
  if (!attributes) return null;
  if (attributes.from) {
    const from = attributes.from, fromKeys = Object.keys(from);
    fromKeys.forEach((channel) => {
      isNil_default(from[channel]) && delete from[channel];
    });
    const computePoints = isValidPointsChannel(fromKeys, element.mark.markType) && !isValid_default(from.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, from)
      }));
      attributes.from = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  if (attributes.to) {
    const to = attributes.to, toKeys = Object.keys(to);
    toKeys.forEach((channel) => {
      isNil_default(to[channel]) && delete to[channel];
    });
    const computePoints = isValidPointsChannel(toKeys, element.mark.markType) && !isValid_default(to.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, to)
      }));
      attributes.to = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  return attributes;
};
function typeAnimationAttributes(element, effect, animationParameters, parameters) {
  const options = isFunction_default(effect.options) ? effect.options.call(null, element.getDatum(), element, parameters) : effect.options;
  if (!effect.type || !Factory.getAnimationType(effect.type)) return null;
  const attributes = Factory.getAnimationType(effect.type)(element, options, animationParameters);
  return transformAnimationAttributes(attributes, element);
}
var parseChannelValue = (element, channel, channelValue, animationParameters, parameters) => isFunction_default(channelValue) ? channelValue(element.getDatum(), element, parameters) : channelValue;
function channelAnimationAttributes(element, effect, animationParameters, parameters) {
  const channel = effect.channel;
  let attributes = null;
  return isArray_default(channel) ? attributes = channel.reduce((res, key) => (res.from[key] = element.getGraphicAttribute(key, true), res.to[key] = element.getGraphicAttribute(key, false), res), {
    from: {},
    to: {}
  }) : isObject_default(channel) && (attributes = Object.keys(channel).reduce((res, key) => {
    var _a, _b;
    const hasFrom = !isNil_default(null === (_a = channel[key]) || void 0 === _a ? void 0 : _a.from), hasTo = !isNil_default(null === (_b = channel[key]) || void 0 === _b ? void 0 : _b.to);
    return (hasFrom || hasTo) && (res.from[key] = hasFrom ? parseChannelValue(element, 0, channel[key].from, 0, parameters) : void 0, res.to[key] = hasTo ? parseChannelValue(element, 0, channel[key].to, 0, parameters) : element.getGraphicAttribute(key, false)), res;
  }, {
    from: {},
    to: {}
  })), transformAnimationAttributes(attributes, element);
}
var CustomInterpolator = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this._interpolator = null == params2 ? void 0 : params2.interpolator, this._element = null == params2 ? void 0 : params2.element;
  }
  onBind() {
    var _a, _b;
    this.from = null !== (_a = this.from) && void 0 !== _a ? _a : {}, this.to = null !== (_b = this.to) && void 0 !== _b ? _b : {};
  }
  getEndProps() {
    return this.to;
  }
  onUpdate(end, ratio, out) {
    this._interpolator && this._element && this._interpolator.call(this, ratio, this.from, this.to, out, this._element.getDatum(), this._element, this.params.parameters);
  }
};
var AttributeAnimate = class extends ACustomAnimate {
  getEndProps() {
    return this.to;
  }
  onBind() {
    var _a, _b;
    this.from = null !== (_a = this.from) && void 0 !== _a ? _a : {}, this.to = null !== (_b = this.to) && void 0 !== _b ? _b : {};
  }
  onStart() {
    var _a;
    const excludedChannelMap = null !== (_a = this.target.constructor.NOWORK_ANIMATE_ATTR) && void 0 !== _a ? _a : NOWORK_ANIMATE_ATTR, excludedChannels = Object.keys(excludedChannelMap).filter((channel) => 0 !== excludedChannelMap[channel]);
    this.subAnimate.animate.preventAttrs(excludedChannels);
    const from = Object.assign({}, this.from), to = Object.assign({}, this.to);
    Object.keys(to).forEach((k3) => {
      excludedChannels.includes(k3) ? (from[k3] = to[k3], this.from[k3] = to[k3]) : isNil_default(from[k3]) && (from[k3] = this.target.getComputedAttribute(k3));
    }), this.target.setAttributes(from, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio: 0,
        end: false
      }
    }), this._fromAttribute = from, this._toAttribute = to;
  }
  onEnd() {
    this.target.setAttributes(this._toAttribute, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  update(end, ratio, out) {
    0 === this.updateCount && this.onFirstRun(), this.updateCount += 1;
    const lastProps = this.step.getLastProps();
    Object.keys(lastProps).forEach((key) => {
      this.subAnimate.animate.validAttr(key) && (out[key] = lastProps[key]);
    }), this.onUpdate(end, ratio, out), end && this.onEnd();
  }
  onUpdate(end, ratio, out) {
    this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this._toAttribute, this._fromAttribute);
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animator.js
Animate.mode |= AnimateMode.SET_ATTR_IMMEDIATELY;
var GlobalAnimatorId = 0;
var isCustomAnimateCtor = (custom) => !isNil_default(custom) && custom.prototype instanceof ACustomAnimate;
var Animator = class {
  constructor(element, unit, animationOptions) {
    this.id = GlobalAnimatorId++, this.isAnimating = false, this.runnings = [], this.element = element, this.animationOptions = animationOptions, this.unit = unit;
  }
  callback(callbackFunction) {
    return this.callbackFunction = callbackFunction, this;
  }
  animate(animationParameters, parameters) {
    return this.isAnimating = true, this.animateElement(animationParameters, parameters), 0 === this.runnings.length && this.animationEnd(), this;
  }
  stop(stopState = "end", invokeCallback = true) {
    return this.runnings.forEach((running) => running.stop(stopState)), this.animationEnd(invokeCallback), this;
  }
  pause() {
    return this.runnings.forEach((running) => running.pause()), this;
  }
  resume() {
    return this.runnings.forEach((running) => running.resume()), this;
  }
  startAt(startTime) {
    return this.runnings.forEach((running) => {
      const initialDelay = this.unit.initialDelay;
      running.startAt(initialDelay + startTime);
    }), this;
  }
  getTotalAnimationTime() {
    var _a;
    const timeLineDuration = this.unit.initialDelay + this.unit.loopDuration * this.unit.loopCount;
    return null !== (_a = this.unit.totalTime) && void 0 !== _a ? _a : timeLineDuration;
  }
  getEndAttributes() {
    return this.runnings.reduce((attributes, running) => Object.assign(attributes, running.getEndProps()), {});
  }
  animationEnd(invokeCallback = true) {
    var _a;
    this.isAnimating = false, this.runnings = null, invokeCallback && (null === (_a = this.callbackFunction) || void 0 === _a || _a.call(null));
  }
  animateElement(animationParameters, parameters) {
    const graphicItem = this.element.getGraphicItem();
    if (!graphicItem) return;
    const graphicAnimate = graphicItem.animate();
    this.runnings.push(graphicAnimate), graphicAnimate.startAt(this.unit.initialDelay), graphicAnimate.wait(this.unit.loopDelay), this.unit.timeSlices.forEach((timeSlice) => {
      this.animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters);
    }), graphicAnimate.wait(this.unit.loopDelayAfter), graphicAnimate.loop(this.unit.loopCount - 1), isValidNumber_default(this.unit.totalTime) && setTimeout(() => {
      graphicAnimate && graphicAnimate.stop("end");
    }, this.unit.totalTime), graphicAnimate.onEnd(() => {
      this.runnings = this.runnings.filter((running) => running !== graphicAnimate), 0 === this.runnings.length && this.animationEnd();
    });
  }
  animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters) {
    const delay = timeSlice.delay, delayAfter = timeSlice.delayAfter, duration = timeSlice.duration, effects = timeSlice.effects;
    if (delay > 0 && graphicAnimate.wait(delay), effects.length < 0) graphicAnimate.wait(duration);
    else {
      const customAnimates = effects.map((effect, index) => {
        var _a;
        const attributes = null !== (_a = effect.type ? typeAnimationAttributes(this.element, effect, animationParameters, parameters) : effect.channel ? channelAnimationAttributes(this.element, effect, animationParameters, parameters) : void 0) && void 0 !== _a ? _a : {}, customOption = attributes.custom || (null == effect ? void 0 : effect.custom), customParametersOption = (null == attributes ? void 0 : attributes.customParameters) || (null == effect ? void 0 : effect.customParameters);
        attributes.from && Object.keys(attributes.from).length && this.unit && this.animationOptions.timeline.controlOptions.immediatelyApply && "component" !== this.element.mark.markType && this.element.getGraphicItem().setAttributes(attributes.from);
        const isCustomAnimate = isCustomAnimateCtor(customOption);
        return !isNil_default(customOption) && !isCustomAnimateCtor(customOption) ? new CustomInterpolator(attributes.from, attributes.to, duration, effect.easing, {
          interpolator: customOption,
          element: this.element,
          parameters: customParametersOption
        }) : isCustomAnimate ? new customOption(attributes.from, attributes.to, duration, effect.easing, customParametersOption) : attributes.to ? new AttributeAnimate(attributes.from, attributes.to, duration, effect.easing) : void 0;
      }).filter((animate) => !isNil_default(animate));
      1 === customAnimates.length ? graphicAnimate.play(customAnimates[0]) : customAnimates.length > 1 && graphicAnimate.play(new AnimateGroup(duration, customAnimates));
    }
    delayAfter > 0 && graphicAnimate.wait(delayAfter);
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/config.js
function transformToTimelineConfig(animationConfig2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (isNil_default(animationConfig2.timeSlices)) {
    const typeConfig = animationConfig2;
    return {
      startTime: null !== (_a = typeConfig.startTime) && void 0 !== _a ? _a : DefaultAnimationStartTime,
      totalTime: typeConfig.totalTime,
      oneByOne: null !== (_b = typeConfig.oneByOne) && void 0 !== _b ? _b : DefaultAnimationOneByOne,
      loop: null !== (_c = typeConfig.loop) && void 0 !== _c ? _c : DefaultAnimationLoop,
      controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_d = typeConfig.controlOptions) && void 0 !== _d ? _d : {}),
      timeSlices: [{
        duration: null !== (_e = typeConfig.duration) && void 0 !== _e ? _e : DefaultAnimationDuration,
        delay: null !== (_f = typeConfig.delay) && void 0 !== _f ? _f : DefaultAnimationDelay,
        delayAfter: null !== (_g = typeConfig.delayAfter) && void 0 !== _g ? _g : DefaultAnimationDelayAfter,
        effects: [{
          type: typeConfig.type,
          channel: typeConfig.channel,
          custom: typeConfig.custom,
          easing: null !== (_h = typeConfig.easing) && void 0 !== _h ? _h : DefaultAnimationEasing,
          customParameters: typeConfig.customParameters,
          options: typeConfig.options
        }]
      }]
    };
  }
  const formattedTimeSlices = array(animationConfig2.timeSlices).filter((timeSlice) => timeSlice.effects && array(timeSlice.effects).filter((effect) => effect.channel || effect.type).length);
  if (formattedTimeSlices.length) return {
    startTime: null !== (_j = animationConfig2.startTime) && void 0 !== _j ? _j : DefaultAnimationStartTime,
    totalTime: animationConfig2.totalTime,
    oneByOne: null !== (_k = animationConfig2.oneByOne) && void 0 !== _k ? _k : DefaultAnimationOneByOne,
    loop: null !== (_l = animationConfig2.loop) && void 0 !== _l ? _l : DefaultAnimationLoop,
    controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_m = animationConfig2.controlOptions) && void 0 !== _m ? _m : {}),
    timeSlices: formattedTimeSlices.map((timeSlice) => {
      var _a2, _b2;
      return {
        duration: timeSlice.duration,
        delay: null !== (_a2 = timeSlice.delay) && void 0 !== _a2 ? _a2 : DefaultAnimationDelay,
        delayAfter: null !== (_b2 = timeSlice.delayAfter) && void 0 !== _b2 ? _b2 : DefaultAnimationDelayAfter,
        effects: array(timeSlice.effects).filter((effect) => effect.channel || effect.type).map((effect) => {
          var _a3;
          return {
            type: effect.type,
            channel: effect.channel,
            custom: effect.custom,
            easing: null !== (_a3 = effect.easing) && void 0 !== _a3 ? _a3 : DefaultAnimationEasing,
            customParameters: effect.customParameters,
            options: effect.options
          };
        })
      };
    }),
    partitioner: animationConfig2.partitioner,
    sort: animationConfig2.sort
  };
}
function normalizeAnimationConfig(config2) {
  let normalizedConfig = [];
  return Object.keys(config2).forEach((state) => {
    normalizedConfig = normalizedConfig.concat(normalizeStateAnimationConfig(state, config2[state]));
  }), normalizedConfig;
}
function normalizeStateAnimationConfig(state, config2, initialIndex = 0) {
  const normalizedConfig = [];
  let index = initialIndex;
  return array(config2).forEach((animationConfig2) => {
    var _a;
    const timelineConfig = transformToTimelineConfig(animationConfig2);
    timelineConfig && (normalizedConfig.push({
      state,
      id: null !== (_a = timelineConfig.id) && void 0 !== _a ? _a : `${state}-${index}`,
      timeline: timelineConfig,
      originConfig: animationConfig2
    }), index += 1);
  }), normalizedConfig;
}
function invokeAnimateSpec(spec, element, parameters) {
  return isFunction_default(spec) ? spec.call(null, element.getDatum(), element, parameters) : spec;
}

// node_modules/@visactor/vgrammar-core/es/graph/animation/arranger.js
var Arranger = class {
  constructor(animators) {
    this.parallelArrangers = [this], this.totalTime = 0, this.startTime = 0, this.endTime = 0, this.animators = animators.filter((animator) => !isNil_default(animator)), this.totalTime = this.animators.reduce((time, animator) => Math.max(time, animator.getTotalAnimationTime()), 0);
  }
  parallel(arranger) {
    const parallelArrangers = Array.from(new Set(this.parallelArrangers.concat(arranger.parallelArrangers)));
    return parallelArrangers.forEach((arranger2) => {
      arranger2.parallelArrangers = parallelArrangers;
    }), this.arrangeTime(), this;
  }
  after(arranger) {
    return this.afterArranger = arranger, this.arrangeTime(), this;
  }
  arrangeTime() {
    const parallelTime = this.parallelArrangers.reduce((time, arranger) => Math.max(time, arranger.totalTime), this.totalTime), startTime = this.parallelArrangers.reduce((time, arranger) => {
      var _a, _b;
      return Math.max(time, null !== (_b = null === (_a = arranger.afterArranger) || void 0 === _a ? void 0 : _a.endTime) && void 0 !== _b ? _b : 0);
    }, 0);
    this.parallelArrangers.forEach((arranger) => {
      arranger.startTime = startTime, arranger.endTime = startTime + parallelTime, arranger.animators.forEach((animator) => {
        animator.startAt(startTime);
      });
    });
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animate.js
var Animate2 = class {
  constructor(mark, config2) {
    this.state = null, this.immediateConfigs = [], this.isEnabled = true, this.disabledStates = [], this.animators = /* @__PURE__ */ new Map(), this.elementRecorder = /* @__PURE__ */ new WeakMap(), this.timelineCount = {}, this.mark = mark, this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  getAnimationConfigs(animationState) {
    var _a;
    return this.isEnabled ? (null !== (_a = this.configs) && void 0 !== _a ? _a : []).filter((config2) => config2.state === animationState) : [];
  }
  updateConfig(config2) {
    this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  updateState(state) {
    this.state = state;
  }
  animate() {
    if (!this.isEnabled || !this.configs || !this.configs.length) return;
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters();
    return elements.forEach((element) => {
      var _a;
      element.isReserved && element.diffState !== DiffState.exit && (element.isReserved = false);
      const prevElementState = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.prevState;
      this.configs.some((config2) => prevElementState !== element.diffState && config2.state === prevElementState && config2.timeline.controlOptions.stopWhenStateChange) && this.clearElementAnimation(element, false);
    }), this.configs.forEach((config2) => {
      this.animateByTimeline(config2, elements, parameters);
    }), this.mark.cleanExitElements(), this;
  }
  runAnimationByState(animationState) {
    if (!this.isEnabled) return;
    const stateConfigs = this.configs.filter((config2) => config2.state === animationState), elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = stateConfigs.reduce((animators2, config2) => animators2.concat(this.animateByTimeline(config2, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stopAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.stop()), this;
  }
  pauseAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.pause()), this;
  }
  resumeAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.resume()), this;
  }
  run(config2) {
    if (!this.isEnabled) return;
    const parsedConfigs = normalizeStateAnimationConfig(ImmediateAnimationState, config2, this.immediateConfigs.length);
    this.immediateConfigs = this.immediateConfigs.concat(parsedConfigs);
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = parsedConfigs.reduce((animators2, config3) => animators2.concat(this.animateByTimeline(config3, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stop() {
    return this.animators.forEach((animators) => {
      animators.forEach((animator) => animator.stop());
    }), this;
  }
  pause() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.pause())), this;
  }
  resume() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.resume())), this;
  }
  reverse() {
    return this;
  }
  restart() {
    return this;
  }
  record() {
    return this;
  }
  recordEnd() {
    return this;
  }
  isAnimating() {
    let isAnimating = false;
    return this.animators.forEach((animators) => {
      isAnimating = isAnimating || animators.some((animator) => animator.isAnimating);
    }), isAnimating;
  }
  isElementAnimating(element) {
    var _a;
    const stateAnimationCounts = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.count;
    return isNil_default(stateAnimationCounts) || Object.values(stateAnimationCounts).every((count) => 0 === count);
  }
  getAnimatorCount() {
    let count = 0;
    return this.animators.forEach((animators) => count += animators.length), count;
  }
  getAllAnimators() {
    const allAnimators = [];
    return this.animators.forEach((animators) => {
      allAnimators.push(...animators);
    }), allAnimators;
  }
  getElementAnimators(element, animationState) {
    var _a;
    const elements = array(element);
    let animators = [];
    return animationState ? animators = null !== (_a = this.animators.get(animationState)) && void 0 !== _a ? _a : [] : this.animators.forEach((stateAnimators) => {
      animators = animators.concat(stateAnimators);
    }), animators.filter((animator) => elements.includes(animator.element));
  }
  enable() {
    return this.isEnabled = true, this;
  }
  disable() {
    return this.isEnabled = false, this.stop(), this.animators.clear(), this;
  }
  enableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.filter((state2) => !states.includes(state2)), this;
  }
  disableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.concat(states), this;
  }
  release() {
    this.stop(), this.animators.clear(), this.configs = null, this.animators = null, this.elementRecorder = null, this.timelineCount = null;
  }
  animateByTimeline(config2, elements, parameters, forceState = false) {
    var _a;
    const animators = [], animatedElements = elements.filter((element) => {
      const checkExit = !(element.isReserved && element.diffState === DiffState.exit), state = this.getAnimationState(element), checkDisabled = !this.disabledStates.includes(state), checkState = forceState || state === config2.state, checkPartitioner = !config2.timeline.partitioner || config2.timeline.partitioner(element.getDatum(), element, parameters);
      return checkExit && checkDisabled && checkState && checkPartitioner;
    });
    if (animatedElements.length) {
      isNil_default(this.timelineCount[config2.id]) && (this.timelineCount[config2.id] = 0), config2.timeline.sort && animatedElements.sort((elementA, elementB) => config2.timeline.sort(elementA.getDatum(), elementB.getDatum(), elementA, elementB, parameters));
      const animationParameters = {
        width: this.mark.view.width(),
        height: this.mark.view.height(),
        group: null !== (_a = this.mark.group) && void 0 !== _a ? _a : null,
        mark: this.mark,
        view: this.mark.view,
        elementCount: animatedElements.length,
        elementIndex: 0
      };
      animatedElements.forEach((element, index) => {
        animationParameters.elementIndex = index;
        const mergedParameters = Object.assign({
          [DefaultAnimationParameters]: animationParameters
        }, parameters), animationUnit = this.getAnimationUnit(config2.timeline, element, index, animatedElements.length, mergedParameters);
        animators.push(this.animateElement(config2, animationUnit, element, animationParameters, mergedParameters));
      });
    }
    return animators;
  }
  animateElement(config2, animationUnit, element, animationParameters, parameters) {
    var _a, _b;
    const animator = new Animator(element, animationUnit, config2);
    if (animator.animate(animationParameters, parameters), !animator.isAnimating) return;
    element.diffState === DiffState.exit && (element.isReserved = true);
    const isFirstAnimator = 0 === this.timelineCount[config2.id];
    this.timelineCount[config2.id] += 1;
    const elementRecord = null !== (_a = this.elementRecorder.get(element)) && void 0 !== _a ? _a : {
      prevState: config2.state,
      count: {}
    };
    elementRecord.prevState = config2.state, elementRecord.count[config2.state] = (null !== (_b = elementRecord.count[config2.state]) && void 0 !== _b ? _b : 0) + 1, this.elementRecorder.set(element, elementRecord);
    const stateData = this.animators.get(config2.state);
    stateData ? stateData.push(animator) : this.animators.set(config2.state, [animator]), animator.callback(() => {
      this.handleAnimatorEnd(animator);
    });
    const animationEvent = {
      mark: this.mark,
      animationState: config2.state,
      animationConfig: config2.originConfig
    };
    return isFirstAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_START, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_START, animationEvent, element), animator;
  }
  getAnimationState(element) {
    const customState = invokeFunctionType(this.state, this.mark.parameters(), element.getDatum(), element);
    return null != customState ? customState : element.diffState;
  }
  getAnimationUnit(timeline, element, index, elementCount, parameters) {
    const timeSlices = [], startTime = invokeAnimateSpec(timeline.startTime, element, parameters), totalTime = invokeAnimateSpec(timeline.totalTime, element, parameters), oneByOne = invokeAnimateSpec(timeline.oneByOne, element, parameters), loop = invokeAnimateSpec(timeline.loop, element, parameters);
    let loopTime = 0;
    timeline.timeSlices.forEach((timeSlice) => {
      var _a;
      const delay = invokeAnimateSpec(timeSlice.delay, element, parameters), delayAfter = invokeAnimateSpec(timeSlice.delayAfter, element, parameters), duration = null !== (_a = invokeAnimateSpec(timeSlice.duration, element, parameters)) && void 0 !== _a ? _a : totalTime / elementCount, effects = array(timeSlice.effects).map((effect) => Object.assign({}, effect, {
        customParameters: invokeAnimateSpec(effect.customParameters, element, parameters)
      }));
      timeSlices.push({
        effects,
        duration,
        delay,
        delayAfter
      }), loopTime += delay + duration + delayAfter;
    });
    const oneByOneDelay = isNumber_default(oneByOne) ? oneByOne : true === oneByOne ? loopTime : 0;
    return {
      initialDelay: startTime,
      loopCount: isNumber_default(loop) ? loop : true === loop ? 1 / 0 : 1,
      loopDelay: oneByOneDelay * index,
      loopDelayAfter: oneByOneDelay * (elementCount - index - 1),
      loopAnimateDuration: loopTime,
      loopDuration: loopTime + oneByOneDelay * (elementCount - 1),
      totalTime,
      timeSlices
    };
  }
  clearElementAnimation(element, clearElement = true) {
    this.animators.forEach((animators) => {
      animators.forEach((animator) => {
        animator.element === element && (animator.animationOptions.state === DiffState.exit ? animator.stop("start", false) : animator.stop("end", false), this.handleAnimatorEnd(animator, clearElement));
      });
    }), this.elementRecorder.delete(element);
  }
  clearAllElements() {
    const elements = this.mark.getAllElements();
    elements && elements.forEach((element, i2) => {
      this.clearElement(element, i2 === elements.length - 1);
    });
  }
  clearElement(element, updateMark = true) {
    this.clearElementAnimation(element), element.getGraphicItem() && (element.clearGraphicAttributes(), element.diffState === DiffState.exit && (element.isReserved = false), updateMark && this.mark.cleanExitElements());
  }
  handleAnimatorEnd(animator, clearElement = true) {
    const element = animator.element, animationOptions = animator.animationOptions, animationState = animationOptions.state, isImmediateAnimation = animationState === ImmediateAnimationState, stateAnimationCounts = this.elementRecorder.get(element).count;
    stateAnimationCounts[animationState] -= 1, this.animators.set(animationState, this.animators.get(animationState).filter((ani) => ani !== animator)), 0 === this.animators.get(animationState).length && this.animators.delete(animationState), this.timelineCount[animationOptions.id] -= 1;
    const isLastAnimator = 0 === this.timelineCount[animationOptions.id], originAnimationConfig = isImmediateAnimation ? this.immediateConfigs.find((config2) => config2.id === animationOptions.id).originConfig : this.configs.find((config2) => config2.id === animationOptions.id).originConfig;
    isLastAnimator && (delete this.timelineCount[animationOptions.id], isImmediateAnimation && (this.immediateConfigs = this.immediateConfigs.filter((config2) => config2.id !== animationOptions.id))), clearElement && (0 === Object.keys(this.timelineCount).length ? this.clearAllElements() : animationState === DiffState.exit && 0 === stateAnimationCounts[DiffState.exit] && this.clearElement(element));
    const animationEvent = {
      mark: this.mark,
      animationState,
      animationConfig: originAnimationConfig
    };
    isLastAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_END, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_END, animationEvent, element);
  }
};

// node_modules/@visactor/vgrammar-core/es/view/mark.js
var __awaiter11 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mark = class extends GrammarBase {
  constructor(view, markType, group) {
    super(view), this.grammarType = "mark", this.elements = [], this.elementMap = /* @__PURE__ */ new Map(), this.isUpdated = true, this._isReentered = false, this.animate = new Animate2(this, {}), this.differ = new Differ([]), this.evaluateSync = (data, parameters) => {
      var _a;
      return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || this.evaluateTransformSync(this._getTransformsAfterEncode(), this.elements, parameters), this;
    }, this.markType = markType, this.spec.type = markType, this.spec.encode = {
      update: {}
    }, this.spec.group = group, group && (this.group = group, this.attach(group), group.appendChild(this));
  }
  parse(spec) {
    var _a, _b, _c;
    if (super.parse(spec), this.spec.group) {
      const groupMark2 = isString_default(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;
      this.detach(groupMark2);
    }
    const groupMark = isString_default(spec.group) ? this.view.getMarkById(spec.group) : spec.group;
    return this.attach(groupMark), this.join(null === (_a = spec.from) || void 0 === _a ? void 0 : _a.data, spec.key, spec.sort, spec.groupBy, spec.groupSort), this.coordinate(spec.coordinate), this.state(spec.state, this.spec.stateSort), Object.keys(null !== (_b = this.spec.encode) && void 0 !== _b ? _b : {}).forEach((state) => {
      this.encodeState(state, {}, true);
    }), Object.keys(null !== (_c = spec.encode) && void 0 !== _c ? _c : {}).forEach((state) => {
      this.encodeState(state, spec.encode[state]);
    }), this.animation(spec.animation), this.animationState(spec.animationState), this.morph(spec.morph, spec.morphKey, spec.morphElementKey), this.layout(spec.layout), this.configure(spec), this.transform(spec.transform), this.parseAddition(spec), this.spec = spec, this.markType = spec.type, this.commit(), this;
  }
  parameters() {
    var _a;
    return null !== (_a = this._finalParameters) && void 0 !== _a ? _a : super.parameters();
  }
  parseAddition(spec) {
    return this;
  }
  reuse(grammar) {
    if (grammar.grammarType !== this.grammarType) return this;
    const mark = grammar;
    return this.markType = mark.markType, this.coord = mark.coord, this.elementMap = mark.elementMap, this.elements = mark.elements, this.elementMap.forEach((element) => element.mark = this), this.differ = mark.differ, this.animate = mark.animate, this.animate.mark = this, this._context = mark._context, this.graphicItem = mark.graphicItem, this.graphicIndex = mark.graphicIndex, this.graphicParent = mark.graphicParent, this.needClear = mark.needClear, this.isUpdated = mark.isUpdated, this;
  }
  needLayout() {
    return !isNil_default(this.spec.layout);
  }
  handleLayoutEnd() {
  }
  handleRenderEnd() {
    this.needClear && (this.cleanExitElements(), this.elementMap.forEach((element) => {
      element.diffState === DiffState.exit ? element.clearGraphicAttributes() : element.clearChangedGraphicAttributes();
    }), this.differ.updateToCurrent(), this.needClear = false);
  }
  evaluateMainTasks(data, parameters) {
    var _a;
    if (this.needSkipBeforeLayout() && this.view.getLayoutState() === LayoutState.before) return this;
    const stage = null === (_a = this.view.renderer) || void 0 === _a ? void 0 : _a.stage();
    this.init(stage, parameters);
    const transformData = this.evaluateTransformSync(this._getTransformsBeforeJoin(), null != data ? data : DefaultMarkData, parameters);
    let inputData = (null == transformData ? void 0 : transformData.progressive) ? data : transformData;
    return this.evaluateGroup(inputData), this.renderContext = this.parseRenderContext(inputData, parameters), this.renderContext.progressive ? (this.differ.reset(), this.elementMap.clear(), this.evaluateProgressive()) : ((null == transformData ? void 0 : transformData.progressive) && (this.renderContext.parameters = parameters, this.renderContext.beforeTransformProgressive = transformData.progressive, inputData = transformData.progressive.output()), this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(inputData), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), parameters), this.emit(HOOK_EVENT.AFTER_MARK_ENCODE)), this.emit(HOOK_EVENT.BEFORE_MARK_UPDATE), this.update(this.spec), this.emit(HOOK_EVENT.AFTER_MARK_UPDATE), this;
  }
  evaluateGroup(data) {
    if (this.markType === GrammarMarkType.group) return;
    const res = groupData(null != data ? data : DefaultMarkData, this.spec.groupBy, this.spec.groupSort), groupKeys = res.keys;
    this._groupKeys = groupKeys, this.differ.setCurrentData(res);
  }
  _getTransformsAfterEncodeItems() {
    return this.transforms && this.transforms.filter((entry) => "afterEncodeItems" === entry.markPhase);
  }
  _getTransformsAfterEncode() {
    return this.transforms && this.transforms.filter((entry) => isNil_default(entry.markPhase) || "afterEncode" === entry.markPhase);
  }
  _getTransformsBeforeJoin() {
    return this.transforms ? this.transforms.filter((entry) => "beforeJoin" === entry.markPhase) : [];
  }
  evaluate(data, parameters) {
    var _a;
    return __awaiter11(this, void 0, void 0, function* () {
      return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || (yield this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, parameters)), this;
    });
  }
  output() {
    return this;
  }
  join(data, key, sort, groupBy2, groupSort) {
    return this.grammarSource && (this.detach(this.grammarSource), this.grammarSource = null), this.spec.from = null, isNil_default(data) || (isString_default(data) ? this.grammarSource = this.view.getDataById(data) : this.grammarSource = data, this.spec.from = {
      data
    }, this.attach(this.grammarSource)), this.spec.key = key, this.spec.sort = sort, this.spec.groupBy = groupBy2, this.spec.groupSort = groupSort, this.commit(), this;
  }
  coordinate(coordinate) {
    return isString_default(coordinate) ? this.coord = this.view.getCoordinateById(coordinate) : this.coord = coordinate, this.attach(this.coord), this.commit(), this;
  }
  state(state, stateSort) {
    return this.spec.stateSort = stateSort, this.setFunctionSpec(state, "state");
  }
  encode(channel, value, clear) {
    return this.encodeState(DiffState.update, channel, value, clear);
  }
  encodeState(state, channel, value, clear) {
    if (state === DiffState.enter && (this._isReentered = true), this.spec.encode[state]) {
      const lastEncoder = this.spec.encode[state];
      if (isFunctionType(lastEncoder)) this.detach(parseEncodeType(lastEncoder, this.view));
      else {
        const isSingleChannel = isString_default(channel);
        isSingleChannel && clear || !isSingleChannel && value ? (Object.keys(lastEncoder).forEach((c4) => {
          this.detach(parseEncodeType(lastEncoder[c4], this.view));
        }), this.spec.encode[state] = {}) : isSingleChannel ? this.detach(parseEncodeType(lastEncoder[channel], this.view)) : Object.keys(channel).forEach((c4) => {
          this.detach(parseEncodeType(lastEncoder[c4], this.view));
        });
      }
    }
    return channel && (this.spec.encode[state] || (this.spec.encode[state] = {}), isString_default(channel) ? (this.spec.encode[state][channel] = value, this.attach(parseEncodeType(value, this.view))) : isFunctionType(channel) ? (this.spec.encode[state] = channel, this.attach(parseEncodeType(channel, this.view))) : channel && (Object.assign(this.spec.encode[state], channel), Object.values(channel).forEach((channelEncoder) => {
      this.attach(parseEncodeType(channelEncoder, this.view));
    }))), this.commit(), this;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this.spec.encode) && void 0 !== _a ? _a : {};
  }
  animation(animationConfig2) {
    return this.spec.animation = animationConfig2, this;
  }
  animationState(animationState) {
    return this.setFunctionSpec(animationState, "animationState");
  }
  layout(layout2) {
    return this.spec.layout = layout2, this.commit(), this;
  }
  morph(enableMorph, morphKey, morphElementKey) {
    return this.spec.morph = enableMorph, this.spec.morphKey = morphKey, this.spec.morphElementKey = morphElementKey, this;
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []);
    const nextTransforms = parseTransformSpec(transforms, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.spec.transform = transforms, this.commit(), this;
  }
  configure(config2) {
    const keys2 = ["clip", "zIndex", "interactive", "context", "setCustomizedShape", "large", "largeThreshold", "progressiveStep", "progressiveThreshold", "support3d", "morph", "morphKey", "morphElementKey", "attributeTransforms", "skipTheme", "enableSegments"];
    return null === config2 ? (keys2.forEach((key) => {
      isNil_default(this.spec[key]) || (this.spec[key] = void 0);
    }), this) : (keys2.forEach((key) => {
      isNil_default(config2[key]) || (this.spec[key] = config2[key]);
    }), this);
  }
  context(context) {
    return this.spec.context = context, this._context = context, this;
  }
  isCollectionMark() {
    return CollectionMarkType.includes(this.markType);
  }
  needAnimate() {
    var _a;
    return !(null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) && !isNil_default(this.spec.animation);
  }
  getAllElements() {
    const elements = this.elements.slice();
    return this.elementMap.forEach((element) => {
      element.diffState !== DiffState.exit || elements.includes(element) || elements.push(element);
    }), this.spec.sort && elements.sort((elementA, elementB) => this.spec.sort(elementA.getDatum(), elementB.getDatum())), elements;
  }
  getScales() {
    const scales = {};
    return this.references.forEach((count, ref) => {
      ref.grammarType === GrammarTypeEnum.scale && (scales[ref.id()] = ref.output());
    }), scales;
  }
  getScalesByChannel() {
    const encoders = this.spec.encode;
    if (!encoders) return {};
    const res = {}, params2 = this.parameters();
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      useEncoders && !isFunctionType(useEncoders) && Object.keys(useEncoders).forEach((channel) => {
        isScaleEncode(useEncoders[channel]) && (res[channel] = getGrammarOutput(useEncoders[channel].scale, params2));
      });
    }), res;
  }
  getFieldsByChannel() {
    const encoders = this.spec.encode;
    if (!encoders) return {};
    const res = {};
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      isFunctionType(useEncoders) || Object.keys(useEncoders).forEach((channel) => {
        isFieldEncode(useEncoders[channel]) && (res[channel] = useEncoders[channel].field);
      });
    }), res;
  }
  init(stage, parameters) {
    var _a, _b, _c, _d;
    if (this._delegateEvent || (this._delegateEvent = (event, type) => {
      var _a2;
      const activeElement = null === (_a2 = event.target) || void 0 === _a2 ? void 0 : _a2[BridgeElementKey];
      if ((null == activeElement ? void 0 : activeElement.mark) === this) {
        const extendedEvt = getExtendedEvents(this.view, event, activeElement, type, EVENT_SOURCE_VIEW);
        this.emitGrammarEvent(type, extendedEvt, activeElement);
      }
    }, this.initEvent()), this.animate || (this.animate = new Animate2(this, this.spec.animation), this.needAnimate() && this.animate.updateState(this.spec.animationState)), !this.group) {
      const group = getGrammarOutput(this.spec.group, parameters);
      this.group = group, group && group.appendChild(this);
    }
    const groupGraphicItem = this.group ? this.group.getGroupGraphicItem() : stage.defaultLayer, markIndex = null !== (_c = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.children) || void 0 === _b ? void 0 : _b.indexOf(this)) && void 0 !== _c ? _c : 0;
    if (this.markType !== GrammarMarkType.group) {
      if (!this.graphicItem) {
        const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
          pickable: false,
          zIndex: null !== (_d = this.spec.zIndex) && void 0 !== _d ? _d : 0
        });
        (this.spec.support3d || Mark3DType.includes(this.markType)) && graphicItem.setMode("3d"), graphicItem.name = `${this.id() || this.markType}`, this.graphicItem = graphicItem;
      }
      this.graphicParent = this.graphicItem, !groupGraphicItem || this.graphicIndex === markIndex && this.graphicItem.parent === groupGraphicItem || groupGraphicItem.insertIntoKeepIdx(this.graphicItem, markIndex);
    } else this.graphicParent = groupGraphicItem;
    this.graphicIndex = markIndex;
  }
  update(spec) {
    this._context = this.spec.context, this.isUpdated = true, this.renderContext.progressive || (spec.animation && this.animate.updateConfig(spec.animation), this.animate.updateState(spec.animationState)), this.markType !== GrammarMarkType.group ? (isNil_default(spec.zIndex) || this.graphicItem.setAttribute("zIndex", spec.zIndex), isNil_default(spec.clip) || this.graphicItem.setAttribute("clip", spec.clip), this.elementMap.forEach((element) => {
      element.updateGraphicItem({
        interactive: spec.interactive
      });
    })) : this.elementMap.forEach((element) => {
      element.updateGraphicItem({
        clip: spec.clip,
        zIndex: spec.zIndex,
        interactive: spec.interactive
      });
    });
  }
  evaluateJoin(data) {
    var _a, _b, _c, _d;
    this.needClear = true;
    const keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), groupKeyGetter = parseField(null !== (_d = this.spec.groupBy) && void 0 !== _d ? _d : () => DefaultKey), sort = this.spec.sort, isCollectionMark = this.isCollectionMark(), enterElements = new Set(this.elements.filter((element) => element.diffState === DiffState.enter)), elements = [];
    this.differ.setCallback((key, data2, prevData) => {
      const elementKey = key;
      let element;
      if (isNil_default(data2)) element = this.elementMap.get(elementKey), element && (element.diffState = DiffState.exit);
      else if (isNil_default(prevData)) {
        if (element = this.elementMap.has(elementKey) ? this.elementMap.get(elementKey) : createElement(this), element.diffState === DiffState.exit) {
          element.diffState = DiffState.enter;
          this.animate.getElementAnimators(element, DiffState.exit).forEach((animator) => animator.stop("start"));
        }
        element.diffState = DiffState.enter;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter, this.view), this.elementMap.set(elementKey, element), elements.push(element);
      } else if (element = this.elementMap.get(elementKey), element) {
        element.diffState = DiffState.update;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter, this.view), elements.push(element);
      }
      enterElements.delete(element);
    });
    const currentData = null != data ? data : DefaultMarkData;
    isCollectionMark || this.differ.setCurrentData(groupData(currentData, (datum) => `${groupKeyGetter(datum)}-${keyGetter(datum)}`, void 0)), this.differ.doDiff(), enterElements.forEach((element) => {
      this.elementMap.delete(isCollectionMark ? element.groupKey : `${element.groupKey}-${element.key}`), element.remove(), element.release();
    }), this.elements = elements, sort && this.elements.length >= 2 && this.elements.sort((elementA, elementB) => sort(elementA.getDatum(), elementB.getDatum()));
  }
  evaluateState(elements, stateSpec, parameters) {
    stateSpec && elements.forEach((element) => {
      element.state(stateSpec, parameters);
    });
  }
  evaluateGroupEncode(elements, groupEncode, parameters) {
    var _a;
    if (this.markType === GrammarMarkType.group) {
      const el = this.elements[0], nextAttrs = {}, items = [Object.assign({}, null === (_a = el.items) || void 0 === _a ? void 0 : _a[0], {
        nextAttrs
      })];
      return invokeEncoderToItems(el, items, groupEncode, parameters), nextAttrs;
    }
    if (!this._groupKeys || !groupEncode) return;
    const res = {};
    return this._groupKeys.forEach((key) => {
      const el = elements.find((el2) => el2.groupKey === key);
      el && (res[key] = invokeEncoder(groupEncode, el.items && el.items[0] && el.items[0].datum, el, parameters));
    }), res;
  }
  evaluateEncode(elements, encoders, parameters) {
    if (encoders) {
      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
      const groupEncodeAttrs = this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
      elements.forEach((element) => {
        this.markType === GrammarMarkType.group && groupEncodeAttrs ? element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs);
        }) : (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && !this.isCollectionMark() && element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs[element.groupKey]);
        }), element.encodeItems(element.items, encoders, this._isReentered, parameters);
      }), this._isReentered = false, this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
        element.encodeGraphic(this.isCollectionMark() ? null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey] : null);
      }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
    } else elements.forEach((element) => {
      element.initGraphicItem();
    });
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    var _a;
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem) {
      if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) {
        let group;
        if (this._groupKeys) {
          const index = this._groupKeys.indexOf(groupKey);
          index >= 0 && (group = this.graphicParent.getChildAt(index));
        } else group = this.graphicParent.at(0);
        this.isCollectionMark() ? (graphicItem.incremental = 1, group.appendChild(graphicItem)) : group.incrementalAppendChild(graphicItem);
      } else this.graphicParent.appendChild(graphicItem);
      return graphicItem;
    }
  }
  parseRenderContext(data, parameters) {
    const enableProgressive = this.markType !== GrammarMarkType.group && this.spec.progressiveStep > 0 && this.spec.progressiveThreshold > 0 && this.spec.progressiveStep < this.spec.progressiveThreshold, large = this.spec.large && this.spec.largeThreshold > 0 && data.length >= this.spec.largeThreshold;
    if (enableProgressive) {
      const groupedData = this.differ.getCurrentData();
      return groupedData && groupedData.keys && groupedData.keys.some((key) => groupedData.data.get(key).length > this.spec.progressiveThreshold) ? {
        large,
        parameters,
        progressive: {
          data,
          step: this.spec.progressiveStep,
          currentIndex: 0,
          totalStep: groupedData.keys.reduce((total, key) => Math.max(Math.ceil(groupedData.data.get(key).length / this.spec.progressiveStep), total), 1),
          groupedData: groupedData.data
        }
      } : {
        large
      };
    }
    return {
      large
    };
  }
  isProgressive() {
    return this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive);
  }
  isDoingProgressive() {
    return this.renderContext && (this.renderContext.progressive && this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep || this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished());
  }
  clearProgressive() {
    this.renderContext && this.renderContext.progressive && (this.elements = [], this.graphicParent.children.forEach((group) => {
      group.incrementalClearChild();
    }), this.graphicParent.removeAllChild()), this.renderContext && this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.release(), this.renderContext = null;
  }
  restartProgressive() {
    this.renderContext && this.renderContext.progressive && (this.renderContext.progressive.currentIndex = 0);
  }
  evaluateJoinProgressive() {
    var _a, _b, _c;
    const currentIndex = this.renderContext.progressive.currentIndex, keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), elements = [];
    if (this.isCollectionMark()) return this._groupKeys.forEach((key, index) => {
      const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);
      if (0 === currentIndex) {
        const element = createElement(this);
        element.diffState = DiffState.enter, element.updateData(key, dataSlice, keyGetter, this.view), elements.push(element);
      } else {
        const element = this.elements[index];
        element.updateData(key, dataSlice, keyGetter, this.view), elements.push(element);
      }
    }), elements;
    const groupElements = {};
    return this._groupKeys.forEach((key) => {
      const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep), group = [];
      dataSlice.forEach((entry) => {
        const element = createElement(this);
        element.diffState = DiffState.enter, element.updateData(key, [entry], keyGetter, this.view), group.push(element), elements.push(element);
      }), groupElements[key] = group;
    }), {
      groupElements,
      elements
    };
  }
  evaluateEncodeProgressive(elements, encoders, parameters) {
    if (!encoders) return void elements.forEach((element) => {
      element.initGraphicItem();
    });
    const positionEncoders = Object.keys(encoders).reduce((res, state) => (!encoders[state] || state !== BuiltInEncodeNames.enter && state !== BuiltInEncodeNames.exit && state !== BuiltInEncodeNames.update || (res[state] = splitEncoderInLarge(this.markType, encoders[state], this.glyphType).positionEncoder), res), {}), progressiveIndex = this.renderContext.progressive.currentIndex, isCollection = this.isCollectionMark();
    this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
      encoders,
      parameters
    }, this);
    const groupEncodeAttrs = this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
    if (elements.forEach((element, index) => {
      const onlyPos = progressiveIndex > 0 || !isCollection && index > 0;
      !onlyPos && (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && element.items.forEach((item) => {
        item.nextAttrs = Object.assign(item.nextAttrs, groupEncodeAttrs[element.groupKey]);
      }), element.encodeItems(element.items, onlyPos ? positionEncoders : encoders, this._isReentered, parameters);
    }), this._isReentered = false, this.evaluateTransformSync(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
      element.encodeGraphic();
    }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
      encoders,
      parameters
    }, this), 0 === progressiveIndex && !isCollection) {
      const firstChild = elements[0].getGraphicItem(), group = null == firstChild ? void 0 : firstChild.parent;
      if (group) {
        const attrs = firstChild.attribute, theme2 = {}, itemAttrs = {};
        Object.keys(attrs).forEach((key) => {
          ["pickable", "zIndex"].includes(key) || (isPositionOrSizeChannel(this.markType, key) ? itemAttrs[key] = attrs[key] : theme2[key] = attrs[key]);
        }), group.setTheme({
          common: theme2
        }), firstChild.initAttributes(itemAttrs);
      }
    }
  }
  evaluateProgressive() {
    var _a, _b, _c;
    if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.beforeTransformProgressive) {
      this.renderContext.beforeTransformProgressive.progressiveRun();
      const output = this.renderContext.beforeTransformProgressive.output();
      return this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(output), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters), void this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    }
    if (!(null === (_b = this.renderContext) || void 0 === _b ? void 0 : _b.progressive)) return;
    const parameters = this.renderContext.parameters;
    this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);
    const result2 = this.evaluateJoinProgressive(), elements = Array.isArray(result2) ? result2 : result2.elements;
    if (this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 0 === this.renderContext.progressive.currentIndex ? (this.graphicParent.removeAllChild(), this._groupKeys.forEach((key) => {
      const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
        pickable: false,
        zIndex: this.spec.zIndex
      });
      graphicItem.incremental = this.renderContext.progressive.step, this.graphicParent.appendChild(graphicItem);
    }), this.elements = elements) : this.elements = this.elements.concat(elements), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), Array.isArray(result2)) this.evaluateEncodeProgressive(elements, this._getEncoders(), parameters);
    else {
      const groupElements = result2.groupElements;
      Object.keys(groupElements).forEach((key) => {
        this.evaluateEncodeProgressive(groupElements[key], this._getEncoders(), parameters);
      });
    }
    this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    const progressiveTransforms = null === (_c = this._getTransformsAfterEncode()) || void 0 === _c ? void 0 : _c.filter((entry) => true === entry.canProgressive);
    (null == progressiveTransforms ? void 0 : progressiveTransforms.length) && this.evaluateTransformSync(progressiveTransforms, this.elements, parameters), this.renderContext.progressive.currentIndex += 1;
  }
  isLargeMode() {
    return this.renderContext && this.renderContext.large;
  }
  cleanExitElements() {
    this.elementMap.forEach((element, key) => {
      element.diffState !== DiffState.exit || element.isReserved || (this.elementMap.delete(key), element.remove(), element.release());
    });
  }
  getGroupGraphicItem() {
    if (this.elements && this.elements[0] && this.elements[0].getGraphicItem) return this.elements[0].getGraphicItem();
  }
  getBounds() {
    var _a;
    return this.graphicItem ? this.graphicItem.AABBBounds : null === (_a = this.getGroupGraphicItem()) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getMorphConfig() {
    var _a;
    return {
      morph: null !== (_a = this.spec.morph) && void 0 !== _a && _a,
      morphKey: this.spec.morphKey,
      morphElementKey: this.spec.morphElementKey
    };
  }
  getAttributeTransforms() {
    var _a;
    return null !== (_a = this.spec.attributeTransforms) && void 0 !== _a ? _a : transformsByType[this.markType];
  }
  getContext() {
    return this._context;
  }
  needSkipBeforeLayout() {
    var _a, _b;
    if (true === (null === (_a = this.spec.layout) || void 0 === _a ? void 0 : _a.skipBeforeLayouted)) return true;
    let group = this.group;
    for (; group; ) {
      if (true === (null === (_b = group.getSpec().layout) || void 0 === _b ? void 0 : _b.skipBeforeLayouted)) return true;
      group = group.group;
    }
    return false;
  }
  initEvent() {
    if (this._delegateEvent) {
      this.view.renderer.stage().on("*", this._delegateEvent);
    }
  }
  releaseEvent() {
    if (this._delegateEvent) {
      const stage = this.view.renderer.stage();
      stage && stage.off("*", this._delegateEvent);
    }
  }
  clear() {
    var _a;
    super.clear(), this.transforms = null, this.elementMap = null, this.elements = null, this.graphicItem = null, this.animate = null, null === (_a = this.group) || void 0 === _a || _a.removeChild(this), this.group = null;
  }
  prepareRelease() {
    this.animate.stop(), this.elementMap.forEach((element) => element.diffState = DiffState.exit), this._finalParameters = this.parameters();
  }
  release() {
    this.releaseEvent(), this.elements.forEach((element) => element.release()), this.elementMap.clear(), this._finalParameters = null, this.animate && this.animate.release(), this.graphicItem && removeGraphicItem(this.graphicItem), this.detachAll(), super.release();
  }
};

// node_modules/@visactor/vgrammar-core/es/view/group.js
var GroupMark = class extends Mark {
  constructor(view, group) {
    super(view, GrammarMarkType.group, group), this.children = [];
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  appendChild(mark) {
    return this.children.push(mark), this;
  }
  removeChild(mark) {
    return this.children = this.children.filter((child) => child !== mark), this;
  }
  includesChild(mark, descendant = true) {
    return !!this.children.includes(mark) || !!descendant && this.children.some((child) => child.markType === GrammarMarkType.group && child.includesChild(mark, true));
  }
  updateLayoutChildren() {
    return this.children.length ? (this.layoutChildren || (this.layoutChildren = []), this.layoutChildren = this.children.filter((child) => child.needLayout()), this) : this;
  }
  getAttributeTransforms() {
    return transformsByType.rect;
  }
  evaluateJoin(data) {
    if (!this.elements.length) {
      const el = createElement(this);
      el.updateData(DefaultKey, DefaultMarkData, () => "", this.view), this.elements = [el], this.elementMap.set(DefaultKey, el);
    }
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem) return this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK), graphicItem.name = `${this.id() || this.markType}`, this.graphicParent.insertIntoKeepIdx(graphicItem, this.graphicIndex), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK), graphicItem;
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/layout/grid.js
function parseTemplate(template, total) {
  if (isValidNumber_default(template)) return template;
  const trimmedTemplate = template.trim();
  if ("auto" === trimmedTemplate) return 0;
  if (trimmedTemplate.endsWith("%")) {
    const percent = parseFloat(trimmedTemplate.substring(0, trimmedTemplate.length - 1));
    return isValidNumber_default(percent) ? percent * total : 0;
  }
  return 0;
}
function computeGrid(layout2, width, height) {
  var _a, _b, _c, _d;
  const templateRows = null !== (_a = layout2.gridTemplateRows) && void 0 !== _a ? _a : [height], templateColumns = null !== (_b = layout2.gridTemplateColumns) && void 0 !== _b ? _b : [width], rowGap = null !== (_c = layout2.gridRowGap) && void 0 !== _c ? _c : 0, columnGap = null !== (_d = layout2.gridColumnGap) && void 0 !== _d ? _d : 0, rows = templateRows.map((row) => parseTemplate(row, height)), columns = templateColumns.map((column) => parseTemplate(column, width)), rowAuto = Math.max(0, rows.reduce((left2, row) => left2 - row, height) - rows.length * rowGap) / templateRows.filter((row) => "auto" === row).length, columnAuto = Math.max(0, columns.reduce((left2, column) => left2 - column, width) - columns.length * columnGap) / templateColumns.filter((column) => "auto" === column).length;
  let lastRow = 0;
  const accumulateRows = rows.map((row, index) => {
    const finalRow = "auto" === templateRows[index] ? rowAuto : row, last2 = lastRow;
    return lastRow += finalRow + rowGap, last2;
  });
  accumulateRows.push(lastRow);
  let lastColumn = 0;
  const accumulateColumns = columns.map((column, index) => {
    const finalColumn = "auto" === templateColumns[index] ? columnAuto : column, last2 = lastColumn;
    return lastColumn += finalColumn + columnGap, last2;
  });
  return accumulateColumns.push(lastColumn), {
    rows: accumulateRows,
    columns: accumulateColumns,
    rowGap,
    columnGap
  };
}
function normalizeIndex(index, count) {
  return Math.min(index < 0 ? index + count : index - 1, count);
}
function normalizeStartEndIndex(start, end, count) {
  let finalStart = normalizeIndex(start, count), finalEnd = normalizeIndex(end, count);
  if (isValidNumber_default(start) || isValidNumber_default(end) ? isValidNumber_default(start) ? isValidNumber_default(end) || (finalStart = normalizeIndex(Math.max(0, finalEnd - 1), count)) : finalEnd = normalizeIndex(finalStart + 1, count) : (finalStart = 1, finalEnd = 2), finalStart > finalEnd) {
    const temp3 = finalEnd;
    finalEnd = finalStart, finalStart = temp3;
  }
  return {
    start: finalStart,
    end: finalEnd
  };
}
function getCellBounds(grid2, rowStart, rowEnd, columnStart, columnEnd) {
  const rowCount = grid2.rows.length, columnCount = grid2.columns.length, { start: finalRowStart, end: finalRowEnd } = normalizeStartEndIndex(rowStart, rowEnd, rowCount), { start: finalColumnStart, end: finalColumnEnd } = normalizeStartEndIndex(columnStart, columnEnd, columnCount), x14 = grid2.columns[finalRowStart], x23 = grid2.columns[finalRowEnd] - (finalColumnEnd === columnCount ? 0 : grid2.columnGap), y14 = grid2.rows[finalColumnStart], y23 = grid2.rows[finalColumnEnd] - (finalRowEnd === rowCount ? 0 : grid2.rowGap);
  return new Bounds().set(x14, y14, x23, y23);
}
var doGridLayout = (group, children, parentLayoutBounds, options) => {
  const grid2 = computeGrid(group.getSpec().layout, parentLayoutBounds.width(), parentLayoutBounds.height());
  children && children.forEach((mark) => {
    const markLayout = mark.getSpec().layout;
    mark.layoutBounds = getCellBounds(grid2, markLayout.gridRowStart, markLayout.gridRowEnd, markLayout.gridColumnStart, markLayout.gridColumnEnd), mark.commit();
  });
};

// node_modules/@visactor/vgrammar-core/es/graph/layout/relative.js
var defaultLayoutOrder = {
  [ComponentEnum.axis]: 0,
  [ComponentEnum.legend]: 1,
  [ComponentEnum.slider]: 2,
  [ComponentEnum.player]: 3,
  [ComponentEnum.datazoom]: 4
};
var getLayoutOrderOfMark = (mark) => {
  var _a, _b, _c;
  return null !== (_b = null === (_a = mark.getSpec().layout) || void 0 === _a ? void 0 : _a.order) && void 0 !== _b ? _b : "component" === mark.markType && null !== (_c = defaultLayoutOrder[mark.componentType]) && void 0 !== _c ? _c : 1 / 0;
};
var doRelativeLayout = (group, children, parentLayoutBounds, options) => {
  const viewBounds = parentLayoutBounds.clone(), groupLayoutSpec = group.getSpec().layout, maxChildWidth = toPercent(groupLayoutSpec.maxChildWidth, viewBounds.width()), maxChildHeight = toPercent(groupLayoutSpec.maxChildHeight, viewBounds.width());
  let minDeltaX1 = 0, minDeltaX2 = 0, minDeltaY1 = 0, minDeltaY2 = 0;
  children.forEach((child) => {
    const layoutSpec = child.getSpec().layout, padding = normalizePadding2(layoutSpec.padding), bounds = options.parseMarkBounds ? options.parseMarkBounds(child.getBounds(), child) : child.getBounds();
    if ("top" === layoutSpec.position || "bottom" === layoutSpec.position) {
      const childHeight = Math.min(bounds.height() + padding.top + padding.bottom, maxChildHeight);
      "top" === layoutSpec.position ? viewBounds.y1 += childHeight : viewBounds.y2 -= childHeight, bounds.x1 < parentLayoutBounds.x1 && (minDeltaX1 = Math.max(minDeltaX1, parentLayoutBounds.x1 - bounds.x1)), bounds.x2 > parentLayoutBounds.x2 && (minDeltaX2 = Math.max(minDeltaX2, bounds.x2 - parentLayoutBounds.x2));
    }
    if ("left" === layoutSpec.position || "right" === layoutSpec.position) {
      const childWidth = Math.min(bounds.width() + padding.left + padding.right, maxChildWidth);
      "left" === layoutSpec.position ? viewBounds.x1 += childWidth : viewBounds.x2 -= childWidth, bounds.y1 < parentLayoutBounds.y1 && (minDeltaY1 = Math.max(minDeltaY1, parentLayoutBounds.y1 - bounds.y1)), bounds.y2 > parentLayoutBounds.y2 && (minDeltaY2 = Math.max(minDeltaY2, bounds.y2 - parentLayoutBounds.y2));
    }
    "outside" === layoutSpec.position && (viewBounds.x1 += Math.max(parentLayoutBounds.x1 - bounds.x1, 0) + padding.left, viewBounds.x2 -= Math.max(bounds.x2 - parentLayoutBounds.x2, 0) + padding.right, viewBounds.y1 += Math.max(parentLayoutBounds.y1 - bounds.y1, 0) + padding.top, viewBounds.y2 -= Math.max(bounds.y2 - parentLayoutBounds.y2) + padding.bottom);
  }), minDeltaX1 > viewBounds.x1 - parentLayoutBounds.x1 && minDeltaX1 < parentLayoutBounds.width() && (viewBounds.x1 = parentLayoutBounds.x1 + minDeltaX1), minDeltaX2 > parentLayoutBounds.x2 - viewBounds.x2 && minDeltaX2 < parentLayoutBounds.width() && (viewBounds.x2 = parentLayoutBounds.x2 - minDeltaX2), minDeltaY1 > viewBounds.y1 - parentLayoutBounds.y1 && minDeltaY1 < parentLayoutBounds.height() && (viewBounds.y1 = parentLayoutBounds.y1 + minDeltaY1), minDeltaY2 > parentLayoutBounds.y2 - viewBounds.y2 && minDeltaY2 < parentLayoutBounds.height() && (viewBounds.y2 = parentLayoutBounds.y2 - minDeltaY2);
  let curTopY = viewBounds.y1, curBottomY = viewBounds.y2, curLeftX = viewBounds.x1, curRightX = viewBounds.x2;
  const sortedChildren = children.slice().sort((markA, markB) => getLayoutOrderOfMark(markA) - getLayoutOrderOfMark(markB));
  for (let i2 = 0, len = sortedChildren.length; i2 < len; i2++) {
    const child = sortedChildren[i2], layoutSpec = child.getSpec().layout, padding = normalizePadding2(layoutSpec.padding), bounds = options.parseMarkBounds ? options.parseMarkBounds(child.getBounds(), child) : child.getBounds();
    if ("top" === layoutSpec.position || "bottom" === layoutSpec.position) {
      const childHeight = Math.min(bounds.height() + padding.top + padding.bottom, maxChildHeight);
      if ("top" === layoutSpec.position ? (child.layoutBounds = new Bounds().set(viewBounds.x1, curTopY - childHeight, viewBounds.x2, curTopY), curTopY -= childHeight) : (child.layoutBounds = new Bounds().set(viewBounds.x1, curBottomY, viewBounds.x2, curBottomY + childHeight), curBottomY += childHeight), child.relativePosition = {
        top: child.layoutBounds.y1 - viewBounds.y1,
        bottom: child.layoutBounds.y1 - viewBounds.y2
      }, layoutSpec.align) {
        const childWidth = bounds.width() + padding.left + padding.right;
        childWidth < viewBounds.width() && ("center" === layoutSpec.align ? (child.layoutBounds.x1 = (viewBounds.x1 + viewBounds.x2) / 2 - childWidth / 2, child.layoutBounds.x2 = child.layoutBounds.x1 + childWidth, child.relativePosition.left = child.relativePosition.right = (viewBounds.width() - childWidth) / 2) : "right" === layoutSpec.align ? (child.layoutBounds.x1 = viewBounds.x2 - childWidth, child.layoutBounds.x2 = viewBounds.x2, child.relativePosition.right = 0, child.relativePosition.left = viewBounds.width() - childWidth) : "left" === layoutSpec.align && (child.layoutBounds.x1 = viewBounds.x1, child.layoutBounds.x2 = viewBounds.x1 + childWidth, child.relativePosition.left = 0, child.relativePosition.right = viewBounds.width() - childWidth));
      }
    } else if ("left" === layoutSpec.position || "right" === layoutSpec.position) {
      const childWidth = Math.min(bounds.width() + padding.left + padding.right, maxChildWidth);
      if ("left" === layoutSpec.position ? (child.layoutBounds = new Bounds().set(curLeftX - childWidth, viewBounds.y1, curLeftX, viewBounds.y2), curLeftX -= childWidth) : (child.layoutBounds = new Bounds().set(curRightX, viewBounds.y1, curRightX + childWidth, viewBounds.y2), curRightX += childWidth), child.relativePosition = {
        left: child.layoutBounds.x1 - viewBounds.x1,
        right: child.layoutBounds.x1 - viewBounds.x2
      }, layoutSpec.align) {
        const childHeight = bounds.height() + padding.top + padding.bottom;
        childWidth < viewBounds.width() && ("middle" === layoutSpec.align ? (child.layoutBounds.y1 = (viewBounds.y1 + viewBounds.y2) / 2 - childHeight / 2, child.layoutBounds.y2 = child.layoutBounds.y1 + childHeight, child.relativePosition.top = child.relativePosition.bottom = (viewBounds.height() - childHeight) / 2) : "bottom" === layoutSpec.align ? (child.layoutBounds.y1 = viewBounds.y2 - childHeight, child.layoutBounds.y2 = viewBounds.y2, child.relativePosition.top = viewBounds.height() - childHeight, child.relativePosition.bottom = 0) : "top" === layoutSpec.align && (child.layoutBounds.y1 = viewBounds.y1, child.layoutBounds.y2 = viewBounds.y1 + childHeight, child.relativePosition.bottom = viewBounds.height() - childHeight, child.relativePosition.top = 0));
      }
    } else "outside" === layoutSpec.position ? (curLeftX -= Math.max(parentLayoutBounds.x1 - bounds.x1, 0) + padding.left, curRightX -= Math.max(bounds.x2 - parentLayoutBounds.x2, 0) + padding.right, curTopY -= Math.max(parentLayoutBounds.y1 - bounds.y1, 0) + padding.top, curBottomY += Math.max(bounds.y2 - parentLayoutBounds.y2) + padding.bottom) : child.layoutBounds = viewBounds;
  }
  return viewBounds;
};

// node_modules/@visactor/vgrammar-core/es/graph/layout/layout.js
var defaultDoLayout = (layoutMarks, options, view) => {
  null == layoutMarks || layoutMarks.forEach((mark) => {
    var _a;
    if (mark.markType !== GrammarMarkType.group) return;
    const layoutChildren = mark.layoutChildren, layoutSpec = mark.getSpec().layout, bounds = null !== (_a = mark.layoutBounds) && void 0 !== _a ? _a : mark.getBounds();
    if (bounds) {
      if (isFunction_default(layoutSpec)) layoutSpec.call(null, mark, layoutChildren, bounds, options);
      else if (isFunction_default(layoutSpec.callback)) layoutSpec.callback.call(null, mark, layoutChildren, bounds, options);
      else if ("relative" === layoutSpec.display) if (layoutSpec.updateViewSignals) {
        const oldViewBox = view.getViewBox();
        oldViewBox && bounds.intersect(oldViewBox);
        const viewBounds = doRelativeLayout(mark, layoutChildren, bounds, options), viewWidth = viewBounds.width(), viewHeight = viewBounds.height(), padding = {
          top: viewBounds.y1,
          right: view.width() - viewBounds.x2,
          left: viewBounds.x1,
          bottom: view.height() - viewBounds.y2
        };
        view.updateSignal(SIGNAL_VIEW_WIDTH, viewWidth), view.updateSignal(SIGNAL_VIEW_HEIGHT, viewHeight), view.updateSignal(SIGNAL_PADDING, padding);
      } else doRelativeLayout(mark, layoutChildren, bounds, options);
      else "grid" === layoutSpec.display && doGridLayout(mark, layoutChildren, bounds, options);
      defaultDoLayout(layoutChildren, options, view);
    }
  });
};

// node_modules/@visactor/vgrammar-core/es/view/glyph.js
var GlyphMark = class extends Mark {
  constructor(view, glyphType, group) {
    super(view, GrammarMarkType.glyph, group), this.glyphType = glyphType, this.glyphMeta = Factory.getGlyph(glyphType);
  }
  configureGlyph(config2) {
    return this.spec.glyphConfig = config2, this.commit(), this;
  }
  getGlyphMeta() {
    return this.glyphMeta;
  }
  getGlyphConfig() {
    return this.spec.glyphConfig;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = createGlyphGraphicItem(this, this.glyphMeta, attrs);
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/morph.js
var EmptyKey = Symbol.for("key");
var Morph = class {
  diffGrammar(prevGrammars, nextGrammars) {
    return diffSingle(prevGrammars, nextGrammars, (grammar) => {
      var _a;
      return null !== (_a = grammar.id()) && void 0 !== _a ? _a : Symbol();
    });
  }
  diffMark(prevMarks, nextMarks, runningConfig) {
    const diffResult = {
      enter: [],
      exit: [],
      update: []
    };
    let prevDiffMarks = [], nextDiffMarks = [];
    prevMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? prevDiffMarks.push(mark) : diffResult.exit.push({
        prev: [mark]
      });
    }), nextMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? nextDiffMarks.push(mark) : diffResult.enter.push({
        next: [mark]
      });
    });
    const keyDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.getMorphConfig().morphKey, (mark) => mark.getMorphConfig().morphKey);
    prevDiffMarks = keyDiffResult.prev, nextDiffMarks = keyDiffResult.next, diffResult.update = diffResult.update.concat(keyDiffResult.update);
    const nameDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.id(), (mark) => mark.id());
    prevDiffMarks = nameDiffResult.prev, nextDiffMarks = nameDiffResult.next, diffResult.update = diffResult.update.concat(nameDiffResult.update);
    const prevParentGroup = groupData(prevDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    }), nextParentGroup = groupData(nextDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    });
    return Object.keys(nextParentGroup).forEach((groupName) => {
      const prevChildren = prevParentGroup.data.get(groupName), nextChildren = nextParentGroup.data.get(groupName);
      if (prevChildren && nextChildren) {
        for (let i2 = 0; i2 < Math.max(prevChildren.length, nextChildren.length); i2 += 1) {
          const prevChild = prevChildren[i2], nextChild = nextChildren[i2];
          prevChild && nextChild ? diffResult.update.push({
            prev: [prevChild],
            next: [nextChild]
          }) : prevChild ? diffResult.exit.push({
            prev: [prevChild]
          }) : nextChild && diffResult.enter.push({
            next: [nextChild]
          });
        }
        prevDiffMarks = prevDiffMarks.filter((mark) => !prevChildren.includes(mark)), nextDiffMarks = nextDiffMarks.filter((mark) => !nextChildren.includes(mark));
      }
    }), prevDiffMarks.forEach((mark) => diffResult.exit.push({
      prev: [mark]
    })), nextDiffMarks.forEach((mark) => diffResult.enter.push({
      next: [mark]
    })), diffResult;
  }
  _appendMorphKeyToElements(mark) {
    const config2 = mark.getMorphConfig();
    if (!isNil_default(config2.morphElementKey)) {
      const getter2 = parseField(config2.morphElementKey);
      mark.elements && mark.elements.forEach((el) => {
        el.morphKey = getter2(el.getDatum());
      });
    }
  }
  morph(prevMarks, nextMarks, runningConfig) {
    const prevElements = prevMarks.reduce((elements, mark) => (this._appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), nextElements = nextMarks.reduce((elements, mark) => (this._appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), diffResult = diffMultiple(prevElements, nextElements, (element) => {
      var _a;
      return null !== (_a = element.morphKey) && void 0 !== _a ? _a : element.key;
    });
    prevMarks.forEach((mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
    }), nextMarks.forEach((mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
    });
    const parameters = prevMarks.concat(nextMarks).reduce((parameters2, mark) => (Object.assign(parameters2, mark.parameters()), parameters2), {});
    let morphCount = 0;
    const onMorphEnd = () => {
      morphCount -= 1, 0 === morphCount && nextMarks.forEach((mark) => {
        var _a, _b;
        null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.enable) || void 0 === _b || _b.call(_a);
      });
    };
    diffResult.enter.forEach((diff) => {
      diff.next.forEach((element) => {
        this.doMorph([], [element], runningConfig, onMorphEnd, parameters);
      }), morphCount += 1;
    }), diffResult.update.forEach((diff) => {
      const divideCount = Math.min(diff.prev.length, diff.next.length), prevDivide = this.divideElements(diff.prev, divideCount), nextDivide = this.divideElements(diff.next, divideCount);
      for (let i2 = 0; i2 < divideCount; i2++) this.doMorph(prevDivide[i2], nextDivide[i2], runningConfig, onMorphEnd, parameters), morphCount += 1;
    });
  }
  diffUpdateByGroup(prev, next, prevKey, nextKey) {
    const prevGroup = groupData(prev, (datum) => {
      var _a;
      return null !== (_a = prevKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    }), nextGroup = groupData(next, (datum) => {
      var _a;
      return null !== (_a = nextKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    });
    let prevAfterDiff = prev, nextAfterDiff = next;
    const update3 = [];
    return nextGroup.keys.forEach((key) => {
      if (key !== EmptyKey) {
        const prevKeyData = prevGroup.data.get(key), nextKeyData = nextGroup.data.get(key);
        prevKeyData && nextKeyData && (update3.push({
          prev: prevKeyData,
          next: nextKeyData
        }), prevAfterDiff = prevAfterDiff.filter((datum) => !prevKeyData.includes(datum)), nextAfterDiff = nextAfterDiff.filter((datum) => !nextKeyData.includes(datum)));
      }
    }), {
      prev: prevAfterDiff,
      next: nextAfterDiff,
      update: update3
    };
  }
  doMorph(prev, next, runningConfig, onEnd, parameters) {
    var _a, _b;
    const morphData = {
      prev: prev.map((element) => element.getDatum()),
      next: next.map((element) => element.getDatum())
    }, morphElements = {
      prev: prev.slice(),
      next: next.slice()
    }, easing = runningConfig.animation.easing, delay = invokeFunctionType(runningConfig.animation.delay, parameters, morphData, morphElements), duration = invokeFunctionType(runningConfig.animation.duration, parameters, morphData, morphElements), oneByOne = invokeFunctionType(runningConfig.animation.oneByOne, parameters, morphData, morphElements), splitPath2 = invokeFunctionType(runningConfig.animation.splitPath, parameters, morphData, morphElements), individualDelay = isValidNumber_default(oneByOne) && oneByOne > 0 ? (index) => isNumber_default(oneByOne) ? index * oneByOne : true === oneByOne ? index * duration : 0 : void 0;
    1 !== prev.length && 0 !== prev.length || 1 !== next.length ? 1 === prev.length && next.length > 1 ? oneToMultiMorph(prev[0].getGraphicItem(), next.map((element) => element.getGraphicItem()), {
      delay,
      duration,
      easing,
      onEnd,
      individualDelay,
      splitPath: splitPath2
    }) : prev.length > 1 && 1 === next.length && multiToOneMorph(prev.map((element) => element.getGraphicItem()), next[0].getGraphicItem(), {
      delay,
      duration,
      easing,
      onEnd,
      individualDelay,
      splitPath: splitPath2
    }) : morphPath(null === (_b = null === (_a = prev[0]) || void 0 === _a ? void 0 : _a.getGraphicItem) || void 0 === _b ? void 0 : _b.call(_a), next[0].getGraphicItem(), {
      delay,
      duration,
      easing,
      onEnd
    });
  }
  divideElements(elements, count) {
    const divideLength = Math.floor(elements.length / count);
    return new Array(count).fill(0).map((i2, index) => elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1)));
  }
};

// node_modules/@visactor/vgrammar-core/es/view/grammar-record.js
var RecordedGrammars = class {
  constructor(mapKey, warningWhenDuplicated) {
    this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    }, this._size = 0, this._mapKey = isString_default(mapKey) ? (grammar) => grammar[mapKey] : mapKey, this._warning = warningWhenDuplicated;
  }
  record(grammar) {
    var _a, _b;
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType].push(grammar), isNil_default(key) || (this._grammarMap[grammarType][key] ? null === (_a = this._warning) || void 0 === _a || _a.call(this, key, grammar) : this._grammarMap[grammarType][key] = grammar)) : (this._grammars.customized.push(grammar), isNil_default(key) || (this._grammarMap.customized[key] ? null === (_b = this._warning) || void 0 === _b || _b.call(this, key, grammar) : this._grammarMap.customized[key] = grammar)), this._size += 1, this;
  }
  unrecord(grammar) {
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType] = this._grammars[grammarType].filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap[grammarType][key] !== grammar || delete this._grammarMap[grammarType][key]) : (this._grammars.customized = this._grammars.customized.filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap.customized[key] !== grammar || delete this._grammarMap.customized[key]), this._size -= 1, this;
  }
  size() {
    return this._size;
  }
  getSignal(key) {
    var _a;
    return null !== (_a = this._grammarMap.signal[key]) && void 0 !== _a ? _a : null;
  }
  getData(key) {
    var _a;
    return null !== (_a = this._grammarMap.data[key]) && void 0 !== _a ? _a : null;
  }
  getScale(key) {
    var _a;
    return null !== (_a = this._grammarMap.scale[key]) && void 0 !== _a ? _a : null;
  }
  getCoordinate(key) {
    var _a;
    return null !== (_a = this._grammarMap.coordinate[key]) && void 0 !== _a ? _a : null;
  }
  getMark(key) {
    var _a;
    return null !== (_a = this._grammarMap.mark[key]) && void 0 !== _a ? _a : null;
  }
  getCustomized(key) {
    var _a;
    return null !== (_a = this._grammarMap.customized[key]) && void 0 !== _a ? _a : null;
  }
  getGrammar(key) {
    return this._grammarMap.data[key] ? this._grammarMap.data[key] : this._grammarMap.signal[key] ? this._grammarMap.signal[key] : this._grammarMap.scale[key] ? this._grammarMap.scale[key] : this._grammarMap.coordinate[key] ? this._grammarMap.coordinate[key] : this._grammarMap.mark[key] ? this._grammarMap.mark[key] : this._grammarMap.customized[key] ? this._grammarMap.customized[key] : null;
  }
  getAllSignals() {
    return this._grammars.signal;
  }
  getAllData() {
    return this._grammars.data;
  }
  getAllScales() {
    return this._grammars.scale;
  }
  getAllCoordinates() {
    return this._grammars.coordinate;
  }
  getAllMarks() {
    return this._grammars.mark;
  }
  getAllCustomized() {
    return this._grammars.customized;
  }
  traverse(func) {
    var _a;
    Object.values(null !== (_a = this._grammars) && void 0 !== _a ? _a : {}).forEach((grammars) => (null != grammars ? grammars : []).forEach((grammar) => {
      func.call(null, grammar);
    }));
  }
  find(func) {
    let targetGrammar = null;
    return this.traverse((grammar) => true === func.call(null, grammar) && (targetGrammar = grammar, true)), targetGrammar;
  }
  filter(func) {
    const targetGrammars = [];
    return this.traverse((grammar) => {
      true === func.call(null, grammar) && targetGrammars.push(grammar);
    }), targetGrammars;
  }
  clear() {
    this._size = 0, this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    };
  }
  release() {
    this._size = 0, this._grammars = null, this._grammarMap = null;
  }
};
var RecordedTreeGrammars = class extends RecordedGrammars {
  constructor() {
    super(...arguments), this._markNodes = [];
  }
  record(grammar) {
    if (super.record(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = {
        mark,
        parent: null,
        children: []
      };
      this._markNodes.forEach((node) => {
        const targetMark = node.mark;
        targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, false) ? (node.children.push(currentNode), currentNode.parent = node) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, false) && (currentNode.children.push(node), node.parent = currentNode);
      }), this._markNodes.push(currentNode);
    }
    return this;
  }
  unrecord(grammar) {
    if (super.unrecord(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = this._markNodes.find((node) => node.mark === mark);
      this._markNodes.forEach((node) => {
        const targetMark = node.mark;
        targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, false) ? (node.children = node.children.filter((n2) => n2 !== currentNode), currentNode.parent = null) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, false) && (currentNode.children = currentNode.children.filter((n2) => n2 !== node), node.parent = null);
      }), this._markNodes = this._markNodes.filter((n2) => n2 !== currentNode);
    }
    return this;
  }
  getAllMarkNodes() {
    return this._markNodes;
  }
  clear() {
    super.clear(), this._markNodes = [];
  }
  release() {
    super.release(), this._markNodes = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/view/animate.js
var ViewAnimate = class {
  constructor(view) {
    this._animations = [], this._additionalAnimateMarks = [], this.isEnabled = true, this._onAnimationStart = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_START, {}), this._animations = this._animations.concat({
        config: event.animationConfig,
        mark: event.mark
      });
    }, this._onAnimationEnd = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), this._animations = this._animations.filter((animation) => animation.config !== event.animationConfig || animation.mark !== event.mark), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_END, {});
    }, this._view = view, this._view.addEventListener(HOOK_EVENT.ANIMATION_START, this._onAnimationStart), this._view.addEventListener(HOOK_EVENT.ANIMATION_END, this._onAnimationEnd);
  }
  stop() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  pause() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this;
  }
  resume() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this;
  }
  enable() {
    return this.isEnabled = true, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enable) || void 0 === _b || _b.call(_a));
    }), this;
  }
  disable() {
    return this.isEnabled = false, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disable) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  enableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  disableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  isAnimating() {
    return 0 !== this._animations.length || this._additionalAnimateMarks.some((mark) => {
      var _a;
      return (null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating()) || false;
    });
  }
  animate() {
    return this.isEnabled ? (this._view.traverseMarkTree((mark) => {
      mark.isUpdated && mark.animate && mark.animate.animate(), mark.cleanExitElements(), mark.isUpdated = false;
    }, null, true), this) : this;
  }
  animateAddition(additionMark) {
    return additionMark.animate.animate(), this._additionalAnimateMarks.push(additionMark), this;
  }
  release() {
    this._additionalAnimateMarks = [], this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_START, this._onAnimationStart), this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_END, this._onAnimationEnd);
  }
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/text.js
var Text2 = class extends Mark {
  addGraphicItem(initAttrs, groupKey) {
    const textConfig = null == initAttrs ? void 0 : initAttrs.text, isRich = "rich" === (null == textConfig ? void 0 : textConfig.type), graphicItem = createGraphicItem(this, isRich ? GrammarMarkType.richtext : GrammarMarkType.text, initAttrs);
    return isRich && (initAttrs.textConfig = []), super.addGraphicItem(initAttrs, groupKey, graphicItem);
  }
  getAttributeTransforms() {
    var _a;
    return "richtext" === (null === (_a = this.getGroupGraphicItem()) || void 0 === _a ? void 0 : _a.type) ? transformsByType.richtext : transformsByType.text;
  }
  release() {
    super.release();
  }
};
Text2.markType = GrammarMarkType.text;

// node_modules/@visactor/vgrammar-core/es/theme/common/component.js
var axis = {
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#89909d",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 100,
    y: 0
  },
  x: 0,
  y: 0
};
var circleAxis = {
  title: {
    space: 4,
    padding: [0, 0, 0, 0],
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    },
    text: "theta"
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#6F6F6F",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  startAngle: 0,
  endAngle: 2 * Math.PI,
  radius: 100,
  innerRadius: 0,
  center: {
    x: 0,
    y: 0
  },
  x: 0,
  y: 0
};
var grid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var circleGrid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var discreteLegend = {
  layout: "vertical",
  title: {
    align: "start",
    space: 12,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: 10,
    spaceRow: 10,
    shape: {
      space: 4,
      style: {
        size: 10,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    label: {
      space: 4,
      style: {
        fontSize: 12,
        fill: "black",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          fillOpacity: 0.7,
          fill: "gray"
        },
        unSelectedHover: {
          fillOpacity: 0.2,
          fill: "gray"
        }
      }
    },
    focus: false,
    focusIconStyle: {
      size: 10,
      fill: "#333",
      cursor: "pointer"
    },
    visible: true,
    padding: {
      top: 2,
      bottom: 2,
      left: 2,
      right: 2
    }
  },
  autoPage: true,
  pager: {
    space: 12,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: false,
  items: [{
    index: 0,
    id: "",
    label: "",
    shape: {
      fill: "#6690F2",
      stroke: "#6690F2",
      symbolType: "circle"
    }
  }]
};
var colorLegend = {
  title: {
    visible: false,
    text: ""
  },
  colors: [],
  layout: "horizontal",
  railWidth: 200,
  railHeight: 8,
  railStyle: {
    cornerRadius: 5
  }
};
var sizeLegend = {
  title: {
    visible: false,
    text: ""
  },
  trackStyle: {
    fill: "#ccc"
  },
  layout: "horizontal",
  align: "bottom",
  railWidth: 200,
  railHeight: 6,
  min: 0,
  max: 1,
  value: [0, 1]
};
var lineCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  }
};
var rectCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  },
  rectStyle: {
    width: 10,
    height: 10
  }
};
var sectorCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: Math.PI / 6
};
var circleCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var polygonCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI,
  sides: 6
};
var slider = {
  layout: "horizontal",
  railWidth: 200,
  railHeight: 10,
  railStyle: {
    cornerRadius: 5
  },
  range: {
    draggableTrack: true
  },
  startText: {
    visible: true,
    text: "",
    space: 8
  },
  endText: {
    visible: true,
    text: "",
    space: 8
  },
  min: 0,
  max: 1,
  value: [0, 1]
};
var dataLabel = {
  size: {
    width: 400,
    height: 400
  },
  dataLabels: []
};
var lineDataLabel = {
  type: "line-data",
  data: [{
    text: ""
  }],
  position: "top",
  overlap: {
    avoidBaseMark: false,
    clampForce: false
  },
  smartInvert: false
};
var lineLabel = {
  type: "line",
  data: [{
    text: "",
    data: {}
  }],
  position: "start",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var areaLabel = {
  type: "area",
  data: [{
    text: "",
    data: {}
  }],
  position: "end",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var rectLabel = {
  type: "rect",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var symbolLabel = {
  type: "symbol",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    avoidBaseMark: true,
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var arcLabel = {
  type: "arc",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  width: 800,
  height: 600,
  position: "outside",
  zIndex: 302
};
var pointLabel = {
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var datazoom = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  start: 0,
  end: 1,
  position: {
    x: 0,
    y: 0
  },
  size: {
    width: 500,
    height: 40
  },
  previewData: []
};
var continuousPlayer = {};
var discretePlayer = {};
var tooltip = {};
var title = {
  textStyle: {
    fill: "#21252c"
  },
  subtextStyle: {
    fill: "#606773"
  }
};
var scrollbar = {
  width: 12,
  height: 12,
  padding: [2, 2],
  railStyle: {
    fill: "rgba(0, 0, 0, .1)"
  }
};
var defaultComponentTheme = {
  axis,
  circleAxis,
  grid,
  circleGrid,
  discreteLegend,
  colorLegend,
  sizeLegend,
  lineCrosshair,
  rectCrosshair,
  sectorCrosshair,
  circleCrosshair,
  polygonCrosshair,
  slider,
  dataLabel,
  pointLabel,
  lineLabel,
  areaLabel,
  rectLabel,
  symbolLabel,
  arcLabel,
  lineDataLabel,
  datazoom,
  continuousPlayer,
  discretePlayer,
  tooltip,
  title,
  scrollbar
};

// node_modules/@visactor/vgrammar-core/es/theme/common/constants.js
var DEFAULT_PADDING = 5;

// node_modules/@visactor/vgrammar-core/es/theme/common/mark.js
var defaultMarkTheme = {
  symbol: {
    shape: "circle",
    size: 8
  },
  text: {
    fontSize: 14,
    fill: "#000000"
  }
};

// node_modules/@visactor/vgrammar-core/es/theme/dark.js
var darkComponents = Object.assign({}, defaultComponentTheme);
darkComponents.axis = Object.assign({}, darkComponents.axis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.circleAxis = Object.assign({}, darkComponents.circleAxis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.grid = Object.assign({}, darkComponents.grid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.circleGrid = Object.assign({}, darkComponents.circleGrid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.rectLabel = Object.assign({}, darkComponents.rectLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.lineLabel = Object.assign({}, darkComponents.lineLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.symbolLabel = Object.assign({}, darkComponents.symbolLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.title = Object.assign({}, darkComponents.title, {
  textStyle: {
    fill: "#fdfdfd"
  },
  subtextStyle: {
    fill: "#888c93"
  }
});
var darkTheme = {
  name: "dark",
  padding: DEFAULT_PADDING,
  background: "#202226",
  palette: {
    default: ["#5383F4", "#7BCF8E", "#FF9D2C", "#FFDB26", "#7568D9", "#80D8FB", "#1857A3", "#CAB0E8", "#FF8867", "#B9E493", "#2CB4A8", "#B9E4E3"]
  },
  marks: defaultMarkTheme,
  components: darkComponents
};

// node_modules/@visactor/vgrammar-core/es/theme/default.js
var defaultTheme = {
  name: "default",
  padding: DEFAULT_PADDING,
  palette: {
    default: ["#6690F2", "#70D6A3", "#B4E6E2", "#63B5FC", "#FF8F62", "#FFDC83", "#BCC5FD", "#A29BFE", "#63C4C7", "#F68484"]
  },
  marks: defaultMarkTheme,
  components: defaultComponentTheme
};

// node_modules/@visactor/vgrammar-core/es/theme/theme-manager.js
var ThemeManager = class _ThemeManager {
  static registerTheme(name, theme2) {
    name && _ThemeManager._themes.set(name, theme2);
  }
  static unregisterTheme(name) {
    _ThemeManager._themes.delete(name);
  }
  static getTheme(name) {
    return _ThemeManager._themes.get(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.getTheme("default");
  }
};
ThemeManager._themes = /* @__PURE__ */ new Map(), ThemeManager.registerTheme("default", defaultTheme), ThemeManager.registerTheme("dark", darkTheme);

// node_modules/@visactor/vgrammar-core/es/view/component.js
var Component = class extends Mark {
  constructor(view, componentType, group, mode2) {
    super(view, GrammarMarkType.component, group), this._componentDatum = {
      [DefaultKey]: 0
    }, this.componentType = componentType, this.spec.type = "component", this.spec.componentType = componentType, this.mode = mode2, this._updateComponentEncoders();
  }
  configureComponent(config2) {
    return this.spec.componentConfig = config2, this.commit(), this;
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : Factory.createGraphicComponent(this.componentType, attrs, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK), this.graphicParent.appendChild(graphicItem), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK), graphicItem;
  }
  join(data) {
    return super.join(data, DefaultKey);
  }
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(), this;
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  _prepareRejoin() {
    this._componentDatum[DefaultKey] += 1;
  }
  evaluateJoin(data) {
    return this.spec.key = DefaultKey, super.evaluateJoin([this._componentDatum]);
  }
  _updateComponentEncoders() {
    this._encoders = this.spec.encode;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
};

// node_modules/@visactor/vgrammar-core/es/view/View.js
var __awaiter12 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var View = class extends import_eventemitter3.default {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      fn();
    });
  }
  constructor(options = {}, config2 = {}) {
    super(), this._observer = null, this._onResize = debounce_default((...args) => {
      const size = this._getContainerSize();
      size && this.resize(size.width, size.height);
    }, 100), this.delegateEvent = (event, type) => {
      var _a;
      const activeElement = null === (_a = event.target) || void 0 === _a ? void 0 : _a[BridgeElementKey], extendedEvt = getExtendedEvents(this, event, activeElement, type, EVENT_SOURCE_VIEW);
      this.emit(type, extendedEvt, activeElement);
    }, this.handleProgressiveFrame = () => {
      this._progressiveMarks.length && this._progressiveMarks.forEach((mark) => {
        mark.isDoingProgressive() && mark.evaluateProgressive();
      }), this.doPreProgressive();
    }, this._config = config2, this._options = Object.assign({
      mode: BROWSER
    }, options), this.initialize();
  }
  getGrammarById(id2) {
    return this.grammars.getGrammar(id2);
  }
  getSignalById(id2) {
    return this.grammars.getSignal(id2);
  }
  getDataById(id2) {
    return this.grammars.getData(id2);
  }
  getScaleById(id2) {
    return this.grammars.getScale(id2);
  }
  getCoordinateById(id2) {
    return this.grammars.getCoordinate(id2);
  }
  getMarkById(id2) {
    return this.grammars.getMark(id2);
  }
  getCustomizedById(id2) {
    return this.grammars.getCustomized(id2);
  }
  getGrammarsByName(name) {
    return this.grammars.filter((grammar) => grammar.name() === name);
  }
  getGrammarsByType(grammarType) {
    return this.grammars.filter((grammar) => grammar.grammarType === grammarType);
  }
  getMarksByType(markType) {
    return this.grammars.getAllMarks().filter((mark) => mark.markType === markType);
  }
  getMarksByName(name) {
    return this.grammars.getAllMarks().filter((mark) => mark.name() === name);
  }
  getMarksBySelector(selector) {
    if (!selector) return null;
    const selectors = array(selector), res = [];
    return selectors.forEach((selectorStr) => {
      if (isGrammar(selectorStr)) return void res.push(selectorStr);
      if (selectorStr[0] === ID_PREFIX) {
        const mark = this.getMarkById(selectorStr.slice(1));
        return void (mark && res.push(mark));
      }
      const marks = selectorStr[0] === NAME_PREFIX ? this.getMarksByName(selectorStr.slice(1)) : isMarkType(selectorStr) ? this.getMarksByType(selectorStr) : null;
      marks && marks.length && marks.forEach((mark) => {
        res.push(mark);
      });
    }), res;
  }
  updateSignal(signal, value) {
    isString_default(signal) && (signal = this.getSignalById(signal)), signal.set(value), this.commit(signal);
  }
  signal(value, update3) {
    const signal = new Signal(this);
    return arguments.length >= 1 && signal.value(value), arguments.length >= 2 && signal.update(update3), this.grammars.record(signal), this._dataflow.add(signal), signal;
  }
  data(values) {
    const data = new Data(this, values);
    return this.grammars.record(data), this._dataflow.add(data), data;
  }
  scale(type) {
    const scale4 = Factory.createGrammar("scale", this, type);
    return scale4 && (this.grammars.record(scale4), this._dataflow.add(scale4)), scale4;
  }
  coordinate(type) {
    const coordinate = Factory.createGrammar("coordinate", this, type);
    return coordinate && (this.grammars.record(coordinate), this._dataflow.add(coordinate)), coordinate;
  }
  mark(type, group, markOptions) {
    const groupMark = isString_default(group) ? this.getMarkById(group) : group;
    let mark;
    switch (type) {
      case GrammarMarkType.group:
        mark = new GroupMark(this, groupMark);
        break;
      case GrammarMarkType.glyph:
        mark = new GlyphMark(this, null == markOptions ? void 0 : markOptions.glyphType, groupMark);
        break;
      case GrammarMarkType.component:
        mark = Factory.hasComponent(null == markOptions ? void 0 : markOptions.componentType) ? Factory.createComponent(null == markOptions ? void 0 : markOptions.componentType, this, groupMark, null == markOptions ? void 0 : markOptions.mode) : new Component(this, null == markOptions ? void 0 : markOptions.componentType, groupMark, null == markOptions ? void 0 : markOptions.mode);
        break;
      case GrammarMarkType.text:
        mark = new Text2(this, type, groupMark);
        break;
      default:
        mark = Factory.hasMark(type) ? Factory.createMark(type, this, groupMark) : new Mark(this, type, groupMark);
    }
    return this.grammars.record(mark), this._dataflow.add(mark), mark;
  }
  group(group) {
    return this.mark(GrammarMarkType.group, group);
  }
  glyph(glyphType, group) {
    return this.mark(GrammarMarkType.glyph, group, {
      glyphType
    });
  }
  component(componentType, group, mode2 = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType,
      mode: mode2
    });
  }
  axis(group, mode2 = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.axis,
      mode: mode2
    });
  }
  grid(group, mode2 = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.grid,
      mode: mode2
    });
  }
  legend(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.legend
    });
  }
  slider(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.slider
    });
  }
  label(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.label
    });
  }
  datazoom(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.datazoom
    });
  }
  player(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.player
    });
  }
  title(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.title
    });
  }
  scrollbar(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.scrollbar
    });
  }
  customized(type, spec) {
    const grammar = Factory.createGrammar(type, this, null == spec ? void 0 : spec.type);
    if (grammar) return grammar.parse(spec), this.grammars.record(grammar), this._dataflow.add(grammar), grammar;
  }
  addGrammar(grammar) {
    return this.grammars.find((storedGrammar) => storedGrammar.uid === grammar.uid) || (this.grammars.record(grammar), this._dataflow.add(grammar), grammar.parse(grammar.getSpec()), this._needBuildLayoutTree = true), this;
  }
  removeGrammar(grammar) {
    const recordedGrammar = isString_default(grammar) ? this.getGrammarById(grammar) : grammar;
    return recordedGrammar && this.grammars.find((storedGrammar) => storedGrammar.uid === recordedGrammar.uid) ? ("mark" === recordedGrammar.grammarType && recordedGrammar.prepareRelease(), this._cachedGrammars.record(recordedGrammar), this._dataflow.remove(recordedGrammar), this.grammars.unrecord(recordedGrammar), this._needBuildLayoutTree = true, this) : this;
  }
  removeAllGrammars() {
    return this.grammars.traverse((grammar) => {
      "signal" === grammar.grammarType && BuiltInSignalID.includes(grammar.id()) || "mark" === grammar.grammarType && "root" === grammar.id() || this.removeGrammar(grammar);
    }), this;
  }
  removeAllGraphicItems() {
    return this.traverseMarkTree((mark) => {
      mark.graphicItem && (removeGraphicItem(mark.graphicItem), mark.elementMap.forEach((element) => {
        element.resetGraphicItem();
      }), mark.graphicItem = null);
    }), this;
  }
  parseSpec(spec) {
    var _a, _b, _c, _d, _e, _f;
    if (this.emit(HOOK_EVENT.BEFORE_PARSE_VIEW), this._spec = spec, normalizeMarkTree(spec), spec.theme ? this.theme(spec.theme) : this.theme(ThemeManager.getDefaultTheme()), spec.width && this.width(spec.width), spec.height && this.height(spec.height), this.padding(null !== (_b = null !== (_a = spec.padding) && void 0 !== _a ? _a : this._options.padding) && void 0 !== _b ? _b : this._theme.padding), !this.width() || !this.height()) {
      const size = this._getContainerSize();
      size && (this.updateSignal(SIGNAL_WIDTH, size.width), this.updateSignal(SIGNAL_HEIGHT, size.height));
    }
    (null === (_c = spec.signals) || void 0 === _c ? void 0 : _c.length) && spec.signals.forEach((signal) => {
      this.signal().parse(signal);
    }), (null === (_d = spec.data) || void 0 === _d ? void 0 : _d.length) && spec.data.forEach((data) => {
      this.data(null).parse(data);
    }), (null === (_e = spec.coordinates) || void 0 === _e ? void 0 : _e.length) && spec.coordinates.forEach((coordinate) => {
      var _a2;
      null === (_a2 = this.coordinate(coordinate.type)) || void 0 === _a2 || _a2.parse(coordinate);
    }), (null === (_f = spec.scales) || void 0 === _f ? void 0 : _f.length) && spec.scales.forEach((scale4) => {
      var _a2;
      null === (_a2 = this.scale(scale4.type)) || void 0 === _a2 || _a2.parse(scale4);
    });
    const customizedGrammars = Factory.getGrammars();
    return Object.keys(customizedGrammars).forEach((key) => {
      const { specKey } = customizedGrammars[key];
      spec[specKey] && spec[specKey].length && spec[specKey].forEach((specValue) => {
        this.customized(key, specValue);
      });
    }), spec.marks && spec.marks.length && spec.marks.forEach((mark) => {
      this.parseMarkSpec(mark);
    }), spec.events && spec.events.length && spec.events.forEach((eventConfig) => {
      this.event(eventConfig);
    }), spec.interactions && spec.interactions.length && spec.interactions.forEach((interaction) => {
      this.interaction(interaction.type, interaction);
    }), false === spec.animation ? this.animate.disable() : this.animate.enable(), this.emit(HOOK_EVENT.AFTER_PARSE_VIEW), this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this;
  }
  updateSpec(spec) {
    return this.removeAllInteractions(), this.removeAllGrammars(), this.parseSpec(spec);
  }
  parseBuiltIn() {
    builtInSignals(this._options, this._config, this.getCurrentTheme()).forEach((signalSpec) => {
      const signal = this.signal().parse(signalSpec);
      signalSpec.value && signal.set(signalSpec.value);
    });
    this.parseMarkSpec({
      id: "root",
      type: "group",
      encode: {
        enter: {
          x: 0,
          y: 0
        },
        update: {
          width: {
            signal: "width"
          },
          height: {
            signal: "height"
          }
        }
      }
    }), this.rootMark = this.getMarkById("root");
  }
  parseMarkSpec(spec) {
    var _a;
    const markOptions = spec.type === GrammarMarkType.glyph ? {
      glyphType: spec.glyphType
    } : spec.type === GrammarMarkType.component ? {
      componentType: spec.componentType,
      mode: spec.mode
    } : null;
    this.mark(spec.type, spec.group, markOptions).parse(spec), null === (_a = spec.marks) || void 0 === _a || _a.forEach((childSpec) => {
      this.parseMarkSpec(childSpec);
    });
  }
  theme(theme2) {
    var _a, _b, _c, _d, _e, _f;
    isString_default(theme2) ? this._theme = null !== (_a = ThemeManager.getTheme(theme2)) && void 0 !== _a ? _a : ThemeManager.getDefaultTheme() : this._theme = theme2;
    const { background, padding } = null !== (_b = this._spec) && void 0 !== _b ? _b : {};
    return this._theme ? (this.background(null !== (_c = null != background ? background : this._options.background) && void 0 !== _c ? _c : this._theme.background), this.padding(null !== (_d = null != padding ? padding : this._options.padding) && void 0 !== _d ? _d : this._theme.padding), null === (_f = null === (_e = this.renderer.stage()) || void 0 === _e ? void 0 : _e.setTheme) || void 0 === _f || _f.call(_e, Object.assign({}, this._theme.marks))) : (this.background(null != background ? background : this._options.background), this.padding(null != padding ? padding : this._options.padding)), this;
  }
  getCurrentTheme() {
    return this._theme;
  }
  setCurrentTheme(theme2, render = true) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!this._isReleased) {
        if (this.theme(theme2), this.grammars.getAllMarks().forEach((mark) => {
          mark.commit();
        }), render) {
          if (yield this.evaluate(), this._isReleased) return;
          this.renderer.render(true);
        } else yield this._dataflow.evaluate();
        return this;
      }
    });
  }
  background(value) {
    return arguments.length ? (this._background = value, this.renderer.background(value), value) : this._background;
  }
  width(value) {
    const signal = this.getSignalById(SIGNAL_WIDTH);
    return arguments.length ? (this._options.width = value, this.updateSignal(signal, value), value) : signal.output();
  }
  height(value) {
    const signal = this.getSignalById(SIGNAL_HEIGHT);
    return arguments.length ? (this._options.height = value, this.updateSignal(signal, value), value) : signal.output();
  }
  viewWidth(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_WIDTH);
    if (arguments.length) {
      const padding = this.padding();
      return this.width(value + padding.left + padding.right), value;
    }
    return signal.output();
  }
  viewHeight(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_HEIGHT);
    if (arguments.length) {
      const padding = this.padding();
      return this.height(value + padding.top + padding.bottom), value;
    }
    return signal.output();
  }
  padding(value) {
    const signal = this.getSignalById(SIGNAL_PADDING);
    if (arguments.length) {
      const padding = normalizePadding2(value);
      return this.updateSignal(signal, padding), padding;
    }
    return normalizePadding2(signal.output());
  }
  autoFit(value) {
    const signal = this.getSignalById(SIGNAL_AUTOFIT);
    return arguments.length ? (this.updateSignal(signal, value), value) : signal.output();
  }
  getViewBox() {
    const signal = this.getSignalById(SIGNAL_VIEW_BOX);
    return null == signal ? void 0 : signal.output();
  }
  updateLayoutTag() {
    return this._layoutState = LayoutState.before, this;
  }
  getLayoutState() {
    return this._layoutState;
  }
  buildLayoutTree() {
    const markMap = {}, rootMarks = [];
    this.traverseMarkTree((mark) => {
      markMap[mark.id()] = true, mark.group && markMap[mark.group.id()] || rootMarks.push(mark), mark.markType === GrammarMarkType.group && mark.updateLayoutChildren();
    }, (mark) => mark.needLayout()), this._layoutMarks = rootMarks;
  }
  doLayout() {
    var _a;
    const doLayout = this._options.doLayout || defaultDoLayout;
    doLayout && (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && (this.emit(HOOK_EVENT.BEFORE_DO_LAYOUT), doLayout(this._layoutMarks, this._options, this), this.emit(HOOK_EVENT.AFTER_DO_LAYOUT));
  }
  handleLayoutEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_LAYOUT_END), this._layoutMarks.forEach((layoutMark) => {
      traverseMarkTree(layoutMark, "layoutChildren", (mark) => {
        mark.handleLayoutEnd();
      }, (mark) => mark !== layoutMark);
    }), this.emit(HOOK_EVENT.AFTER_MARK_LAYOUT_END);
  }
  handleRenderEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_RENDER_END), traverseMarkTree(this.rootMark, "children", (mark) => {
      mark.handleRenderEnd();
    }), this.emit(HOOK_EVENT.AFTER_MARK_RENDER_END);
  }
  commit(grammar) {
    return this._dataflow.commit(grammar), this;
  }
  run(runningConfig) {
    return this.evaluate(runningConfig), this;
  }
  runSync(runningConfig) {
    return this.evaluateSync(runningConfig), this;
  }
  isRunning() {
    return this._running;
  }
  runAsync(runningConfig) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this._isReleased) return;
      for (; this._running && (yield this._running, !this._isReleased); ) ;
      const clear = () => {
        this._running = null;
      };
      return (this._running = this.evaluate(runningConfig)).then(clear, clear), this._running;
    });
  }
  runNextTick(runningConfig) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this._currentDataflow || (this._currentDataflow = Promise.resolve().then(() => this.runAsync(runningConfig).then(() => {
        this._currentDataflow = null;
      }).catch((e3) => {
        this._currentDataflow = null, this.logger.error(e3);
      }))), yield this._currentDataflow, this;
    });
  }
  doRender(immediately) {
    this.emit(HOOK_EVENT.BEFORE_DO_RENDER), this.renderer && (this._progressiveMarks || this.animate.animate(), this.renderer.render(immediately), this.handleRenderEnd()), this.emit(HOOK_EVENT.AFTER_DO_RENDER);
  }
  evaluate(runningConfig) {
    var _a, _b, _c, _d;
    return __awaiter12(this, void 0, void 0, function* () {
      if (this._isReleased) return;
      const normalizedRunningConfig = normalizeRunningConfig(runningConfig), grammarWillDetach = this._cachedGrammars.size() > 0;
      grammarWillDetach && (this.reuseCachedGrammars(normalizedRunningConfig), this.detachCachedGrammar());
      const hasResize = this._resizeRenderer(), hasUpdate = this._dataflow.hasCommitted();
      if (!(grammarWillDetach || hasUpdate || this._layoutState || hasResize)) return this;
      if (this.clearProgressive(), null === (_a = this.renderer) || void 0 === _a || _a.preventRender(true), yield this._dataflow.evaluate(), !this._isReleased) {
        if (this._needBuildLayoutTree && (this.buildLayoutTree(), this._needBuildLayoutTree = false), this._layoutState) {
          if (this._layoutState = LayoutState.layouting, this.doLayout(), this._dataflow.hasCommitted() && (this._layoutState = LayoutState.reevaluate, yield this._dataflow.evaluate(), this._isReleased)) return;
          this._layoutState = LayoutState.after, (null === (_b = this._layoutMarks) || void 0 === _b ? void 0 : _b.length) && this.handleLayoutEnd();
        }
        return null === (_c = this.renderer) || void 0 === _c || _c.preventRender(false), this._layoutState = null, this.findProgressiveMarks(), this._resizeRenderer(), this.doRender(false), null === (_d = this._willMorphMarks) || void 0 === _d || _d.forEach((morphMarks) => {
          this._morph.morph(morphMarks.prev, morphMarks.next, normalizedRunningConfig);
        }), this._willMorphMarks = null, this.releaseCachedGrammars(normalizedRunningConfig), this.doPreProgressive(), this;
      }
    });
  }
  evaluateSync(runningConfig) {
    var _a, _b;
    const normalizedRunningConfig = normalizeRunningConfig(runningConfig), grammarWillDetach = this._cachedGrammars.size() > 0;
    grammarWillDetach && (this.reuseCachedGrammars(normalizedRunningConfig), this.detachCachedGrammar());
    const hasResize = this._resizeRenderer(), hasUpdate = this._dataflow.hasCommitted();
    return grammarWillDetach || hasUpdate || this._layoutState || hasResize ? (this.clearProgressive(), this._dataflow.evaluateSync(), this._needBuildLayoutTree && (this.buildLayoutTree(), this._needBuildLayoutTree = false), this._layoutState && (this._layoutState = LayoutState.layouting, this.doLayout(), this._dataflow.hasCommitted() && (this._layoutState = LayoutState.reevaluate, this._dataflow.evaluateSync()), this._layoutState = LayoutState.after, (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && this.handleLayoutEnd()), this._layoutState = null, this.findProgressiveMarks(), this._resizeRenderer(), this.doRender(true), null === (_b = this._willMorphMarks) || void 0 === _b || _b.forEach((morphMarks) => {
      this._morph.morph(morphMarks.prev, morphMarks.next, normalizedRunningConfig);
    }), this._willMorphMarks = null, this.releaseCachedGrammars(normalizedRunningConfig), this.doPreProgressive(), this) : this;
  }
  reuseCachedGrammars(runningConfig) {
    if (this._willMorphMarks || (this._willMorphMarks = []), runningConfig.reuse) {
      const reuseDiffUpdate = (diff) => {
        diff.next.reuse(diff.prev), diff.prev.detachAll(), diff.prev.clear(), this._cachedGrammars.unrecord(diff.prev);
      };
      this._morph.diffGrammar(this._cachedGrammars.getAllSignals(), this.grammars.getAllSignals().filter((signal) => !BuiltInSignalID.includes(signal.id()))).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllData(), this.grammars.getAllData()).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllScales(), this.grammars.getAllScales()).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllCoordinates(), this.grammars.getAllCoordinates()).update.forEach(reuseDiffUpdate);
    }
    this._morph.diffMark(this._cachedGrammars.getAllMarks(), this.grammars.getAllMarks().filter((mark) => "root" !== mark.id()), runningConfig).update.forEach((diff) => {
      const matched = 1 === diff.prev.length && 1 === diff.next.length && diff.prev[0].markType === diff.next[0].markType, enableMarkMorphConfig = diff.prev.every((mark) => mark.getMorphConfig().morph) && diff.next.every((mark) => mark.getMorphConfig().morph);
      matched && runningConfig.reuse ? (diff.next[0].reuse(diff.prev[0]), diff.prev[0].detachAll(), diff.prev[0].clear(), this._cachedGrammars.unrecord(diff.prev[0])) : (runningConfig.morph && enableMarkMorphConfig || runningConfig.morphAll) && this._willMorphMarks.push({
        prev: diff.prev,
        next: diff.next
      });
    });
  }
  detachCachedGrammar() {
    this._cachedGrammars.traverse((grammar) => {
      var _a, _b;
      if (grammar.detachAll(), "mark" === grammar.grammarType) {
        const mark = grammar;
        null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.removeChild) || void 0 === _b || _b.call(_a, mark);
      }
    });
  }
  releaseCachedGrammars(runningConfig) {
    this._cachedGrammars.traverse((grammar) => {
      "mark" !== grammar.grammarType && grammar.release();
    });
    const markNodes = this._cachedGrammars.getAllMarkNodes();
    markNodes.forEach((node) => {
      node.mark.animate.stop(), runningConfig.enableExitAnimation && this.animate.animateAddition(node.mark);
    });
    const releaseUp = (node) => {
      if (node.mark.view && 0 === node.mark.animate.getAnimatorCount() && (!node.children || 0 === node.children.length)) {
        node.mark.release();
        const parent = node.parent;
        parent && (node.parent.children = node.parent.children.filter((n2) => n2 !== node), node.parent = null, releaseUp(parent));
      }
    };
    markNodes.forEach((node) => {
      const mark = node.mark;
      0 === mark.animate.getAnimatorCount() ? releaseUp(node) : mark.addEventListener("animationEnd", () => {
        0 === mark.animate.getAnimatorCount() && releaseUp(node);
      });
    }), this._cachedGrammars.clear();
  }
  runAfter(callback) {
    return this._dataflow.runAfter(() => {
      callback.call(null, this);
    }), this;
  }
  runBefore(callback) {
    return this._dataflow.runBefore(() => {
      callback.call(null, this);
    }), this;
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._options.mode) return void this.logger.error(new TypeError("getImageBuffer() now only support node environment."));
    const stage = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a);
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return this.logger.error(new ReferenceError("render is not defined")), null;
  }
  traverseMarkTree(apply, filter2, leafFirst) {
    return traverseMarkTree(this.rootMark, "children", apply, filter2, leafFirst), this;
  }
  _bindResizeEvent() {
    var _a, _b, _c, _d, _e, _f;
    if (this.autoFit()) {
      const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
      if (container2) {
        const ResizeObserverWindow = window.ResizeObserver;
        this._observer = new ResizeObserverWindow(this._onResize), null === (_f = this._observer) || void 0 === _f || _f.observe(container2);
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this.autoFit() && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  _getContainerSize() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
    if (container2) {
      const { width: containerWidth, height: containerHeight } = getContainerSize(container2);
      return {
        width: null !== (_h = null !== (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.width) && void 0 !== _g ? _g : this._options.width) && void 0 !== _h ? _h : containerWidth,
        height: null !== (_l = null !== (_k = null === (_j = this._spec) || void 0 === _j ? void 0 : _j.height) && void 0 !== _k ? _k : this._options.height) && void 0 !== _l ? _l : containerHeight
      };
    }
    return null;
  }
  resize(width, height, render = true) {
    return __awaiter12(this, void 0, void 0, function* () {
      let needDataflow = false;
      return width !== this.width() && (needDataflow = true, this.updateSignal(SIGNAL_WIDTH, width)), height !== this.height() && (needDataflow = true, this.updateSignal(SIGNAL_HEIGHT, height)), needDataflow && (render ? yield this.evaluate() : yield this._dataflow.evaluate()), this;
    });
  }
  _resizeRenderer() {
    const width = this.width(), height = this.height();
    return !!this.renderer.shouldResize(width, height) && (this.renderer.resize(width, height), this.emit("resize", {}, {
      width,
      height
    }), true);
  }
  bindEvents(eventSpec) {
    if (this._eventConfig.disable) return;
    const { type: evtType, filter: filter2, callback, throttle: throttle2, debounce: debounce2, consume, target, dependency } = eventSpec, eventSelector = parseEventSelector(evtType);
    if (!eventSelector) return;
    const { source, type } = eventSelector, markFilter = generateFilterByMark(eventSelector), validateSignals = (Array.isArray(target) && target.length ? target.map((entry) => ({
      signal: this.getSignalById(entry.target),
      callback: entry.callback
    })) : [{
      signal: isString_default(target) ? this.getSignalById(target) : null,
      callback
    }]).filter((entry) => entry.signal || entry.callback), refs = parseReference(dependency, this), send = parseHandler((evt, element) => {
      const needPreventDefault = source === EVENT_SOURCE_VIEW && prevent(this._eventConfig, type) || consume && (void 0 === evt.cancelable || evt.cancelable);
      source === EVENT_SOURCE_WINDOW && (evt = getExtendedEvents(this, evt, element, type, EVENT_SOURCE_WINDOW));
      let hasCommitted = false;
      if ((!filter2 || filter2(evt)) && (!markFilter || markFilter(element)) && validateSignals.length) {
        const params2 = refs.reduce((params3, ref) => (params3[ref.id()] = ref.output(), params3), {});
        validateSignals.forEach((entry) => {
          if (entry.callback && entry.signal) {
            entry.signal.set(entry.callback(evt, params2)) && (this.commit(entry.signal), hasCommitted = true);
          } else entry.callback ? entry.callback(evt, params2) : (this.commit(entry.signal), hasCommitted = true);
        });
      }
      needPreventDefault && evt.preventDefault(), consume && evt.stopPropagation(), hasCommitted && this.runAsync();
    }, {
      throttle: throttle2,
      debounce: debounce2
    });
    if (source === EVENT_SOURCE_VIEW) {
      if (permit(this._eventConfig, EVENT_SOURCE_VIEW, type)) return this.addEventListener(type, send, NO_TRAP), () => {
        this.removeEventListener(type, send);
      };
    } else if (source === EVENT_SOURCE_WINDOW) return vglobal.addEventListener(type, send), this._eventListeners.push({
      type,
      source: vglobal,
      handler: send
    }), () => {
      vglobal.removeEventListener(type, send);
      const index = this._eventListeners.findIndex((entry) => entry.type === type && entry.source === vglobal && entry.handler === send);
      index >= 0 && this._eventListeners.splice(index, 1);
    };
  }
  event(eventSpec) {
    if ("between" in eventSpec) {
      const [starEvent, endEvent] = eventSpec.between, id2 = `${starEvent.type}-${eventSpec.type}-${endEvent.type}`;
      let unbindEndEvent;
      this.bindEvents(Object.assign({}, starEvent, {
        callback: () => {
          if (this._eventCache || (this._eventCache = {}), !this._eventCache[id2]) {
            const unbindEvent = this.bindEvents(eventSpec);
            this._eventCache[id2] = unbindEvent;
          }
          unbindEndEvent || (unbindEndEvent = this.bindEvents(Object.assign({}, endEvent, {
            callback: () => {
              this._eventCache[id2] && (this._eventCache[id2](), this._eventCache[id2] = null);
            }
          })));
        }
      }));
    } else "merge" in eventSpec ? eventSpec.merge.forEach((entry) => {
      const singleEvent = Object.assign({}, eventSpec);
      isString_default(entry) ? singleEvent.type = entry : isObject_default(entry) && Object.assign(singleEvent, entry), singleEvent.debounce = 50, this.bindEvents(singleEvent);
    }) : this.bindEvents(eventSpec);
  }
  interaction(type, spec) {
    const interaction = Factory.createInteraction(type, this, spec);
    return interaction && (interaction.bind(), this._boundInteractions || (this._boundInteractions = []), this._boundInteractions.push(interaction)), interaction;
  }
  removeInteraction(type, id2) {
    if (this._boundInteractions) {
      const instances = this._boundInteractions.filter((interaction) => {
        var _a;
        return isNil_default(id2) ? isString_default(type) ? interaction.type === type : type ? interaction === type : void 0 : (null === (_a = interaction.options) || void 0 === _a ? void 0 : _a.id) === id2;
      });
      instances.length && instances.forEach((instance) => {
        instance.unbind();
      });
    }
    return this;
  }
  removeAllInteractions() {
    return this._boundInteractions && (this._boundInteractions.forEach((instance) => {
      instance.unbind();
    }), this._boundInteractions = null), this;
  }
  initEvent() {
    const stage = this.renderer.stage();
    stage && stage.on("*", this.delegateEvent);
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  initializeRenderer() {
    const width = this._options.width, height = this._options.height;
    this.renderer = new CanvasRenderer(this), this.renderer.initialize(width, height, this._options, this._eventConfig).background(this._background);
  }
  initialize() {
    var _a;
    this.grammars = new RecordedGrammars((grammar) => grammar.id(), (key, grammar) => this.logger.warn(`Grammar id '${key}' has been occupied`, grammar)), this._cachedGrammars = new RecordedTreeGrammars((grammar) => grammar.id()), this._options.logger && Logger.setInstance(this._options.logger), this.logger = Logger.getInstance(null !== (_a = this._options.logLevel) && void 0 !== _a ? _a : 0), this._dataflow = new Dataflow(), this.animate = new ViewAnimate(this), this._morph = new Morph(), this._options.hooks && (Object.keys(this._options.hooks).forEach((key) => {
      this.on(key, this._options.hooks[key]);
    }), this.hooks = this._options.hooks), this.container = null, this.renderer = null, this._eventListeners = [], this._eventConfig = initializeEventConfig(this._options.eventConfig), this._theme = this._options.disableTheme ? null : ThemeManager.getDefaultTheme(), this.parseBuiltIn(), configureEnvironment(this._options), this.initializeRenderer(), this._eventConfig.disable || this.initEvent(), this._bindResizeEvent(), this._currentDataflow = null, this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this.theme(this._theme);
  }
  pauseProgressive() {
    return false;
  }
  resumeProgressive() {
    return false;
  }
  restartProgressive() {
    return false;
  }
  findProgressiveMarks() {
    const marks = [];
    return this.traverseMarkTree((mark) => {
      marks.push(mark);
    }, (mark) => mark.markType !== GrammarMarkType.group && mark.isProgressive()), marks.length ? (this._progressiveMarks = marks, this.renderer && this.renderer.combineIncrementalLayers(), marks) : (this._progressiveMarks = null, null);
  }
  doPreProgressive() {
    if (this._progressiveMarks && this._progressiveMarks.some((mark) => mark.isDoingProgressive())) {
      const raf = vglobal.getRequestAnimationFrame();
      this._progressiveRafId = raf(this.handleProgressiveFrame);
    }
  }
  clearProgressive() {
    if (this._progressiveRafId) {
      vglobal.getCancelAnimationFrame()(this._progressiveRafId);
    }
    this._progressiveMarks && this._progressiveMarks.length && (this._progressiveMarks.forEach((entry) => {
      entry.clearProgressive();
    }), this._progressiveMarks = null);
  }
  release() {
    var _a, _b, _c;
    this._isReleased = true, this._unBindResizeEvent(), this.clearProgressive(), Factory.unregisterRuntimeTransforms(), this.animate.stop(), this.grammars.release(), this._cachedGrammars.release(), this._dataflow.release(), this._dataflow = null, null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), this.renderer = null, this._boundInteractions = null, this.removeAllListeners(), null === (_c = this._eventListeners) || void 0 === _c || _c.forEach((listener) => {
      listener.source.removeEventListener(listener.type, listener.handler);
    }), this._eventListeners = null;
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/mark/graphic.js
var registerArcGraphic2 = () => {
  registerShadowRoot(), registerArc(), Factory.registerGraphic(GrammarMarkType.arc, createArc);
};
var registerArc3dGraphic2 = () => {
  registerShadowRoot(), registerArc3d(), Factory.registerGraphic(GrammarMarkType.arc3d, createArc3d);
};
var registerPyramid3dGraphic2 = () => {
  registerShadowRoot(), registerPyramid3d(), Factory.registerGraphic(GrammarMarkType.pyramid3d, createPyramid3d);
};
var registerAreaGraphic2 = () => {
  registerShadowRoot(), registerArea(), Factory.registerGraphic(GrammarMarkType.area, createArea);
};
var registerGroupGraphic2 = () => {
  registerShadowRoot(), registerGroup(), Factory.registerGraphic(GrammarMarkType.group, createGroup);
};
var registerImageGraphic2 = () => {
  registerShadowRoot(), registerImage(), Factory.registerGraphic(GrammarMarkType.image, createImage);
};
var registerLineGraphic2 = () => {
  registerShadowRoot(), registerLine(), Factory.registerGraphic(GrammarMarkType.line, createLine);
};
var registerPathGraphic2 = () => {
  registerShadowRoot(), registerPath(), Factory.registerGraphic(GrammarMarkType.path, createPath);
};
var registerRectGraphic2 = () => {
  registerShadowRoot(), registerRect(), Factory.registerGraphic(GrammarMarkType.rect, createRect);
};
var registerRect3dGraphic2 = () => {
  registerShadowRoot(), registerRect3d(), Factory.registerGraphic(GrammarMarkType.rect3d, createRect3d);
};
var registerRuleGraphic = () => {
  registerShadowRoot(), registerLine(), Factory.registerGraphic(GrammarMarkType.rule, createLine);
};
var registerSymbolGraphic2 = () => {
  registerShadowRoot(), registerSymbol(), Factory.registerGraphic(GrammarMarkType.symbol, createSymbol);
};
var registerTextGraphic2 = () => {
  registerShadowRoot(), registerText(), registerRichtext(), Factory.registerGraphic(GrammarMarkType.text, createText);
};
var registerPolygonGraphic2 = () => {
  registerShadowRoot(), registerPolygon(), Factory.registerGraphic(GrammarMarkType.polygon, createPolygon);
};
var registerRichTextGraphic = () => {
  registerShadowRoot(), registerRichtext(), Factory.registerGraphic(GrammarMarkType.richtext, createRichText);
};
var registerCellGraphic = () => {
  registerShadowRoot(), registerSymbol(), Factory.registerGraphic(GrammarMarkType.cell, createSymbol);
};
var registerGlyphGraphic2 = () => {
  registerShadowRoot(), registerGlyph(), Factory.registerGraphic(GrammarMarkType.glyph, createGlyph);
};

// node_modules/@visactor/vgrammar-core/es/glyph/boxplot.js
var scaleIn = (computeCenter) => (element, options, animationParameters) => {
  var _a, _b, _c;
  const direction2 = null !== (_c = null !== (_a = element.getGraphicAttribute("direction", false)) && void 0 !== _a ? _a : null === (_b = element.mark.getGlyphConfig()) || void 0 === _b ? void 0 : _b.direction) && void 0 !== _c ? _c : "vertical", center2 = computeCenter(element, direction2, options);
  if (!isValidNumber_default(center2)) return {};
  const x3 = element.getGraphicAttribute("x", false), y3 = element.getGraphicAttribute("y", false), min4 = element.getGraphicAttribute("min", false), max4 = element.getGraphicAttribute("max", false), q1 = element.getGraphicAttribute("q1", false), q3 = element.getGraphicAttribute("q3", false), median4 = element.getGraphicAttribute("median", false), animateAttributes = {
    from: {
      x: x3,
      y: y3
    },
    to: {
      x: x3,
      y: y3
    }
  };
  return isValidNumber_default(min4) && (animateAttributes.from.min = center2, animateAttributes.to.min = min4), isValidNumber_default(max4) && (animateAttributes.from.max = center2, animateAttributes.to.max = max4), isValidNumber_default(q1) && (animateAttributes.from.q1 = center2, animateAttributes.to.q1 = q1), isValidNumber_default(q3) && (animateAttributes.from.q3 = center2, animateAttributes.to.q3 = q3), isValidNumber_default(median4) && (animateAttributes.from.median = center2, animateAttributes.to.median = median4), animateAttributes;
};
var scaleOut = (computeCenter) => (element, options, animationParameters) => {
  var _a, _b, _c;
  const direction2 = null !== (_c = null !== (_a = element.getGraphicAttribute("direction", false)) && void 0 !== _a ? _a : null === (_b = element.mark.getGlyphConfig()) || void 0 === _b ? void 0 : _b.direction) && void 0 !== _c ? _c : "vertical", center2 = computeCenter(element, direction2, options);
  if (!isValidNumber_default(center2)) return {};
  const x3 = element.getGraphicAttribute("x", true), y3 = element.getGraphicAttribute("y", true), min4 = element.getGraphicAttribute("min", true), max4 = element.getGraphicAttribute("max", true), q1 = element.getGraphicAttribute("q1", true), q3 = element.getGraphicAttribute("q3", true), median4 = element.getGraphicAttribute("median", true), animateAttributes = {
    from: {
      x: x3,
      y: y3
    },
    to: {
      x: x3,
      y: y3
    }
  };
  return isValidNumber_default(min4) && (animateAttributes.to.min = center2, animateAttributes.from.min = min4), isValidNumber_default(max4) && (animateAttributes.to.max = center2, animateAttributes.from.max = max4), isValidNumber_default(q1) && (animateAttributes.to.q1 = center2, animateAttributes.from.q1 = q1), isValidNumber_default(q3) && (animateAttributes.to.q3 = center2, animateAttributes.from.q3 = q3), isValidNumber_default(median4) && (animateAttributes.to.median = center2, animateAttributes.from.median = median4), animateAttributes;
};
var computeBoxplotCenter = (glyphElement, direction2, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (options && isValidNumber_default(options.center)) return options.center;
  let median4, max4, min4, q1, q3;
  if (isHorizontal(direction2)) {
    median4 = null === (_b = null === (_a = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.x, max4 = null === (_d = null === (_c = glyphElement.getGraphicAttribute("points", false, "max")) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.x, min4 = null === (_f = null === (_e = glyphElement.getGraphicAttribute("points", false, "min")) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.x;
    const boxWidth = glyphElement.getGraphicAttribute("width", false, "box"), boxX = glyphElement.getGraphicAttribute("x", false, "box");
    q1 = boxX, q3 = boxX + boxWidth;
  } else {
    median4 = null === (_h = null === (_g = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.y, max4 = null === (_k = null === (_j = glyphElement.getGraphicAttribute("points", false, "max")) || void 0 === _j ? void 0 : _j[0]) || void 0 === _k ? void 0 : _k.y, min4 = null === (_m = null === (_l = glyphElement.getGraphicAttribute("points", false, "min")) || void 0 === _l ? void 0 : _l[0]) || void 0 === _m ? void 0 : _m.y;
    const boxHeight = glyphElement.getGraphicAttribute("height", false, "box"), boxY = glyphElement.getGraphicAttribute("y", false, "box");
    q1 = boxY, q3 = boxY + boxHeight;
  }
  return isValidNumber_default(median4) ? median4 : isValidNumber_default(q1) && isValidNumber_default(q3) ? (q1 + q3) / 2 : isValidNumber_default(max4) && isValidNumber_default(min4) ? (max4 + min4) / 2 : isValidNumber_default(min4) ? min4 : isValidNumber_default(max4) ? max4 : NaN;
};
var encodeBoxplotSize = (encodeValues, datum, element, config2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const attributes = {
    shaft: {},
    box: {},
    max: {},
    min: {},
    median: {}
  }, x3 = null !== (_a = encodeValues.x) && void 0 !== _a ? _a : element.getGraphicAttribute("x", false), y3 = null !== (_b = encodeValues.y) && void 0 !== _b ? _b : element.getGraphicAttribute("y", false), width = null !== (_c = encodeValues.width) && void 0 !== _c ? _c : element.getGraphicAttribute("width", false), height = null !== (_d = encodeValues.height) && void 0 !== _d ? _d : element.getGraphicAttribute("height", false), boxWidth = null !== (_e = encodeValues.boxWidth) && void 0 !== _e ? _e : element.getGraphicAttribute("boxWidth", false), boxHeight = null !== (_f = encodeValues.boxHeight) && void 0 !== _f ? _f : element.getGraphicAttribute("boxHeight", false), ruleWidth = null !== (_g = encodeValues.ruleWidth) && void 0 !== _g ? _g : element.getGraphicAttribute("ruleWidth", false), ruleHeight = null !== (_h = encodeValues.ruleHeight) && void 0 !== _h ? _h : element.getGraphicAttribute("ruleHeight", false);
  return config2 && isHorizontal(config2.direction) ? (isValidNumber_default(boxHeight) ? (Object.assign(attributes.box, {
    y: y3 - boxHeight / 2,
    y1: y3 + boxHeight / 2
  }), Object.assign(attributes.median, {
    y: y3 - boxHeight / 2,
    y1: y3 + boxHeight / 2
  })) : (Object.assign(attributes.box, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }), Object.assign(attributes.median, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  })), isValidNumber_default(ruleHeight) ? (Object.assign(attributes.max, {
    y: y3 - ruleHeight / 2,
    y1: y3 + ruleHeight / 2
  }), Object.assign(attributes.min, {
    y: y3 - ruleHeight / 2,
    y1: y3 + ruleHeight / 2
  })) : (Object.assign(attributes.max, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }), Object.assign(attributes.min, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }))) : (isValidNumber_default(boxWidth) ? (Object.assign(attributes.box, {
    x: x3 - boxWidth / 2,
    x1: x3 + boxWidth / 2
  }), Object.assign(attributes.median, {
    x: x3 - boxWidth / 2,
    x1: x3 + boxWidth / 2
  })) : (Object.assign(attributes.box, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }), Object.assign(attributes.median, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  })), isValidNumber_default(ruleWidth) ? (Object.assign(attributes.max, {
    x: x3 - ruleWidth / 2,
    x1: x3 + ruleWidth / 2
  }), Object.assign(attributes.min, {
    x: x3 - ruleWidth / 2,
    x1: x3 + ruleWidth / 2
  })) : (Object.assign(attributes.max, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }), Object.assign(attributes.min, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }))), attributes;
};
var boxplotScaleIn = scaleIn(computeBoxplotCenter);
var boxplotScaleOut = scaleOut(computeBoxplotCenter);
function registerBoxplotGlyph() {
  Factory.registerGlyph("boxplot", {
    shaft: "rule",
    box: "rect",
    max: "rule",
    min: "rule",
    median: "rule"
  }).registerProgressiveChannels(["x", "y", "q1", "q3", "min", "max", "median", "angle", "width", "height", "boxWidth", "boxHeight", "ruleWidth", "ruleHeight"]).registerFunctionEncoder(encodeBoxplotSize).registerChannelEncoder("x", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? null : {
    shaft: {
      x: encodeValue,
      x1: encodeValue
    }
  }).registerChannelEncoder("y", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      y: encodeValue,
      y1: encodeValue
    }
  } : null).registerChannelEncoder("q1", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    box: {
      x: encodeValue
    }
  } : {
    box: {
      y: encodeValue
    }
  }).registerChannelEncoder("q3", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    box: {
      x1: encodeValue
    }
  } : {
    box: {
      y1: encodeValue
    }
  }).registerChannelEncoder("min", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      x: encodeValue
    },
    min: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    shaft: {
      y: encodeValue
    },
    min: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("max", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    shaft: {
      x1: encodeValue
    },
    max: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    shaft: {
      y1: encodeValue
    },
    max: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("median", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    median: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    median: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("angle", (channel, encodeValue, encodeValues, datum, element, config2) => {
    var _a;
    const defaultAnchor = config2 && isHorizontal(config2.direction) ? [(encodeValues.min + encodeValues.max) / 2, encodeValues.y] : [encodeValues.x, (encodeValues.min + encodeValues.max) / 2], anchor = null !== (_a = encodeValues.anchor) && void 0 !== _a ? _a : defaultAnchor;
    return {
      shaft: {
        angle: encodeValue,
        anchor
      },
      box: {
        angle: encodeValue,
        anchor
      },
      max: {
        angle: encodeValue,
        anchor
      },
      min: {
        angle: encodeValue,
        anchor
      },
      median: {
        angle: encodeValue,
        anchor
      }
    };
  }).registerDefaultEncoder(() => ({
    max: {
      visible: false
    },
    min: {
      visible: false
    },
    median: {
      visible: false
    }
  })), Factory.registerAnimationType("boxplotScaleIn", boxplotScaleIn), Factory.registerAnimationType("boxplotScaleOut", boxplotScaleOut), registerGlyphGraphic2(), registerRectGraphic2(), registerRuleGraphic();
}
var computeBarBoxplotCenter = (glyphElement, direction2, options) => {
  var _a, _b, _c, _d;
  if (isValidNumber_default(null == options ? void 0 : options.center)) return options.center;
  let median4, max4, min4, q1, q3;
  if (isHorizontal(direction2)) {
    median4 = null === (_b = null === (_a = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.x;
    const minMaxBoxWidth = glyphElement.getGraphicAttribute("width", false, "minMaxBox"), minMaxBoxBoxX = glyphElement.getGraphicAttribute("x", false, "minMaxBox");
    min4 = minMaxBoxBoxX, max4 = minMaxBoxBoxX + minMaxBoxWidth;
    const q1q3BoxWidth = glyphElement.getGraphicAttribute("width", false, "q1q3Box"), q1q3BoxX = glyphElement.getGraphicAttribute("x", false, "q1q3Box");
    q1 = q1q3BoxX, q3 = q1q3BoxX + q1q3BoxWidth;
  } else {
    median4 = null === (_d = null === (_c = glyphElement.getGraphicAttribute("points", false, "median")) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.y;
    const minMaxBoxHeight = glyphElement.getGraphicAttribute("height", false, "minMaxBox"), minMaxBoxBoxY = glyphElement.getGraphicAttribute("y", false, "minMaxBox");
    min4 = minMaxBoxBoxY, max4 = minMaxBoxBoxY + minMaxBoxHeight;
    const q1q3BoxHeight = glyphElement.getGraphicAttribute("height", false, "q1q3Box"), q1q3BoxY = glyphElement.getGraphicAttribute("y", false, "q1q3Box");
    q1 = q1q3BoxY, q3 = q1q3BoxY + q1q3BoxHeight;
  }
  return isValidNumber_default(median4) ? median4 : isValidNumber_default(q1) && isValidNumber_default(q3) ? (q1 + q3) / 2 : isValidNumber_default(max4) && isValidNumber_default(min4) ? (max4 + min4) / 2 : isValidNumber_default(min4) ? min4 : isValidNumber_default(max4) ? max4 : NaN;
};
var encodeBarBoxplotSize = (encodeValues, datum, element, config2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const attributes = {
    minMaxBox: {},
    q1q3Box: {},
    median: {}
  }, x3 = null !== (_a = encodeValues.x) && void 0 !== _a ? _a : element.getGraphicAttribute("x", false), y3 = null !== (_b = encodeValues.y) && void 0 !== _b ? _b : element.getGraphicAttribute("y", false), width = null !== (_c = encodeValues.width) && void 0 !== _c ? _c : element.getGraphicAttribute("width", false), minMaxWidth = null !== (_d = encodeValues.minMaxWidth) && void 0 !== _d ? _d : element.getGraphicAttribute("minMaxWidth", false), q1q3Width = null !== (_e = encodeValues.q1q3Width) && void 0 !== _e ? _e : element.getGraphicAttribute("q1q3Width", false), height = null !== (_f = encodeValues.height) && void 0 !== _f ? _f : element.getGraphicAttribute("height", false), minMaxHeight = null !== (_g = encodeValues.minMaxHeight) && void 0 !== _g ? _g : element.getGraphicAttribute("minMaxHeight", false), q1q3Height = null !== (_h = encodeValues.q1q3Height) && void 0 !== _h ? _h : element.getGraphicAttribute("q1q3Height", false);
  return config2 && isHorizontal(config2.direction) ? (isValidNumber_default(minMaxHeight) ? Object.assign(attributes.minMaxBox, {
    y: y3 - minMaxHeight / 2,
    y1: y3 + minMaxHeight / 2
  }) : Object.assign(attributes.minMaxBox, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }), isValidNumber_default(q1q3Height) ? (Object.assign(attributes.q1q3Box, {
    y: y3 - q1q3Height / 2,
    y1: y3 + q1q3Height / 2
  }), Object.assign(attributes.median, {
    y: y3 - q1q3Height / 2,
    y1: y3 + q1q3Height / 2
  })) : (Object.assign(attributes.q1q3Box, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }), Object.assign(attributes.median, {
    y: y3 - height / 2,
    y1: y3 + height / 2
  }))) : (isValidNumber_default(minMaxWidth) ? Object.assign(attributes.minMaxBox, {
    x: x3 - minMaxWidth / 2,
    x1: x3 + minMaxWidth / 2
  }) : Object.assign(attributes.minMaxBox, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }), isValidNumber_default(q1q3Width) ? (Object.assign(attributes.q1q3Box, {
    x: x3 - q1q3Width / 2,
    x1: x3 + q1q3Width / 2
  }), Object.assign(attributes.median, {
    x: x3 - q1q3Width / 2,
    x1: x3 + q1q3Width / 2
  })) : (Object.assign(attributes.q1q3Box, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }), Object.assign(attributes.median, {
    x: x3 - width / 2,
    x1: x3 + width / 2
  }))), attributes;
};
var barBoxplotScaleIn = scaleIn(computeBarBoxplotCenter);
var barBoxplotScaleOut = scaleOut(computeBarBoxplotCenter);
function registerBarBoxplotGlyph() {
  Factory.registerGlyph("barBoxplot", {
    minMaxBox: "rect",
    q1q3Box: "rect",
    median: "rule"
  }).registerProgressiveChannels(["x", "y", "q1", "q3", "min", "max", "median", "angle", "width", "height", "minMaxWidth", "q1q3Width", "minMaxHeight", "q1q3Height"]).registerFunctionEncoder(encodeBarBoxplotSize).registerChannelEncoder("q1", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    q1q3Box: {
      x: encodeValue
    }
  } : {
    q1q3Box: {
      y: encodeValue
    }
  }).registerChannelEncoder("q3", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    q1q3Box: {
      x1: encodeValue
    }
  } : {
    q1q3Box: {
      y1: encodeValue
    }
  }).registerChannelEncoder("min", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    minMaxBox: {
      x: encodeValue
    }
  } : {
    minMaxBox: {
      y: encodeValue
    }
  }).registerChannelEncoder("max", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    minMaxBox: {
      x1: encodeValue
    }
  } : {
    minMaxBox: {
      y1: encodeValue
    }
  }).registerChannelEncoder("median", (channel, encodeValue, encodeValues, datum, element, config2) => config2 && isHorizontal(config2.direction) ? {
    median: {
      x: encodeValue,
      x1: encodeValue,
      visible: true
    }
  } : {
    median: {
      y: encodeValue,
      y1: encodeValue,
      visible: true
    }
  }).registerChannelEncoder("angle", (channel, encodeValue, encodeValues, datum, element, config2) => {
    var _a;
    const anchor = null !== (_a = encodeValues.anchor) && void 0 !== _a ? _a : [encodeValues.x, (encodeValues.min + encodeValues.max) / 2];
    return {
      minMaxBox: {
        angle: encodeValue,
        anchor
      },
      q1q3Box: {
        angle: encodeValue,
        anchor
      },
      median: {
        angle: encodeValue,
        anchor
      }
    };
  }).registerChannelEncoder("lineWidth", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      lineWidth: 0
    },
    q1q3Box: {
      lineWidth: 0
    }
  })).registerChannelEncoder("minMaxFillOpacity", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      fillOpacity: encodeValue
    }
  })).registerChannelEncoder("stroke", (channel, encodeValue, encodeValues, datum, element, config2) => ({
    minMaxBox: {
      stroke: false
    },
    q1q3Box: {
      stroke: false
    }
  })).registerDefaultEncoder(() => ({
    minMaxBox: {
      lineWidth: 0
    },
    q1q3Box: {
      lineWidth: 0
    },
    median: {
      visible: false
    }
  })), Factory.registerAnimationType("barBoxplotScaleIn", barBoxplotScaleIn), Factory.registerAnimationType("barBoxplotScaleOut", barBoxplotScaleOut), registerGlyphGraphic2(), registerRectGraphic2(), registerRuleGraphic();
}

// node_modules/@visactor/vgrammar-core/es/glyph/ripple.js
var registerRippleGlyph = () => {
  Factory.registerGlyph("ripplePoint", {
    symbol: "symbol",
    ripple0: "symbol",
    ripple1: "symbol",
    ripple2: "symbol"
  }).registerFunctionEncoder((encodeValues, datum, element, config2) => {
    var _a;
    const ripple = Math.max(0, Math.min(encodeValues.ripple, 1)), size = null !== (_a = encodeValues.size) && void 0 !== _a ? _a : element.getGraphicAttribute("size"), rippleSize = 0.5 * size;
    return {
      ripple0: {
        size: size + rippleSize * ripple,
        fillOpacity: 0.75 - 0.25 * ripple
      },
      ripple1: {
        size: size + rippleSize * (1 + ripple),
        fillOpacity: 0.5 - 0.25 * ripple
      },
      ripple2: {
        size: size + rippleSize * (2 + ripple),
        fillOpacity: 0.25 - 0.25 * ripple
      }
    };
  }).registerDefaultEncoder(() => ({
    ripple0: {
      fillOpacity: 0.75
    },
    ripple1: {
      fillOpacity: 0.5
    },
    ripple2: {
      fillOpacity: 0.25
    }
  })), registerGlyphGraphic2(), registerSymbolGraphic2();
};

// node_modules/@visactor/vgrammar-core/es/glyph/link-path.js
var getHorizontalPath2 = (options, ratio) => {
  var _a;
  const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : 0.5, thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let x05 = options.x0, x14 = options.x1, y004 = options.y0, y10 = options.y1, cpx0 = x05 + curvature * (x14 - x05), cpx1 = x14 + curvature * (x05 - x14), formatter = (v2) => v2;
  false !== options.round && (x05 = Math.round(x05), x14 = Math.round(x14), y004 = Math.round(y004), y10 = Math.round(y10), cpx0 = Math.round(cpx0), cpx1 = Math.round(cpx1), formatter = Math.round);
  "line" === options.pathType || options.pathType;
  "center" === options.align ? (y004 = formatter(options.y0 - thickness / 2), y10 = formatter(options.y1 - thickness / 2)) : "end" === options.align ? (y004 = formatter(options.y0 + options.thickness / 2 - thickness), y10 = formatter(options.y1 + options.thickness / 2 - thickness)) : (y004 = formatter(options.y0 - options.thickness / 2), y10 = formatter(options.y1 - options.thickness / 2));
  const y01 = formatter(y004 + thickness), y112 = formatter(y10 + thickness), hasLength = Math.abs(x14 - x05) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${x14},${formatter(y10 - thickness / 2)}L${formatter(x14 + thickness)},${formatter((y10 + y112) / 2)}L${x14},${formatter(y112 + thickness / 2)}` : "", startArrowPath = options.startArrow && hasLength ? `L${x05},${formatter(y01 + thickness / 2)}L${formatter(x05 - thickness)},${formatter((y004 + y01) / 2)}L${x05},${formatter(y004 - thickness / 2)}` : "";
  return "line" === options.pathType ? `M${x05},${y004}L${x14},${y10}${endArrowPath}L${x14},${y112}L${x05},${y01}${startArrowPath}Z` : "polyline" === options.pathType ? `M${x05},${y004}L${cpx0},${y004}L${cpx0},${y10}L${x14},${y10}
    ${endArrowPath}L${x14},${y112}L${cpx0},${y112}L${cpx0},${y01}L${x05},${y01}${startArrowPath}Z` : `M${x05},${y004}C${cpx0},${y004},${cpx1},${y10},${x14},${y10}
  ${endArrowPath}L${x14},${y112}C${cpx1},${y112},${cpx0},${y01},${x05},${y01}${startArrowPath}Z`;
};
var getVerticalPath2 = (options, ratio) => {
  var _a;
  const curvature = null !== (_a = options.curvature) && void 0 !== _a ? _a : 0.5, thickness = "number" == typeof ratio ? options.thickness * ratio : options.thickness;
  let y05 = options.y0, y14 = options.y1, x004 = options.x0, x10 = options.x1, cpy0 = y05 + curvature * (y14 - y05), cpy1 = y14 + curvature * (y05 - y14), formatter = (v2) => v2;
  false !== options.round && (formatter = Math.round, y05 = Math.round(y05), y14 = Math.round(y14), x004 = Math.round(x004), x10 = Math.round(x10), cpy0 = Math.round(cpy0), cpy1 = Math.round(cpy1));
  "line" === options.pathType || options.pathType;
  "center" === options.align ? (x004 = formatter(options.x0 - thickness / 2), x10 = formatter(options.x1 - thickness / 2)) : "end" === options.align ? (x004 = formatter(options.x0 + options.thickness / 2 - thickness), x10 = formatter(options.x1 + options.thickness / 2 - thickness)) : (x004 = formatter(options.x0 - options.thickness / 2), x10 = formatter(options.x1 - options.thickness / 2));
  const x01 = formatter(x004 + thickness), x112 = formatter(x10 + thickness), hasLength = Math.abs(y14 - y05) > 1e-6, endArrowPath = options.endArrow && hasLength ? `L${formatter(x10 - thickness / 2)},${y14}L${formatter((x10 + x112) / 2)},${formatter(y14 + thickness)}L${formatter(x112 + thickness / 2)},${y14}` : "", startArrowPath = options.startArrow && hasLength ? `L${formatter(x01 + thickness / 2)},${y05}L${formatter((x01 + x004) / 2)},${formatter(y05 - thickness)}L${formatter(x004 - thickness / 2)},${y05}` : "";
  return "line" === options.pathType ? `M${x004},${y05}L${x10},${y14}${endArrowPath}L${x112},${y14}L${x01},${y05}${startArrowPath}Z` : "polyline" === options.pathType ? `M${x004},${y05}L${x004},${cpy0}L${x10},${cpy0}L${x10},${y14}
    ${endArrowPath}L${x112},${y14}L${x112},${cpy0}L${x01},${cpy0}L${x01},${y05}${startArrowPath}Z` : `M${x004},${y05}C${x004},${cpy0},${x10},${cpy1},${x10},${y14}
  ${endArrowPath}L${x112},${y14}C${x112},${cpy1},${x01},${cpy0},${x01},${y05}${startArrowPath}Z`;
};
var encoder = (encodeValues, datum, element, config2) => {
  var _a;
  const direction2 = null !== (_a = encodeValues.direction) && void 0 !== _a ? _a : null == config2 ? void 0 : config2.direction, parsePath = ["vertical", "TB", "BT"].includes(direction2) ? getVerticalPath2 : getHorizontalPath2, isRatioShow = "number" == typeof encodeValues.ratio && encodeValues.ratio >= 0 && encodeValues.ratio <= 1, encodeChannels = Object.keys(encodeValues);
  return ["x0", "y0", "x1", "y1"].every((channel) => encodeChannels.includes(channel)) ? {
    back: {
      path: isRatioShow ? parsePath(encodeValues, 1) : ""
    },
    front: {
      path: parsePath(encodeValues, isRatioShow ? encodeValues.ratio : 1)
    }
  } : {};
};
var linkPathGrowIn = (element, options, animationParameters) => {
  const linkValues = {
    x0: element.getGraphicAttribute("x0", false),
    x1: element.getGraphicAttribute("x1", false),
    y0: element.getGraphicAttribute("y0", false),
    y1: element.getGraphicAttribute("y1", false),
    thickness: element.getGraphicAttribute("thickness", false),
    round: element.getGraphicAttribute("round", false),
    align: element.getGraphicAttribute("align", false),
    pathType: element.getGraphicAttribute("pathType", false),
    endArrow: element.getGraphicAttribute("endArrow", false),
    startArrow: element.getGraphicAttribute("startArrow", false)
  };
  return Object.keys(linkValues).forEach((key) => {
    isNil_default(linkValues[key]) && delete linkValues[key];
  }), {
    from: Object.assign({}, linkValues, {
      x1: linkValues.x0,
      y1: linkValues.y0
    }),
    to: linkValues
  };
};
var linkPathGrowOut = (element, options, animationParameters) => {
  const linkValues = {
    x0: element.getGraphicAttribute("x0", true),
    x1: element.getGraphicAttribute("x1", true),
    y0: element.getGraphicAttribute("y0", true),
    y1: element.getGraphicAttribute("y1", true),
    thickness: element.getGraphicAttribute("thickness", true),
    round: element.getGraphicAttribute("round", true),
    align: element.getGraphicAttribute("align", true),
    pathType: element.getGraphicAttribute("pathType", true),
    endArrow: element.getGraphicAttribute("endArrow", true),
    startArrow: element.getGraphicAttribute("startArrow", true)
  };
  return Object.keys(linkValues).forEach((key) => {
    isNil_default(linkValues[key]) && delete linkValues[key];
  }), {
    from: linkValues,
    to: Object.assign({}, linkValues, {
      x1: linkValues.x0,
      y1: linkValues.y0
    })
  };
};
var linkPathUpdate = (element, options, animationParameters) => {
  const bassLinkValues = {
    thickness: element.getGraphicAttribute("thickness", false),
    round: element.getGraphicAttribute("round", false),
    align: element.getGraphicAttribute("align", false),
    pathType: element.getGraphicAttribute("pathType", false),
    endArrow: element.getGraphicAttribute("endArrow", false),
    startArrow: element.getGraphicAttribute("startArrow", false)
  };
  Object.keys(bassLinkValues).forEach((key) => {
    isNil_default(bassLinkValues[key]) && delete bassLinkValues[key];
  });
  return {
    from: Object.assign(Object.assign({
      x0: element.getGraphicAttribute("x0", true),
      x1: element.getGraphicAttribute("x1", true),
      y0: element.getGraphicAttribute("y0", true),
      y1: element.getGraphicAttribute("y1", true)
    }, bassLinkValues), bassLinkValues),
    to: Object.assign({
      x0: element.getGraphicAttribute("x0", false),
      x1: element.getGraphicAttribute("x1", false),
      y0: element.getGraphicAttribute("y0", false),
      y1: element.getGraphicAttribute("y1", false)
    }, bassLinkValues)
  };
};
var registerLinkPathGlyph = () => {
  Factory.registerGlyph("linkPath", {
    back: "path",
    front: "path"
  }).registerFunctionEncoder(encoder).registerChannelEncoder("backgroundStyle", (channel, encodeValue) => ({
    back: encodeValue
  })).registerDefaultEncoder(() => ({
    back: {
      zIndex: 0
    },
    front: {
      zIndex: 1
    }
  })), Factory.registerAnimationType("linkPathGrowIn", linkPathGrowIn), Factory.registerAnimationType("linkPathGrowOut", linkPathGrowOut), Factory.registerAnimationType("linkPathUpdate", linkPathUpdate), registerGlyphGraphic2(), registerPathGraphic2();
};

// node_modules/@visactor/vgrammar-core/es/component/scale.js
var ScaleComponent = class extends Component {
  parseAddition(spec) {
    return super.parseAddition(spec), this.scale(spec.scale), this;
  }
  scale(scale4) {
    if (this.spec.scale) {
      const lastScaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this.detach(lastScaleGrammar), this.spec.scale = void 0;
    }
    const scaleGrammar = isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
    return this.spec.scale = scaleGrammar, this.attach(scaleGrammar), this._updateComponentEncoders(), this.commit(), this;
  }
  getScale() {
    return isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
  }
};

// node_modules/@visactor/vgrammar-core/es/component/axis.js
var generateLineAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.axis) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleAxis) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCoordinateAxisAttribute = (scale4, coordinate, inside, baseValue, layout2, isGrid) => {
  var _a;
  const axisPosition = scale4.getCoordinateAxisPosition();
  layout2 && "auto" === layout2.position && (layout2.position = inside ? "content" : axisPosition);
  const axisPoints = scale4.getCoordinateAxisPoints(baseValue);
  if (axisPoints) {
    const res = {
      start: axisPoints[0],
      end: axisPoints[1],
      verticalFactor: ("top" === axisPosition || "left" === axisPosition ? -1 : 1) * (inside ? -1 : 1) * ((null === (_a = scale4.getSpec().range) || void 0 === _a ? void 0 : _a.reversed) ? -1 : 1)
    };
    if (isGrid && "polar" === coordinate.type) {
      const angle3 = coordinate.angle();
      res.center = coordinate.origin(), res.startAngle = angle3[0], res.endAngle = angle3[1];
    }
    return res;
  }
  const radius = coordinate.radius(), angle2 = coordinate.angle();
  return {
    center: coordinate.origin(),
    radius: radius[1],
    innerRadius: radius[0],
    inside,
    startAngle: angle2[0],
    endAngle: angle2[1]
  };
};
var Axis = class extends ScaleComponent {
  constructor(view, group, mode2) {
    super(view, ComponentEnum.axis, group), this.spec.componentType = ComponentEnum.axis, this.mode = mode2;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.axisType(spec.axisType), this.tickCount(spec.tickCount), this.inside(spec.inside), this.baseValue(spec.baseValue), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._axisComponentType = null, this;
  }
  axisType(axisType) {
    return this.spec.axisType = axisType, this._axisComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory.createGraphicComponent(this._getAxisComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  getAxisComponentType() {
    return this._axisComponentType;
  }
  _updateComponentEncoders() {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let addition = invokeEncoder(encoder2, datum, element, parameters);
          const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element), coordinate = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
          coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout), addition));
          const scale4 = null === (_b = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getAxisComponentType()) {
            case AxisEnum.lineAxis:
              return generateLineAxisAttributes(scale4, theme2, addition, tickCount);
            case AxisEnum.circleAxis:
              return generateCircleAxisAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getAxisComponentType() {
    var _a;
    if (this._axisComponentType) return this._axisComponentType;
    let type = this.spec.axisType;
    if (isNil_default(type)) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      type = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? "line" : "circle" : "line";
    }
    return this._axisComponentType = "circle" === type ? AxisEnum.circleAxis : AxisEnum.lineAxis, this._axisComponentType;
  }
};
Axis.componentType = ComponentEnum.axis;
var registerAxis = () => {
  Factory.registerGraphicComponent(AxisEnum.lineAxis, (attrs, options) => new LineAxis(attrs, options)), Factory.registerGraphicComponent(AxisEnum.circleAxis, (attrs) => new CircleAxis(attrs)), Factory.registerComponent(ComponentEnum.axis, Axis);
};

// node_modules/@visactor/vgrammar-core/es/interactions/legend-filter.js
var LegendFilter = class _LegendFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _LegendFilter.type, this.options = Object.assign({}, _LegendFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "legend" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const legend = this._marks[0];
    if (!this._data || !legend) return [];
    const isContinuous2 = legend.isContinuousLegend(), filter2 = this.options.target.filter, transform29 = this.options.target.transform, dataFilter = isString_default(filter2) ? isContinuous2 ? (datum, filterValue) => datum[filter2] >= filterValue.start && datum[filter2] <= filterValue.end : (datum, filterValue) => filterValue.includes(datum[filter2]) : filter2;
    this._filterData(this._data, legend, DataFilterRank.legend, (event) => isContinuous2 ? {
      start: event.detail.value[0],
      end: event.detail.value[1]
    } : event.detail.currentSelected, dataFilter, transform29);
    return [{
      type: isContinuous2 ? "change" : LegendEvent.legendItemClick,
      handler: this.handleFilter
    }];
  }
};
LegendFilter.type = "legend-filter", LegendFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/legend.js
var generateDiscreteLegendAttributes = (scale4, theme2, addition, shapeScale) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.discreteLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const items = Array.from(new Set(array(scale4.domain()))).map((item, index) => {
    var _a2, _b, _c, _d, _e, _f;
    const value = scale4.scale(item), color = parseColor(value), shape = color ? Object.assign(Object.assign({}, null !== (_c = null === (_b = null === (_a2 = null == legendTheme ? void 0 : legendTheme.items) || void 0 === _a2 ? void 0 : _a2[0]) || void 0 === _b ? void 0 : _b.shape) && void 0 !== _c ? _c : {}), {
      fill: color,
      stroke: color
    }) : null !== (_f = null === (_e = null === (_d = null == legendTheme ? void 0 : legendTheme.items) || void 0 === _d ? void 0 : _d[0]) || void 0 === _e ? void 0 : _e.shape) && void 0 !== _f ? _f : {};
    return shapeScale && Object.assign(shape, {
      symbolType: shapeScale.scale(item)
    }), {
      label: item.toString(),
      id: item,
      shape,
      index
    };
  });
  return merge({}, legendTheme, {
    items
  }, null != addition ? addition : {});
};
var generateColorLegendAttributes = (scale4, theme2, addition) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.colorLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const domain = scale4.domain();
  return merge({}, legendTheme, {
    colors: scale4.range().slice(),
    min: domain[0],
    max: last(domain)
  }, null != addition ? addition : {});
};
var generateSizeLegendAttributes = (scale4, theme2, addition) => {
  var _a;
  const legendTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.sizeLegend;
  if (!scale4) return merge({}, legendTheme, null != addition ? addition : {});
  const domain = scale4.domain(), attributes = {
    min: domain[0],
    max: domain[domain.length - 1],
    value: [domain[0], domain[domain.length - 1]]
  };
  return merge({}, legendTheme, attributes, null != addition ? addition : {});
};
var Legend = class extends ScaleComponent {
  constructor(view, group) {
    super(view, ComponentEnum.legend, group), this.spec.componentType = ComponentEnum.legend, this.spec.legendType = "auto";
  }
  parseAddition(spec) {
    return this.shapeScale(spec.shapeScale), super.parseAddition(spec), this.legendType(spec.legendType), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._legendComponentType = null, this;
  }
  shapeScale(shapeScale) {
    if (this.spec.shapeScale) {
      const lastScaleGrammar = isString_default(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale;
      this.detach(lastScaleGrammar), this.spec.shapeScale = void 0;
    }
    const scaleGrammar = isString_default(shapeScale) ? this.view.getScaleById(shapeScale) : shapeScale;
    return this.spec.shapeScale = scaleGrammar, this.attach(scaleGrammar), this.commit(), this;
  }
  legendType(legendType) {
    return this.spec.legendType = legendType, this._legendComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  isContinuousLegend() {
    return this._getLegendComponentType() !== LegendEnum.discreteLegend;
  }
  setSelected(selectedValues) {
    return this.getGroupGraphicItem().setSelected(selectedValues), this;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = Factory.createGraphicComponent(this._getLegendComponentType(), attrs, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, shapeScaleGrammar = isString_default(this.spec.shapeScale) ? this.view.getScaleById(this.spec.shapeScale) : this.spec.shapeScale, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters), scale4 = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
          switch (this._getLegendComponentType()) {
            case LegendEnum.discreteLegend:
              return generateDiscreteLegendAttributes(scale4, theme2, addition, null === (_b = null == shapeScaleGrammar ? void 0 : shapeScaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(shapeScaleGrammar));
            case LegendEnum.colorLegend:
              return generateColorLegendAttributes(scale4, theme2, addition);
            case LegendEnum.sizeLegend:
              return generateSizeLegendAttributes(scale4, theme2, addition);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getLegendComponentType() {
    var _a;
    if (this._legendComponentType) return this._legendComponentType;
    if (this.spec.legendType && "auto" !== this.spec.legendType) this._legendComponentType = "color" === this.spec.legendType ? "colorLegend" : "size" === this.spec.legendType ? "sizeLegend" : "discreteLegend";
    else {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, scaleType = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getScaleType) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
      if (scaleType && isContinuous(scaleType)) {
        const range2 = scaleGrammar.getScale().range();
        parseColor(null == range2 ? void 0 : range2[0]) ? this._legendComponentType = LegendEnum.colorLegend : this._legendComponentType = LegendEnum.sizeLegend;
      } else this._legendComponentType = LegendEnum.discreteLegend;
    }
    return this._legendComponentType;
  }
};
Legend.componentType = ComponentEnum.legend;

// node_modules/@visactor/vgrammar-core/es/interactions/slider-filter.js
var SliderFilter = class _SliderFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _SliderFilter.type, this.options = Object.assign({}, _SliderFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "slider" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const slider2 = this._marks[0];
    if (!this._data || !slider2) return [];
    const filter2 = this.options.target.filter, transform29 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => datum[filter2] >= filterValue.start && datum[filter2] <= filterValue.end : filter2;
    return this._filterData(this._data, slider2, DataFilterRank.slider, (event) => ({
      start: event.detail.value[0],
      end: event.detail.value[1]
    }), dataFilter, transform29), [{
      type: "change",
      handler: this.handleFilter
    }];
  }
};
SliderFilter.type = "slider-filter", SliderFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/slider.js
var generateSliderAttributes = (min4, max4, theme2, addition) => {
  var _a;
  const sliderTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.slider;
  return merge({}, sliderTheme, {
    min: min4,
    max: max4,
    value: [min4, max4]
  }, null != addition ? addition : {});
};
var Slider2 = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.slider, group), this.spec.componentType = ComponentEnum.slider;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.min(spec.min), this.max(spec.max), this;
  }
  min(min4) {
    return this.setFunctionSpec(min4, "min");
  }
  max(max4) {
    return this.setFunctionSpec(max4, "max");
  }
  setStartEndValue(start, end) {
    return this.getGroupGraphicItem().setValue([start, end]), this;
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          const min4 = isNil_default(this.spec.min) ? 0 : invokeFunctionType(this.spec.min, parameters, datum, element), max4 = isNil_default(this.spec.max) ? 1 : invokeFunctionType(this.spec.max, parameters, datum, element), theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateSliderAttributes(min4, max4, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Slider2.componentType = ComponentEnum.slider;

// node_modules/@visactor/vgrammar-core/es/component/label.js
var generateLabelAttributes = (marks, groupSize, encoder2, labelStyle, parameters, theme2 = {}) => {
  var _a;
  const labelTheme = null === (_a = theme2.components) || void 0 === _a ? void 0 : _a.dataLabel, dataLabels = marks.map((mark, index) => {
    var _a2, _b, _c, _d, _e;
    const labelParameters = Object.assign(Object.assign({}, parameters), {
      labelIndex: index
    }), addition = null !== (_a2 = invokeFunctionType(labelStyle, labelParameters, mark)) && void 0 !== _a2 ? _a2 : {}, { components = {} } = theme2;
    let currentTheme = {};
    switch (mark.markType) {
      case GrammarMarkType.line:
      case GrammarMarkType.area:
        currentTheme = "line" === addition.type ? components.lineLabel : "area" === addition.type ? components.areaLabel : components.lineDataLabel;
        break;
      case GrammarMarkType.rect:
      case GrammarMarkType.rect3d:
      case GrammarMarkType.interval:
        currentTheme = components.rectLabel;
        break;
      case GrammarMarkType.symbol:
      case GrammarMarkType.circle:
      case GrammarMarkType.cell:
        currentTheme = components.symbolLabel;
        break;
      case GrammarMarkType.arc:
      case GrammarMarkType.arc3d:
        currentTheme = components.arcLabel;
        break;
      case GrammarMarkType.polygon:
      case GrammarMarkType.path:
      default:
        currentTheme = components.pointLabel;
    }
    const data = null !== (_b = addition.data) && void 0 !== _b ? _b : [], themeDatum = null !== (_d = null === (_c = null == currentTheme ? void 0 : currentTheme.data) || void 0 === _c ? void 0 : _c[0]) && void 0 !== _d ? _d : {};
    data && data.length > 0 ? data.forEach((d2, index2) => {
      if (mark.elements[index2]) {
        const attributes = invokeEncoder(encoder2, d2, mark.elements[index2], labelParameters);
        merge(d2, themeDatum, attributes);
      }
    }) : mark.elements.forEach((element) => {
      if ("willRelease" !== element.getGraphicItem().releaseStatus) if (mark.isCollectionMark()) {
        element.getDatum().forEach((entry) => {
          const attributes = invokeEncoder(encoder2, entry, element, labelParameters);
          data.push(merge({}, themeDatum, attributes));
        });
      } else {
        const attributes = invokeEncoder(encoder2, element.getDatum(), element, labelParameters), datum = merge({}, themeDatum, attributes);
        data.push(datum);
      }
    });
    const graphicItemName = null === (_e = mark.graphicItem) || void 0 === _e ? void 0 : _e.name;
    return merge({}, currentTheme, {
      data,
      baseMarkGroupName: graphicItemName,
      getBaseMarks: () => mark.elements.map((element) => element.getGraphicItem())
    }, null != addition ? addition : {});
  }).filter((label) => !isNil_default(label));
  return merge({}, labelTheme, {
    size: groupSize,
    dataLabels
  });
};
var Label = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.label, group), this.spec.componentType = ComponentEnum.label;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.labelStyle(spec.labelStyle), this.size(spec.size), this.target(spec.target), this;
  }
  labelStyle(style) {
    return this.setFunctionSpec(style, "labelStyle");
  }
  size(size) {
    return this.setFunctionSpec(size, "size");
  }
  target(mark) {
    if (this.spec.target) {
      const prevMarks = array(this.spec.target).map((m5) => isString_default(m5) ? this.view.getMarkById(m5) : m5);
      this.detach(prevMarks);
    }
    if (this.spec.target = mark, mark) {
      const nextMarks = array(mark).map((m5) => isString_default(m5) ? this.view.getMarkById(m5) : m5);
      this.attach(nextMarks);
    }
    return this.commit(), this;
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c, _d;
          const marks = array(this.spec.target).map((m5) => isString_default(m5) ? this.view.getMarkById(m5) : m5), groupGraphicItem = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.getGroupGraphicItem) || void 0 === _b ? void 0 : _b.call(_a);
          let size = invokeFunctionType(this.spec.size, parameters);
          size || (size = groupGraphicItem ? {
            width: null !== (_c = groupGraphicItem.attribute.width) && void 0 !== _c ? _c : groupGraphicItem.AABBBounds.width(),
            height: null !== (_d = groupGraphicItem.attribute.height) && void 0 !== _d ? _d : groupGraphicItem.AABBBounds.height()
          } : {
            width: 1 / 0,
            height: 1 / 0
          });
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          return generateLabelAttributes(marks, size, encoder2, this.spec.labelStyle, parameters, theme2);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Label.componentType = ComponentEnum.label;
var registerLabel = () => {
  Factory.registerGraphicComponent(ComponentEnum.label, (attrs) => new DataLabel(attrs)), Factory.registerComponent(ComponentEnum.label, Label);
};

// node_modules/@visactor/vgrammar-core/es/interactions/datazoom-filter.js
var DatazoomFilter = class _DatazoomFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _DatazoomFilter.type, this.options = Object.assign({}, _DatazoomFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "datazoom" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const datazoom2 = this._marks[0];
    if (!this._data || !datazoom2) return [];
    const filter2 = this.options.target.filter, transform29 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => {
      if (isNil_default(filterValue.start) || isNil_default(filterValue.end)) return true;
      const scale4 = datazoom2.getDatazoomMainScale(), datumRatio = getScaleRangeRatio(scale4, datum[filter2]);
      return filterValue.startRatio <= datumRatio && filterValue.endRatio >= datumRatio;
    } : filter2;
    return this._filterData(this._data, datazoom2, DataFilterRank.datazoom, (event) => {
      const startRatio = event.detail.start, endRatio = event.detail.end;
      return {
        startRatio,
        endRatio,
        start: datazoom2.invertDatazoomRatio(startRatio),
        end: datazoom2.invertDatazoomRatio(endRatio)
      };
    }, dataFilter, transform29), [{
      type: "change",
      handler: this.handleFilter
    }];
  }
};
DatazoomFilter.type = "datazoom-filter", DatazoomFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/datazoom.js
var generateDatazoomAttributes = (data, theme2, addition) => {
  var _a;
  const datazoomTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.datazoom;
  return data ? merge({}, datazoomTheme, {
    previewData: data
  }, null != addition ? addition : {}) : merge({}, datazoomTheme, null != addition ? addition : {});
};
var Datazoom = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.datazoom, group), this.spec.componentType = ComponentEnum.datazoom;
  }
  parseAddition(spec) {
    var _a;
    super.parseAddition(spec);
    const { data, x: x3, y: y3, x1: x14, y1: y14 } = null !== (_a = spec.preview) && void 0 !== _a ? _a : {};
    return this.preview(data, x3, y3, x14, y14), this._updateComponentEncoders(), this;
  }
  preview(data, x3, y3, x14, y14) {
    if (!isNil_default(this.spec.preview)) {
      const lastData = this.spec.preview.data, lastDataGrammar = isString_default(lastData) ? this.view.getDataById(lastData) : lastData;
      this.detach(lastDataGrammar), this.detach(parseEncodeType(this.spec.preview.x, this.view)), this.detach(parseEncodeType(this.spec.preview.y, this.view)), this.detach(parseEncodeType(this.spec.preview.x1, this.view)), this.detach(parseEncodeType(this.spec.preview.y1, this.view));
    }
    if (this.spec.preview = void 0, data) {
      this.spec.preview = {
        data,
        x: x3,
        y: y3,
        x1: x14,
        y1: y14
      };
      const dataGrammar = isString_default(data) ? this.view.getDataById(data) : data;
      this.attach(dataGrammar), this.attach(parseEncodeType(x3, this.view)), this.attach(parseEncodeType(y3, this.view)), this.attach(parseEncodeType(x14, this.view)), this.attach(parseEncodeType(y14, this.view));
    }
    return this._updateComponentEncoders(), this.commit(), this;
  }
  setStartEndValue(start, end) {
    const datazoom2 = this.getGroupGraphicItem();
    return datazoom2 && datazoom2.setStartAndEnd && datazoom2.setStartAndEnd(start, end), this;
  }
  getStartEndValue() {
    const datazoom2 = this.getGroupGraphicItem();
    if (datazoom2) {
      const state = datazoom2.state;
      return {
        start: state.start,
        end: state.end
      };
    }
    return null;
  }
  addGraphicItem(attrs, groupKey) {
    var _a, _b;
    const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), initialAttributes = Object.assign({}, null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.datazoom, attrs), graphicItem = Factory.createGraphicComponent(this.componentType, initialAttributes, {
      skipDefault: this.spec.skipTheme
    }), datazoom2 = graphicItem;
    datazoom2.setStatePointToData((state) => {
      var _a2;
      return this.spec.preview && null !== (_a2 = this.invertDatazoomRatio(state)) && void 0 !== _a2 ? _a2 : state;
    });
    const { data, x: x3, y: y3, x1: x14, y1: y14 } = null !== (_b = this.spec.preview) && void 0 !== _b ? _b : {};
    return datazoom2.setPreviewPointsX((datum) => {
      if (x3 && data) return invokeEncoder({
        x: x3
      }, datum, this.elements[0], this.parameters()).x;
    }), datazoom2.setPreviewPointsY((datum) => {
      if (y3 && data) return invokeEncoder({
        y: y3
      }, datum, this.elements[0], this.parameters()).y;
    }), datazoom2.setPreviewPointsX1((datum) => {
      if (x14 && data) return invokeEncoder({
        x1: x14
      }, datum, this.elements[0], this.parameters()).x1;
    }), datazoom2.setPreviewPointsY1((datum) => {
      if (y14 && data) return invokeEncoder({
        y1: y14
      }, datum, this.elements[0], this.parameters()).y1;
    }), super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    var _a;
    const data = null === (_a = this.spec.preview) || void 0 === _a ? void 0 : _a.data, dataGrammar = isString_default(data) ? this.view.getDataById(data) : data, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a2;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateDatazoomAttributes(null === (_a2 = null == dataGrammar ? void 0 : dataGrammar.getValue) || void 0 === _a2 ? void 0 : _a2.call(dataGrammar), theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  invertDatazoomRatio(ratio) {
    const scale4 = this.getDatazoomMainScale();
    if (scale4) {
      const range2 = scale4.range(), scaledValue = (range2[range2.length - 1] - range2[0]) * ratio + range2[0];
      return scale4.invert(scaledValue);
    }
    return null;
  }
  getDatazoomMainScale() {
    var _a, _b;
    const datazoom2 = this.getGroupGraphicItem();
    if (datazoom2 && this.spec.preview) {
      const scale4 = "top" === datazoom2.attribute.orient || "bottom" === datazoom2.attribute.orient ? null === (_a = this.spec.preview.x) || void 0 === _a ? void 0 : _a.scale : null === (_b = this.spec.preview.y) || void 0 === _b ? void 0 : _b.scale, scaleGrammar = isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
      return null == scaleGrammar ? void 0 : scaleGrammar.getScale();
    }
    return null;
  }
};
Datazoom.componentType = ComponentEnum.datazoom;

// node_modules/@visactor/vgrammar-core/es/interactions/player-filter.js
var PlayerFilter = class _PlayerFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _PlayerFilter.type, this.options = Object.assign({}, _PlayerFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "player" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const player2 = this._marks[0];
    if (!this._data || !player2) return [];
    const transform29 = this.options.target.transform;
    return this._filterData(this._data, player2, DataFilterRank.player, (event) => ({
      index: event.detail.index,
      value: event.detail.value
    }), void 0, (data, filterValue) => transform29 ? transform29(data, filterValue) : filterValue.value), [{
      type: PlayerEventEnum.OnChange,
      handler: this.handleFilter
    }];
  }
};
PlayerFilter.type = "player-filter", PlayerFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/player.js
var generateContinuousPlayerAttributes = (data, theme2, addition) => {
  var _a;
  const playerTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.continuousPlayer;
  return merge({}, playerTheme, {
    data,
    dataIndex: 0
  }, null != addition ? addition : {});
};
var generateDiscretePlayerAttributes = (data, theme2, addition) => {
  var _a;
  const playerTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.discretePlayer;
  return merge({}, playerTheme, {
    data,
    dataIndex: 0
  }, null != addition ? addition : {});
};
var Player = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.player, group), this.spec.componentType = ComponentEnum.player, this.spec.playerType = "auto";
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.playerType(spec.playerType), this.source(spec.source), this;
  }
  playerType(playerType) {
    return this.spec.playerType = playerType, this._playerComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  source(source) {
    var _a;
    if (this.spec.source) {
      const lastSource = null === (_a = this.spec) || void 0 === _a ? void 0 : _a.source, lastSourceDataGrammar = isArray_default(lastSource) ? null : isString_default(lastSource) ? this.view.getDataById(lastSource) : lastSource;
      this.detach(lastSourceDataGrammar);
    }
    this.spec.source = source;
    const sourceDataGrammar = isArray_default(source) ? null : isString_default(source) ? this.view.getDataById(source) : source;
    return this.attach(sourceDataGrammar), this.commit(), this;
  }
  play() {
    return this.getGroupGraphicItem().play(), this;
  }
  pause() {
    return this.getGroupGraphicItem().pause(), this;
  }
  backward() {
    return this.getGroupGraphicItem().backward(), this;
  }
  forward() {
    return this.getGroupGraphicItem().forward(), this;
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const initialAttributes = merge({
      slider: {
        handlerStyle: {
          size: 16
        }
      }
    }, attrs), graphicItem = null != newGraphicItem ? newGraphicItem : Factory.createGraphicComponent(this._getPlayerComponentType(), initialAttributes, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), addition = invokeEncoder(encoder2, datum, element, parameters), source = this.spec.source, sourceDataGrammar = isArray_default(source) ? null : isString_default(source) ? this.view.getDataById(source) : source, sourceData = isArray_default(source) ? source : null !== (_a = null == sourceDataGrammar ? void 0 : sourceDataGrammar.getValue()) && void 0 !== _a ? _a : [];
          switch (this._getPlayerComponentType()) {
            case "continuousPlayer":
              return generateContinuousPlayerAttributes(sourceData, theme2, addition);
            case "discretePlayer":
              return generateDiscretePlayerAttributes(sourceData, theme2, addition);
          }
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getPlayerComponentType() {
    return this._playerComponentType || (this.spec.playerType && "auto" !== this.spec.playerType ? this._playerComponentType = "discrete" === this.spec.playerType ? "discretePlayer" : "continuous" === this.spec.playerType ? "continuousPlayer" : "discretePlayer" : this._playerComponentType = "discretePlayer"), this._playerComponentType;
  }
};
Player.componentType = ComponentEnum.player;

// node_modules/@visactor/vgrammar-core/es/component/title.js
var generateTitleAttributes = (title3, subTitle, theme2, addition) => {
  var _a;
  const titleTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.title, attributes = {};
  return isValid_default(title3) && (attributes.text = title3), isValid_default(subTitle) && (attributes.subtext = subTitle), merge({}, titleTheme, attributes, null != addition ? addition : {});
};
var Title2 = class extends Component {
  constructor(view, group) {
    super(view, ComponentEnum.title, group), this.spec.componentType = ComponentEnum.title;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.title(spec.title), this.subTitle(spec.subTitle), this;
  }
  title(text2) {
    return this.setFunctionSpec(text2, "title");
  }
  subTitle(text2) {
    return this.setFunctionSpec(text2, "subTitle");
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), title3 = invokeFunctionType(this.spec.title, parameters, datum, element), subTitle = invokeFunctionType(this.spec.subTitle, parameters, datum, element), addition = invokeEncoder(encoder2, datum, element, parameters);
          return generateTitleAttributes(title3, subTitle, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Title2.componentType = ComponentEnum.title;

// node_modules/@visactor/vgrammar-core/es/component/grid.js
var generateLineAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.grid) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleGrid) && void 0 !== _b ? _b : {};
  if (!scale4) return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var Grid = class extends ScaleComponent {
  constructor(view, group, mode2) {
    super(view, ComponentEnum.grid, group), this.spec.componentType = ComponentEnum.grid, this.mode = mode2;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.target(spec.target), this.gridType(spec.gridType), this.gridShape(spec.gridShape), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._gridComponentType = null, this;
  }
  gridType(gridType) {
    return this.spec.gridType = gridType, this._gridComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  gridShape(gridShape) {
    return this.spec.gridShape = gridShape, this.commit(), this;
  }
  target(axis2) {
    if (this.spec.target) {
      const prevAxis = isString_default(this.spec.target) ? this.view.getMarkById(this.spec.target) : this.spec.target;
      this.detach(prevAxis);
    }
    this.spec.target = axis2;
    const nextAxis = isString_default(axis2) ? this.view.getMarkById(axis2) : axis2;
    return this.attach(nextAxis), this._targetAxis = nextAxis, this._gridComponentType = null, this._updateComponentEncoders(), this.commit(), this;
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory.createGraphicComponent(this._getGridComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c, _d;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let scaleGrammar, addition = invokeEncoder(encoder2, datum, element, parameters);
          const baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element);
          if (this._targetAxis) {
            const targetScale = null === (_a = this._targetAxis.getSpec()) || void 0 === _a ? void 0 : _a.scale;
            scaleGrammar = isString_default(targetScale) ? this.view.getScaleById(targetScale) : targetScale;
            const targetElement = this._targetAxis.elements[0];
            if (targetElement) switch (this._getGridComponentType()) {
              case GridEnum.lineAxisGrid:
                addition = Object.assign({
                  x: targetElement.getGraphicAttribute("x"),
                  y: targetElement.getGraphicAttribute("y"),
                  start: targetElement.getGraphicAttribute("start"),
                  end: targetElement.getGraphicAttribute("end"),
                  verticalFactor: null !== (_b = targetElement.getGraphicAttribute("verticalFactor")) && void 0 !== _b ? _b : 1
                }, addition);
                break;
              case GridEnum.circleAxisGrid:
                addition = Object.assign({
                  x: targetElement.getGraphicAttribute("x"),
                  y: targetElement.getGraphicAttribute("y"),
                  center: targetElement.getGraphicAttribute("center"),
                  radius: targetElement.getGraphicAttribute("radius"),
                  innerRadius: targetElement.getGraphicAttribute("innerRadius"),
                  inside: targetElement.getGraphicAttribute("inside"),
                  startAngle: targetElement.getGraphicAttribute("startAngle"),
                  endAngle: targetElement.getGraphicAttribute("endAngle")
                }, addition);
            }
          } else {
            scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
            const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), coordinate = null === (_c = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _c ? void 0 : _c.call(scaleGrammar);
            coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout, true), addition));
          }
          this._getGridComponentType() === GridEnum.lineAxisGrid && (addition = "line" !== this.spec.gridShape && this.spec.gridShape ? Object.assign({
            center: addition.start,
            closed: true
          }, addition, {
            type: this.spec.gridShape
          }) : Object.assign({}, addition, {
            type: "line"
          }));
          const scale4 = null === (_d = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _d ? void 0 : _d.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getGridComponentType()) {
            case GridEnum.lineAxisGrid:
              return generateLineAxisGridAttributes(scale4, theme2, addition, tickCount);
            case GridEnum.circleAxisGrid:
              return generateCircleAxisGridAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getGridComponentType() {
    var _a;
    if (this._gridComponentType) return this._gridComponentType;
    if (this.spec.gridType) if ("circle" === this.spec.gridType) this._gridComponentType = GridEnum.circleAxisGrid;
    else this._gridComponentType = GridEnum.lineAxisGrid;
    else if (this._targetAxis) {
      switch (this._targetAxis.getAxisComponentType()) {
        case AxisEnum.circleAxis:
          this._gridComponentType = GridEnum.circleAxisGrid;
          break;
        case AxisEnum.lineAxis:
        default:
          this._gridComponentType = GridEnum.lineAxisGrid;
      }
    } else if (this.spec.scale) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this._gridComponentType = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? GridEnum.lineAxisGrid : GridEnum.circleAxisGrid : GridEnum.lineAxisGrid;
    } else this._gridComponentType = GridEnum.lineAxisGrid;
    return this._gridComponentType;
  }
};
Grid.componentType = ComponentEnum.grid;
var registerGrid = () => {
  Factory.registerGraphicComponent(GridEnum.lineAxisGrid, (attrs, options) => new LineAxisGrid(attrs, options)), Factory.registerGraphicComponent(GridEnum.circleAxisGrid, (attrs, options) => new CircleAxisGrid(attrs, options)), Factory.registerComponent(ComponentEnum.grid, Grid);
};

// node_modules/@visactor/vgrammar-core/es/interactions/scrollbar-filter.js
var ScrollbarFilter = class _ScrollbarFilter extends Filter {
  constructor(view, options) {
    super(view, options), this.type = _ScrollbarFilter.type, this.options = Object.assign({}, _ScrollbarFilter.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.source).filter((mark) => mark.markType === GrammarMarkType.component && "scrollbar" === mark.componentType), this._data = isString_default(this.options.target.data) ? view.getDataById(this.options.target.data) : this.options.target.data;
  }
  getEvents() {
    if (!this._marks || 0 === this._marks.length) return [];
    const scrollbar2 = this._marks[0];
    if (!this._data || !scrollbar2) return [];
    const filter2 = this.options.target.filter, transform29 = this.options.target.transform, dataFilter = isString_default(filter2) ? (datum, filterValue) => {
      const scale4 = scrollbar2.getScale().getScale(), range2 = scale4.range(), datumRatio = (scale4.scale(datum[filter2]) - range2[0]) / (range2[range2.length - 1] - range2[0]);
      return filterValue.startRatio <= datumRatio && filterValue.endRatio >= datumRatio;
    } : filter2;
    return this._filterData(this._data, scrollbar2, DataFilterRank.scrollbar, (event) => {
      if (isString_default(filter2)) {
        const range2 = event.detail.value, scaleGrammar = scrollbar2.getScale();
        if (scaleGrammar) {
          const scale4 = scaleGrammar.getScale(), scaleRange = scale4.range();
          return {
            start: scale4.invert(range2[0] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
            end: scale4.invert(range2[1] * (scaleRange[1] - scaleRange[0]) + scaleRange[0]),
            startRatio: range2[0],
            endRatio: range2[1]
          };
        }
        return {
          startRatio: range2[0],
          endRatio: range2[1]
        };
      }
      return {
        startRatio: event.detail.value[0],
        endRatio: event.detail.value[1]
      };
    }, dataFilter, transform29), [{
      type: "scroll",
      handler: this.handleFilter
    }];
  }
};
ScrollbarFilter.type = "scrollbar-filter", ScrollbarFilter.defaultOptions = {};

// node_modules/@visactor/vgrammar-core/es/component/scrollbar.js
var generateScrollbarAttributes = (groupSize, direction2, position, theme2, addition) => {
  var _a, _b, _c, _d, _e;
  const scrollbarTheme = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.scrollbar;
  let finalDirection = "horizontal", finalPosition = "bottom";
  isValidDirection(direction2) || isValidPosition(position) ? !isValidDirection(direction2) && isValidPosition(position) ? (finalDirection = isHorizontalPosition(position) ? "horizontal" : "vertical", finalPosition = position) : isValidDirection(direction2) && !isValidPosition(position) ? (finalDirection = direction2, finalPosition = isHorizontal(direction2) ? "bottom" : "right") : (finalDirection = direction2, finalPosition = isHorizontal(direction2) && !isHorizontalPosition(position) ? "bottom" : isVertical(direction2) && isHorizontalPosition(position) ? "right" : position) : (finalDirection = "horizontal", finalPosition = "bottom");
  const attributes = {
    direction: finalDirection
  };
  if (isHorizontal(finalDirection)) {
    const size = null !== (_c = null !== (_b = addition.height) && void 0 !== _b ? _b : null == scrollbarTheme ? void 0 : scrollbarTheme.height) && void 0 !== _c ? _c : 12;
    "top" === finalPosition ? Object.assign(attributes, {
      width: groupSize.width,
      height: size,
      x: 0,
      y: 0
    }) : Object.assign(attributes, {
      width: groupSize.width,
      height: size,
      x: 0,
      y: groupSize.height - size
    });
  } else {
    const size = null !== (_e = null !== (_d = addition.width) && void 0 !== _d ? _d : null == scrollbarTheme ? void 0 : scrollbarTheme.width) && void 0 !== _e ? _e : 12;
    "left" === finalPosition ? Object.assign(attributes, {
      width: size,
      height: groupSize.height,
      x: 0,
      y: 0
    }) : Object.assign(attributes, {
      width: size,
      height: groupSize.height,
      x: groupSize.width - size,
      y: 0
    });
  }
  return merge({}, scrollbarTheme, attributes, null != addition ? addition : {});
};
var Scrollbar = class extends ScaleComponent {
  constructor(view, group) {
    super(view, ComponentEnum.scrollbar, group), this.spec.componentType = ComponentEnum.scrollbar;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.container(spec.container), this.direction(spec.direction), this.position(spec.position), this;
  }
  container(container2) {
    if (this.spec.container) {
      const prevContainer = isString_default(this.spec.container) ? this.view.getMarkById(this.spec.container) : this.spec.container;
      this.detach(prevContainer);
    }
    if (this.spec.container = container2, container2) {
      const nextContainer = isString_default(container2) ? this.view.getMarkById(container2) : container2;
      this.attach(nextContainer);
    }
    return this.commit(), this;
  }
  direction(direction2) {
    return this.setFunctionSpec(direction2, "direction");
  }
  position(position) {
    return this.setFunctionSpec(position, "position");
  }
  setScrollStart(start) {
    var _a;
    const scrollbar2 = this.getGroupGraphicItem(), range2 = null === (_a = null == scrollbar2 ? void 0 : scrollbar2.attribute) || void 0 === _a ? void 0 : _a.range;
    if (scrollbar2 && range2) {
      const nextRange = [start, range2[1] - range2[0] + start];
      scrollbar2.setScrollRange(nextRange);
    }
    return this;
  }
  getScrollRange() {
    const scrollbar2 = this.getGroupGraphicItem();
    if (scrollbar2) return scrollbar2.getScrollRange();
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      range: [0, 1]
    }, attrs), graphicItem = Factory.createGraphicComponent(ComponentEnum.scrollbar, initialAttributes, {
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder2 = encoders[state];
      return encoder2 && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme(), direction2 = invokeFunctionType(this.spec.direction, parameters, datum, element), position = invokeFunctionType(this.spec.position, parameters, datum, element), addition = invokeEncoder(encoder2, datum, element, parameters), targetMark = this.spec.container ? isString_default(this.spec.container) ? this.view.getMarkById(this.spec.container) : this.spec.container : null, groupGraphicItem = (targetMark && targetMark.markType === GrammarMarkType.group ? targetMark : this.group).getGroupGraphicItem(), size = groupGraphicItem ? {
            width: null !== (_a = groupGraphicItem.attribute.width) && void 0 !== _a ? _a : groupGraphicItem.AABBBounds.width(),
            height: null !== (_b = groupGraphicItem.attribute.height) && void 0 !== _b ? _b : groupGraphicItem.AABBBounds.height()
          } : {
            width: this.view.width(),
            height: this.view.height()
          };
          return generateScrollbarAttributes(size, direction2, position, theme2, addition);
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
};
Scrollbar.componentType = ComponentEnum.scrollbar;

// node_modules/@visactor/vgrammar-core/es/transforms/data/filter.js
var transform = (options, data, parameters) => data.filter((entry) => options.callback(entry, parameters));

// node_modules/@visactor/vgrammar-core/es/transforms/data/map.js
var transform2 = (options, upstreamData, params2) => {
  const func = options.callback, as = options.as;
  if (!options.all) return upstreamData.forEach((entry) => {
    const data2 = func(entry, params2);
    if (!isNil_default(as)) {
      if (isNil_default(entry)) return;
      entry[as] = data2;
    }
    return data2;
  }), upstreamData;
  const data = func(upstreamData, params2);
  return isNil_default(as) || isNil_default(upstreamData) ? data : (upstreamData[as] = data, upstreamData);
};

// node_modules/@visactor/vgrammar-core/es/transforms/data/kde.js
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2PI2 = Math.sqrt((2 * Math.PI) ** 2);

// node_modules/@visactor/vgrammar-core/es/transforms/util/util.js
function sum4(arr) {
  return arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}
function average2(arr) {
  if (0 === arr.length) return 0;
  return sum4(arr) / arr.length;
}

// node_modules/@visactor/vgrammar-core/es/transforms/data/sampling.js
var samplerMap = {
  min: minInArray,
  max: maxInArray,
  average: average2,
  sum: sum4
};
function lttb(size, array2, isGroup, yfield) {
  const frameSize = Math.floor(array2.length / size), newIndices = [], len = array2.length;
  let maxArea, area2, nextIndex, currentIndex = 0, sampledIndex = 0;
  newIndices[sampledIndex++] = currentIndex;
  for (let i2 = 1; i2 < len - 1; i2 += frameSize) {
    const nextFrameStart = Math.min(i2 + frameSize, len - 1), nextFrameEnd = Math.min(i2 + 2 * frameSize, len), avgX = (nextFrameEnd + nextFrameStart) / 2;
    let avgY = 0;
    for (let idx = nextFrameStart; idx < nextFrameEnd; idx++) {
      const value = array2[idx][yfield];
      Number.isNaN(value) || (avgY += value);
    }
    avgY /= nextFrameEnd - nextFrameStart;
    const frameStart = i2, frameEnd = Math.min(i2 + frameSize, len), pointAX = i2 - 1, pointAY = array2[currentIndex][yfield];
    maxArea = -1, nextIndex = frameStart;
    for (let idx = frameStart; idx < frameEnd; idx++) {
      const value = array2[idx][yfield];
      Number.isNaN(yfield) || (area2 = Math.abs((pointAX - avgX) * (value - pointAY) - (pointAX - idx) * (avgY - pointAY)), area2 > maxArea && (maxArea = area2, nextIndex = idx));
    }
    newIndices[sampledIndex++] = nextIndex, currentIndex = nextIndex;
  }
  newIndices[sampledIndex - 1] !== len - 1 && (newIndices[sampledIndex++] = len - 1);
  return newIndices.map((i2) => isGroup ? array2[i2].i : i2);
}
function sample2(size, array2, isGroup, mode2, yfield) {
  let frameSize = Math.floor(array2.length / size);
  const newIndices = [], len = array2.length;
  let sampledIndex = 0, frameValues = [];
  newIndices.push(sampledIndex), array2[sampledIndex][yfield] = array2[sampledIndex][yfield];
  for (let i2 = 1; i2 < len - 1; i2 += frameSize) {
    frameSize > len - i2 && (frameSize = len - i2, frameValues.length = frameSize), frameValues = [];
    for (let k3 = 0; k3 < frameSize; k3++) frameValues.push(array2[i2 + k3][yfield]);
    const value = samplerMap[mode2](frameValues);
    sampledIndex = Math.min(Math.round(i2 + frameValues.length / 2) || 0, len - 1), array2[sampledIndex][yfield] = value, newIndices.push(sampledIndex);
  }
  return newIndices.map((i2) => isGroup ? array2[i2].i : i2);
}
function sampleMin(size, array2, isGroup, yfield) {
  return sample2(size, array2, isGroup, "min", yfield);
}
function sampleMax(size, array2, isGroup, yfield) {
  return sample2(size, array2, isGroup, "max", yfield);
}
function sampleAverage(size, array2, isGroup, yfield) {
  return sample2(size, array2, isGroup, "average", yfield);
}
function sampleSum(size, array2, isGroup, yfield) {
  return sample2(size, array2, isGroup, "sum", yfield);
}
var transform3 = (options, upstreamData) => {
  let size = options.size;
  const factor = options.factor || 1;
  if (Array.isArray(size) && (size = Math.floor(size[1] - size[0])), size *= factor, size <= 0) return [];
  if (upstreamData.length <= size) return upstreamData;
  if (options.skipfirst) return upstreamData.slice(0, 1);
  const { mode: mode2, yfield: y3, groupBy: groupBy2 } = options, yfield = null != y3 ? y3 : "y";
  let sampler = lttb;
  if ("min" === mode2 ? sampler = sampleMin : "max" === mode2 ? sampler = sampleMax : "average" === mode2 ? sampler = sampleAverage : "sum" === mode2 && (sampler = sampleSum), upstreamData.length) {
    const groups2 = {};
    if (groupBy2) {
      for (let i2 = 0, n2 = upstreamData.length; i2 < n2; i2++) {
        const datum = upstreamData[i2], groupId = datum[groupBy2];
        groups2[groupId] ? groups2[groupId].push({
          [yfield]: datum[yfield],
          i: i2
        }) : (groups2[groupId] = [], groups2[groupId].push({
          [yfield]: datum[yfield],
          i: i2
        }));
      }
      let rawIndice = [];
      return Object.keys(groups2).forEach((groupName) => {
        const group = groups2[groupName];
        if (group.length <= size) {
          const indices = group.map((datum) => datum.i);
          rawIndice = rawIndice.concat(indices);
        } else {
          const indices = sampler(size, group, true, yfield);
          rawIndice = rawIndice.concat(indices), group.forEach((datum) => upstreamData[datum.i][yfield] = datum[yfield]);
        }
      }), rawIndice.sort((a4, b2) => a4 - b2), rawIndice.map((index) => upstreamData[index]);
    }
    return sampler(size, upstreamData, false, yfield).map((index) => upstreamData[index]);
  }
  return [];
};

// node_modules/@visactor/vgrammar-core/es/transforms/mark/mark-overlap.js
var HIDE_KEY = "_mo_hide_";
function reset2(elements) {
  return elements.forEach((element) => {
    element.getGraphicAttribute("HIDE_KEY") && (element.setGraphicAttribute("visible", true), element.setGraphicAttribute(HIDE_KEY, false));
  }), elements;
}
function overlapX(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastX = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r2 = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x");
      useDeltaMul && (itemDelta = (r2 + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastX = currentX, lastR = r2;
    });
  }
}
function overlapY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastY = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r2 = element.getGraphicAttribute("size") / 2, currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r2 + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r2;
    });
  }
}
function overlapXY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    const lastX = -1 / 0;
    let lastY = -1 / 0, lastR = 0, dis = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible")) return;
      const r2 = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x"), currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r2 + lastR) * deltaMul), dis = (lastX - currentX) ** 2 + (lastY - currentY) ** 2, dis < (itemDelta + lastR + r2) ** 2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r2;
    });
  }
}
var transform4 = (options, upstreamData) => {
  if (!upstreamData || 0 === upstreamData.length) return;
  let { radius } = options;
  isNil_default(radius) && "symbol" === upstreamData[0].mark.markType && (radius = true);
  const { direction: direction2, delta, deltaMul = 1, groupBy: groupBy2 } = options, handleOverlap = (elements) => {
    reset2(elements);
    const sortedElements = elements.slice().sort((a4, b2) => a4.getGraphicAttribute("x") - b2.getGraphicAttribute("x"));
    0 === direction2 ? overlapXY(sortedElements, delta, deltaMul, radius) : 1 === direction2 ? overlapX(sortedElements, delta, deltaMul, radius) : overlapY(sortedElements, delta, deltaMul, radius);
  };
  if (groupBy2) {
    const map4 = upstreamData.reduce((res, element) => {
      const groupName = element.getDatum()[groupBy2];
      return res[groupName] ? res[groupName].push(element) : res[groupName] = [element], res;
    }, {});
    Object.keys(map4).forEach((key) => {
      handleOverlap(map4[key]);
    });
  } else handleOverlap(upstreamData);
  return upstreamData;
};

// node_modules/@visactor/vgrammar-core/es/transforms/index.js
var registerFilterTransform = () => {
  Factory.registerTransform("filter", {
    transform,
    markPhase: "beforeJoin"
  }, true);
};
var registerMapTransform = () => {
  Factory.registerTransform("map", {
    transform: transform2,
    markPhase: "beforeJoin"
  }, true);
};
var registerSampleTransform = () => {
  Factory.registerTransform("sampling", {
    transform: transform3,
    markPhase: "afterEncode"
  }, true);
};
var registerMarkOverlapTransform = () => {
  Factory.registerTransform("markoverlap", {
    transform: transform4,
    markPhase: "afterEncode"
  }, true);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/clip.js
var clipIn = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", false), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", false)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange: 0,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange: 0
    },
    to: {
      clipRange
    }
  };
};
var clipOut = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", true), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", true)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange: 0,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange
    },
    to: {
      clipRange: 0
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/fade.js
var fadeIn2 = (element, options, animationParameters) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_a = element.getGraphicAttribute("opacity", false)) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = element.getGraphicAttribute("fillOpacity", false)) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = element.getGraphicAttribute("strokeOpacity", false)) && void 0 !== _c ? _c : 1
    }
  };
};
var fadeOut2 = (element, options, animationParameters) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = element.getGraphicAttribute("opacity", true)) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = element.getGraphicAttribute("fillOpacity", true)) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = element.getGraphicAttribute("strokeOpacity", true)) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-cartesian.js
var growCenterIn = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
      return {
        from: isValid_default(width) ? {
          x: x3 + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x3 + x14) / 2,
          x1: (x3 + x14) / 2,
          width: void 0
        },
        to: {
          x: x3,
          x1: x14,
          width
        }
      };
    }
    case "y": {
      const y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
      return {
        from: isValid_default(height) ? {
          y: y3 + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y3 + y14) / 2,
          y1: (y3 + y14) / 2,
          height: void 0
        },
        to: {
          y: y3,
          y1: y14,
          height
        }
      };
    }
    default: {
      const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false), y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false), from = {};
      return isValid_default(width) ? (from.x = x3 + width / 2, from.width = 0, from.x1 = void 0) : (from.x = (x3 + x14) / 2, from.x1 = (x3 + x14) / 2, from.width = void 0), isValid_default(height) ? (from.y = y3 + height / 2, from.height = 0, from.y1 = void 0) : (from.y = (y3 + y14) / 2, from.y1 = (y3 + y14) / 2, from.height = void 0), {
        from,
        to: {
          x: x3,
          y: y3,
          x1: x14,
          y1: y14,
          width,
          height
        }
      };
    }
  }
};
var growCenterOut = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
      return {
        to: isValid_default(width) ? {
          x: x3 + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x3 + x14) / 2,
          x1: (x3 + x14) / 2,
          width: void 0
        }
      };
    }
    case "y": {
      const y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
      return {
        to: isValid_default(height) ? {
          y: y3 + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y3 + y14) / 2,
          y1: (y3 + y14) / 2,
          height: void 0
        }
      };
    }
    default: {
      const x3 = element.getGraphicAttribute("x", false), y3 = element.getGraphicAttribute("y", false), x14 = element.getGraphicAttribute("x1", false), y14 = element.getGraphicAttribute("y1", false), width = element.getGraphicAttribute("width", false), height = element.getGraphicAttribute("height", false), to = {};
      return isValid_default(width) ? (to.x = x3 + width / 2, to.width = 0, to.x1 = void 0) : (to.x = (x3 + x14) / 2, to.x1 = (x3 + x14) / 2, to.width = void 0), isValid_default(height) ? (to.y = y3 + height / 2, to.height = 0, to.y1 = void 0) : (to.y = (y3 + y14) / 2, to.y1 = (y3 + y14) / 2, to.height = void 0), {
        to
      };
    }
  }
};
function growWidthInIndividual(element, options, animationParameters) {
  const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x3, x3 + width) : Math.max(x3, x14);
    return {
      from: {
        x: computedX1,
        x1: isNil_default(x14) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      },
      to: {
        x: x3,
        x1: x14,
        width
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x3, x3 + width) : Math.min(x3, x14);
  return {
    from: {
      x: computedX,
      x1: isNil_default(x14) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x: x3,
      x1: x14,
      width
    }
  };
}
function growWidthInOverall(element, options, animationParameters) {
  var _a;
  const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? null == options ? void 0 : options.overall : 0, {
    from: {
      x: overallValue,
      x1: isNil_default(x14) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x: x3,
      x1: x14,
      width
    }
  };
}
var growWidthIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthInOverall(element, options, animationParameters) : growWidthInIndividual(element, options, animationParameters);
};
function growWidthOutIndividual(element, options, animationParameters) {
  const x3 = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x3, x3 + width) : Math.max(x3, x14);
    return {
      to: {
        x: computedX1,
        x1: isNil_default(x14) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x3, x3 + width) : Math.min(x3, x14);
  return {
    to: {
      x: computedX,
      x1: isNil_default(x14) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
function growWidthOutOverall(element, options, animationParameters) {
  var _a;
  const x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      x: overallValue,
      x1: isNil_default(x14) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
var growWidthOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthOutOverall(element, options, animationParameters) : growWidthOutIndividual(element, options, animationParameters);
};
function growHeightInIndividual(element, options, animationParameters) {
  const y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y3, y3 + height) : Math.max(y3, y14);
    return {
      from: {
        y: computedY1,
        y1: isNil_default(y14) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      },
      to: {
        y: y3,
        y1: y14,
        height
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y3, y3 + height) : Math.min(y3, y14);
  return {
    from: {
      y: computedY,
      y1: isNil_default(y14) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y: y3,
      y1: y14,
      height
    }
  };
}
function growHeightInOverall(element, options, animationParameters) {
  var _a;
  const y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    from: {
      y: overallValue,
      y1: isNil_default(y14) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y: y3,
      y1: y14,
      height
    }
  };
}
var growHeightIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightInOverall(element, options, animationParameters) : growHeightInIndividual(element, options, animationParameters);
};
function growHeightOutIndividual(element, options, animationParameters) {
  const y3 = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y3, y3 + height) : Math.max(y3, y14);
    return {
      to: {
        y: computedY1,
        y1: isNil_default(y14) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y3, y3 + height) : Math.min(y3, y14);
  return {
    to: {
      y: computedY,
      y1: isNil_default(y14) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
function growHeightOutOverall(element, options, animationParameters) {
  var _a;
  const y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      y: overallValue,
      y1: isNil_default(y14) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
var growHeightOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(element, options, animationParameters) : growHeightOutIndividual(element, options, animationParameters);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-polar.js
var growAngleInIndividual = (element, options, animationParameters) => options && "anticlockwise" === options.orient ? {
  from: {
    startAngle: element.getGraphicAttribute("endAngle", false)
  },
  to: {
    startAngle: element.getGraphicAttribute("startAngle", false)
  }
} : {
  from: {
    endAngle: element.getGraphicAttribute("startAngle", false)
  },
  to: {
    endAngle: element.getGraphicAttribute("endAngle", false)
  }
};
var growAngleInOverall = (element, options, animationParameters) => {
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: overallValue2,
        endAngle: overallValue2
      },
      to: {
        startAngle: element.getGraphicAttribute("startAngle", false),
        endAngle: element.getGraphicAttribute("endAngle", false)
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: overallValue,
      endAngle: overallValue
    },
    to: {
      startAngle: element.getGraphicAttribute("startAngle", false),
      endAngle: element.getGraphicAttribute("endAngle", false)
    }
  };
};
var growAngleIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleInOverall(element, options) : growAngleInIndividual(element, options);
};
var growAngleOutIndividual = (element, options, animationParameters) => options && "anticlockwise" === options.orient ? {
  from: {
    startAngle: element.getGraphicAttribute("startAngle", true)
  },
  to: {
    startAngle: element.getGraphicAttribute("endAngle", false)
  }
} : {
  from: {
    endAngle: element.getGraphicAttribute("endAngle", true)
  },
  to: {
    endAngle: element.getGraphicAttribute("startAngle", false)
  }
};
var growAngleOutOverall = (element, options, animationParameters) => {
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: element.getGraphicAttribute("startAngle", true),
        endAngle: element.getGraphicAttribute("endAngle", true)
      },
      to: {
        startAngle: overallValue2,
        endAngle: overallValue2
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: element.getGraphicAttribute("startAngle", true),
      endAngle: element.getGraphicAttribute("endAngle", true)
    },
    to: {
      startAngle: overallValue,
      endAngle: overallValue
    }
  };
};
var growAngleOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(element, options) : growAngleOutIndividual(element, options);
};
var growRadiusInIndividual = (element, options, animationParameters) => options && "inside" === options.orient ? {
  from: {
    innerRadius: element.getGraphicAttribute("outerRadius", false)
  },
  to: {
    innerRadius: element.getGraphicAttribute("innerRadius", false)
  }
} : {
  from: {
    outerRadius: element.getGraphicAttribute("innerRadius", false)
  },
  to: {
    outerRadius: element.getGraphicAttribute("outerRadius", false)
  }
};
var growRadiusInOverall = (element, options, animationParameters) => {
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: overallValue,
      outerRadius: overallValue
    },
    to: {
      innerRadius: element.getGraphicAttribute("innerRadius", false),
      outerRadius: element.getGraphicAttribute("outerRadius", false)
    }
  };
};
var growRadiusIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusInOverall(element, options) : growRadiusInIndividual(element, options);
};
var growRadiusOutIndividual = (element, options, animationParameters) => options && "inside" === options.orient ? {
  from: {
    innerRadius: element.getGraphicAttribute("innerRadius", true)
  },
  to: {
    innerRadius: element.getGraphicAttribute("outerRadius", false)
  }
} : {
  from: {
    outerRadius: element.getGraphicAttribute("outerRadius", true)
  },
  to: {
    outerRadius: element.getGraphicAttribute("innerRadius", false)
  }
};
var growRadiusOutOverall = (element, options, animationParameters) => {
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: element.getGraphicAttribute("innerRadius", true),
      outerRadius: element.getGraphicAttribute("outerRadius", true)
    },
    to: {
      innerRadius: overallValue,
      outerRadius: overallValue
    }
  };
};
var growRadiusOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusOutOverall(element, options) : growRadiusOutIndividual(element, options);
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/grow-points.js
var getCenterPoints = (element, options, animationParameters) => {
  const points = element.getGraphicAttribute("points", false), center2 = {
    x: 0,
    y: 0
  };
  return points.forEach((point6) => {
    center2.x += point6.x, center2.y += point6.y;
  }), center2.x /= points.length, center2.y /= points.length, options && options.center && (isValidNumber_default(options.center.x) && (center2.x = options.center.x), isValidNumber_default(options.center.y) && (center2.y = options.center.y)), "area" === element.mark.markType && (center2.x1 = center2.x, center2.y1 = center2.y), points.map(() => Object.assign(center2));
};
var growPointsIn = (element, options, animationParameters) => ({
  from: {
    points: getCenterPoints(element, options)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: getCenterPoints(element, options)
  }
});
var changePointsX = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point6) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupRight = animationParameters.width;
    return animationParameters.group && (groupRight = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = groupRight), {
      x: groupRight,
      y: point6.y,
      x1: groupRight,
      y1: point6.y1,
      defined: false !== point6.defined
    };
  }
  return {
    x: 0,
    y: point6.y,
    x1: 0,
    y1: point6.y1,
    defined: false !== point6.defined
  };
});
var growPointsXIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsX(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsXOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsX(element, options, animationParameters)
  }
});
var changePointsY = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point6) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupBottom = animationParameters.height;
    return animationParameters.group && (groupBottom = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = groupBottom), {
      x: point6.x,
      y: groupBottom,
      x1: point6.x1,
      y1: groupBottom,
      defined: false !== point6.defined
    };
  }
  return {
    x: point6.x,
    y: 0,
    x1: point6.x1,
    y1: 0,
    defined: false !== point6.defined
  };
});
var growPointsYIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsY(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsYOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsY(element, options, animationParameters)
  }
});

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/move.js
var moveIn = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction: direction2, point: pointOpt } = null != options ? options : {};
  let changedX = 0, changedY = 0;
  "negative" === orient && (animationParameters.group ? (changedX = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), changedY = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), animationParameters.groupWidth = changedX, animationParameters.groupHeight = changedY) : (changedX = animationParameters.width, changedY = animationParameters.height)), changedX += offset, changedY += offset;
  const point6 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point6 && isValidNumber_default(point6.x) ? point6.x : changedX, fromY = point6 && isValidNumber_default(point6.y) ? point6.y : changedY;
  switch (direction2) {
    case "x":
      return {
        from: {
          x: fromX
        },
        to: {
          x: element.getGraphicAttribute("x", false)
        }
      };
    case "y":
      return {
        from: {
          y: fromY
        },
        to: {
          y: element.getGraphicAttribute("y", false)
        }
      };
    default:
      return {
        from: {
          x: fromX,
          y: fromY
        },
        to: {
          x: element.getGraphicAttribute("x", false),
          y: element.getGraphicAttribute("y", false)
        }
      };
  }
};
var moveOut = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction: direction2, point: pointOpt } = null != options ? options : {}, groupBounds = animationParameters.group ? animationParameters.group.getBounds() : null, groupWidth = null !== (_a = null == groupBounds ? void 0 : groupBounds.width()) && void 0 !== _a ? _a : animationParameters.width, groupHeight = null !== (_b = null == groupBounds ? void 0 : groupBounds.height()) && void 0 !== _b ? _b : animationParameters.height, changedX = ("negative" === orient ? groupWidth : 0) + offset, changedY = ("negative" === orient ? groupHeight : 0) + offset, point6 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point6 && isValidNumber_default(point6.x) ? point6.x : changedX, fromY = point6 && isValidNumber_default(point6.y) ? point6.y : changedY;
  switch (direction2) {
    case "x":
      return {
        from: {
          x: element.getGraphicAttribute("x", true)
        },
        to: {
          x: fromX
        }
      };
    case "y":
      return {
        from: {
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          y: fromY
        }
      };
    default:
      return {
        from: {
          x: element.getGraphicAttribute("x", true),
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          x: fromX,
          y: fromY
        }
      };
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/scale.js
var scaleIn2 = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: 0
        },
        to: {
          scaleX: null !== (_a = element.getGraphicAttribute("scaleX", false)) && void 0 !== _a ? _a : 1
        }
      };
    case "y":
      return {
        from: {
          scaleY: 0
        },
        to: {
          scaleY: null !== (_b = element.getGraphicAttribute("scaleY", false)) && void 0 !== _b ? _b : 1
        }
      };
    default:
      return {
        from: {
          scaleX: 0,
          scaleY: 0
        },
        to: {
          scaleX: null !== (_c = element.getGraphicAttribute("scaleX", false)) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = element.getGraphicAttribute("scaleY", false)) && void 0 !== _d ? _d : 1
        }
      };
  }
};
var scaleOut2 = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: null !== (_a = element.getGraphicAttribute("scaleX", true)) && void 0 !== _a ? _a : 1
        },
        to: {
          scaleX: 0
        }
      };
    case "y":
      return {
        from: {
          scaleY: null !== (_b = element.getGraphicAttribute("scaleY", true)) && void 0 !== _b ? _b : 1
        },
        to: {
          scaleY: 0
        }
      };
    default:
      return {
        from: {
          scaleX: null !== (_c = element.getGraphicAttribute("scaleX", true)) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = element.getGraphicAttribute("scaleY", true)) && void 0 !== _d ? _d : 1
        },
        to: {
          scaleX: 0,
          scaleY: 0
        }
      };
  }
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/update.js
var update2 = (element, options, animationParameters) => {
  const from = Object.assign({}, element.getPrevGraphicAttributes()), to = Object.assign({}, element.getNextGraphicAttributes());
  return options && array(options.excludeChannels).forEach((key) => {
    delete from[key], delete to[key];
  }), Object.keys(to).forEach((key) => {
    isEqual2(key, from, to) && (delete from[key], delete to[key]);
  }), {
    from,
    to
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/rotate.js
var rotateIn = (element, options, animationParameters) => {
  var _a;
  const finalAngle = null !== (_a = element.getGraphicAttribute("angle", false)) && void 0 !== _a ? _a : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: angle2
    },
    to: {
      angle: finalAngle
    }
  };
};
var rotateOut = (element, options, animationParameters) => {
  var _a;
  const finalAngle = null !== (_a = element.getGraphicAttribute("angle", true)) && void 0 !== _a ? _a : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: finalAngle
    },
    to: {
      angle: angle2
    }
  };
};

// node_modules/@visactor/vgrammar-core/es/graph/animation/animation/index.js
var registerClipInAnimation = () => {
  Factory.registerAnimationType("clipIn", clipIn);
};
var registerClipOutAnimation = () => {
  Factory.registerAnimationType("clipOut", clipOut);
};
var registerFadeInAnimation = () => {
  Factory.registerAnimationType("fadeIn", fadeIn2);
};
var registerFadeOutAnimation = () => {
  Factory.registerAnimationType("fadeOut", fadeOut2);
};
var registerGrowCenterInAnimation = () => {
  Factory.registerAnimationType("growCenterIn", growCenterIn);
};
var registerGrowCenterOutAnimation = () => {
  Factory.registerAnimationType("growCenterOut", growCenterOut);
};
var registerGrowHeightInAnimation = () => {
  Factory.registerAnimationType("growHeightIn", growHeightIn);
};
var registerGrowHeightOutAnimation = () => {
  Factory.registerAnimationType("growHeightOut", growHeightOut);
};
var registerGrowWidthInAnimation = () => {
  Factory.registerAnimationType("growWidthIn", growWidthIn);
};
var registerGrowWidthOutAnimation = () => {
  Factory.registerAnimationType("growWidthOut", growWidthOut);
};
var registerGrowPointsInAnimation = () => {
  Factory.registerAnimationType("growPointsIn", growPointsIn);
};
var registerGrowPointsOutAnimation = () => {
  Factory.registerAnimationType("growPointsOut", growPointsOut);
};
var registerGrowPointsXInAnimation = () => {
  Factory.registerAnimationType("growPointsXIn", growPointsXIn);
};
var registerGrowPointsXOutAnimation = () => {
  Factory.registerAnimationType("growPointsXOut", growPointsXOut);
};
var registerGrowPointsYInAnimation = () => {
  Factory.registerAnimationType("growPointsYIn", growPointsYIn);
};
var registerGrowPointsYOutAnimation = () => {
  Factory.registerAnimationType("growPointsYOut", growPointsYOut);
};
var registerGrowAngleInAnimation = () => {
  Factory.registerAnimationType("growAngleIn", growAngleIn);
};
var registerGrowAngleOutAnimation = () => {
  Factory.registerAnimationType("growAngleOut", growAngleOut);
};
var registerGrowRadiusInAnimation = () => {
  Factory.registerAnimationType("growRadiusIn", growRadiusIn);
};
var registerGrowRadiusOutAnimation = () => {
  Factory.registerAnimationType("growRadiusOut", growRadiusOut);
};
var registerMoveInAnimation = () => {
  Factory.registerAnimationType("moveIn", moveIn);
};
var registerMoveOutAnimation = () => {
  Factory.registerAnimationType("moveOut", moveOut);
};
var registerScaleInAnimation = () => {
  Factory.registerAnimationType("scaleIn", scaleIn2);
};
var registerScaleOutAnimation = () => {
  Factory.registerAnimationType("scaleOut", scaleOut2);
};
var registerRotateInAnimation = () => {
  Factory.registerAnimationType("rotateIn", rotateIn);
};
var registerRotateOutAnimation = () => {
  Factory.registerAnimationType("rotateOut", rotateOut);
};
var registerUpdateAnimation = () => {
  Factory.registerAnimationType("update", update2);
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/cell.js
var Cell = class extends Mark {
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(state), this;
  }
  _updateComponentEncoders(state) {
    this._encoders || (this._encoders = {});
    const userEncoder = this.spec.encode[state];
    if (userEncoder && "update" === state) {
      const params2 = this.parameters(), scales = isFunctionType(userEncoder) ? null : Object.keys(userEncoder).reduce((res, channel) => (isScaleEncode(userEncoder[channel]) && (res[channel] = getGrammarOutput(userEncoder[channel].scale, params2)), res), {});
      this._encoders[state] = {
        callback: (datum, element, parameters) => {
          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);
          if (isNil_default(userEncodeRes.size)) {
            const sizeX = scales.x ? getBandWidthOfScale(scales.x) : void 0, sizeY = scales.y ? getBandWidthOfScale(scales.y) : void 0;
            isNil_default(sizeX) && isNil_default(sizeY) ? userEncodeRes.size = 10 : isNil_default(sizeX) ? userEncodeRes.size = sizeY : isNil_default(sizeY) && (userEncodeRes.size = sizeX), userEncodeRes.size = [sizeX, sizeY];
          }
          return isNil_default(userEncodeRes.shape) && (userEncodeRes.shape = "rect"), userEncodeRes;
        }
      };
    } else this._encoders[state] = userEncoder;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
  getAttributeTransforms() {
    return [{
      channels: ["size", "padding"],
      transform: (graphicAttributes, nextAttrs, storedAttrs) => {
        if (isNumber_default(storedAttrs.padding) && storedAttrs.padding > 0) graphicAttributes.size = isArray_default(storedAttrs.size) ? storedAttrs.size.map((entry) => Math.max(entry - storedAttrs.padding, 1)) : Math.max(storedAttrs.size - storedAttrs.padding, 1);
        else if (isArray_default(storedAttrs.padding) && 2 === storedAttrs.padding.length) {
          const arraySize = isArray_default(storedAttrs.size) ? storedAttrs.size : [storedAttrs.size, storedAttrs.size];
          graphicAttributes.size = [Math.max(arraySize[0] - storedAttrs.padding[0], 1), Math.max(arraySize[1] - storedAttrs.padding[1], 1)];
        } else graphicAttributes.size = storedAttrs.size;
      },
      storedAttrs: "paddingAttrs"
    }].concat(transformsByType.symbol);
  }
  release() {
    super.release(), this._encoders = null;
  }
};
Cell.markType = GrammarMarkType.cell;
var registerCellMark = () => {
  Factory.registerMark(GrammarMarkType.cell, Cell);
};

// node_modules/@visactor/vgrammar-core/es/semantic-marks/interval.js
var Interval = class extends Mark {
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(state), this;
  }
  _updateComponentEncoders(state) {
    this._encoders || (this._encoders = {});
    const userEncoder = this.spec.encode[state];
    if (userEncoder && "update" === state) {
      const params2 = this.parameters(), scales = isFunctionType(userEncoder) ? null : Object.keys(userEncoder).reduce((res, channel) => (isScaleEncode(userEncoder[channel]) && (res[channel] = getGrammarOutput(userEncoder[channel].scale, params2)), res), {});
      this._encoders[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c;
          const userEncodeRes = invokeEncoder(userEncoder, datum, element, parameters);
          if (this.disableCoordinateTransform = false, scales && scales.x && scales.x.type === ScaleEnum.Band) {
            if (!isNil_default(scales.y)) {
              const domain = scales.y.domain(), min4 = minInArray(domain), max4 = maxInArray(domain), baseValue = min4 > 0 ? min4 : max4 < 0 ? max4 : 0;
              userEncodeRes.y1 = scales.y.scale(baseValue);
            }
            const bandWidth = scales.x.bandwidth();
            userEncodeRes.x = userEncodeRes.x + bandWidth / 4, userEncodeRes.x1 = userEncodeRes.x + bandWidth / 2;
          } else if (scales && scales.y && scales.y.type === ScaleEnum.Band) {
            if (!isNil_default(scales.x)) {
              const domain = scales.x.domain(), min4 = minInArray(domain), max4 = maxInArray(domain), baseValue = min4 > 0 ? min4 : max4 < 0 ? max4 : 0;
              userEncodeRes.x1 = scales.x.scale(baseValue);
            }
            const bandWidth = scales.y.bandwidth();
            userEncodeRes.y = userEncodeRes.y + bandWidth / 4, userEncodeRes.y1 = userEncodeRes.y + bandWidth / 2;
          }
          if (scales) {
            const coord = (null !== (_b = this.view.getScaleById(null === (_a = userEncoder.x) || void 0 === _a ? void 0 : _a.scale)) && void 0 !== _b ? _b : this.view.getScaleById(null === (_c = userEncoder.y) || void 0 === _c ? void 0 : _c.scale)).getCoordinate();
            if (coord && "polar" === coord.type) {
              this.disableCoordinateTransform = true;
              const origin = coord.origin();
              userEncodeRes.cx = origin.x, userEncodeRes.cy = origin.y;
            }
          }
          return userEncodeRes;
        }
      };
    } else this._encoders[state] = userEncoder;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
  getAttributeTransforms() {
    return this.coord && "polar" === this.coord.output().type ? [{
      channels: ["x", "y", "x1", "y1", "cx", "cy"],
      transform: (graphicAttributes, nextAttrs, storedAttrs) => {
        graphicAttributes.x = storedAttrs.cx, graphicAttributes.y = storedAttrs.cy, this.coord.output().isTransposed() ? (graphicAttributes.startAngle = storedAttrs.y, graphicAttributes.endAngle = storedAttrs.y1, graphicAttributes.innerRadius = storedAttrs.x, graphicAttributes.outerRadius = storedAttrs.x1) : (graphicAttributes.startAngle = storedAttrs.x, graphicAttributes.endAngle = storedAttrs.x1, graphicAttributes.innerRadius = storedAttrs.y, graphicAttributes.outerRadius = storedAttrs.y1);
      },
      storedAttrs: "sizeAttrs"
    }] : transformsByType.rect;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = createGraphicItem(this, this.coord && "polar" === this.coord.output().type ? GrammarMarkType.arc : GrammarMarkType.rect, attrs);
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
  release() {
    super.release(), this._encoders = null;
  }
};
Interval.markType = GrammarMarkType.interval;

// node_modules/@visactor/vchart/esm/constant/event.js
var BASE_EVENTS = ["pointerdown", "pointerup", "pointerupoutside", "pointertap", "pointerover", "pointermove", "pointerenter", "pointerleave", "pointerout", "mousedown", "mouseup", "mouseupoutside", "rightdown", "rightup", "rightupoutside", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mouseenter", "mouseleave", "wheel", "touchstart", "touchend", "touchendoutside", "touchmove", "touchcancel", "tap", "dragstart", "drag", "dragenter", "dragleave", "dragover", "dragend", "drop", "pan", "panstart", "panend", "press", "pressup", "pressend", "pinch", "pinchstart", "pinchend", "swipe"];
var ChartEvent;
!function(ChartEvent2) {
  ChartEvent2.initialized = "initialized", ChartEvent2.rendered = "rendered", ChartEvent2.renderFinished = "renderFinished", ChartEvent2.animationFinished = "animationFinished", ChartEvent2.regionSeriesDataFilterOver = "regionSeriesDataFilterOver", ChartEvent2.afterInitData = "afterInitData", ChartEvent2.afterInitEvent = "afterInitEvent", ChartEvent2.afterInitMark = "afterInitMark", ChartEvent2.rawDataUpdate = "rawDataUpdate", ChartEvent2.viewDataFilterOver = "viewDataFilterOver", ChartEvent2.viewDataUpdate = "viewDataUpdate", ChartEvent2.viewDataStatisticsUpdate = "viewDataStatisticsUpdate", ChartEvent2.markDeltaYUpdate = "markDeltaYUpdate", ChartEvent2.viewDataLabelUpdate = "viewDataLabelUpdate", ChartEvent2.scaleDomainUpdate = "scaleDomainUpdate", ChartEvent2.scaleUpdate = "scaleUpdate", ChartEvent2.dataZoomChange = "dataZoomChange", ChartEvent2.drill = "drill", ChartEvent2.layoutStart = "layoutStart", ChartEvent2.layoutEnd = "layoutEnd", ChartEvent2.layoutRectUpdate = "layoutRectUpdate", ChartEvent2.playerPlay = "playerPlay", ChartEvent2.playerPause = "playerPause", ChartEvent2.playerEnd = "playerEnd", ChartEvent2.playerChange = "playerChange", ChartEvent2.playerForward = "playerForward", ChartEvent2.playerBackward = "playerBackward", ChartEvent2.scrollBarChange = "scrollBarChange", ChartEvent2.brushStart = "brushStart", ChartEvent2.brushChange = "brushChange", ChartEvent2.brushEnd = "brushEnd", ChartEvent2.brushClear = "brushClear", ChartEvent2.legendSelectedDataChange = "legendSelectedDataChange", ChartEvent2.legendFilter = "legendFilter", ChartEvent2.legendItemClick = "legendItemClick", ChartEvent2.legendItemHover = "legendItemHover", ChartEvent2.legendItemUnHover = "legendItemUnHover", ChartEvent2.tooltipShow = "tooltipShow", ChartEvent2.tooltipHide = "tooltipHide", ChartEvent2.tooltipRelease = "tooltipRelease", ChartEvent2.afterResize = "afterResize", ChartEvent2.afterRender = "afterRender", ChartEvent2.afterLayout = "afterLayout";
}(ChartEvent || (ChartEvent = {}));
var Event_Source_Type;
!function(Event_Source_Type2) {
  Event_Source_Type2.chart = "chart", Event_Source_Type2.window = "window", Event_Source_Type2.canvas = "canvas";
}(Event_Source_Type || (Event_Source_Type = {}));
var Event_Bubble_Level;
!function(Event_Bubble_Level2) {
  Event_Bubble_Level2.vchart = "vchart", Event_Bubble_Level2.chart = "chart", Event_Bubble_Level2.model = "model", Event_Bubble_Level2.mark = "mark";
}(Event_Bubble_Level || (Event_Bubble_Level = {}));

// node_modules/@visactor/vchart/esm/constant/waterfall.js
var WaterfallDefaultSeriesField = `${PREFIX}_waterfall_default_seriesField`;

// node_modules/@visactor/vchart/esm/constant/correlation.js
var CORRELATION_X = `${PREFIX}_CORRELATION_X`;
var CORRELATION_Y = `${PREFIX}_CORRELATION_Y`;
var CORRELATION_SIZE = `${PREFIX}_CORRELATION_SIZE`;

// node_modules/@visactor/vchart/esm/constant/index.js
var DEFAULT_MEASURE_CANVAS_ID = `${PREFIX}_MEASURE_CANVAS_ID`;
var DEFAULT_DATA_INDEX = `${PREFIX}_DEFAULT_DATA_INDEX`;
var DEFAULT_DATA_KEY = `${PREFIX}_DEFAULT_DATA_KEY`;
var DEFAULT_DATA_SERIES_FIELD = `${PREFIX}_DEFAULT_DATA_SERIES_FIELD`;
var DEFAULT_SERIES_STYLE_NAME = `${PREFIX}_DEFAULT_SERIES_STYLE_NAME`;
var AttributeLevel;
!function(AttributeLevel2) {
  AttributeLevel2[AttributeLevel2.Default = 0] = "Default", AttributeLevel2[AttributeLevel2.Theme = 1] = "Theme", AttributeLevel2[AttributeLevel2.Chart = 2] = "Chart", AttributeLevel2[AttributeLevel2.Base_Series = 3] = "Base_Series", AttributeLevel2[AttributeLevel2.Series = 4] = "Series", AttributeLevel2[AttributeLevel2.Mark = 5] = "Mark", AttributeLevel2[AttributeLevel2.User_Chart = 6] = "User_Chart", AttributeLevel2[AttributeLevel2.User_Series = 7] = "User_Series", AttributeLevel2[AttributeLevel2.User_Mark = 8] = "User_Mark", AttributeLevel2[AttributeLevel2.Built_In = 99] = "Built_In";
}(AttributeLevel || (AttributeLevel = {}));
var STACK_FIELD_START = `${PREFIX}_STACK_START`;
var STACK_FIELD_END = `${PREFIX}_STACK_END`;
var STACK_FIELD_START_PERCENT = `${PREFIX}_STACK_START_PERCENT`;
var STACK_FIELD_END_PERCENT = `${PREFIX}_STACK_END_PERCENT`;
var STACK_FIELD_START_OffsetSilhouette = `${PREFIX}_STACK_START_OffsetSilhouette`;
var STACK_FIELD_END_OffsetSilhouette = `${PREFIX}_STACK_END_OffsetSilhouette`;
var STACK_FIELD_TOTAL = `${PREFIX}_STACK_TOTAL`;
var STACK_FIELD_TOTAL_PERCENT = `${PREFIX}_STACK_TOTAL_PERCENT`;
var STACK_FIELD_TOTAL_TOP = `${PREFIX}_STACK_TOTAL_TOP`;
var SEGMENT_FIELD_START = `${PREFIX}_SEGMENT_START`;
var SEGMENT_FIELD_END = `${PREFIX}_SEGMENT_END`;
var LayoutZIndex;
!function(LayoutZIndex2) {
  LayoutZIndex2[LayoutZIndex2.Axis_Grid = 50] = "Axis_Grid", LayoutZIndex2[LayoutZIndex2.CrossHair_Grid = 100] = "CrossHair_Grid", LayoutZIndex2[LayoutZIndex2.Region = 450] = "Region", LayoutZIndex2[LayoutZIndex2.Mark = 300] = "Mark", LayoutZIndex2[LayoutZIndex2.Node = 400] = "Node", LayoutZIndex2[LayoutZIndex2.Axis = 100] = "Axis", LayoutZIndex2[LayoutZIndex2.MarkLine = 500] = "MarkLine", LayoutZIndex2[LayoutZIndex2.MarkArea = 100] = "MarkArea", LayoutZIndex2[LayoutZIndex2.MarkPoint = 500] = "MarkPoint", LayoutZIndex2[LayoutZIndex2.DataZoom = 500] = "DataZoom", LayoutZIndex2[LayoutZIndex2.ScrollBar = 500] = "ScrollBar", LayoutZIndex2[LayoutZIndex2.Player = 500] = "Player", LayoutZIndex2[LayoutZIndex2.Legend = 500] = "Legend", LayoutZIndex2[LayoutZIndex2.CrossHair = 500] = "CrossHair", LayoutZIndex2[LayoutZIndex2.Indicator = 500] = "Indicator", LayoutZIndex2[LayoutZIndex2.Title = 500] = "Title", LayoutZIndex2[LayoutZIndex2.Label = 500] = "Label", LayoutZIndex2[LayoutZIndex2.Brush = 500] = "Brush", LayoutZIndex2[LayoutZIndex2.CustomMark = 500] = "CustomMark", LayoutZIndex2[LayoutZIndex2.Interaction = 700] = "Interaction";
}(LayoutZIndex || (LayoutZIndex = {}));
var LayoutLevel;
!function(LayoutLevel2) {
  LayoutLevel2[LayoutLevel2.Indicator = 10] = "Indicator", LayoutLevel2[LayoutLevel2.Region = 20] = "Region", LayoutLevel2[LayoutLevel2.Axis = 30] = "Axis", LayoutLevel2[LayoutLevel2.DataZoom = 40] = "DataZoom", LayoutLevel2[LayoutLevel2.Player = 40] = "Player", LayoutLevel2[LayoutLevel2.ScrollBar = 40] = "ScrollBar", LayoutLevel2[LayoutLevel2.Legend = 50] = "Legend", LayoutLevel2[LayoutLevel2.Title = 70] = "Title", LayoutLevel2[LayoutLevel2.CustomMark = 70] = "CustomMark";
}(LayoutLevel || (LayoutLevel = {}));
var GradientType = ["linear", "radial", "conical"];
var DEFAULT_LINEAR_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1
};
var DEFAULT_RADIAL_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1,
  r0: 0,
  r1: 1
};
var DEFAULT_CONICAL_GRADIENT_CONFIG = {
  x: 0.5,
  y: 0.5,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var DEFAULT_GRADIENT_CONFIG = {
  linear: DEFAULT_LINEAR_GRADIENT_CONFIG,
  radial: DEFAULT_RADIAL_GRADIENT_CONFIG,
  conical: DEFAULT_CONICAL_GRADIENT_CONFIG
};

// node_modules/@visactor/vchart/esm/series/base/constant.js
var baseSeriesMark = {
  label: {
    name: "label",
    type: "text"
  }
};
var RECT_X = `${PREFIX}_rect_x`;
var RECT_X1 = `${PREFIX}_rect_x1`;
var RECT_Y = `${PREFIX}_rect_y`;
var RECT_Y1 = `${PREFIX}_rect_y1`;

// node_modules/@visactor/vchart/esm/series/bar/constant.js
var barSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar: {
    name: "bar",
    type: "rect"
  },
  barBackground: {
    name: "barBackground",
    type: "rect"
  }
});
var bar3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar3d: {
    name: "bar3d",
    type: "rect3d"
  }
});

// node_modules/@visactor/vchart/esm/series/mixin/constant.js
var lineLikeSeriesMark = {
  point: {
    name: "point",
    type: "symbol"
  },
  line: {
    name: "line",
    type: "line"
  }
};

// node_modules/@visactor/vchart/esm/series/line/constant.js
var lineSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark);

// node_modules/@visactor/vchart/esm/series/scatter/constant.js
var scatterSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  point: {
    name: "point",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/area/constant.js
var areaSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// node_modules/@visactor/vchart/esm/series/radar/constant.js
var radarSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// node_modules/@visactor/vchart/esm/series/pie/constant.js
var pieSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie: {
    name: "pie",
    type: "arc"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});
var pie3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie3d: {
    name: "pie3d",
    type: "arc3d"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});

// node_modules/@visactor/vchart/esm/series/rose/constant.js
var roseSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  rose: {
    name: "rose",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/map/constant.js
var mapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  area: {
    name: "area",
    type: "path"
  }
});

// node_modules/@visactor/vchart/esm/series/polar/progress-like/constant.js
var progressLikeSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/series/progress/circular/constant.js
var circularProgressSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  track: {
    name: "track",
    type: "progressArc"
  },
  progress: {
    name: "progress",
    type: "progressArc"
  }
});

// node_modules/@visactor/vchart/esm/series/link/constant.js
var linkSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  link: {
    name: "link",
    type: "rule"
  },
  arrow: {
    name: "arrow",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/dot/constant.js
var dotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  grid: {
    name: "grid",
    type: "rule"
  },
  gridBackground: {
    name: "gridBackground",
    type: "rect"
  },
  dot: {
    name: "dot",
    type: "symbol"
  },
  title: {
    name: "title",
    type: "text"
  },
  subTitle: {
    name: "subTitle",
    type: "text"
  },
  symbol: {
    name: "symbol",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/word-cloud/constant.js
var wordCloudSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  word: {
    name: "word",
    type: "text"
  },
  fillingWord: {
    name: "fillingWord",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/funnel/constant.js
var funnelSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel: {
    name: "funnel",
    type: "polygon"
  },
  transform: {
    name: "transform",
    type: "polygon"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});
var funnel3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel3d: {
    name: "funnel3d",
    type: "pyramid3d"
  },
  transform3d: {
    name: "transform3d",
    type: "pyramid3d"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});

// node_modules/@visactor/vchart/esm/series/progress/linear/constant.js
var linearProgressSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  track: {
    name: "track",
    type: "rect"
  },
  progress: {
    name: "progress",
    type: "rect"
  },
  group: {
    name: "group",
    type: "group"
  }
});

// node_modules/@visactor/vchart/esm/series/waterfall/constant.js
var waterfallSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  leaderLine: {
    name: "leaderLine",
    type: "rule"
  },
  stackLabel: {
    name: "stackLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/box-plot/constant.js
var boxPlotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  boxPlot: {
    name: "boxPlot",
    type: "boxPlot"
  },
  outlier: {
    name: "outlier",
    type: "symbol"
  }
});

// node_modules/@visactor/vchart/esm/series/treemap/constant.js
var treemapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nonLeaf: {
    name: "nonLeaf",
    type: "rect"
  },
  leaf: {
    name: "leaf",
    type: "rect"
  },
  nonLeafLabel: {
    name: "nonLeafLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/sankey/constant.js
var sankeySeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  node: {
    name: "node",
    type: "rect"
  },
  link: {
    name: "link",
    type: "linkPath"
  }
});

// node_modules/@visactor/vchart/esm/series/gauge/constant.js
var gaugeSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  segment: {
    name: "segment",
    type: "progressArc"
  },
  track: {
    name: "track",
    type: "progressArc"
  }
});
var gaugePointerSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pin: {
    name: "pin",
    type: "path"
  },
  pinBackground: {
    name: "pinBackground",
    type: "path"
  },
  pointer: {
    name: "pointer",
    type: ["path", "rect"]
  }
});

// node_modules/@visactor/vchart/esm/series/sunburst/constant.js
var sunburstSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  sunburst: {
    name: "sunburst",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/range-column/constant.js
var rangeColumnSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});
var rangeColumn3dSeriesMark = Object.assign(Object.assign({}, bar3dSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/circle-packing/constant.js
var circlePackingSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  circlePacking: {
    name: "circlePacking",
    type: "arc"
  }
});

// node_modules/@visactor/vchart/esm/series/heatmap/constant.js
var heatmapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  cell: {
    name: "cell",
    type: "cell"
  },
  cellBackground: {
    name: "cellBackground",
    type: "cell"
  }
});

// node_modules/@visactor/vchart/esm/series/correlation/constant.js
var correlationSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nodePoint: {
    name: "nodePoint",
    type: "symbol"
  },
  ripplePoint: {
    name: "ripplePoint",
    type: "ripple"
  },
  centerPoint: {
    name: "centerPoint",
    type: "symbol"
  },
  centerLabel: {
    name: "centerLabel",
    type: "text"
  }
});

// node_modules/@visactor/vchart/esm/series/range-area/constant.js
var rangeAreaSeriesMark = Object.assign({}, areaSeriesMark);

// node_modules/@visactor/vchart/esm/series/interface/theme.js
var SeriesTypeForThemeEnum;
!function(SeriesTypeForThemeEnum2) {
  SeriesTypeForThemeEnum2.area_horizontal = "area_horizontal", SeriesTypeForThemeEnum2.area_vertical = "area_vertical", SeriesTypeForThemeEnum2.line_horizontal = "line_horizontal", SeriesTypeForThemeEnum2.line_vertical = "line_vertical", SeriesTypeForThemeEnum2.bar_horizontal = "bar_horizontal", SeriesTypeForThemeEnum2.bar_vertical = "bar_vertical", SeriesTypeForThemeEnum2.bar3d_horizontal = "bar3d_horizontal", SeriesTypeForThemeEnum2.bar3d_vertical = "bar3d_vertical", SeriesTypeForThemeEnum2.rangeColumn_horizontal = "rangeColumn_horizontal", SeriesTypeForThemeEnum2.rangeColumn_vertical = "rangeColumn_vertical", SeriesTypeForThemeEnum2.rangeColumn3d_horizontal = "rangeColumn3d_horizontal", SeriesTypeForThemeEnum2.rangeColumn3d_vertical = "rangeColumn3d_vertical", SeriesTypeForThemeEnum2.rangeArea_horizontal = "rangeArea_horizontal", SeriesTypeForThemeEnum2.rangeArea_vertical = "rangeArea_vertical", SeriesTypeForThemeEnum2.linearProgress_horizontal = "linearProgress_horizontal", SeriesTypeForThemeEnum2.linearProgress_vertical = "linearProgress_vertical", SeriesTypeForThemeEnum2.boxPlot_horizontal = "boxPlot_horizontal", SeriesTypeForThemeEnum2.boxPlot_vertical = "boxPlot_vertical", SeriesTypeForThemeEnum2.sankey_horizontal = "sankey_horizontal", SeriesTypeForThemeEnum2.sankey_vertical = "sankey_vertical", SeriesTypeForThemeEnum2.waterfall_horizontal = "waterfall_horizontal", SeriesTypeForThemeEnum2.waterfall_vertical = "waterfall_vertical";
}(SeriesTypeForThemeEnum || (SeriesTypeForThemeEnum = {}));
var seriesMarkInfoMap = {
  [SeriesTypeEnum.bar]: barSeriesMark,
  [SeriesTypeEnum.bar3d]: bar3dSeriesMark,
  [SeriesTypeEnum.line]: lineSeriesMark,
  [SeriesTypeEnum.scatter]: scatterSeriesMark,
  [SeriesTypeEnum.area]: areaSeriesMark,
  [SeriesTypeEnum.radar]: radarSeriesMark,
  [SeriesTypeEnum.pie]: pieSeriesMark,
  [SeriesTypeEnum.pie3d]: pie3dSeriesMark,
  [SeriesTypeEnum.rose]: roseSeriesMark,
  [SeriesTypeEnum.geo]: baseSeriesMark,
  [SeriesTypeEnum.map]: mapSeriesMark,
  [SeriesTypeEnum.circularProgress]: circularProgressSeriesMark,
  [SeriesTypeEnum.link]: linkSeriesMark,
  [SeriesTypeEnum.dot]: dotSeriesMark,
  [SeriesTypeEnum.wordCloud]: wordCloudSeriesMark,
  [SeriesTypeEnum.wordCloud3d]: wordCloudSeriesMark,
  [SeriesTypeEnum.funnel]: funnelSeriesMark,
  [SeriesTypeEnum.funnel3d]: funnel3dSeriesMark,
  [SeriesTypeEnum.linearProgress]: linearProgressSeriesMark,
  [SeriesTypeEnum.waterfall]: waterfallSeriesMark,
  [SeriesTypeEnum.boxPlot]: boxPlotSeriesMark,
  [SeriesTypeEnum.treemap]: treemapSeriesMark,
  [SeriesTypeEnum.sankey]: sankeySeriesMark,
  [SeriesTypeEnum.gauge]: gaugeSeriesMark,
  [SeriesTypeEnum.gaugePointer]: gaugePointerSeriesMark,
  [SeriesTypeEnum.sunburst]: sunburstSeriesMark,
  [SeriesTypeEnum.rangeColumn]: rangeColumnSeriesMark,
  [SeriesTypeEnum.rangeColumn3d]: rangeColumn3dSeriesMark,
  [SeriesTypeEnum.circlePacking]: circlePackingSeriesMark,
  [SeriesTypeEnum.heatmap]: heatmapSeriesMark,
  [SeriesTypeEnum.correlation]: correlationSeriesMark,
  [SeriesTypeEnum.rangeArea]: rangeAreaSeriesMark
};

// node_modules/@visactor/vchart/esm/series/util/spec.js
function getDirectionFromSeriesSpec(spec) {
  var _a, _b;
  const { type } = spec;
  return type === SeriesTypeEnum.sankey ? null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal" : null !== (_b = spec.direction) && void 0 !== _b ? _b : "vertical";
}

// node_modules/@visactor/vchart/esm/theme/color-scheme/legacy.js
var newTokenToLegacyToken = {
  primaryFontColor: "titleFontColor",
  tertiaryFontColor: "labelFontColor",
  axisLabelFontColor: "axisFontColor",
  axisMarkerFontColor: "labelReverseFontColor",
  dataZoomHandleStrokeColor: "dataZoomHandlerStrokeColor",
  sliderHandleColor: "dataZoomHandlerFillColor",
  sliderRailColor: "dataZoomBackgroundColor",
  sliderTrackColor: "dataZoomSelectedColor",
  playerControllerColor: "dataZoomSelectedColor",
  popupBackgroundColor: "tooltipBackgroundColor",
  hoverBackgroundColor: "axisGridColor"
};
var legacyTokenToNewToken = {
  titleFontColor: "primaryFontColor",
  labelFontColor: "tertiaryFontColor",
  axisFontColor: "axisLabelFontColor",
  labelReverseFontColor: "axisMarkerFontColor",
  dataZoomHandlerStrokeColor: "dataZoomHandleStrokeColor",
  dataZoomHandlerFillColor: "sliderHandleColor",
  dataZoomBackgroundColor: "sliderRailColor",
  dataZoomSelectedColor: "sliderTrackColor",
  tooltipBackgroundColor: "popupBackgroundColor"
};
function getUpgradedTokenValue(palette, key) {
  const legacyKey = newTokenToLegacyToken[key];
  if (legacyKey && palette[legacyKey]) return palette[legacyKey];
  if (palette[key]) return palette[key];
  const newKey = legacyTokenToNewToken[key];
  return newKey ? palette[newKey] : void 0;
}

// node_modules/@visactor/vchart/esm/theme/color-scheme/util.js
function getDataScheme(colorScheme3, seriesSpec) {
  var _a;
  if (!colorScheme3) return [];
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme || isArray_default(scheme)) return null !== (_a = scheme) && void 0 !== _a ? _a : [];
  if (isObject_default(scheme)) {
    const { dataScheme: dataScheme2 } = scheme;
    return dataScheme2 ? isProgressiveDataColorScheme(dataScheme2) ? dataScheme2.map((item) => Object.assign(Object.assign({}, item), {
      scheme: item.scheme.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default)
    })) : dataScheme2.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default) : [];
  }
  return [];
}
function computeActualDataScheme(dataScheme2, colorDomain) {
  var _a, _b;
  return isProgressiveDataColorScheme(dataScheme2) ? null !== (_b = null === (_a = dataScheme2.find((item) => isValid_default(item.isAvailable) ? isFunction_default(item.isAvailable) ? item.isAvailable(colorDomain) : !!item.isAvailable : !isValid_default(item.maxDomainLength) || (null == colorDomain ? void 0 : colorDomain.length) <= item.maxDomainLength)) || void 0 === _a ? void 0 : _a.scheme) && void 0 !== _b ? _b : dataScheme2[dataScheme2.length - 1].scheme : dataScheme2;
}
function queryColorFromColorScheme(colorScheme3, colorKey, seriesSpec) {
  var _a;
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme) return;
  let color;
  const { palette } = scheme;
  if (isObject_default(palette) && (color = null !== (_a = getUpgradedTokenValue(palette, colorKey.key)) && void 0 !== _a ? _a : colorKey.default), !color) return;
  if (isNil_default(colorKey.a) && isNil_default(colorKey.l) || !isString_default(color)) return color;
  let c4 = new Color(color);
  if (isValid_default(colorKey.l)) {
    const { r: r2, g: g3, b: b2 } = c4.color, { h: h2, s: s3 } = rgbToHsl(r2, g3, b2), rgb2 = hslToRgb(h2, s3, colorKey.l), newColor = new Color(`rgb(${rgb2.r}, ${rgb2.g}, ${rgb2.b})`);
    newColor.setOpacity(c4.color.opacity), c4 = newColor;
  }
  return isValid_default(colorKey.a) && c4.setOpacity(colorKey.a), c4.toRGBA();
}
var getActualColor = (value, colorScheme3, seriesSpec) => {
  if (colorScheme3 && isColorKey(value)) {
    const color = queryColorFromColorScheme(colorScheme3, value, seriesSpec);
    if (color) return color;
  }
  return value;
};
function isColorKey(obj) {
  return obj && "palette" === obj.type && !!obj.key;
}
function isProgressiveDataColorScheme(obj) {
  return !(!isArray_default(obj) || 0 === obj.length) && obj.every((item) => isValid_default(item.scheme));
}
function transformColorSchemeToStandardStruct(colorScheme3) {
  return isArray_default(colorScheme3) ? {
    dataScheme: colorScheme3
  } : colorScheme3;
}
function getColorSchemeBySeries(colorScheme3, seriesSpec) {
  var _a, _b;
  const { type: seriesType } = null != seriesSpec ? seriesSpec : {};
  let scheme;
  if (!seriesSpec || isNil_default(seriesType)) scheme = null == colorScheme3 ? void 0 : colorScheme3.default;
  else {
    const direction2 = getDirectionFromSeriesSpec(seriesSpec);
    scheme = null !== (_b = null !== (_a = null == colorScheme3 ? void 0 : colorScheme3[`${seriesType}_${direction2}`]) && void 0 !== _a ? _a : null == colorScheme3 ? void 0 : colorScheme3[seriesType]) && void 0 !== _b ? _b : null == colorScheme3 ? void 0 : colorScheme3.default;
  }
  return scheme;
}

// node_modules/@visactor/vchart/esm/scale/color-ordinal-scale.js
var ColorOrdinalScale = class extends OrdinalScale {
  range(value) {
    return value ? (this._range = value, this._resetRange(), this) : super.range();
  }
  domain(value) {
    return value ? (super.domain(value), this._resetRange(), this) : super.domain();
  }
  _resetRange() {
    if (!isProgressiveDataColorScheme(this._range)) return void super.range(this._range);
    const range2 = computeActualDataScheme(this._range, this._domain);
    super.range(range2);
  }
};

// node_modules/@visactor/vchart/esm/util/scale.js
var defaultScaleMap = {
  linear: LinearScale,
  band: BandScale,
  point: PointScale,
  ordinal: OrdinalScale,
  threshold: ThresholdScale,
  colorOrdinal: ColorOrdinalScale
};
function createScale2(type) {
  const scaleConstructor = defaultScaleMap[type];
  return scaleConstructor ? new scaleConstructor() : null;
}
function createScaleWithSpec(spec, context) {
  if ("scale" in spec && spec.scale) return isString_default(spec.scale) && (null == context ? void 0 : context.globalScale) ? context.globalScale.registerMarkAttributeScale(spec, context.seriesId) : spec.scale;
  const scale4 = createScale2(spec.type);
  return scale4 && initScaleWithSpec(scale4, spec), scale4;
}
function initScaleWithSpec(scale4, spec) {
  scale4 && spec && (spec.domain && scale4.domain(spec.domain), spec.range && scale4.range(spec.range), spec.specified && scale4.specified && scale4.specified(spec.specified));
}
function valueInScaleRange(v2, s3) {
  if (!s3) return v2;
  const range2 = s3.range(), min4 = Math.min(range2[0], range2[range2.length - 1]), max4 = Math.max(range2[0], range2[range2.length - 1]);
  return Math.min(Math.max(min4, v2), max4);
}
function isSpecValueWithScale(specValue) {
  return isValid_default(null == specValue ? void 0 : specValue.field) && isValid_default(null == specValue ? void 0 : specValue.scale);
}

// node_modules/@visactor/vchart/esm/util/space.js
function isValidOrient(orient) {
  switch (orient) {
    case "left":
    case "right":
    case "top":
    case "bottom":
      return true;
    default:
      return false;
  }
}
function isPercent(v2) {
  return !!isString_default(v2) && (!!v2.endsWith("%") && couldBeValidNumber(v2.substring(0, v2.length - 1)));
}
function isPercentOffset(v2) {
  return !!isObject_default(v2) && ("percent" in v2 || "offset" in v2);
}
function calcLayoutNumber(v2, size, callOp) {
  var _a, _b;
  return isNumber_default(v2) ? v2 : isPercent(v2) ? Number(v2.substring(0, v2.length - 1)) * size / 100 : isFunction_default(v2) ? v2(callOp) : isObject_default(v2) ? size * (null !== (_a = v2.percent) && void 0 !== _a ? _a : 0) + (null !== (_b = v2.offset) && void 0 !== _b ? _b : 0) : 0;
}
function calcPadding(paddingSpec, rect, callOp) {
  var _a, _b, _c, _d;
  const result2 = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  if (Object.values(paddingSpec).every((value) => isNumber_default(value))) return result2.top = null !== (_a = paddingSpec.top) && void 0 !== _a ? _a : 0, result2.right = null !== (_b = paddingSpec.right) && void 0 !== _b ? _b : 0, result2.bottom = null !== (_c = paddingSpec.bottom) && void 0 !== _c ? _c : 0, result2.left = null !== (_d = paddingSpec.left) && void 0 !== _d ? _d : 0, result2;
  return [{
    orients: ["left", "right"],
    size: rect.width
  }, {
    orients: ["top", "bottom"],
    size: rect.height
  }].forEach((p2) => {
    p2.orients.forEach((o2) => {
      result2[o2] = calcLayoutNumber(paddingSpec[o2], p2.size, callOp);
    });
  }), result2;
}
function boundsInRect(bounds, rect) {
  return bounds ? {
    width: Math.ceil(Math.min(bounds.x2 - bounds.x1, rect.width)),
    height: Math.ceil(Math.min(bounds.y2 - bounds.y1, rect.height))
  } : {
    width: 0,
    height: 0
  };
}
function normalizeLayoutPaddingSpec(spec) {
  let result2 = {};
  return isArray_default(spec) ? (isNil_default(spec[0]) || (result2.top = result2.left = result2.bottom = result2.right = spec[0]), isNil_default(spec[1]) || (result2.left = result2.right = spec[1]), isNil_default(spec[2]) || (result2.bottom = spec[2]), isNil_default(spec[3]) || (result2.left = spec[3]), result2) : isNumber_default(spec) || isPercent(spec) || isFunction_default(spec) || isPercentOffset(spec) ? (result2.top = result2.left = result2.bottom = result2.right = spec, result2) : isObject_default(spec) ? (result2 = Object.assign({}, spec), result2) : result2;
}
function convertPoint(point6, relativePoint, convert) {
  return convert ? {
    x: point6.x + relativePoint.x,
    y: point6.y + relativePoint.y
  } : point6;
}
var getActualNumValue = (originValue, total) => {
  const originNumValue = Number(originValue), originStrValue = originValue.toString();
  return isNaN(originNumValue) && "%" === originStrValue[originStrValue.length - 1] ? total * (Number(originStrValue.slice(0, originStrValue.length - 1)) / 100) : originNumValue;
};

// node_modules/@visactor/vchart/esm/util/spec/background.js
function convertBackgroundSpec(bg) {
  if (!bg) return null;
  if ("string" == typeof bg) return {
    fill: bg,
    fillOpacity: 1
  };
  if ("object" != typeof bg) return null;
  const result2 = pickWithout(bg, ["x", "y", "width", "height", "x1", "y1", "image"]);
  return result2.background = bg.image, result2;
}

// node_modules/@visactor/vchart/esm/theme/color-scheme/builtin/default.js
var dataScheme = [{
  maxDomainLength: 10,
  scheme: ["#1664FF", "#1AC6FF", "#FF8A00", "#3CC780", "#7442D4", "#FFC400", "#304D77", "#B48DEB", "#009488", "#FF7DDA"]
}, {
  scheme: ["#1664FF", "#B2CFFF", "#1AC6FF", "#94EFFF", "#FF8A00", "#FFCE7A", "#3CC780", "#B9EDCD", "#7442D4", "#DDC5FA", "#FFC400", "#FAE878", "#304D77", "#8B959E", "#B48DEB", "#EFE3FF", "#009488", "#59BAA8", "#FF7DDA", "#FFCFEE"]
}];

// node_modules/@visactor/vchart/esm/theme/builtin/light/color-scheme.js
var colorScheme = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#ffffff",
      borderColor: "#e3e5e8",
      shadowColor: "rgba(33,37,44,0.1)",
      hoverBackgroundColor: "#f1f2f5",
      sliderRailColor: "#f1f3f4",
      sliderHandleColor: "#ffffff",
      sliderTrackColor: "#0040ff",
      popupBackgroundColor: "#ffffff",
      primaryFontColor: "#21252c",
      secondaryFontColor: "#606773",
      tertiaryFontColor: "#89909d",
      axisLabelFontColor: "#89909d",
      disableFontColor: "#bcc1cb",
      axisMarkerFontColor: "#ffffff",
      axisGridColor: "#f1f2f5",
      axisDomainColor: "#d9dde4",
      dataZoomHandleStrokeColor: "#aeb5be",
      dataZoomChartColor: "#c9ced8",
      playerControllerColor: "#0040ff",
      scrollBarSliderColor: "rgba(0,0,0,0.3)",
      axisMarkerBackgroundColor: "#21252c",
      markLabelBackgroundColor: "#f1f2f5",
      markLineStrokeColor: "#606773",
      dangerColor: "#e33232",
      warningColor: "#ffc528",
      successColor: "#07a35a",
      infoColor: "#3073f2"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/area.js
var area = {
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/bar.js
var bar = {
  label: {
    visible: false,
    position: "outside",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/bar3d.js
var bar3d = {
  bar3d: {
    style: {
      length: 3
    }
  },
  label: {
    visible: false,
    style: {
      offset: 12,
      position: "outside"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/circular-progress.js
var circularProgress = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fillOpacity: 0.2
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/constants.js
var THEME_CONSTANTS = {
  defaultFontFamily: "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol",
  defaultFontSize: 14,
  l1FontSize: 32,
  l1LineHeight: "150%",
  l2FontSize: 20,
  l2LineHeight: "140%",
  l3FontSize: 16,
  l3LineHeight: "150%",
  l4FontSize: 14,
  l4LineHeight: "150%",
  l5FontSize: 12,
  l5LineHeight: "130%",
  l6FontSize: 10,
  l6LineHeight: "120%",
  axisTickSize: 4,
  areaOpacity: 0.2
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/dot.js
var dot = {
  dot: {
    style: {
      size: 10,
      fillOpacity: 1
    }
  },
  symbol: {
    style: {
      size: 10
    }
  },
  title: {
    style: {
      textAlign: "left",
      textBaseline: "middle",
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight
    }
  },
  subTitle: {
    style: {
      textAlign: "left",
      textBaseline: "top",
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/funnel.js
var funnel = {
  transform: {
    style: {
      fill: {
        type: "palette",
        key: "axisGridColor"
      }
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      lineWidth: 2
    }
  },
  outerLabel: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight,
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "axisDomainColor"
        }
      }
    }
  },
  transformLabel: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight,
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      },
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/funnel3d.js
var funnel3d = {
  transform3d: {
    style: {
      fill: "#f5f5f5"
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      lineWidth: 2
    }
  },
  outerLabel: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight,
      fill: "#707070"
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "axisDomainColor"
        }
      }
    }
  },
  transformLabel: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight,
      fill: "#707070",
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/gauge.js
var gauge = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  padAngle: 1.146,
  segment: {
    style: {
      fillOpacity: 1
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/gauge-pointer.js
var pointerPath = "M-0.020059 -0.978425 C-0.018029 -0.9888053 -0.013378 -1 0 -1 C0.01342 -1 0.01812 -0.989146 0.0201 -0.978425 C0.02161 -0.9702819 0.0692 -0.459505 0.09486 -0.184807 C0.10298 -0.097849 0.1089 -0.034548 0.11047 -0.018339 C0.11698 0.04908 0.07373 0.11111 0.00002 0.11111 C-0.07369 0.11111 -0.117184 0.04991 -0.110423 -0.018339 C-0.103662 -0.086591 -0.022089 -0.9680447 -0.020059 -0.978425Z";
var circlePath = "M1 0 C1 0.55228 0.55228 1 0 1 C-0.552285 1 -1 0.55228 -1 0 C-1 -0.552285 -0.552285 -1 0 -1 C0.55228 -1 1 -0.552285 1 0Z";
var gaugePointer = {
  pointer: {
    type: "path",
    width: 0.4,
    height: 0.4,
    style: {
      path: pointerPath
    }
  },
  pin: {
    width: 0.025,
    height: 0.025,
    style: {
      path: circlePath,
      fill: "#888"
    }
  },
  pinBackground: {
    width: 0.06,
    height: 0.06,
    style: {
      path: circlePath,
      fill: "#ddd"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/line.js
var line = {
  label: {
    visible: false,
    position: "top",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/linear-progress.js
var linearProgress = {
  bandWidth: 30,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fill: "#E7EBED",
      fillOpacity: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/link.js
var link2 = {
  arrow: {
    style: {
      size: 10
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/map.js
var map2 = {
  defaultFillColor: "#f3f3f3",
  area: {
    style: {
      lineWidth: 0.5,
      strokeOpacity: 1,
      stroke: "black",
      fillOpacity: 1
    }
  },
  label: {
    interactive: false,
    style: {
      fontSize: THEME_CONSTANTS.l6FontSize,
      lineHeight: THEME_CONSTANTS.l6LineHeight,
      textBaseline: "middle",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      },
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/pie.js
var pie = {
  outerRadius: 0.6,
  pie: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    position: "outside",
    style: {
      fontWeight: "normal",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1
    }
  },
  innerLabel: {
    style: {
      lineWidth: 2
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/pie3d.js
var pie3d = {
  outerRadius: 0.6,
  pie3d: {
    style: {
      height: 10,
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    position: "outside"
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/radar.js
var radar = {
  label: {
    visible: false,
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/scatter.js
var scatter = {
  point: {
    style: {
      size: 8,
      symbolType: "circle",
      lineWidth: 0,
      fillOpacity: 0.8
    }
  },
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/waterfall.js
var waterfall = {
  seriesFieldName: {
    total: "total",
    increase: "increase",
    decrease: "decrease"
  },
  leaderLine: {
    style: {
      stroke: "black",
      lineWidth: 1,
      lineDash: [4, 4]
    }
  },
  stackLabel: {
    visible: true,
    offset: 12,
    position: "withChange",
    style: {
      fill: "black",
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight
    }
  },
  label: {
    visible: false,
    offset: 12,
    position: "inside"
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/word-cloud.js
var wordCloud = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/word-cloud3d.js
var wordCloud3d = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/treemap.js
var treemap = {
  gapWidth: 1,
  nodePadding: [5],
  nonLeaf: {
    visible: false,
    style: {
      fillOpacity: 0.5
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      textAlign: "center",
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight
    }
  },
  nonLeafLabel: {
    padding: 2 * THEME_CONSTANTS.l5FontSize,
    style: {
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      textBaseline: "middle",
      textAlign: "center"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/sunburst.js
var sunburst = {
  innerRadius: 0,
  outerRadius: 1,
  startAngle: POLAR_START_ANGLE,
  endAngle: POLAR_END_ANGLE,
  gap: 0,
  labelLayout: {
    align: "center",
    offset: 0,
    rotate: "radial"
  },
  sunburst: {
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1,
      cursor: "pointer"
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/rangeColumn.js
var rangeColumn = {
  label: {
    visible: false,
    offset: 5,
    position: "inside",
    style: {
      fill: {
        type: "palette",
        key: "axisMarkerFontColor"
      }
    },
    minLabel: {
      position: "end"
    },
    maxLabel: {
      position: "start"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/circle-packing.js
var circlePacking = {
  layoutPadding: 5,
  circlePacking: {
    visible: true,
    style: {
      cursor: "pointer",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/heatmap.js
var heatmap = {
  cell: {
    style: {
      shape: "square",
      fillOpacity: 1
    }
  },
  cellBackground: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/sankey.js
var sankey = {
  link: {
    style: {
      fillOpacity: 0.15,
      round: true
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/rose.js
var rose = {
  rose: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      textAlign: "center",
      textBaseline: "middle"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/box-plot.js
var boxPlot = {
  boxPlot: {
    style: {
      lineWidth: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/correlation.js
var correlation = {
  centerLabel: {
    visible: true,
    position: "center",
    style: {
      fill: "#fff",
      text: ""
    }
  },
  label: {
    visible: true,
    position: "bottom",
    style: {
      fill: "#000"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/series/index.js
var series = {
  scatter,
  line,
  area,
  bar,
  bar3d,
  pie,
  pie3d,
  map: map2,
  radar,
  dot,
  link: link2,
  wordCloud,
  wordCloud3d,
  funnel,
  funnel3d,
  linearProgress,
  circularProgress,
  waterfall,
  gauge,
  gaugePointer,
  treemap,
  sunburst,
  rangeColumn,
  circlePacking,
  heatmap,
  sankey,
  rose,
  boxPlot,
  correlation
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/mark.js
var markByType = {
  text: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      lineHeight: THEME_CONSTANTS.l4LineHeight,
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var markByName = {
  label: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  area: {
    style: {
      fillOpacity: THEME_CONSTANTS.areaOpacity
    }
  },
  line: {
    style: {
      lineWidth: 2,
      lineCap: "round",
      lineJoin: "round"
    }
  },
  point: {
    style: {
      size: 8,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 1,
      fillOpacity: 1
    }
  },
  word: {
    style: {
      fontSize: null
    }
  },
  fillingWord: {
    style: {
      fontSize: null
    }
  },
  sunburst: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  circlePacking: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  funnel3d: {
    style: {
      stroke: false
    }
  },
  barBackground: {
    visible: false,
    style: {
      fill: {
        type: "palette",
        key: "primaryFontColor",
        a: 0.06
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/band-axis.js
var axisBand = {
  domainLine: {
    visible: true
  },
  grid: {
    visible: false
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: true
  },
  subTick: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/cartesian-axis.js
var axisX = {
  label: {
    space: 8
  },
  title: {
    space: 8
  },
  maxHeight: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisY = {
  label: {
    space: 12,
    autoLimit: true
  },
  title: {
    space: 12,
    autoRotate: true
  },
  maxWidth: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisZ = Object.assign(Object.assign({}, axisX), {
  label: {
    space: 0
  }
});

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/common-axis.js
var commonAxis = {
  domainLine: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  grid: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: []
    }
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  },
  tick: {
    visible: true,
    inside: false,
    tickSize: THEME_CONSTANTS.axisTickSize,
    alignWithLabel: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    tickSize: THEME_CONSTANTS.axisTickSize / 2,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 10,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  title: {
    space: 10,
    padding: 0,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/linear-axis.js
var axisLinear = {
  domainLine: {
    visible: false
  },
  grid: {
    visible: true
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: false
  },
  subTick: {
    visible: false
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/axis/polar-axis.js
var axisRadius = {
  grid: {
    smooth: true,
    visible: true
  },
  subGrid: {
    smooth: true,
    visible: false
  }
};
var axisAngle = {
  grid: {
    visible: true,
    style: {
      lineDash: [6, 6]
    }
  },
  label: {
    space: 5
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/brush.js
var brush = {
  style: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    lineWidth: 2
  },
  brushMode: "single",
  brushType: "rect",
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 0
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/crosshair.js
var getLabelSpec = () => ({
  visible: false,
  style: {
    fontWeight: "normal",
    fill: {
      type: "palette",
      key: "axisMarkerFontColor"
    },
    fontSize: THEME_CONSTANTS.l5FontSize
  },
  labelBackground: {
    padding: {
      bottom: 0,
      top: 0,
      left: 2,
      right: 2
    },
    style: {
      fill: {
        type: "palette",
        key: "axisMarkerBackgroundColor"
      },
      cornerRadius: 1
    }
  }
});
var crosshair = {
  trigger: "hover",
  bandField: {
    visible: false,
    line: {
      type: "rect",
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "axisGridColor"
        },
        opacity: 0.7,
        lineDash: []
      }
    },
    label: getLabelSpec()
  },
  linearField: {
    visible: false,
    line: {
      type: "line",
      visible: true,
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        fill: {
          type: "palette",
          key: "axisGridColor"
        },
        opacity: 0.7,
        lineDash: [2, 3]
      }
    },
    label: getLabelSpec()
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/data-zoom.js
var DataZoomHandlerSymbolType = "M-0.5-2.4h0.9c0.4,0,0.7,0.3,0.7,0.7v3.3c0,0.4-0.3,0.7-0.7,0.7h-0.9c-0.4,0-0.7-0.3-0.7-0.7v-3.3\nC-1.2-2-0.9-2.4-0.5-2.4z M-0.4-1.4L-0.4-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC-0.4-1.4-0.4-1.4-0.4-1.4z M0.3-1.4L0.3-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC0.3-1.4,0.3-1.4,0.3-1.4z;";
var dataZoom = {
  padding: [12, 0],
  showDetail: "auto",
  brushSelect: false,
  middleHandler: {
    visible: false,
    background: {
      size: 6,
      style: {
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        cornerRadius: 2
      }
    },
    icon: {
      style: {
        size: 4,
        fill: {
          type: "palette",
          key: "sliderHandleColor"
        },
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
        lineWidth: 0.5
      }
    }
  },
  background: {
    size: 20,
    style: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      },
      lineWidth: 0
    }
  },
  selectedBackground: {
    style: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.1,
      outerBorder: {
        stroke: {
          type: "palette",
          key: "sliderTrackColor"
        },
        strokeOpacity: 0.2,
        distance: -0.5,
        lineWidth: 1
      }
    }
  },
  selectedBackgroundChart: {
    area: {
      style: {
        visible: false,
        stroke: false,
        fill: {
          type: "palette",
          key: "dataZoomChartColor"
        }
      }
    },
    line: {
      style: {
        visible: false,
        stroke: {
          type: "palette",
          key: "dataZoomChartColor"
        },
        lineWidth: 1
      }
    }
  },
  startHandler: {
    style: {
      symbolType: DataZoomHandlerSymbolType,
      fill: {
        type: "palette",
        key: "sliderHandleColor"
      },
      scaleX: 1.2,
      scaleY: 1.2,
      stroke: {
        type: "palette",
        key: "dataZoomHandleStrokeColor"
      },
      lineWidth: 1
    }
  },
  endHandler: {
    style: {
      symbolType: DataZoomHandlerSymbolType,
      fill: {
        type: "palette",
        key: "sliderHandleColor"
      },
      scaleX: 1.2,
      scaleY: 1.2,
      stroke: {
        type: "palette",
        key: "dataZoomHandleStrokeColor"
      },
      lineWidth: 1
    }
  },
  startText: {
    padding: 8,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  endText: {
    padding: 8,
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  backgroundChart: {
    area: {
      style: {
        stroke: false,
        fill: {
          type: "palette",
          key: "dataZoomChartColor"
        }
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "dataZoomChartColor"
        },
        lineWidth: 1
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/indicator.js
var indicator = {
  title: {
    visible: true,
    autoLimit: false,
    autoFit: false,
    style: {
      fontSize: THEME_CONSTANTS.l1FontSize,
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  },
  content: {
    visible: true,
    style: {
      fontSize: THEME_CONSTANTS.l2FontSize,
      fill: {
        type: "palette",
        key: "tertiaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/continuous.js
var DEFAULT_CONTINUOUS_LEGEND_THEME = {
  orient: "right",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    space: 12
  },
  handler: {
    visible: true
  },
  startText: {
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  endText: {
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  handlerText: {
    style: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/color-legend.js
var handlerTheme = {
  style: {
    symbolType: "circle",
    lineWidth: 0,
    outerBorder: {
      lineWidth: 2,
      distance: 0.8,
      stroke: "#ffffff"
    },
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: {
      type: "palette",
      key: "shadowColor"
    }
  }
};
var colorLegend2 = {
  horizontal: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    rail: {
      width: 200,
      height: 8,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme
  }),
  vertical: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    rail: {
      width: 8,
      height: 200,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme
  })
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/discrete-legend.js
var discreteLegend2 = {
  orient: "bottom",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: THEME_CONSTANTS.l5FontSize,
      lineHeight: THEME_CONSTANTS.l5LineHeight,
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontWeight: "normal"
    },
    space: 12
  },
  item: {
    visible: true,
    spaceCol: 10,
    spaceRow: 6,
    padding: 2,
    background: {
      state: {
        selectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        },
        unSelectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        }
      }
    },
    shape: {
      space: 6,
      style: {
        lineWidth: 0,
        fillOpacity: 1,
        opacity: 1
      },
      state: {
        unSelected: {
          fillOpacity: 0.2,
          opacity: 1
        }
      }
    },
    label: {
      space: 6,
      style: {
        fill: {
          type: "palette",
          key: "secondaryFontColor",
          default: "#89909d"
        },
        fontSize: THEME_CONSTANTS.l5FontSize,
        lineHeight: THEME_CONSTANTS.l5LineHeight,
        opacity: 1
      },
      state: {
        unSelected: {
          fill: {
            type: "palette",
            key: "disableFontColor"
          },
          opacity: 1
        }
      }
    }
  },
  allowAllCanceled: false
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/legend/size-legend.js
var handlerTheme2 = {
  style: {
    symbolType: "circle",
    lineWidth: 0,
    outerBorder: {
      lineWidth: 2,
      distance: 0.8,
      stroke: {
        type: "palette",
        key: "sliderTrackColor"
      }
    },
    fill: {
      type: "palette",
      key: "sliderHandleColor"
    }
  }
};
var sizeLegend2 = {
  horizontal: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    sizeBackground: {
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    },
    track: {
      style: {
        fill: {
          type: "palette",
          key: "sliderTrackColor",
          a: 0.8
        }
      }
    },
    rail: {
      width: 200,
      height: 4,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme2
  }),
  vertical: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    sizeBackground: {
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    },
    track: {
      style: {
        fill: {
          type: "palette",
          key: "sliderTrackColor",
          a: 0.8
        }
      }
    },
    rail: {
      width: 4,
      height: 200,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme2
  })
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/map-label.js
var mapLabel = {
  visible: true,
  offset: 12,
  position: "top",
  space: 10,
  nameLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: THEME_CONSTANTS.l6FontSize
    }
  },
  valueLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: THEME_CONSTANTS.l6FontSize
    }
  },
  background: {
    visible: true,
    padding: {
      top: 4,
      bottom: 4,
      left: 6,
      right: 6
    },
    style: {
      cornerRadius: 2,
      lineWidth: 1,
      fill: "white",
      stroke: "grey"
    }
  },
  leader: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "red"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-area.js
var markArea = {
  area: {
    style: {
      fill: {
        type: "palette",
        key: "axisDomainColor",
        a: 0.25
      }
    }
  },
  label: {
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      fontWeight: "normal",
      fontStyle: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    labelBackground: {
      padding: {
        top: 2,
        bottom: 2,
        right: 4,
        left: 4
      },
      style: {
        cornerRadius: 3,
        fill: {
          type: "palette",
          key: "markLabelBackgroundColor"
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-line.js
var markLine = {
  line: {
    style: {
      lineDash: [3, 3],
      stroke: {
        type: "palette",
        key: "markLineStrokeColor"
      }
    }
  },
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 10,
    style: {
      fill: {
        type: "palette",
        key: "markLineStrokeColor"
      },
      stroke: null,
      lineWidth: 0
    }
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 10,
    style: {
      fill: {
        type: "palette",
        key: "markLineStrokeColor"
      },
      stroke: null,
      lineWidth: 0
    }
  },
  label: {
    refY: 5,
    style: {
      fontSize: THEME_CONSTANTS.l4FontSize,
      fontWeight: "normal",
      fontStyle: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    labelBackground: {
      padding: {
        top: 2,
        bottom: 2,
        right: 4,
        left: 4
      },
      style: {
        cornerRadius: 3,
        fill: {
          type: "palette",
          key: "markLabelBackgroundColor"
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/mark-point.js
var markPoint = {
  itemLine: {
    decorativeLine: {
      visible: false
    },
    startSymbol: {
      size: 5,
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    endSymbol: {
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        }
      }
    }
  },
  itemContent: {
    offsetY: -50
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/player.js
var player = {
  visible: true,
  position: "start",
  padding: {
    top: 20,
    bottom: 20
  },
  slider: {
    space: 10,
    trackStyle: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.8
    },
    railStyle: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      }
    },
    handlerStyle: {
      size: 15,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fill: {
        type: "palette",
        key: "playerControllerColor"
      }
    }
  },
  controller: {
    start: {
      order: 0,
      space: 0,
      style: {
        size: 25,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    pause: {
      order: 0,
      space: 0,
      style: {
        size: 25,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    backward: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    forward: {
      order: 0,
      space: 10,
      position: "end",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/title.js
var title2 = {
  padding: {
    top: 4,
    bottom: 20
  },
  textStyle: {
    fontSize: THEME_CONSTANTS.l3FontSize,
    lineHeight: THEME_CONSTANTS.l3LineHeight,
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  subtextStyle: {
    fontSize: THEME_CONSTANTS.l4FontSize,
    lineHeight: THEME_CONSTANTS.l4LineHeight,
    fill: {
      type: "palette",
      key: "tertiaryFontColor"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/tooltip.js
var tooltip2 = {
  offset: {
    x: 10,
    y: 10
  },
  panel: {
    padding: {
      top: 10,
      left: 10,
      right: 10,
      bottom: 10
    },
    backgroundColor: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    border: {
      color: {
        type: "palette",
        key: "popupBackgroundColor"
      },
      width: 0,
      radius: 3
    },
    shadow: {
      x: 0,
      y: 4,
      blur: 12,
      spread: 0,
      color: {
        type: "palette",
        key: "shadowColor"
      }
    }
  },
  spaceRow: 6,
  titleLabel: {
    fontSize: THEME_CONSTANTS.l4FontSize,
    lineHeight: THEME_CONSTANTS.l4LineHeight,
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "middle",
    spacing: 0
  },
  shape: {
    size: 8,
    spacing: 6
  },
  keyLabel: {
    fontSize: THEME_CONSTANTS.l4FontSize,
    lineHeight: THEME_CONSTANTS.l4LineHeight,
    fontColor: {
      type: "palette",
      key: "secondaryFontColor"
    },
    textAlign: "left",
    textBaseline: "middle",
    spacing: 26
  },
  valueLabel: {
    fontSize: THEME_CONSTANTS.l4FontSize,
    lineHeight: THEME_CONSTANTS.l4LineHeight,
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textBaseline: "middle",
    spacing: 0
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/poptip.js
var poptip = {
  visible: true,
  position: "auto",
  padding: 8,
  titleStyle: {
    fontSize: THEME_CONSTANTS.l5FontSize,
    fontWeight: "bold",
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  contentStyle: {
    fontSize: THEME_CONSTANTS.l5FontSize,
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  panel: {
    visible: true,
    fill: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    cornerRadius: 3,
    lineWidth: 0,
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: {
      type: "palette",
      key: "shadowColor"
    },
    size: 0,
    space: 12
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/total-label.js
var totalLabel = {
  visible: false,
  offset: 5,
  overlap: {
    clampForce: true,
    strategy: []
  },
  smartInvert: false,
  animation: false,
  style: {
    fontSize: THEME_CONSTANTS.l4FontSize,
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/scroll-bar.js
var scrollBar = {
  horizontal: {
    height: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  },
  vertical: {
    width: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/common/component/index.js
var component = {
  discreteLegend: discreteLegend2,
  colorLegend: colorLegend2,
  sizeLegend: sizeLegend2,
  axis: commonAxis,
  axisBand,
  axisLinear,
  axisX,
  axisY,
  axisZ,
  axisAngle,
  axisRadius,
  markLine,
  markArea,
  markPoint,
  tooltip: tooltip2,
  dataZoom,
  crosshair,
  player,
  brush,
  indicator,
  title: title2,
  mapLabel,
  poptip,
  totalLabel,
  scrollBar
};

// node_modules/@visactor/vchart/esm/theme/builtin/light/index.js
var lightTheme = {
  name: "light",
  background: {
    type: "palette",
    key: "backgroundColor"
  },
  padding: 20,
  fontFamily: THEME_CONSTANTS.defaultFontFamily,
  colorScheme,
  mark: markByType,
  markByName,
  series,
  component,
  animationThreshold: 2e3
};

// node_modules/@visactor/vchart/esm/theme/builtin/dark/color-scheme.js
var colorScheme2 = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#202226",
      borderColor: "#404349",
      shadowColor: "rgba(0,0,0,0.1)",
      hoverBackgroundColor: "#404349",
      sliderRailColor: "#404349",
      sliderHandleColor: "#202226",
      sliderTrackColor: "#4284FF",
      popupBackgroundColor: "#404349",
      primaryFontColor: "#fdfdfd",
      secondaryFontColor: "#bbbdc3",
      tertiaryFontColor: "#888c93",
      axisLabelFontColor: "#888c93",
      disableFontColor: "#55595f",
      axisMarkerFontColor: "#202226",
      axisGridColor: "#404349",
      axisDomainColor: "#4b4f54",
      dataZoomHandleStrokeColor: "#bbbdc3",
      dataZoomChartColor: "#55595F",
      playerControllerColor: "#4284FF",
      scrollBarSliderColor: "rgba(255,255,255,0.3)",
      axisMarkerBackgroundColor: "#fdfdfd",
      markLabelBackgroundColor: "#404349",
      markLineStrokeColor: "#bbbdc3",
      dangerColor: "#eb4b4b",
      warningColor: "#f0bd30",
      successColor: "#14b267",
      infoColor: "#4284ff"
    }
  }
};

// node_modules/@visactor/vchart/esm/theme/builtin/dark/index.js
var darkTheme2 = {
  name: "dark",
  colorScheme: colorScheme2,
  component: {
    dataZoom: {
      selectedBackground: {
        style: {
          fillOpacity: 0.4,
          outerBorder: {
            strokeOpacity: 0.4
          }
        }
      }
    }
  }
};

// node_modules/@visactor/vchart/esm/util/spec/merge-spec.js
function baseMerge2(target, source, shallowArray = false) {
  if (source) {
    if (target === source) return;
    if (isValid_default(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key in iterable) props.push(key);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key = props[++propIndex];
        isValid_default(iterable[key]) && "object" == typeof iterable[key] && !isArray_default(target[key]) ? baseMergeDeep2(target, source, key, shallowArray) : assignMergeValue2(target, key, iterable[key]);
      }
    }
  }
}
function baseMergeDeep2(target, source, key, shallowArray = false) {
  const objValue = target[key], srcValue = source[key];
  let newValue = source[key], isCommon = true;
  if (isArray_default(srcValue)) {
    if (shallowArray) newValue = [];
    else if (isArray_default(objValue)) newValue = objValue;
    else if (isArrayLike_default(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length2 = objValue.length;
      for (; ++index < length2; ) newValue[index] = objValue[index];
    }
  } else isPlainObject_default(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge2(newValue, srcValue, shallowArray), assignMergeValue2(target, key, newValue);
}
function assignMergeValue2(target, key, value) {
  (void 0 !== value && !eq2(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq2(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function mergeSpec(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge2(target, sources[sourceIndex], true);
  }
  return target;
}
function mergeSpecWithFilter(target, filter2, spec, forceMerge) {
  Object.keys(target).forEach((k3) => {
    if (isObject_default(filter2)) filter2.type === k3 && (isArray_default(target[k3]) ? target[k3].length >= filter2.index && (target[k3][filter2.index] = forceMerge ? mergeSpec({}, target[k3][filter2.index], spec) : spec) : target[k3] = forceMerge ? mergeSpec({}, target[k3], spec) : spec);
    else if (isArray_default(target[k3])) {
      const index = target[k3].findIndex((_s) => _s.id === filter2);
      index >= 0 && (target[k3][index] = forceMerge ? mergeSpec({}, target[k3][index], spec) : spec);
    } else target.id === filter2 && (target[k3] = forceMerge ? mergeSpec({}, target[k3], spec) : spec);
  });
}

// node_modules/@visactor/vchart/esm/util/spec/merge-theme.js
function mergeTheme(target, ...sources) {
  return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}
function transformThemeToMerge(theme2) {
  if (!theme2) return theme2;
  const colorScheme3 = transformColorSchemeToMerge(theme2.colorScheme), { series: series2 } = theme2, { mark: markByType2, markByName: markByName2 } = theme2;
  let newSeriesTheme;
  return (markByType2 || markByName2) && (newSeriesTheme = Object.keys(seriesMarkInfoMap).reduce((newSeriesTheme2, key) => {
    var _a;
    const value = null !== (_a = null == series2 ? void 0 : series2[key]) && void 0 !== _a ? _a : {};
    return newSeriesTheme2[key] = transformSeriesThemeToMerge(value, key, markByType2, markByName2), newSeriesTheme2;
  }, {})), Object.assign({}, theme2, {
    colorScheme: colorScheme3,
    series: Object.assign({}, theme2.series, newSeriesTheme)
  });
}
function transformColorSchemeToMerge(colorScheme3) {
  return colorScheme3 && (colorScheme3 = Object.keys(colorScheme3).reduce((scheme, key) => {
    const value = colorScheme3[key];
    return scheme[key] = transformColorSchemeToStandardStruct(value), scheme;
  }, {})), colorScheme3;
}
function transformSeriesThemeToMerge(seriesTheme, seriesType, markByType2, markByName2) {
  if (!seriesMarkInfoMap[seriesType]) return seriesTheme;
  const newTheme = {};
  return Object.values(seriesMarkInfoMap[seriesType]).forEach(({ type, name }) => {
    newTheme[name] = mergeSpec({}, null == markByType2 ? void 0 : markByType2[array(type)[0]], null == markByName2 ? void 0 : markByName2[name], null == seriesTheme ? void 0 : seriesTheme[name]);
  }), Object.assign(Object.assign({}, seriesTheme), newTheme);
}

// node_modules/@visactor/vchart/esm/util/spec/preprocess.js
var IGNORE_KEYS = ["animationThreshold", "colorScheme", "fontFamily", "name", "padding"];
function preprocessTheme(obj, colorScheme3, seriesSpec) {
  if (!obj) return obj;
  const newObj = {};
  return Object.keys(obj).forEach((key) => {
    const value = obj[key];
    IGNORE_KEYS.includes(key) ? newObj[key] = value : isPlainObject_default(value) ? isColorKey(value) ? newObj[key] = getActualColor(value, colorScheme3, seriesSpec) : newObj[key] = preprocessTheme(value, colorScheme3, seriesSpec) : newObj[key] = value;
  }), newObj;
}

// node_modules/@visactor/vchart/esm/theme/builtin/index.js
var builtinThemes = {
  [lightTheme.name]: lightTheme
};
var defaultThemeName = lightTheme.name;
var themes = new Map(Object.keys(builtinThemes).map((key) => [key, builtinThemes[key]]));
var transformedThemes = new Map(Object.keys(builtinThemes).map((key) => [key, preprocessTheme(builtinThemes[key], builtinThemes[key].colorScheme)]));
var hasThemeMerged = new Map(Object.keys(builtinThemes).map((key) => [key, key === defaultThemeName]));
var registerTheme = (name, theme2) => {
  if (!name) return;
  const mergedTheme = getMergedTheme(theme2);
  themes.set(name, mergedTheme), transformedThemes.set(name, preprocessTheme(mergedTheme, mergedTheme.colorScheme)), hasThemeMerged.set(name, true);
};
var getTheme2 = (name = defaultThemeName, transformed = false) => (hasThemeMerged.has(name) && !hasThemeMerged.get(name) && registerTheme(name, themes.get(name)), transformed ? transformedThemes.get(name) : themes.get(name));
var removeTheme = (name) => themes.delete(name) && transformedThemes.delete(name) && hasThemeMerged.delete(name);
var themeExist = (name) => !!isString_default(name) && themes.has(name);
var getMergedTheme = (theme2) => {
  var _a;
  const baseThemeName = null !== (_a = theme2.type) && void 0 !== _a ? _a : defaultThemeName, baseTheme = getTheme2(baseThemeName);
  return mergeTheme({}, baseTheme, theme2);
};

// node_modules/@visactor/vchart/esm/core/instance-manager.js
var InstanceManager = class _InstanceManager {
  static registerInstance(instance) {
    _InstanceManager.instances.set(instance.id, instance);
  }
  static unregisterInstance(instance) {
    _InstanceManager.instances.delete(instance.id);
  }
  static getInstance(id2) {
    return _InstanceManager.instances.get(id2);
  }
  static instanceExist(id2) {
    return _InstanceManager.instances.has(id2);
  }
  static forEach(callbackfn, excludeId = [], thisArg) {
    const excludeIdList = array(excludeId);
    return _InstanceManager.instances.forEach((instance, id2, map4) => {
      excludeIdList.includes(id2) || callbackfn(instance, id2, map4);
    }, thisArg);
  }
};
InstanceManager.instances = /* @__PURE__ */ new Map();

// node_modules/@visactor/vchart/esm/theme/theme-manager.js
var ThemeManager2 = class _ThemeManager {
  static registerTheme(name, theme2) {
    registerTheme(name, theme2);
  }
  static getTheme(name, transformed = false) {
    return getTheme2(name, transformed);
  }
  static removeTheme(name) {
    return removeTheme(name);
  }
  static themeExist(name) {
    return themeExist(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.themes.get(defaultThemeName);
  }
  static setCurrentTheme(name) {
    _ThemeManager.themeExist(name) && (_ThemeManager._currentThemeName = name, InstanceManager.forEach((instance) => null == instance ? void 0 : instance.setCurrentTheme(name)));
  }
  static getCurrentTheme() {
    return _ThemeManager.getTheme(_ThemeManager._currentThemeName);
  }
  static getCurrentThemeName() {
    return _ThemeManager._currentThemeName;
  }
};
ThemeManager2.themes = themes, ThemeManager2._currentThemeName = defaultThemeName;

// node_modules/@visactor/vchart/esm/util/spec/common.js
function isDataView(obj) {
  return obj instanceof DataView;
}
function isHTMLElement(obj) {
  try {
    return obj instanceof Element;
  } catch (_a) {
    const htmlElementKeys = ["children", "innerHTML", "classList", "setAttribute", "tagName", "getBoundingClientRect"], keys2 = Object.keys(obj);
    return htmlElementKeys.every((key) => keys2.includes(key));
  }
}
function getThemeObject(theme2, transformed) {
  return isString_default(theme2) ? ThemeManager2.themeExist(theme2) ? ThemeManager2.getTheme(theme2, transformed) : {} : isObject_default(theme2) ? theme2 : {};
}

// node_modules/@visactor/vchart/esm/util/spec/clone-deep.js
function cloneDeepSpec(spec, excludeKeys = ["data"]) {
  const value = spec;
  let result2;
  if (!isValid_default(value) || "object" != typeof value) return value;
  if (isDataView(value) || isHTMLElement(value)) return value;
  const isArr = isArray_default(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default(value) || isNumber_default(value) || isString_default(value) ? value : isDate_default(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2) for (; ++index < (props || value).length; ) {
    const key = props ? props[index] : index, subValue = value[key];
    (null == excludeKeys ? void 0 : excludeKeys.includes(key.toString())) ? result2[key] = subValue : result2[key] = cloneDeepSpec(subValue, excludeKeys);
  }
  return result2;
}

// node_modules/@visactor/vchart/esm/util/spec/transform.js
function specTransform(spec, special = {
  data: (v2) => v2
}) {
  if (!spec) return spec;
  if (spec.constructor === Object) {
    const result2 = {};
    for (const key in spec) if (Object.prototype.hasOwnProperty.call(spec, key)) {
      if (special[key]) {
        result2[key] = special[key](spec[key]);
        continue;
      }
      result2[key] = specTransform(spec[key], special);
    }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s3) => specTransform(s3, special)) : spec;
}
function functionTransform(spec, VChart2) {
  if (!spec) return spec;
  if (isPlainObject_default(spec)) {
    const result2 = {};
    for (const key in spec) if (Object.prototype.hasOwnProperty.call(spec, key)) {
      if (isString_default(spec[key]) && VChart2.getFunction(spec[key])) {
        result2[key] = VChart2.getFunction(spec[key]);
        continue;
      }
      result2[key] = functionTransform(spec[key], VChart2);
    }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s3) => functionTransform(s3, VChart2)) : spec;
}

// node_modules/@visactor/vchart/esm/util/text.js
var initTextMeasure3 = (textSpec, option, useNaiveCanvas) => initTextMeasure(textSpec, option, useNaiveCanvas, {
  fontFamily: THEME_CONSTANTS.defaultFontFamily,
  fontSize: THEME_CONSTANTS.defaultFontSize
});
var measureText = (text2, textSpec, option, useNaiveCanvas) => initTextMeasure3(textSpec, option, useNaiveCanvas).measure(text2);

// node_modules/@visactor/vchart/esm/util/data.js
function mergeFields(targetFields, mergeFields2) {
  for (let i2 = 0; i2 < mergeFields2.length; i2++) {
    const element = mergeFields2[i2], _target = findFields(targetFields, element.key);
    _target ? _target.operations = [...new Set(_target.operations.concat(element.operations))] : targetFields.push(element);
  }
  return targetFields;
}
function findFields(list, fieldKey) {
  return list.find((i2) => i2.key === fieldKey);
}
function getFieldAlias(dataView, field5) {
  var _a;
  if (!dataView) return null != field5 ? field5 : null;
  const fields2 = dataView.getFields();
  return fields2 && fields2[field5] ? null !== (_a = fields2[field5].alias) && void 0 !== _a ? _a : field5 : null != field5 ? field5 : null;
}
function getRegionStackGroup(region, setInitialValue, filter2) {
  const stackValueGroup = {};
  return region.getSeries().forEach((s3) => {
    var _a;
    const stackData = s3.getStackData(), stackValue = s3.getStackValue(), stackValueField = s3.getStackValueField(), filterEnable = !filter2 || filter2(s3);
    stackData && stackValueField && filterEnable && (stackValueGroup[stackValue] = null !== (_a = stackValueGroup[stackValue]) && void 0 !== _a ? _a : {
      nodes: {}
    }, stackGroup(s3, stackData, stackValueGroup[stackValue], stackValueField, setInitialValue));
  }), stackValueGroup;
}
function stackTotal(stackData, valueField) {
  if ("values" in stackData && stackData.values.length) {
    const total = sum3(stackData.values, valueField), percent = max3(stackData.values, STACK_FIELD_END_PERCENT);
    stackData.values.forEach((v2) => {
      v2[STACK_FIELD_TOTAL] = total, v2[STACK_FIELD_TOTAL_PERCENT] = percent, delete v2[STACK_FIELD_TOTAL_TOP];
    });
    const maxNode = stackData.values.reduce((max4, current) => current[STACK_FIELD_END] > max4[STACK_FIELD_END] ? current : max4);
    maxNode[STACK_FIELD_TOTAL_TOP] = true;
  } else for (const key in stackData.nodes) stackTotal(stackData.nodes[key], valueField);
}
function stackOffsetSilhouette(stackCache) {
  if (!stackCache.values.length) return;
  const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;
  for (let j2 = 0; j2 < stackCache.values.length; j2++) stackCache.values[j2][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j2][STACK_FIELD_START] - centerValue, stackCache.values[j2][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j2][STACK_FIELD_END] - centerValue;
}
function stack(stackCache, stackInverse, hasPercent) {
  if (stackCache.values.length > 0) {
    let positiveStart = 0, negativeStart = 0, sign4 = 1, value = 0;
    const maxLength = stackCache.values.length;
    for (let index = 0; index < maxLength; index++) {
      const v2 = stackCache.values[stackInverse ? maxLength - 1 - index : index];
      value = v2[STACK_FIELD_END], value >= 0 ? (v2[STACK_FIELD_START] = positiveStart, positiveStart += v2[STACK_FIELD_END], v2[STACK_FIELD_END] = positiveStart) : (v2[STACK_FIELD_START] = negativeStart, negativeStart += v2[STACK_FIELD_END], v2[STACK_FIELD_END] = negativeStart);
    }
    if (hasPercent) for (let index = 0; index < maxLength; index++) {
      const v2 = stackCache.values[stackInverse ? maxLength - 1 - index : index];
      value = v2[STACK_FIELD_END];
      const denominator = value >= 0 ? positiveStart : negativeStart;
      sign4 = value >= 0 ? 1 : -1, v2[STACK_FIELD_START_PERCENT] = 0 === denominator ? 0 : Math.min(1, v2[STACK_FIELD_START] / denominator) * sign4, v2[STACK_FIELD_END_PERCENT] = 0 === denominator ? 0 : Math.min(1, v2[STACK_FIELD_END] / denominator) * sign4;
    }
  }
  for (const key in stackCache.nodes) stack(stackCache.nodes[key], stackInverse, hasPercent);
}
function stackGroup(s3, stackData, stackCache, valueField, setInitialValue) {
  if ("values" in stackData) return setInitialValue && stackData.values.forEach((v2) => v2[STACK_FIELD_END] = toValidNumber2(v2[valueField])), stackCache.values.push(...stackData.values), void stackCache.series.push({
    s: s3,
    values: stackData.values
  });
  for (const key in stackData.nodes) !stackCache.nodes[key] && (stackCache.nodes[key] = {
    values: [],
    series: [],
    nodes: {}
  }), stackGroup(s3, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue);
}

// node_modules/@visactor/vchart/esm/util/hierarchy.js
var findHierarchyNode = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i2 = 0; i2 < hierarchyData.length; i2++) {
    const node = hierarchyData[i2];
    if (node[keyField] === key) return node;
    if (node[childrenField]) {
      const result2 = findHierarchyNode(node[childrenField], key, keyField, childrenField);
      if (result2) return result2;
    }
  }
  return null;
};
var findHierarchyNodeParent = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i2 = 0; i2 < hierarchyData.length; i2++) {
    const node = hierarchyData[i2];
    if (node[childrenField]) for (let j2 = 0; j2 < node[childrenField].length; j2++) {
      const childNode = node[childrenField][j2];
      if (childNode[keyField] === key) return node;
      const result2 = findHierarchyNodeParent([childNode], key, keyField, childrenField);
      if (result2) return result2;
    }
  }
  return null;
};
var findHierarchyPath = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  const result2 = [], dfs = (data, path) => {
    for (const item of data) {
      if (item[keyField] === key) return result2.push(...path, item[keyField].toString()), true;
      if (item[childrenField]) {
        const res = dfs(item[childrenField], [...path, item[keyField]]);
        if (true === res) return res;
      }
    }
    return false;
  };
  return dfs(hierarchyData, []), result2;
};

// node_modules/@visactor/vchart/esm/util/style.js
function transformComponentStyle(cfg = {}) {
  const newConfig = Object.assign({}, cfg);
  if (isFunction_default(cfg.style) ? newConfig.style = (item, isSelected, index, allItems) => transformToGraphic(cfg.style(item, isSelected, index, allItems)) : isEmpty_default(cfg.style) || (newConfig.style = transformToGraphic(cfg.style)), !isEmpty_default(cfg.state)) {
    const newStateStyle = {};
    Object.keys(cfg.state).forEach((key) => {
      isFunction_default(cfg.state[key]) ? newStateStyle[key] = (item, isSelected, index, allItems) => transformToGraphic(cfg.state[key](item, isSelected, index, allItems)) : isEmpty_default(cfg.state[key]) || (newStateStyle[key] = transformToGraphic(cfg.state[key]));
    }), newConfig.state = newStateStyle;
  }
  return newConfig;
}
function transformStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle)) return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (value, index, datum, data) => transformToGraphic(stateStyle[key](value, index, datum, data)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformAxisLabelStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle)) return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (datum, index, data, layer) => transformToGraphic(stateStyle[key](datum.rawValue, index, datum, data, layer)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformToGraphic(style) {
  return (null == style ? void 0 : style.angle) && (style.angle = degreeToRadian(style.angle)), style;
}

// node_modules/@visactor/vchart/esm/core/factory.js
var Factory2 = class _Factory {
  static registerChart(key, chart) {
    _Factory._charts[key] = chart;
  }
  static registerSeries(key, series2) {
    _Factory._series[key] = series2;
  }
  static registerComponent(key, cmp, alwaysCheck) {
    _Factory._components[key] = {
      cmp,
      alwaysCheck
    };
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static registerRegion(key, region) {
    _Factory._regions[key] = region;
  }
  static registerTransform(key, transform29) {
    _Factory.transforms[key] = transform29;
  }
  static registerLayout(key, layout2) {
    _Factory._layout[key] = layout2;
  }
  static registerAnimation(key, animation) {
    _Factory._animations[key] = animation;
  }
  static registerImplement(key, implement) {
    _Factory._implements[key] = implement;
  }
  static registerChartPlugin(key, plugin) {
    _Factory._chartPlugin[key] = plugin;
  }
  static createChart(chartType, spec, options) {
    if (!_Factory._charts[chartType]) return null;
    return new (0, _Factory._charts[chartType])(spec, options);
  }
  static createChartSpecTransformer(chartType, option) {
    if (!_Factory._charts[chartType]) return null;
    const ChartConstructor = _Factory._charts[chartType];
    return new (0, ChartConstructor.transformerConstructor)(Object.assign({
      seriesType: ChartConstructor.seriesType
    }, option));
  }
  static createRegion(regionType, spec, options) {
    if (!_Factory._regions[regionType]) return null;
    return new (0, _Factory._regions[regionType])(spec, options);
  }
  static createRegionSpecTransformer(regionType, options) {
    if (!_Factory._regions[regionType]) return null;
    return new (0, _Factory._regions[regionType].transformerConstructor)(options);
  }
  static createSeries(seriesType, spec, options) {
    if (!_Factory._series[seriesType]) return null;
    return new (0, _Factory._series[seriesType])(spec, options);
  }
  static createSeriesSpecTransformer(seriesType, options) {
    if (!_Factory._series[seriesType]) return null;
    return new (0, _Factory._series[seriesType].transformerConstructor)(options);
  }
  static createMark(markType, name, options) {
    if (!_Factory._marks[markType]) return null;
    const markInstance = new (0, _Factory._marks[markType])(name, options);
    return "group" === markInstance.type && markInstance.setInteractive(false), markInstance;
  }
  static getComponents() {
    return Object.values(_Factory._components);
  }
  static getComponentInKey(name) {
    return _Factory._components[name].cmp;
  }
  static getLayout() {
    return Object.values(_Factory._layout);
  }
  static getLayoutInKey(name) {
    return _Factory._layout[name];
  }
  static getSeries() {
    return Object.values(_Factory._series);
  }
  static getSeriesInType(type) {
    return _Factory._series[type];
  }
  static getRegionInType(type) {
    return _Factory._regions[type];
  }
  static getAnimationInKey(key) {
    return _Factory._animations[key];
  }
  static getImplementInKey(key) {
    return _Factory._implements[key];
  }
  static getSeriesMarkMap(seriesType) {
    return _Factory._series[seriesType] ? _Factory._series[seriesType].mark : {};
  }
  static getChartPlugins() {
    return Object.values(_Factory._chartPlugin);
  }
};
Factory2._charts = {}, Factory2._series = {}, Factory2._components = {}, Factory2._marks = {}, Factory2._regions = {}, Factory2._animations = {}, Factory2._implements = {}, Factory2._chartPlugin = {}, Factory2.transforms = {
  simplify,
  fields,
  filter,
  fold
}, Factory2.dataParser = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser
}, Factory2._layout = {};

// node_modules/@visactor/vchart/esm/event/events/dimension/util/common.js
var isInBound = (pos, min4, max4) => pos.x >= min4.x && pos.x <= max4.x && pos.y >= min4.y && pos.y <= max4.y;
var isInRegionBound = (chart, axis2, pos) => {
  const regionList = chart.getRegionsInIds(array(axis2.layout.layoutBindRegionID));
  return null == regionList ? void 0 : regionList.some((region) => {
    const rect = region.getLayoutRect(), startPoint = region.getLayoutStartPoint();
    return isInBound(pos, {
      x: startPoint.x,
      y: startPoint.y
    }, {
      x: rect.width + startPoint.x,
      y: rect.height + startPoint.y
    });
  });
};
var isSameDimensionInfo = (a4, b2) => {
  var _a, _b;
  return a4 === b2 || !isNil_default(a4) && !isNil_default(b2) && (a4.value === b2.value && (null === (_a = a4.axis) || void 0 === _a ? void 0 : _a.id) === (null === (_b = b2.axis) || void 0 === _b ? void 0 : _b.id));
};
var getDimensionData = (value, axis2, coordinate, getDimensionField) => {
  var _a;
  const scale4 = axis2.getScale(), isDiscreteAxis2 = isDiscrete(scale4.type), data = [], regions = axis2.getRegions();
  for (const region of regions) {
    const seriesList = region.getSeries();
    for (const series2 of seriesList) if (series2.coordinate === coordinate) {
      const dimensionField = array(getDimensionField(series2)), viewData = null === (_a = series2.getViewData()) || void 0 === _a ? void 0 : _a.latestData;
      if (dimensionField && viewData) if (isDiscreteAxis2) data.push({
        series: series2,
        datum: viewData.filter((datum) => {
          var _a2;
          return (null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString());
        })
      });
      else if (isValid_default(dimensionField[1])) data.push({
        series: series2,
        datum: viewData.filter((datum) => {
          var _a2;
          return (null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString()) || isValid_default(datum[dimensionField[0]]) && isValid_default(datum[dimensionField[1]]) && value >= datum[dimensionField[0]] && value < datum[dimensionField[1]];
        })
      });
      else {
        const range2 = axis2.getSpec().tooltipFilterRange, rangeArr = isValidNumber_default(range2) ? [-range2, range2] : range2;
        let datums = [];
        if (rangeArr) viewData.forEach((datum) => {
          if (isValid_default(datum[dimensionField[0]])) {
            const delta = datum[dimensionField[0]] - value;
            delta >= rangeArr[0] && delta <= rangeArr[1] && datums.push(datum);
          }
        });
        else {
          let minDelta = 1 / 0, deltaSign = 0;
          viewData.forEach((datum) => {
            if (isValid_default(datum[dimensionField[0]])) {
              const delta = Math.abs(datum[dimensionField[0]] - value), sign4 = Math.sign(datum[dimensionField[0]] - value);
              delta < minDelta ? (minDelta = delta, datums = [datum], deltaSign = sign4) : delta === minDelta && sign4 === deltaSign && datums.push(datum);
            }
          });
        }
        data.push({
          series: series2,
          datum: datums
        });
      }
    }
  }
  return data;
};
var getAxis = (chart, filter2, pos) => {
  const axesComponents = chart.getAllComponents().filter((c4) => "axes" === c4.specKey && filter2(c4) && isInRegionBound(chart, c4, pos));
  return axesComponents.length ? axesComponents : null;
};

// node_modules/@visactor/vchart/esm/event/events/dimension/util/polar.js
var angleStandardize = (angle2, range2) => {
  const unit = 2 * Math.PI, min4 = minInArray(range2), max4 = maxInArray(range2);
  return angle2 < min4 ? angle2 += Math.ceil((min4 - angle2) / unit) * unit : angle2 > max4 && (angle2 -= Math.ceil((angle2 - max4) / unit) * unit), angle2;
};
var getPolarDimensionInfo = (chart, pos) => {
  if (!chart) return null;
  if (!getFirstSeries(chart.getRegionsInIndex(), "polar")) return null;
  const { x: x3, y: y3 } = pos, angleAxisList = getAxis(chart, (cmp) => "angle" === cmp.getOrient(), pos), radiusAxisList = getAxis(chart, (cmp) => "radius" === cmp.getOrient(), pos), targetAxisInfo = [], getDimensionField = (series2) => series2.getDimensionField()[0];
  return angleAxisList && angleAxisList.forEach((axis2) => {
    var _a;
    const angleScale = axis2.getScale();
    if (angleScale && isDiscrete(angleScale.type)) {
      const angleDomain = angleScale.domain(), angleRange = angleScale.range(), center2 = axis2.getCenter(), vector = {
        x: x3 - axis2.getLayoutStartPoint().x - center2.x,
        y: y3 - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 = angleStandardize(angle2, angleRange);
      const radius = distance(vector), radiusScale = null === (_a = radiusAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
      const value = axis2.invert(angle2);
      if (isNil_default(value)) return;
      let index = angleDomain.findIndex((v2) => (null == v2 ? void 0 : v2.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        axis: axis2,
        data
      });
    }
  }), radiusAxisList && radiusAxisList.forEach((axis2) => {
    var _a;
    const radiusScale = axis2.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
    if (radiusScale && isDiscrete(radiusScale.type)) {
      const center2 = axis2.getCenter(), vector = {
        x: x3 - axis2.getLayoutStartPoint().x - center2.x,
        y: y3 - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 < -Math.PI / 2 && (angle2 = 2 * Math.PI + angle2);
      const radius = distance(vector), angleScale = null === (_a = angleAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), angleRange = null == angleScale ? void 0 : angleScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
      const value = radiusScale.invert(radius);
      if (isNil_default(value)) return;
      let index = radiusScale.domain().findIndex((v2) => (null == v2 ? void 0 : v2.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        axis: axis2,
        data
      });
    }
  }), targetAxisInfo.length ? targetAxisInfo : null;
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/util/common.js
function isXAxis(orient) {
  return "bottom" === orient || "top" === orient;
}
function isYAxis(orient) {
  return "left" === orient || "right" === orient;
}
function isZAxis(orient) {
  return "z" === orient;
}
function autoAxisType(orient, isHorizontal4) {
  return isHorizontal4 ? isXAxis(orient) ? "linear" : "band" : isXAxis(orient) ? "band" : "linear";
}
function getOrient(spec, whiteList) {
  return isValidOrient(spec.orient) || whiteList && whiteList.includes(spec.orient) ? spec.orient : "left";
}
function getDirectionByOrient(orient) {
  return "top" === orient || "bottom" === orient ? "horizontal" : "vertical";
}
function transformInverse(spec, isHorizontal4) {
  let inverse = spec.inverse;
  return isHorizontal4 && !isXAxis(spec.orient) && (inverse = !isValid_default(spec.inverse) || !spec.inverse), inverse;
}
function getCartesianAxisInfo(spec, isHorizontal4) {
  var _a;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : autoAxisType(spec.orient, isHorizontal4);
  return {
    axisType,
    componentName: `${ComponentTypeEnum.cartesianAxis}-${axisType}`
  };
}

// node_modules/@visactor/vchart/esm/event/events/dimension/util/cartesian.js
var discreteXAxisGetDimensionField = (series2) => series2.fieldX[0];
var discreteYAxisGetDimensionField = (series2) => series2.fieldY[0];
var continuousXAxisGetDimensionField = (series2) => [series2.fieldX[0], series2.fieldX2];
var continuousYAxisGetDimensionField = (series2) => [series2.fieldY[0], series2.fieldY2];
var getCartesianDimensionInfo = (chart, pos) => {
  var _a, _b;
  if (!chart) return null;
  if (!getFirstSeries(chart.getRegionsInIndex(), "cartesian")) return null;
  const { x: x3, y: y3 } = pos, xAxisList = null !== (_a = getAxis(chart, (cmp) => isXAxis(cmp.getOrient()), pos)) && void 0 !== _a ? _a : [], yAxisList = null !== (_b = getAxis(chart, (cmp) => isYAxis(cmp.getOrient()), pos)) && void 0 !== _b ? _b : [], bandAxisSet = /* @__PURE__ */ new Set(), linearAxisSet = /* @__PURE__ */ new Set();
  [xAxisList, yAxisList].forEach((axisList) => axisList.forEach((axis2) => {
    isDiscrete(axis2.getScale().type) ? bandAxisSet.add(axis2) : linearAxisSet.add(axis2);
  }));
  const targetAxisInfo = [], addAxisDimensionInfo = (orient, isDiscrete2) => {
    ("x" === orient ? xAxisList : yAxisList).forEach((axis2) => {
      if ((isDiscrete2 ? bandAxisSet : linearAxisSet).has(axis2)) {
        const info = getDimensionInfoByPosition(axis2, "x" === orient ? x3 : y3, orient, "x" === orient ? isDiscrete2 ? discreteXAxisGetDimensionField : continuousXAxisGetDimensionField : isDiscrete2 ? discreteYAxisGetDimensionField : continuousYAxisGetDimensionField);
        info && targetAxisInfo.push(info);
      }
    });
  };
  return "horizontal" === chart.getSpec().direction ? (addAxisDimensionInfo("y", bandAxisSet.size > 0), 0 === targetAxisInfo.length && addAxisDimensionInfo("x", bandAxisSet.size > 0)) : (addAxisDimensionInfo("x", bandAxisSet.size > 0), 0 === targetAxisInfo.length && addAxisDimensionInfo("y", bandAxisSet.size > 0)), targetAxisInfo.length ? targetAxisInfo : null;
};
var getDimensionInfoByPosition = (axis2, posValue, posKey, getDimensionField) => {
  const scale4 = axis2.getScale(), scalePos = posValue - axis2.getLayoutStartPoint()[posKey];
  if ((scalePos - scale4.range()[0]) * (scalePos - scale4.range()[1]) > 0) return null;
  const value = scale4.invert(scalePos);
  return getDimensionInfoByValue(axis2, value, getDimensionField);
};
var getDimensionInfoByValue = (axis2, value, getDimensionField) => {
  const scale4 = axis2.getScale();
  if (isNil_default(value)) return null;
  let index = scale4.domain().findIndex((v2) => (null == v2 ? void 0 : v2.toString()) === value.toString());
  index < 0 && (index = void 0);
  const data = getDimensionData(value, axis2, "cartesian", null != getDimensionField ? getDimensionField : isXAxis(axis2.getOrient()) ? discreteXAxisGetDimensionField : discreteYAxisGetDimensionField);
  return {
    index,
    value,
    axis: axis2,
    data
  };
};

// node_modules/@visactor/vchart/esm/event/events/dimension/base.js
var DimensionEvent = class {
  constructor(eventDispatcher, mode2) {
    this._eventDispatcher = eventDispatcher, this._mode = mode2;
  }
  get chart() {
    var _a, _b;
    return this._chart || (this._chart = null === (_b = (_a = this._eventDispatcher.globalInstance).getChart) || void 0 === _b ? void 0 : _b.call(_a)), this._chart;
  }
  register(eType, handler) {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  unregister() {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  getTargetDimensionInfo(x3, y3) {
    var _a, _b;
    const cartesianInfo = null !== (_a = getCartesianDimensionInfo(this.chart, {
      x: x3,
      y: y3
    })) && void 0 !== _a ? _a : [], polarInfo = null !== (_b = getPolarDimensionInfo(this.chart, {
      x: x3,
      y: y3
    })) && void 0 !== _b ? _b : [], result2 = [].concat(cartesianInfo, polarInfo);
    return 0 === result2.length ? null : result2;
  }
  dispatch(v2, opt) {
    var _a;
    const axis2 = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c4) => {
      if ("axes" !== c4.specKey) return false;
      const scale4 = c4.getScale();
      return !!isDiscrete(scale4.type) && (!(null == opt ? void 0 : opt.filter) || opt.filter(c4));
    }), dimensionInfo = [];
    return axis2.forEach((a4) => {
      const info = getDimensionInfoByValue(a4, v2);
      info && dimensionInfo.push(info);
    }), this._callback.call(null, {
      action: "enter",
      dimensionInfo
    }), dimensionInfo;
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/dimension-click.js
var DimensionClickEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this.onClick = (params2) => {
      if (!params2) return;
      const x3 = params2.event.viewX, y3 = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x3, y3);
      targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "click",
        dimensionInfo: targetDimensionInfo.slice()
      }));
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointertap", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onClick
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointertap", {
      query: null,
      callback: this.onClick
    });
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/dimension-hover.js
var DimensionHoverEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this._cacheDimensionInfo = null, this.onMouseMove = (params2) => {
      if (!params2) return;
      const x3 = params2.event.viewX, y3 = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x3, y3);
      null === targetDimensionInfo && null !== this._cacheDimensionInfo ? (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo) : null === targetDimensionInfo || null !== this._cacheDimensionInfo && targetDimensionInfo.length === this._cacheDimensionInfo.length && !targetDimensionInfo.some((info, i2) => !isSameDimensionInfo(info, this._cacheDimensionInfo[i2])) ? null !== targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "move",
        dimensionInfo: targetDimensionInfo.slice()
      })) : (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "enter",
        dimensionInfo: targetDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo);
    }, this.onMouseOut = (params2) => {
      params2 && (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo ? this._cacheDimensionInfo.slice() : []
      })), this._cacheDimensionInfo = null);
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointermove", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    }), this._eventDispatcher.register("pointerout", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.canvas
      }),
      callback: this.onMouseOut
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.register("pointerdown", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointermove", {
      query: null,
      callback: this.onMouseMove
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.unregister("pointerdown", {
      query: null,
      callback: this.onMouseMove
    });
  }
};

// node_modules/@visactor/vchart/esm/event/events/dimension/interface.js
var DimensionEventEnum;
!function(DimensionEventEnum2) {
  DimensionEventEnum2.dimensionHover = "dimensionHover", DimensionEventEnum2.dimensionClick = "dimensionClick";
}(DimensionEventEnum || (DimensionEventEnum = {}));

// node_modules/@visactor/vchart/esm/event/events/index.js
var ComposedEventMapper = {
  [DimensionEventEnum.dimensionHover]: DimensionHoverEvent,
  [DimensionEventEnum.dimensionClick]: DimensionClickEvent
};

// node_modules/@visactor/vchart/esm/event/event.js
var Event2 = class {
  getComposedEventMap() {
    return this._composedEventMap;
  }
  constructor(eventDispatcher, mode2) {
    this._composedEventMap = /* @__PURE__ */ new Map(), this._eventDispatcher = eventDispatcher, this._mode = mode2;
  }
  on(eType, query, callback) {
    const handler = "function" == typeof query ? {
      query: null,
      callback: query
    } : {
      query,
      callback
    };
    if (ComposedEventMapper[eType]) {
      const composedEvent = new ComposedEventMapper[eType](this._eventDispatcher, this._mode);
      composedEvent.register(eType, handler), this._composedEventMap.set(callback, {
        eventType: eType,
        event: composedEvent
      });
    } else this._eventDispatcher.register(eType, handler);
    return this;
  }
  off(eType, query, cb) {
    var _a, _b;
    const callback = null != cb ? cb : query;
    if (ComposedEventMapper[eType]) if (callback) null === (_a = this._composedEventMap.get(callback)) || void 0 === _a || _a.event.unregister(), this._composedEventMap.delete(callback);
    else for (const entry of this._composedEventMap.entries()) entry[1].eventType === eType && (null === (_b = this._composedEventMap.get(entry[0])) || void 0 === _b || _b.event.unregister(), this._composedEventMap.delete(entry[0]));
    else if (callback) {
      const handler = {
        callback,
        query: null,
        filter: {
          nodeName: null,
          type: eType,
          level: null,
          source: query.source,
          markName: null,
          filter: null,
          userId: null
        }
      };
      this._eventDispatcher.unregister(eType, handler);
    } else this._eventDispatcher.unregister(eType);
    return this;
  }
  emit(eType, params2, level) {
    return this._eventDispatcher.dispatch(eType, params2, level), this;
  }
  release() {
    this._eventDispatcher.release(), this._composedEventMap.clear();
  }
};

// node_modules/@visactor/vchart/esm/event/bubble.js
var Bubble = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._levelNodes = /* @__PURE__ */ new Map(), this._levelNodes.set(Event_Bubble_Level.vchart, []), this._levelNodes.set(Event_Bubble_Level.chart, []), this._levelNodes.set(Event_Bubble_Level.model, []), this._levelNodes.set(Event_Bubble_Level.mark, []);
  }
  addHandler(handler, level) {
    var _a;
    const node = {
      level,
      handler
    };
    return null === (_a = this._levelNodes.get(level)) || void 0 === _a || _a.push(node), this._map.set(handler.callback, node), this;
  }
  removeHandler(handler) {
    const node = this._map.get(handler.callback);
    if (!node) return this;
    this._map.delete(handler.callback);
    const nodes = this._levelNodes.get(node.level), index = null == nodes ? void 0 : nodes.findIndex((n2) => n2.handler.callback === handler.callback);
    return void 0 !== index && index >= 0 && (null == nodes || nodes.splice(index, 1)), this;
  }
  getHandlers(level) {
    var _a;
    return (null === (_a = this._levelNodes.get(level)) || void 0 === _a ? void 0 : _a.map((node) => node.handler)) || [];
  }
  getCount() {
    return this._map.size;
  }
  release() {
    this._map.clear(), this._levelNodes.clear();
  }
};

// node_modules/@visactor/vchart/esm/event/event-dispatcher.js
var componentTypeMap = {
  cartesianAxis: "axis",
  "cartesianAxis-band": "axis",
  "cartesianAxis-linear": "axis",
  "cartesianAxis-time": "axis",
  polarAxis: "axis",
  "polarAxis-band": "axis",
  "polarAxis-linear": "axis",
  discreteLegend: "legend",
  continuousLegend: "legend",
  colorLegend: "legend",
  sizeLegend: "legend",
  label: "label"
};
var EventDispatcher = class {
  constructor(vchart, compiler) {
    this._viewBubbles = /* @__PURE__ */ new Map(), this._windowBubbles = /* @__PURE__ */ new Map(), this._canvasBubbles = /* @__PURE__ */ new Map(), this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this.globalInstance = vchart, this._compiler = compiler;
  }
  register(eType, handler) {
    var _a, _b, _c, _d;
    this._parseQuery(handler);
    const bubbles = this.getEventBubble((null === (_a = handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    bubbles.get(eType) || bubbles.set(eType, new Bubble());
    if (bubbles.get(eType).addHandler(handler, null === (_c = handler.filter) || void 0 === _c ? void 0 : _c.level), this._isValidEvent(eType) && !listeners.has(eType)) {
      const callback = this._onDelegate.bind(this);
      this._compiler.addEventListener(null === (_d = handler.filter) || void 0 === _d ? void 0 : _d.source, eType, callback), listeners.set(eType, callback);
    }
    return this;
  }
  unregister(eType, handler) {
    var _a, _b, _c, _d;
    let clean = false;
    const bubbles = this.getEventBubble((null === (_a = null == handler ? void 0 : handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = null == handler ? void 0 : handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    if (handler) {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.removeHandler(handler), 0 === (null == bubble ? void 0 : bubble.getCount()) && (null == bubble || bubble.release(), bubbles.delete(eType), clean = true), (null === (_c = null == handler ? void 0 : handler.wrappedCallback) || void 0 === _c ? void 0 : _c.cancel) && handler.wrappedCallback.cancel();
    } else {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.release(), bubbles.delete(eType), clean = true;
    }
    if (clean && this._isValidEvent(eType)) {
      const callback = listeners.get(eType);
      this._compiler.removeEventListener((null === (_d = null == handler ? void 0 : handler.filter) || void 0 === _d ? void 0 : _d.source) || Event_Source_Type.chart, eType, callback), listeners.delete(eType);
    }
    return this;
  }
  dispatch(eType, params2, level) {
    const bubble = this.getEventBubble(params2.source || Event_Source_Type.chart).get(eType);
    if (!bubble) return this;
    let stopBubble = false;
    if (level) {
      const handlers = bubble.getHandlers(level);
      stopBubble = this._invoke(handlers, eType, params2);
    } else {
      const handlers = bubble.getHandlers(Event_Bubble_Level.mark);
      if (stopBubble = this._invoke(handlers, eType, params2), !stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.model);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
      if (!stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.chart);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
      if (!stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.vchart);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
    }
    return this;
  }
  release() {
    for (const entry of this._viewListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.chart, entry[0], entry[1]);
    this._viewListeners.clear();
    for (const entry of this._windowListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.window, entry[0], entry[1]);
    this._windowListeners.clear();
    for (const entry of this._canvasListeners.entries()) this._compiler.removeEventListener(Event_Source_Type.canvas, entry[0], entry[1]);
    this._canvasListeners.clear();
    for (const bubble of this._viewBubbles.values()) bubble.release();
    this._viewBubbles.clear();
    for (const bubble of this._windowBubbles.values()) bubble.release();
    this._windowBubbles.clear();
    for (const bubble of this._canvasBubbles.values()) bubble.release();
    this._canvasBubbles.clear();
  }
  _filter(filter2, evt, params2) {
    var _a, _b, _c;
    if (isFunction_default(filter2.filter) && !filter2.filter(params2)) return false;
    if (filter2.nodeName && get_default(params2, "node.name") !== filter2.nodeName) return false;
    if (filter2.markName && (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name) !== filter2.markName) return false;
    let modelType = null === (_b = params2.model) || void 0 === _b ? void 0 : _b.type;
    return componentTypeMap[modelType] && (modelType = componentTypeMap[modelType]), (!filter2.type || modelType === filter2.type) && (!("mark" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.mark)) && (!("model" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.model)) && (!isValid_default(filter2.userId) || (null === (_c = params2.model) || void 0 === _c ? void 0 : _c.userId) === filter2.userId)));
  }
  _prepareParams(filter2, params2) {
    if (filter2.markName && params2.mark && params2.itemMap) {
      const markId = params2.mark.getProductId(), item = params2.itemMap.get(markId), datum = null == item ? void 0 : item.getDatum();
      return Object.assign(Object.assign({}, params2), {
        item,
        datum
      });
    }
    return Object.assign({}, params2);
  }
  _onDelegate(listenerParams) {
    var _a;
    const chart = this.globalInstance.getChart(), model = isValid_default(listenerParams.modelId) && (null == chart ? void 0 : chart.getModelById(listenerParams.modelId)) || void 0, mark = isValid_default(listenerParams.markId) && (null == chart ? void 0 : chart.getMarkById(listenerParams.markId)) || null, itemMap = /* @__PURE__ */ new Map();
    let targetMark = null === (_a = listenerParams.item) || void 0 === _a ? void 0 : _a.mark;
    for (targetMark && isValid_default(targetMark.id()) && itemMap.set(targetMark.id(), listenerParams.item); null == targetMark ? void 0 : targetMark.elements; ) {
      const id2 = targetMark.id();
      isValid_default(id2) && !itemMap.has(id2) && itemMap.set(id2, targetMark.elements[0]), targetMark = targetMark.group;
    }
    const params2 = {
      event: listenerParams.event,
      item: listenerParams.item,
      datum: listenerParams.datum,
      source: listenerParams.source,
      itemMap,
      chart,
      model,
      mark: null != mark ? mark : void 0,
      node: get_default(listenerParams.event, "target")
    };
    this.dispatch(listenerParams.type, params2);
  }
  _invoke(handlers, type, params2) {
    return handlers.map((handler) => {
      var _a, _b, _c;
      const filter2 = handler.filter;
      if (!handler.query || this._filter(filter2, type, params2)) {
        const stopBubble = (handler.wrappedCallback || handler.callback).call(null, this._prepareParams(filter2, params2)), doStopBubble = null != stopBubble ? stopBubble : null === (_a = handler.query) || void 0 === _a ? void 0 : _a.consume;
        return doStopBubble && (null === (_b = params2.event) || void 0 === _b || _b.stopPropagation(), null === (_c = params2.event) || void 0 === _c || _c.preventDefault()), !!doStopBubble;
      }
    }).some((r2) => true === r2);
  }
  _getQueryLevel(query) {
    return query ? query.level ? query.level : isValid_default(query.id) ? Event_Bubble_Level.model : Event_Bubble_Level.vchart : Event_Bubble_Level.vchart;
  }
  _parseQuery(handler) {
    var _a;
    const query = handler.query;
    (null == query ? void 0 : query.throttle) ? handler.wrappedCallback = throttle_default(handler.callback, query.throttle) : (null == query ? void 0 : query.debounce) && (handler.wrappedCallback = debounce_default(handler.callback, query.debounce));
    let level = this._getQueryLevel(query), type = null, source = Event_Source_Type.chart, nodeName = null, markName = null, userId = null;
    return (null == query ? void 0 : query.nodeName) && (nodeName = query.nodeName), (null == query ? void 0 : query.markName) && (markName = query.markName), !(null == query ? void 0 : query.type) || level !== Event_Bubble_Level.model && level !== Event_Bubble_Level.mark || (type = query.type), (null == query ? void 0 : query.source) && (source = query.source), isValid_default(null == query ? void 0 : query.id) && (userId = null == query ? void 0 : query.id, level = Event_Bubble_Level.model), handler.filter = {
      level,
      markName,
      type,
      source,
      nodeName,
      userId,
      filter: null !== (_a = null == query ? void 0 : query.filter) && void 0 !== _a ? _a : null
    }, handler;
  }
  getEventBubble(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewBubbles;
      case Event_Source_Type.window:
        return this._windowBubbles;
      case Event_Source_Type.canvas:
        return this._canvasBubbles;
      default:
        return this._viewBubbles;
    }
  }
  getEventListeners(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewListeners;
      case Event_Source_Type.window:
        return this._windowListeners;
      case Event_Source_Type.canvas:
        return this._canvasListeners;
      default:
        return this._viewListeners;
    }
  }
  _isValidEvent(eType) {
    return BASE_EVENTS.includes(eType) || Object.values(HOOK_EVENT).includes(eType) || Object.values(ChartEvent).includes(eType);
  }
};

// node_modules/@visactor/vchart/esm/data/register.js
function registerDataSetInstanceTransform(dataSet, name, transform29) {
  dataSet.getTransform(name) || dataSet.registerTransform(name, transform29);
}
function registerDataSetInstanceParser(dataSet, name, parse2) {
  dataSet.getParser(name) || dataSet.registerParser(name, parse2);
}

// node_modules/@visactor/vchart/esm/series/map/geo-source.js
var geoSourceMap = /* @__PURE__ */ new Map();
var mapDataSet;
function initMapDataSet() {
  mapDataSet || (mapDataSet = new DataSet(), registerDataSetInstanceParser(mapDataSet, "geojson", geoJSONParser), registerDataSetInstanceParser(mapDataSet, "topojson", topoJSONParser), registerDataSetInstanceTransform(mapDataSet, "simplify", simplify));
}
function registerMapSource(key, source, option = {
  type: "geojson",
  centroid: true
}) {
  geoSourceMap.has(key) && warn(`map type of '${key}' already exists, will be overwritten.`), initMapDataSet();
  const dataView = new DataView(mapDataSet), options = merge({}, {
    centroid: true,
    simplify: false
  }, option);
  "topojson" === option.type ? dataView.parse(source, {
    type: "topojson",
    options
  }) : dataView.parse(source, {
    type: "geojson",
    options
  }), true === option.simplify && dataView.transform({
    type: "simplify"
  }), geoSourceMap.set(key, dataView);
}
function unregisterMapSource(key) {
  geoSourceMap.has(key) ? geoSourceMap.delete(key) : warn(`map type of '${key}' does not exists.`);
}
function getMapSource(type) {
  return geoSourceMap.get(type);
}

// node_modules/@visactor/vchart/esm/data/transforms/copy-data-view.js
function copyOneDataView(d2, deep = false) {
  let _deep = deep;
  return d2.latestData instanceof DataView && (_deep = false), _deep ? cloneDeep(d2.latestData) : d2.latestData.slice();
}
var copyDataView = (data, options) => 0 === data.length ? [] : 1 === data.length ? copyOneDataView(data[0], null == options ? void 0 : options.deep) : data.map((d2) => copyOneDataView(d2, null == options ? void 0 : options.deep));

// node_modules/@visactor/vchart/esm/data/initialize.js
function dataViewFromDataView(rawData, dataSet, op) {
  dataSet = dataSet instanceof DataSet ? dataSet : rawData.dataSet, registerDataSetInstanceTransform(dataSet, "copyDataView", copyDataView);
  const viewData = new DataView(dataSet, op);
  return viewData.parse([rawData], {
    type: "dataview"
  }), viewData.transform({
    type: "copyDataView",
    level: TransformLevel.copyDataView
  }), viewData;
}
function dataToDataView(data, dataSet, sourceDataViews = [], ctx = {}) {
  var _a, _b, _c;
  if (data instanceof DataView) return data;
  const { id: id2, values = [], fromDataIndex, fromDataId, transforms = [] } = data, parser = data.parser ? cloneDeep(data.parser) : {
    clone: true
  }, fields2 = cloneDeep(data.fields);
  let dataView;
  parser.clone = !(false === parser.clone);
  const existDataView = sourceDataViews.find((dv) => dv.name === id2);
  if (existDataView) dataView = existDataView;
  else {
    const initOption = {
      name: id2
    };
    if (fields2 && (initOption.fields = fields2), dataView = new DataView(dataSet, initOption), "string" == typeof fromDataId) {
      const fromDataView = sourceDataViews.find((dv) => dv.name === fromDataId);
      if (!fromDataView) return (null !== (_a = ctx.onError) && void 0 !== _a ? _a : error)(`no data matches fromDataId ${fromDataId}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else if ("number" == typeof fromDataIndex) {
      const fromDataView = sourceDataViews[fromDataIndex];
      if (!fromDataView) return (null !== (_b = ctx.onError) && void 0 !== _b ? _b : error)(`no data matches fromDataIndex ${fromDataIndex}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else Array.isArray(values) ? dataView.parse(values, parser) : !isString_default(values) || parser && !["csv", "dsv", "tsv"].includes(parser.type) ? (dataView.parse([]), warn("values should be array")) : dataView.parse(values, null !== (_c = parser) && void 0 !== _c ? _c : {
      type: "csv"
    });
    transforms && transforms.length && transforms.forEach((transform29) => {
      dataSet.getTransform(transform29.type) && dataView.transform(transform29);
    });
  }
  return dataView;
}
function updateDataViewInData(dataView, data, forceMerge) {
  dataView && (data.fields && dataView.setFields(data.fields, forceMerge), dataView.parseNewData(data.values, data.parser));
}
var TransformLevel;
!function(TransformLevel2) {
  TransformLevel2[TransformLevel2.copyDataView = -10] = "copyDataView", TransformLevel2[TransformLevel2.treemapFilter = -8] = "treemapFilter", TransformLevel2[TransformLevel2.treemapFlatten = -7] = "treemapFlatten", TransformLevel2[TransformLevel2.dotObjFlat = -7] = "dotObjFlat", TransformLevel2[TransformLevel2.linkDotInfo = -7] = "linkDotInfo", TransformLevel2[TransformLevel2.sankeyLayout = -7] = "sankeyLayout", TransformLevel2[TransformLevel2.dataZoomFilter = -6] = "dataZoomFilter", TransformLevel2[TransformLevel2.legendFilter = -5] = "legendFilter";
}(TransformLevel || (TransformLevel = {}));

// node_modules/@visactor/vchart/esm/data/transforms/stack-split.js
var stackSplit = (data, op) => {
  const result2 = {
    nodes: {}
  }, { fields: fields2 } = op;
  if (!(null == fields2 ? void 0 : fields2.length)) return result2;
  const lastFieldIndex = fields2.length - 1;
  let nextNode, leaf, temp3 = result2;
  return data.forEach((dv) => {
    dv.latestData.forEach((d2) => {
      temp3 = result2;
      for (let i2 = 0; i2 < fields2.length; i2++) {
        const fV = d2[fields2[i2]];
        if (isNil_default(fV)) break;
        temp3.nodes[fV] || (i2 === lastFieldIndex ? temp3.nodes[fV] = {
          values: []
        } : (nextNode = {
          nodes: {}
        }, temp3.nodes[fV] = nextNode)), i2 === lastFieldIndex ? (leaf = temp3.nodes[fV], leaf.values.push(d2)) : temp3 = temp3.nodes[fV];
      }
    });
  }), result2;
};

// node_modules/@visactor/vchart/esm/animation/interface.js
var AnimationStateEnum;
!function(AnimationStateEnum2) {
  AnimationStateEnum2.appear = "appear", AnimationStateEnum2.disappear = "disappear", AnimationStateEnum2.enter = "enter", AnimationStateEnum2.update = "update", AnimationStateEnum2.state = "state", AnimationStateEnum2.exit = "exit", AnimationStateEnum2.normal = "normal", AnimationStateEnum2.none = "none";
}(AnimationStateEnum || (AnimationStateEnum = {}));

// node_modules/@visactor/vchart/esm/compile/interface/compilable-item.js
var GrammarType;
!function(GrammarType2) {
  GrammarType2.data = "data", GrammarType2.signal = "signal", GrammarType2.mark = "mark";
}(GrammarType || (GrammarType = {}));

// node_modules/@visactor/vchart/esm/compile/util.js
function toRenderMode(mode2) {
  switch (mode2) {
    case RenderModeEnum["desktop-browser"]:
    case RenderModeEnum["mobile-browser"]:
      return "browser";
    case RenderModeEnum.node:
    case RenderModeEnum.worker:
      return "node";
    case RenderModeEnum.miniApp:
    case RenderModeEnum["desktop-miniApp"]:
      return "feishu";
    case RenderModeEnum.lynx:
      return "lynx";
    case RenderModeEnum.wx:
      return "wx";
  }
  return "browser";
}

// node_modules/@visactor/vchart/esm/compile/compiler.js
var __awaiter13 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Compiler = class {
  getVGrammarView() {
    return this._view;
  }
  getModel() {
    return this._model;
  }
  constructor(container2, option) {
    this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this.isInited = false, this.isReleased = false, this._model = {
      [GrammarType.signal]: {},
      [GrammarType.data]: {},
      [GrammarType.mark]: {}
    }, this._compileChart = null, this._container = container2, this._option = option;
  }
  getRenderer() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer;
  }
  getCanvas() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.canvas();
  }
  getStage() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.stage();
  }
  initView() {
    var _a, _b, _c, _d;
    if (this.isReleased) return;
    if (this.isInited = true, this._view) return;
    const logger = new Logger(null !== (_a = this._option.logLevel) && void 0 !== _a ? _a : LoggerLevel.Error);
    (null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError) && logger.addErrorHandler((...args) => {
      var _a2, _b2;
      null === (_b2 = null === (_a2 = this._option) || void 0 === _a2 ? void 0 : _a2.onError) || void 0 === _b2 || _b2.call(_a2, ...args);
    }), this._view = new View(Object.assign(Object.assign({
      width: this._width,
      height: this._height,
      container: null !== (_c = this._container.dom) && void 0 !== _c ? _c : null,
      renderCanvas: null !== (_d = this._container.canvas) && void 0 !== _d ? _d : null,
      hooks: this._option.performanceHook
    }, this._option), {
      mode: toRenderMode(this._option.mode),
      autoFit: false,
      eventConfig: {
        gesture: isMobileLikeMode(this._option.mode),
        disable: false === this._option.interactive
      },
      doLayout: () => {
        var _a2;
        null === (_a2 = this._compileChart) || void 0 === _a2 || _a2.onLayout(this._view);
      },
      logger,
      logLevel: logger.level()
    })), this._setCanvasStyle(), this.getStage().hooks.afterRender.tap("chart-event", () => {
      var _a2, _b2;
      null === (_b2 = null === (_a2 = this._compileChart) || void 0 === _a2 ? void 0 : _a2.getEvent()) || void 0 === _b2 || _b2.emit(ChartEvent.afterRender, {
        chart: this._compileChart
      });
    });
    false !== this._option.interactive && this._viewListeners.forEach((listener) => {
      var _a2;
      null === (_a2 = this._view) || void 0 === _a2 || _a2.addEventListener(listener.type, listener.callback);
    });
  }
  _setCanvasStyle() {
    if (this._view && this._container.dom && !isString_default(this._container.dom)) {
      this._container.dom.style.display = "block", this._container.dom.style.position = "relative";
      const canvas = this.getCanvas();
      canvas && (canvas.style.display = "block");
    }
  }
  compile(ctx, option) {
    const { chart } = ctx;
    this._compileChart = chart, this.initView(), this._view && (chart.compile(), chart.afterCompile(), this.updateDepend());
  }
  clear(ctx, removeGraphicItems = false) {
    const { chart } = ctx;
    chart.clear(), this.releaseGrammar(removeGraphicItems);
  }
  renderAsync(morphConfig) {
    var _a;
    return __awaiter13(this, void 0, void 0, function* () {
      if (!this.isReleased) return this.initView(), this._view ? (yield null === (_a = this._view) || void 0 === _a ? void 0 : _a.runNextTick(morphConfig), this) : Promise.reject("srView init fail");
    });
  }
  renderSync(morphConfig) {
    var _a;
    this.initView(), this._view && (null === (_a = this._view) || void 0 === _a || _a.runSync(morphConfig));
  }
  updateViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  resize(width, height, reRender = true) {
    return this._view ? (this._width = width, this._height = height, this._view.resize(width, height), reRender ? this.renderAsync({
      morph: false
    }) : this) : Promise.reject();
  }
  setBackground(color) {
    var _a;
    null === (_a = this._view) || void 0 === _a || _a.background(color);
  }
  setSize(width, height) {
    this._width = width, this._height = height, this._view && (this._view.width(width), this._view.height(height));
  }
  setViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  addEventListener(source, type, callback) {
    var _a, _b;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = (function(event, element) {
          var _a2, _b2, _c;
          const context = null !== (_b2 = null === (_a2 = null == element ? void 0 : element.mark) || void 0 === _a2 ? void 0 : _a2.getContext()) && void 0 !== _b2 ? _b2 : {}, modelId = isValid_default(context.modelId) ? context.modelId : null, markId = isValid_default(context.markId) ? context.markId : null, modelUserId = isValid_default(context.modelUserId) ? context.modelUserId : null, markUserId = isValid_default(context.markUserId) ? context.markUserId : null, params2 = {
            event,
            type,
            source,
            item: element,
            datum: (null === (_c = null == element ? void 0 : element.getDatum) || void 0 === _c ? void 0 : _c.call(element)) || null,
            markId,
            modelId,
            markUserId,
            modelUserId
          };
          callback.call(null, params2);
        }).bind(this);
        this._viewListeners.set(callback, {
          type,
          callback: wrappedCallback
        }), null === (_a = this._view) || void 0 === _a || _a.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.window) {
        const wrappedCallback = (function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }).bind(this);
        this._windowListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const windowObject = this._getGlobalThis();
        null == windowObject || windowObject.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.canvas) {
        const wrappedCallback = (function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }).bind(this);
        this._canvasListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const canvasObject = null === (_b = this.getStage()) || void 0 === _b ? void 0 : _b.window;
        null == canvasObject || canvasObject.addEventListener(type, wrappedCallback);
      }
    }
  }
  removeEventListener(source, type, callback) {
    var _a, _b, _c, _d;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = null === (_a = this._viewListeners.get(callback)) || void 0 === _a ? void 0 : _a.callback;
        wrappedCallback && (null === (_b = this._view) || void 0 === _b || _b.removeEventListener(type, wrappedCallback)), this._viewListeners.delete(callback);
      } else if (source === Event_Source_Type.window) {
        const windowObject = this._getGlobalThis(), wrappedCallback = null === (_c = this._windowListeners.get(callback)) || void 0 === _c ? void 0 : _c.callback;
        wrappedCallback && (null == windowObject || windowObject.removeEventListener(type, wrappedCallback)), this._windowListeners.delete(callback);
      } else if (source === Event_Source_Type.canvas) {
        const canvasObject = this._getGlobalThis(), wrappedCallback = null === (_d = this._canvasListeners.get(callback)) || void 0 === _d ? void 0 : _d.callback;
        wrappedCallback && (null == canvasObject || canvasObject.removeEventListener(type, wrappedCallback)), this._canvasListeners.delete(callback);
      }
    }
  }
  releaseEvent() {
    this._viewListeners.clear(), this._windowListeners.clear(), this._canvasListeners.clear();
  }
  release() {
    var _a;
    this.releaseEvent(), this._option = this._container = null, this._releaseModel(), null === (_a = this._view) || void 0 === _a || _a.release(), this._view = null, this.isInited = false, this.isReleased = true;
  }
  releaseGrammar(removeGraphicItems = false) {
    var _a, _b;
    this._releaseModel(), removeGraphicItems && (null === (_a = this._view) || void 0 === _a || _a.removeAllGraphicItems()), null === (_b = this._view) || void 0 === _b || _b.removeAllGrammars();
  }
  _releaseModel() {
    Object.keys(this._model).forEach((type) => {
      Object.values(this._model[type]).forEach((grammarItemMap) => {
        Object.values(grammarItemMap).forEach((item) => {
          item.removeProduct(true);
        });
      }), this._model[type] = {};
    });
  }
  addGrammarItem(grammarItem) {
    const product2 = grammarItem.getProduct();
    if (isNil_default(product2)) return;
    const id2 = product2.id(), type = grammarItem.grammarType;
    isNil_default(this._model[type][id2]) && (this._model[type][id2] = {}), this._model[type][id2][grammarItem.id] = grammarItem;
  }
  removeGrammarItem(grammarItem, reserveVGrammarModel) {
    var _a;
    const product2 = grammarItem.getProduct();
    if (isNil_default(product2)) return;
    const id2 = product2.id(), type = grammarItem.grammarType, map4 = this._model[type][id2];
    isValid_default(map4) && (delete map4[grammarItem.id], 0 === Object.keys(map4).length && delete this._model[type][id2]), reserveVGrammarModel || null === (_a = this._view) || void 0 === _a || _a.removeGrammar(product2);
  }
  updateDepend(items) {
    return isValid_default(items) && items.length > 0 ? items.every((item) => item.updateDepend()) : (Object.values(this._model).forEach((productMap) => {
      Object.values(productMap).forEach((grammarItemMap) => {
        const grammarItems = Object.values(grammarItemMap), product2 = grammarItems[0].getProduct(), dependList = grammarItems.reduce((depend, item) => item.getDepend().length > 0 ? depend.concat(item.getDepend()) : depend, []).filter((grammarItem) => !!grammarItem).map((grammarItem) => grammarItem.getProduct());
        product2.depend(dependList);
      });
    }), true);
  }
  _getGlobalThis() {
    var _a;
    return isTrueBrowser(this._option.mode) ? globalThis : null === (_a = this.getStage()) || void 0 === _a ? void 0 : _a.window;
  }
};

// node_modules/@visactor/vchart/esm/util/image.js
var __awaiter14 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function URLToImage(name = "vchart", url) {
  const link3 = document.createElement("a");
  link3.setAttribute("href", url), link3.setAttribute("target", "_blank"), link3.setAttribute("download", `${name}.png`), link3.dispatchEvent(new MouseEvent("click"));
}
function OffscreenCanvasToDataURL(c4) {
  return new Promise((r2) => {
    c4.convertToBlob().then((b2) => {
      const reader = new FileReader();
      reader.readAsDataURL(b2), reader.onload = () => {
        r2(reader.result);
      };
    });
  });
}
function getCanvasDataURL(c4, ctx) {
  var _a;
  return __awaiter14(this, void 0, void 0, function* () {
    if (!c4) return "";
    try {
      if (void 0 !== OffscreenCanvas && c4 instanceof OffscreenCanvas) return OffscreenCanvasToDataURL(c4);
    } catch (_error) {
      (null !== (_a = null == ctx ? void 0 : ctx.onError) && void 0 !== _a ? _a : error)(`getCanvasDataURL error : ${_error.toString()}`);
    }
    return c4.toDataURL();
  });
}

// node_modules/@visactor/vchart/esm/chart/util.js
function setDefaultCrosshairForCartesianChart(spec) {
  spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
    ["horizontal" === spec.direction ? "yField" : "xField"]: {
      visible: true,
      line: {
        visible: true,
        type: "rect"
      }
    }
  }, crosshairCfg));
}
function calculateChartSize(spec, option, defaultSize) {
  var _a;
  const { width: userWidth, height: userHeight } = spec;
  if (isValid_default(userWidth) && isValid_default(userHeight)) return {
    width: userWidth,
    height: userHeight
  };
  let width = defaultSize.width, height = defaultSize.height;
  const container2 = option.container, canvas = option.canvas;
  if (container2) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container2, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (canvas && isTrueBrowser(option.mode)) {
    let canvasNode;
    canvasNode = isString_default(canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(canvas) : canvas;
    const { width: containerWidth, height: containerHeight } = getContainerSize(canvasNode, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (isMiniAppLikeMode(option.mode) && (null === (_a = option.modeParams) || void 0 === _a ? void 0 : _a.domref)) {
    const domRef = option.modeParams.domref;
    width = domRef.width, height = domRef.height;
  }
  return width = null != userWidth ? userWidth : width, height = null != userHeight ? userHeight : height, {
    width,
    height
  };
}
function mergeUpdateResult(target, ...sources) {
  const merge2 = (key) => sources.reduce((value, cur) => value || (null == cur ? void 0 : cur[key]), target[key]);
  return Object.assign(target, {
    change: merge2("change"),
    reCompile: merge2("reCompile"),
    reMake: merge2("reMake"),
    reRender: merge2("reRender"),
    reSize: merge2("reSize")
  }), target;
}
function getTrimPaddingConfig(chartType, spec) {
  return "line" === chartType || "area" === chartType || "common" === chartType && spec.series.every((item) => "area" === item.type || "line" === item.type) ? {
    paddingInner: 1,
    paddingOuter: 0
  } : {
    paddingOuter: 0
  };
}

// node_modules/@visactor/vchart/esm/compile/mark/interface.js
var STATE_VALUE_ENUM;
!function(STATE_VALUE_ENUM2) {
  STATE_VALUE_ENUM2.STATE_NORMAL = "normal", STATE_VALUE_ENUM2.STATE_HOVER = "hover", STATE_VALUE_ENUM2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER = "dimension_hover", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM2.STATE_SELECTED = "selected", STATE_VALUE_ENUM2.STATE_SELECTED_REVERSE = "selected_reverse";
}(STATE_VALUE_ENUM || (STATE_VALUE_ENUM = {}));
var STATE_VALUE_ENUM_REVERSE;
!function(STATE_VALUE_ENUM_REVERSE2) {
  STATE_VALUE_ENUM_REVERSE2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_SELECTED_REVERSE = "selected_reverse";
}(STATE_VALUE_ENUM_REVERSE || (STATE_VALUE_ENUM_REVERSE = {}));

// node_modules/@visactor/vchart/esm/mark/mark-set/index.js
var MarkSet = class _MarkSet {
  constructor() {
    this._children = [], this._markNameMap = {}, this._infoMap = /* @__PURE__ */ new Map();
  }
  getMarkNameMap() {
    return this._markNameMap;
  }
  addMark(mark, markInfo) {
    isNil_default(mark) || (this._children.push(mark), this._markNameMap[mark.name] = mark, this._infoMap.set(mark, merge({}, _MarkSet.defaultMarkInfo, markInfo)));
  }
  removeMark(markName) {
    const index = this._children.findIndex((m5) => m5.name === markName);
    index >= 0 && (this._infoMap.delete(this._children[index]), delete this._markNameMap[markName], this._children.splice(index, 1));
  }
  clear() {
    this._children = [], this._markNameMap = {}, this._infoMap.clear();
  }
  forEach(callbackfn) {
    this._children.forEach(callbackfn);
  }
  includes(mark, fromIndex) {
    return this._children.includes(mark, fromIndex);
  }
  get(key) {
    return isNaN(Number(key)) ? this._markNameMap[key] : this._children[key];
  }
  getMarks() {
    return this._children.slice();
  }
  getMarksInType(type) {
    const types = array(type);
    return this._children.filter((m5) => types.includes(m5.type));
  }
  getMarkInId(markId) {
    return this._children.find((m5) => m5.id === markId);
  }
  getMarkWithInfo(info) {
    return this._children.find((mark) => Object.keys(info).every((key) => info[key] === this._infoMap.get(mark)[key]));
  }
};
MarkSet.defaultMarkInfo = {};

// node_modules/@visactor/vchart/esm/interaction/dimension-trigger.js
var DimensionTrigger = class {
  get hover() {
    return this._hover;
  }
  get select() {
    return this._select;
  }
  constructor(option) {
    this._marks = new MarkSet(), this._markReverse = new MarkSet(), this._lastDimensionEvent = null, this.onHover = (params2) => {
      const elements = this.getEventElement(params2);
      switch (params2.action) {
        case "enter":
          this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER).forEach((e3) => {
            this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE, e3);
          }), this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, false), elements.forEach(({ el, mark }) => {
            this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, el);
          }), this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER);
          break;
        case "leave":
          this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, true), params2 = null;
      }
      this._lastDimensionEvent = params2;
    }, this._option = option, this.event = this._option.model.getOption().getChart().getEvent(), this.interaction = option.interaction, this.initConfig(option.mode);
  }
  setStateKeys(fields2) {
  }
  registerMark(mark) {
    isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]) || this._marks.addMark(mark), isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE]) || this._markReverse.addMark(mark);
  }
  init() {
    this.initEvent();
  }
  release() {
    this.releaseEvent();
  }
  initEvent() {
    this.event.on(DimensionEventEnum.dimensionHover, this.onHover);
  }
  releaseEvent() {
    this.event.release();
  }
  initConfig(mode2) {
  }
  getEventElement(params2, reverse2 = false) {
    const items = [];
    return params2.dimensionInfo.forEach((df) => {
      df.data.forEach((dd) => {
        (reverse2 ? this._markReverse : this._marks).getMarks().filter((m5) => m5.model === dd.series && m5.getVisible()).forEach((m5) => {
          const elements = m5.getProduct().elements.filter((e3) => {
            const datum = e3.getDatum();
            let c4;
            return c4 = isArray_default(datum) ? datum.every((oneData, i2) => oneData === dd.datum[i2]) : dd.datum.some((dd_d) => dd_d === datum), reverse2 ? !c4 : c4;
          }).map((el) => ({
            el,
            mark: m5
          }));
          items.push(...elements);
        });
      });
    }), items;
  }
  dimensionDataEqual(params2) {
    if (this._lastDimensionEvent === params2) return true;
    if (!this._lastDimensionEvent || !params2) return false;
    if (this._lastDimensionEvent.dimensionInfo.length !== params2.dimensionInfo.length) return false;
    for (let i2 = 0; i2 < this._lastDimensionEvent.dimensionInfo.length; i2++) {
      const last2 = this._lastDimensionEvent.dimensionInfo[i2], current = params2.dimensionInfo[i2];
      if (last2.value !== current.value) return false;
      if (last2.axis !== current.axis) return false;
      if (last2.data.length !== current.data.length) return false;
      for (let j2 = 0; j2 < last2.data.length; j2++) {
        const lastData = last2.data[j2], currentData = current.data[j2];
        if (lastData.series !== currentData.series) return false;
        if (lastData.datum.length !== currentData.datum.length) return false;
        for (let k3 = 0; k3 < lastData.datum.length; k3++) if (lastData.datum[k3] !== currentData.datum[k3]) return false;
      }
    }
    return true;
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/util.js
function isStateAttrChangeable(key, stateStyle, facetField) {
  var _a;
  const style = null === (_a = stateStyle[key]) || void 0 === _a ? void 0 : _a.style;
  if (isGradientAttribute(key, style)) return true;
  if (isFunction_default(style)) return true;
  return !(!(null == style ? void 0 : style.scale) || style.field === facetField);
}
function isGradientAttribute(key, style) {
  return ("fill" === key || "stroke" === key) && (null == style ? void 0 : style.gradient) && (null == style ? void 0 : style.stops);
}
var DEFAULT_STATE_VALUE_ENUM = {};
Object.values(STATE_VALUE_ENUM).forEach((v2) => {
  DEFAULT_STATE_VALUE_ENUM[v2] = true;
});
function stateInDefaultEnum(state) {
  return !!DEFAULT_STATE_VALUE_ENUM[state];
}
var DEFAULT_STATE_VALUE_TO_REVERSE = {
  [STATE_VALUE_ENUM.STATE_HOVER]: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
  [STATE_VALUE_ENUM.STATE_SELECTED]: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
  [STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE
};
function stateToReverse(state) {
  return DEFAULT_STATE_VALUE_TO_REVERSE[state];
}

// node_modules/@visactor/vchart/esm/interaction/interaction.js
var Interaction = class {
  constructor() {
    this._stateMarks = /* @__PURE__ */ new Map(), this._stateElements = /* @__PURE__ */ new Map(), this._disableTriggerEvent = false;
  }
  static markStateEnable(mark, state) {
    return !isEmpty_default(mark.stateStyle[state]);
  }
  setDisableActiveEffect(disable) {
    this._disableTriggerEvent = disable;
  }
  registerMark(state, mark) {
    var _a;
    this._stateMarks.has(state) || this._stateMarks.set(state, []), null === (_a = this._stateMarks.get(state)) || void 0 === _a || _a.push(mark);
  }
  getStateMark(state) {
    return this._stateMarks.get(state);
  }
  filterEventMark(params2, state) {
    var _a;
    return !(!params2.mark || !(null === (_a = this._stateMarks.get(state)) || void 0 === _a ? void 0 : _a.includes(params2.mark)));
  }
  getEventElement(stateValue) {
    var _a;
    return null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
  }
  getEventElementData(stateValue) {
    return this.getEventElement(stateValue).map((e3) => e3.getDatum());
  }
  exchangeEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent) return;
    const reState = stateToReverse(stateValue);
    null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e3) => {
      e3.removeState(stateValue), reState && this.addEventElement(reState, e3);
    }), element.getStates().includes(stateValue) || (element.addState(stateValue), reState && element.removeState(reState)), this._stateElements.set(stateValue, [element]);
  }
  removeEventElement(stateValue, element) {
    var _a, _b;
    if (this._disableTriggerEvent) return;
    element.removeState(stateValue);
    const list = null !== (_b = null === (_a = this._stateElements.get(stateValue)) || void 0 === _a ? void 0 : _a.filter((e3) => e3 !== element)) && void 0 !== _b ? _b : [];
    this._stateElements.set(stateValue, list);
    const reState = stateToReverse(stateValue);
    reState && (0 === list.length ? this.clearEventElement(reState, false) : this.addEventElement(reState, element));
  }
  addEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent) return;
    element.getStates().includes(stateValue) || element.addState(stateValue);
    const list = null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
    list.push(element), this._stateElements.set(stateValue, list);
  }
  clearEventElement(stateValue, clearReverse) {
    var _a;
    if (!this._disableTriggerEvent && (null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e3) => {
      e3.removeState(stateValue);
    }), this._stateElements.set(stateValue, []), clearReverse)) {
      const reState = stateToReverse(stateValue);
      reState && this.clearEventElement(reState, false);
    }
  }
  reverseEventElement(stateValue) {
    if (this._disableTriggerEvent) return;
    const state = stateToReverse(stateValue);
    if (!state) return;
    const marks = this.getStateMark(state);
    if (!marks) return;
    const activeElements = this.getEventElement(stateValue);
    if (!activeElements.length) return;
    this.getEventElement(state).length || (1 === activeElements.length ? marks.forEach((m5) => {
      m5.getProduct().elements.filter((e3) => e3 !== activeElements[0]).forEach((e3) => {
        this.addEventElement(state, e3);
      });
    }) : marks.forEach((m5) => {
      m5.getProduct().elements.filter((e3) => !activeElements.includes(e3)).forEach((e3) => {
        this.addEventElement(state, e3);
      });
    }));
  }
};

// node_modules/@visactor/vchart/esm/compile/compilable-base.js
var CompilableBase = class {
  getOption() {
    return this._option;
  }
  constructor(option) {
    this._option = option, this.getCompiler = this._option.getCompiler;
  }
  getVGrammarView() {
    var _a;
    return null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
  }
  release() {
    this._option = null;
  }
};

// node_modules/@visactor/vchart/esm/compile/grammar-item.js
var GrammarItem = class extends CompilableBase {
  constructor() {
    super(...arguments), this.id = createID(), this._compiledProductId = null, this._depend = [];
  }
  getProduct() {
    if (isValid_default(this._product)) return this._product;
    const view = this.getVGrammarView(), id2 = this.getProductId();
    return isValid_default(id2) && isValid_default(view) && (this._product = this._lookupGrammar(id2)), this._product;
  }
  getProductId() {
    var _a;
    return null !== (_a = this._compiledProductId) && void 0 !== _a ? _a : this.generateProductId();
  }
  getDepend() {
    return this._depend;
  }
  setDepend(...depend) {
    this._depend = depend;
  }
  compile(option) {
    this._compileProduct(option), this._afterCompile(option);
  }
  _afterCompile(option) {
    var _a;
    isValid_default(this._product) && (null === (_a = this.getCompiler()) || void 0 === _a || _a.addGrammarItem(this));
  }
  updateDepend() {
    if (isValid_default(this._product)) {
      const depend = this.getDepend().map((item) => item.getProduct()).filter(isValid_default);
      return this._product.depend(depend), depend.length === this.getDepend().length;
    }
    return false;
  }
  release() {
    this.removeProduct(), super.release(), this._depend = [];
  }
  removeProduct(reserveVGrammarModel) {
    this.getCompiler().removeGrammarItem(this, reserveVGrammarModel), this._product = null, this._compiledProductId = null;
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/compilable-signal.js
var CompilableSignal = class extends GrammarItem {
  getValue() {
    return this._value;
  }
  getUpdateFunc() {
    return this._updateFunc;
  }
  constructor(option, name, value, updateFunc) {
    super(option), this.grammarType = GrammarType.signal, this.name = name, this._value = value, this._updateFunc = updateFunc;
  }
  updateSignal(value, updateFunc) {
    this._value = value, this._updateFunc = updateFunc, this.compile();
  }
  _compileProduct() {
    const view = this.getVGrammarView();
    if (!view) return;
    if (!this.getProduct()) {
      const id2 = this.getProductId();
      this._product = view.signal().id(id2), this._compiledProductId = id2;
    }
    isValid_default(this._value) && this._product.value(this._value), isValid_default(this._updateFunc) && this._product.update(this._updateFunc);
  }
  generateProductId() {
    return this.name;
  }
  _lookupGrammar(id2) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getSignalById(id2);
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/signal-manager.js
var SignalManager = class extends CompilableBase {
  constructor() {
    super(...arguments), this._signalMap = {};
  }
  getSignalMap() {
    return this._signalMap;
  }
  getSignal(name) {
    return this._signalMap[name];
  }
  updateSignal(name, value, updateFunc) {
    this._signalMap[name] ? this._signalMap[name].updateSignal(value, updateFunc) : (this._signalMap[name] = new CompilableSignal(this._option, name, value, updateFunc), this._signalMap[name].compile());
  }
  compile() {
    Object.values(this._signalMap).forEach((signal) => {
      signal.compile();
    });
  }
  release() {
    super.release(), Object.values(this._signalMap).forEach((signal) => {
      signal.release();
    }), this._signalMap = {};
  }
};

// node_modules/@visactor/vchart/esm/compile/signal/state-manager.js
var StateManager = class extends SignalManager {
  getStateMap() {
    return this._stateMap;
  }
  _getDefaultStateMap() {
    return {};
  }
  constructor(option) {
    super(option), option.stateKeyToSignalName ? this.stateKeyToSignalName = option.stateKeyToSignalName : this.stateKeyToSignalName = () => "state_signal", this.initStateMap();
  }
  initStateMap(state) {
    this._stateMap = null != state ? state : this._getDefaultStateMap();
  }
  compile(stateMap) {
    const state = null != stateMap ? stateMap : this._stateMap;
    Object.keys(state).forEach((key) => {
      const name = this.stateKeyToSignalName(key), value = state[key];
      this.updateSignal(name, value);
    });
  }
  updateState(newState, noRender) {
    return newState ? (merge(this._stateMap, newState), this.compile(newState), noRender ? Promise.resolve() : this.getCompiler().renderAsync()) : Promise.resolve();
  }
};

// node_modules/@visactor/vchart/esm/animation/animate-manager.js
var AnimateManager = class extends StateManager {
  constructor() {
    super(...arguments), this.id = createID(), this.stateKeyToSignalName = (key) => `${PREFIX}_animate_${this.id}_${key}`;
  }
  getAnimationStateSignalName() {
    return this.stateKeyToSignalName("animationState");
  }
  updateAnimateState(state, noRender) {
    state === AnimationStateEnum.update ? this.updateState({
      animationState: {
        callback: (datum, element) => element.diffState
      }
    }, noRender) : state === AnimationStateEnum.appear ? this.updateState({
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.none : AnimationStateEnum.appear
      }
    }, noRender) : this.updateState({
      animationState: {
        callback: (datum, element) => state
      }
    }, noRender);
  }
  _getDefaultStateMap() {
    return {
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.exit : AnimationStateEnum.appear
      }
    };
  }
};

// node_modules/@visactor/vchart/esm/model/base-model-transformer.js
var BaseModelSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type;
  }
  _initTheme(spec, chartSpec) {
    return this._theme = this.getTheme(spec, chartSpec), this._mergeThemeToSpec(spec, chartSpec);
  }
  getTheme(spec, chartSpec) {
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    this._transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo);
    const result2 = this._initTheme(spec, chartSpec);
    return this._transformSpecAfterMergingTheme(result2.spec, chartSpec, chartSpecInfo), result2;
  }
  _transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec), merge2 = (originalSpec) => mergeSpec({}, theme2, specFromChart, originalSpec);
      return isArray_default(spec) ? {
        spec: spec.map((specItem) => merge2(specItem)),
        theme: theme2
      } : {
        spec: merge2(spec),
        theme: theme2
      };
    }
    return {
      spec,
      theme: theme2
    };
  }
  _shouldMergeThemeToSpec() {
    return true;
  }
  _getDefaultSpecFromChart(chartSpec) {
  }
};

// node_modules/@visactor/vchart/esm/model/base-model.js
var BaseModel = class extends CompilableBase {
  getSpec() {
    return this._spec || {};
  }
  getSpecPath() {
    return this._option.specPath;
  }
  getSpecInfoPath() {
    var _a;
    return null !== (_a = this._option.specInfoPath) && void 0 !== _a ? _a : this._option.specPath;
  }
  getData() {
    return this._data;
  }
  get layout() {
    return this._layout;
  }
  getSpecIndex() {
    return this._specIndex;
  }
  getOption() {
    return this._option;
  }
  getMarks() {
    var _a, _b;
    return null !== (_b = null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarks()) && void 0 !== _b ? _b : [];
  }
  getMarkNameMap() {
    var _a;
    return null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarkNameMap();
  }
  getMarkSet() {
    return this._marks;
  }
  getMarkInfoList() {
    return this.getMarks().map((mark) => ({
      type: mark.type,
      name: mark.name
    }));
  }
  getChart() {
    return this._option.getChart();
  }
  get _theme() {
    var _a;
    return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.theme;
  }
  constructor(spec, option) {
    var _a, _b;
    super(option), this.transformerConstructor = BaseModelSpecTransformer, this.type = "null", this.modelType = "null", this.userId = void 0, this._data = null, this._layout = null, this._specIndex = 0, this.specKey = "", this._marks = new MarkSet(), this._lastLayoutRect = null, this.id = createID(), this.userId = spec.id, this._spec = spec, this._specIndex = null !== (_a = option.specIndex) && void 0 !== _a ? _a : 0, this.effect = {}, this.event = new Event2(option.eventDispatcher, option.mode), null === (_b = option.map) || void 0 === _b || _b.set(this.id, this);
  }
  _releaseEvent() {
    this.event.release();
  }
  created() {
    this.setAttrFromSpec();
  }
  init(option) {
  }
  afterInit() {
  }
  getVisible() {
    var _a;
    return false !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.visible);
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutEnd(ctx), this.getMarks().forEach((m5) => m5.updateLayoutState(true, true));
  }
  onEvaluateEnd(ctx) {
  }
  onDataUpdate() {
  }
  beforeRelease() {
  }
  release() {
    var _a;
    this._releaseEvent(), this._spec = void 0, this.getMarks().forEach((m5) => m5.release()), null === (_a = this._data) || void 0 === _a || _a.release(), this._data = this._specIndex = null, this._marks.clear(), super.release();
  }
  updateSpec(spec) {
    const result2 = this._compareSpec(spec, this._spec);
    return this._spec = spec, result2.reMake || this.reInit(), result2;
  }
  _compareSpec(spec, prevSpec) {
    return {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
  }
  reInit(spec) {
    spec && (this._spec = spec), this.setAttrFromSpec();
  }
  updateLayoutAttribute() {
  }
  setAttrFromSpec() {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.setAttrFromSpec(this._spec, this._option.getChartViewRect());
  }
  _convertMarkStyle(style) {
    return Object.assign({}, style);
  }
  setMarkStyle(mark, style, state, level) {
    isValid_default(mark) && isValid_default(style) && mark.setStyle(this._convertMarkStyle(style), state, level);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (!isValid_default(mark) || !isValid_default(spec)) return;
    const { style, state } = spec, newSpec = Object.assign({}, spec);
    style && (newSpec.style = this._convertMarkStyle(style)), state && (newSpec.state = {}, Object.keys(state).forEach((key2) => {
      newSpec.state[key2] = this._convertMarkStyle(state[key2]);
    })), mark.initStyleWithSpec(newSpec, key);
  }
  stateKeyToSignalName(key, opt) {
    let name = `${PREFIX}_${this.modelType}_${this.type}_${this.id}_${key}`;
    return opt && (name += `_${opt}`), name;
  }
  compileData() {
    var _a;
    null === (_a = this._data) || void 0 === _a || _a.compile();
  }
  compileMarks(group) {
    this.getMarks().forEach((m5) => {
      m5.compile({
        group
      });
    });
  }
  _createMark(markInfo, option = {}) {
    const { type, name } = markInfo, m5 = Factory2.createMark(type, name, Object.assign({
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._option.globalScale
    }, option));
    return null == m5 || m5.created(), m5;
  }
  _getDataIdKey() {
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
  getSpecInfo() {
    var _a, _b, _c;
    const specInfo = null !== (_c = null === (_b = (_a = this._option).getSpecInfo) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : {};
    return getProperty(specInfo, this.getSpecInfoPath());
  }
};

// node_modules/@visactor/vchart/esm/layout/layout-item.js
var LayoutItem = class {
  getSpec() {
    return this._spec || {};
  }
  getLayoutStartPoint() {
    return this._layoutStartPoint;
  }
  get layoutRectLevelMap() {
    return this._layoutRectLevelMap;
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v2) {
    this._minWidth = v2;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v2) {
    this._maxWidth = v2;
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v2) {
    this._minHeight = v2;
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v2) {
    this._maxHeight = v2;
  }
  getLastComputeOutBounds() {
    return this._lastComputeOutBounds;
  }
  get layoutOrient() {
    return this._layoutOrient;
  }
  set layoutOrient(v2) {
    this._layoutOrient = v2;
  }
  get model() {
    return this._model;
  }
  get type() {
    return this._model.type;
  }
  constructor(model, option) {
    var _a;
    this.layoutClip = false, this.autoIndent = false, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutRectLevelMap = {
      width: DEFAULT_LAYOUT_RECT_LEVEL,
      height: DEFAULT_LAYOUT_RECT_LEVEL
    }, this._minWidth = null, this._maxWidth = null, this._minHeight = null, this._maxHeight = null, this._lastComputeRect = null, this._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this.getLayoutRect = () => this._layoutRect, this.layoutType = "normal", this._layoutOrient = "left", this.layoutPaddingLeft = 0, this.layoutPaddingTop = 0, this.layoutPaddingRight = 0, this.layoutPaddingBottom = 0, this.layoutOffsetX = 0, this.layoutOffsetY = 0, this.layoutLevel = LayoutLevel.Region, this._model = model, this._option = option, this.layoutLevel = option.layoutLevel, this.layoutType = option.layoutType, option.layoutOrient && (this.layoutOrient = option.layoutOrient), this._spec = null === (_a = null == model ? void 0 : model.getSpec) || void 0 === _a ? void 0 : _a.call(model);
  }
  _setLayoutAttributeFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    if (this._spec && false !== this._spec.visible) {
      const padding = normalizeLayoutPaddingSpec(spec.padding), paddingValue = calcPadding(padding, chartViewRect, chartViewRect);
      this.layoutPaddingLeft = paddingValue.left, this.layoutPaddingRight = paddingValue.right, this.layoutPaddingTop = paddingValue.top, this.layoutPaddingBottom = paddingValue.bottom, this._minHeight = isNil_default(spec.minHeight) ? null !== (_a = this._minHeight) && void 0 !== _a ? _a : null : calcLayoutNumber(spec.minHeight, chartViewRect.height, chartViewRect), this._maxHeight = isNil_default(spec.maxHeight) ? null !== (_b = this._maxHeight) && void 0 !== _b ? _b : null : calcLayoutNumber(spec.maxHeight, chartViewRect.height, chartViewRect), this._minWidth = isNil_default(spec.minWidth) ? null !== (_c = this._minWidth) && void 0 !== _c ? _c : null : calcLayoutNumber(spec.minWidth, chartViewRect.width, chartViewRect), this._maxWidth = isNil_default(spec.maxWidth) ? null !== (_d = this._maxWidth) && void 0 !== _d ? _d : null : calcLayoutNumber(spec.maxWidth, chartViewRect.width, chartViewRect), spec.width && this.setLayoutRect({
        width: calcLayoutNumber(spec.width, chartViewRect.width, chartViewRect)
      }, {
        width: USER_LAYOUT_RECT_LEVEL
      }), spec.height && this.setLayoutRect({
        height: calcLayoutNumber(spec.height, chartViewRect.height, chartViewRect)
      }, {
        height: USER_LAYOUT_RECT_LEVEL
      }), isNil_default(spec.offsetX) || (this.layoutOffsetX = calcLayoutNumber(spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(spec.offsetY) || (this.layoutOffsetY = calcLayoutNumber(spec.offsetY, chartViewRect.height, chartViewRect)), spec.alignSelf && (this.alignSelf = spec.alignSelf);
    }
  }
  setAttrFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    this._spec = spec, this.layoutType = null !== (_a = spec.layoutType) && void 0 !== _a ? _a : this.layoutType, this.layoutLevel = null !== (_b = spec.layoutLevel) && void 0 !== _b ? _b : this.layoutLevel, this.layoutOrient = null !== (_c = spec.orient) && void 0 !== _c ? _c : this.layoutOrient, this._setLayoutAttributeFromSpec(spec, chartViewRect), this.layoutClip = null !== (_d = spec.clip) && void 0 !== _d ? _d : this.layoutClip;
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._setLayoutAttributeFromSpec(this._spec, viewRect);
  }
  onLayoutEnd(option) {
  }
  _getAbsoluteSpecValue(layoutRect) {
    const result2 = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };
    return ["top", "bottom", "left", "right"].forEach((k3) => {
      isNil_default(this._spec[k3]) || (result2[k3] = calcLayoutNumber(this._spec[k3], "top" === k3 || "bottom" === k3 ? layoutRect.height : layoutRect.width, layoutRect));
    }), result2;
  }
  absoluteLayoutInRect(layoutRect) {
    const { top, bottom, left: left2, right: right2 } = this._getAbsoluteSpecValue(layoutRect), layoutSize = {
      width: layoutRect.width - this.layoutPaddingLeft - this.layoutPaddingRight,
      height: layoutRect.height - this.layoutPaddingTop - this.layoutPaddingBottom
    };
    isNil_default(left2) || (layoutSize.width -= left2), isNil_default(right2) || (layoutSize.width -= right2), isNil_default(top) || (layoutSize.height -= top), isNil_default(bottom) || (layoutSize.height -= bottom), this.setLayoutRect(layoutSize);
    const { width, height } = this.computeBoundsInRect(this.getLayoutRect());
    this.setLayoutRect({
      width,
      height
    });
    const pos = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    true === this._spec.center ? (pos.x = layoutRect.x + 0.5 * layoutRect.width - 0.5 * width, pos.y = layoutRect.y + 0.5 * layoutRect.height - 0.5 * height) : (isNil_default(left2) ? isNil_default(right2) || (pos.x = layoutRect.x + layoutRect.width - this.layoutPaddingRight - right2 - width) : pos.x = layoutRect.x + left2 + this.layoutPaddingLeft, isNil_default(top) ? isNil_default(bottom) || (pos.y = layoutRect.y + layoutRect.height - this.layoutPaddingBottom - bottom - height) : pos.y = layoutRect.y + top + this.layoutPaddingTop), this.setLayoutStartPosition(pos);
  }
  setLayoutStartPosition(pos) {
    var _a, _b;
    this._option.transformLayoutPosition && (pos = this._option.transformLayoutPosition(pos)), isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y), null === (_b = (_a = this._model).afterSetLayoutStartPoint) || void 0 === _b || _b.call(_a, this._layoutStartPoint);
  }
  setLayoutRect({ width, height }, levelMap) {
    var _a, _b, _c, _d;
    isValidNumber_default(width) && (null !== (_a = null == levelMap ? void 0 : levelMap.width) && void 0 !== _a ? _a : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.width && (this._layoutRect.width = width, this._layoutRectLevelMap.width = null !== (_b = null == levelMap ? void 0 : levelMap.width) && void 0 !== _b ? _b : DEFAULT_LAYOUT_RECT_LEVEL), isValidNumber_default(height) && (null !== (_c = null == levelMap ? void 0 : levelMap.height) && void 0 !== _c ? _c : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.height && (this._layoutRect.height = height, this._layoutRectLevelMap.height = null !== (_d = null == levelMap ? void 0 : levelMap.height) && void 0 !== _d ? _d : DEFAULT_LAYOUT_RECT_LEVEL), this.setRectInSpec(this._layoutRect);
  }
  getLayout() {
    return {
      x: this._layoutStartPoint.x,
      y: this._layoutStartPoint.y,
      width: this._layoutRect.width,
      height: this._layoutRect.height
    };
  }
  mergeLayoutRect({ width, height }) {
    const rect = {
      width,
      height
    };
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (rect.width = this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (rect.height = this._layoutRect.height), rect;
  }
  getOrientPosAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "x" : "y";
  }
  getOrientSizeAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "width" : "height";
  }
  changeBoundsBySetting(bounds) {
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.x2 = bounds.x1 + this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.y2 = bounds.y1 + this._layoutRect.height), bounds.x1 -= this._layoutStartPoint.x, bounds.x2 -= this._layoutStartPoint.x, bounds.y1 -= this._layoutStartPoint.y, bounds.y2 -= this._layoutStartPoint.y, bounds;
  }
  setRectInSpec(rect) {
    const result2 = Object.assign({}, rect);
    return this._layoutRectLevelMap.width < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minWidth) || (result2.width = Math.max(result2.width, this._minWidth)), isNil_default(this._maxWidth) || (result2.width = Math.min(result2.width, this._maxWidth))) : result2.width = this._layoutRect.width, this._layoutRectLevelMap.height < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minHeight) || (result2.height = Math.max(result2.height, this._minHeight)), isNil_default(this._maxHeight) || (result2.height = Math.min(result2.height, this._maxHeight))) : result2.height = this._layoutRect.height, result2;
  }
  computeBoundsInRect(rect) {
    if (this._lastComputeRect = rect, "region-relative" === this.layoutType && (this._layoutRectLevelMap.width === USER_LAYOUT_RECT_LEVEL && ("left" === this.layoutOrient || "right" === this.layoutOrient) || this._layoutRectLevelMap.height === USER_LAYOUT_RECT_LEVEL && ("bottom" === this.layoutOrient || "top" === this.layoutOrient))) return this._layoutRect;
    const bounds = Object.assign({}, this._model.getBoundsInRect(this.setRectInSpec(rect), rect));
    this.changeBoundsBySetting(bounds), this.autoIndent && bounds.x2 - bounds.x1 > 0 && bounds.y2 - bounds.y1 > 0 && (this._lastComputeOutBounds.x1 = Math.ceil(-bounds.x1), this._lastComputeOutBounds.x2 = Math.ceil(bounds.x2 - rect.width), this._lastComputeOutBounds.y1 = Math.ceil(-bounds.y1), this._lastComputeOutBounds.y2 = Math.ceil(bounds.y2 - rect.height));
    let result2 = this.setRectInSpec(boundsInRect(bounds, rect));
    return this._option.transformLayoutRect && (result2 = this._option.transformLayoutRect(result2)), result2;
  }
  getModelId() {
    return this._model.id;
  }
  getModelVisible() {
    return this._model.getVisible();
  }
};

// node_modules/@visactor/vchart/esm/model/layout-model.js
var LayoutModel = class extends BaseModel {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutLevel = 0, this.layoutZIndex = 0, this._forceLayoutTag = false, this._layout = null, this._orient = null, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutStartPos = {
      x: 0,
      y: 0
    }, this._isLayout = true, this.getGraphicBounds = () => this._layout ? {
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this._transformLayoutRect = null, this._transformLayoutPosition = null;
  }
  get layoutOrient() {
    return this._orient;
  }
  set layoutOrient(v2) {
    this._orient = v2, this._layout && (this._layout.layoutOrient = v2);
  }
  initLayout() {
    "none" !== this.layoutType && (this._layout = new LayoutItem(this, {
      layoutType: this.layoutType,
      layoutLevel: this.layoutLevel,
      layoutOrient: this._orient,
      transformLayoutRect: this._transformLayoutRect,
      transformLayoutPosition: this._transformLayoutPosition
    }), this._orient && "radius" !== this._orient && "angle" !== this._orient && this.layout && (this._layout.layoutOrient = this._orient));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._isLayout = true, super.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.updateLayoutAttribute();
    const layoutRect = this.getLayoutRect();
    !this._forceLayoutTag && isEqual(this._lastLayoutRect, layoutRect) || (this._lastLayoutRect = Object.assign({}, layoutRect)), this._forceLayoutTag = false, this._isLayout = false;
  }
  afterSetLayoutStartPoint(_pos) {
  }
  _forceLayout() {
    var _a;
    this._isLayout || (this._forceLayoutTag = true, null === (_a = this._option.globalInstance.getChart()) || void 0 === _a || _a.setLayoutTag(true));
  }
  getLayoutStartPoint() {
    return this._layout ? this._layout.getLayoutStartPoint() : this._layoutStartPos;
  }
  setLayoutStartPosition(pos) {
    return this._layout ? this._layout.setLayoutStartPosition(pos) : this._layoutStartPos = merge(this._layoutStartPos, pos);
  }
  getLayoutRect() {
    return this._layout ? this._layout.getLayoutRect() : this._layoutRect;
  }
  setLayoutRect(rect, levelMap) {
    return this._layout ? this._layout.setLayoutRect(rect) : this._lastLayoutRect = merge(this._layoutRect, rect);
  }
  getLastComputeOutBounds() {
    var _a;
    return null === (_a = this._layout) || void 0 === _a ? void 0 : _a.getLastComputeOutBounds();
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.layoutClip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this.layoutClip, this.layoutZIndex = null !== (_b = this._spec.zIndex) && void 0 !== _b ? _b : this.layoutZIndex, this.layoutType = null !== (_c = this._spec.layoutType) && void 0 !== _c ? _c : this.layoutType;
  }
};

// node_modules/@visactor/vchart/esm/region/region-transformer.js
var RegionSpecTransformer = class extends BaseModelSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// node_modules/@visactor/vchart/esm/region/region.js
var Region = class _Region extends LayoutModel {
  getMaxWidth() {
    return this._layout.maxWidth;
  }
  setMaxWidth(value) {
    this._layout.maxWidth = value;
  }
  getMaxHeight() {
    return this._layout.maxHeight;
  }
  setMaxHeight(value) {
    this._layout.maxHeight = value;
  }
  getGroupMark() {
    return this._groupMark;
  }
  getInteractionMark() {
    return this._interactionMark;
  }
  getStackInverse() {
    return true === this._spec.stackInverse;
  }
  constructor(spec, ctx) {
    var _a;
    super(spec, ctx), this.transformerConstructor = RegionSpecTransformer, this.modelType = "region", this.specKey = "region", this.type = _Region.type, this._series = [], this.layoutType = "region", this.layoutZIndex = LayoutZIndex.Region, this.interaction = new Interaction(), this.seriesDataFilterOver = () => {
      this.event.emit(ChartEvent.regionSeriesDataFilterOver, {
        model: this
      }), this._series.forEach((s3) => {
        s3.getViewDataFilter() && s3.reTransformViewData();
      });
    }, this.getBoundsInRect = () => ({
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    }), this.userId = spec.id, this.coordinate = null !== (_a = spec.coordinate) && void 0 !== _a ? _a : "cartesian", this._option.animation && (this.animate = new AnimateManager({
      getCompiler: ctx.getCompiler
    })), this.interaction.setDisableActiveEffect(this._option.disableTriggerEvent);
  }
  _getClipDefaultValue() {
    var _a, _b, _c, _d;
    const chartSpec = this._option.getChart().getSpec(), hasDataZoom = null === (_b = null === (_a = chartSpec.dataZoom) || void 0 === _a ? void 0 : _a.some) || void 0 === _b ? void 0 : _b.call(_a, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "filter");
    }), hasScrollBar = null === (_d = null === (_c = chartSpec.scrollBar) || void 0 === _c ? void 0 : _c.some) || void 0 === _d ? void 0 : _d.call(_c, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "axis");
    });
    return !(!hasDataZoom && !hasScrollBar) || this._layout.layoutClip;
  }
  created() {
    var _a;
    this.initLayout(), super.created();
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    this._groupMark = this._createGroupMark("regionGroup", this.userId, this.layoutZIndex), this._interactionMark = this._createGroupMark("regionInteractionGroup", this.userId + "_interaction", LayoutZIndex.Interaction), this._spec.style && (this._backgroundMark = this._createMark({
      type: "rect",
      name: "regionBackground"
    }), clip && (this._foregroundMark = this._createMark({
      type: "rect",
      name: "regionForeground"
    })), [this._backgroundMark, this._foregroundMark].forEach((mark) => {
      mark && (mark.created(), this.setMarkStyle(mark, {
        width: () => this.getLayoutRect().width,
        height: () => this.getLayoutRect().height
      }, "normal", AttributeLevel.Built_In), this._groupMark.addMark(mark));
    }), this._backgroundMark && this._backgroundMark.setZIndex(0), this._foregroundMark && this._foregroundMark.setZIndex(LayoutZIndex.Mark + 1)), this.createTrigger();
  }
  _createGroupMark(name, userId, zIndex) {
    var _a, _b;
    const groupMark = this._createMark({
      type: "group",
      name
    });
    groupMark.setUserId(userId), groupMark.setZIndex(zIndex);
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    return this.setMarkStyle(groupMark, {
      x: () => this.getLayoutStartPoint().x,
      y: () => this.getLayoutStartPoint().y,
      width: () => this.getLayoutRect().width,
      height: () => this.getLayoutRect().height,
      clip
    }, "normal", AttributeLevel.Built_In), this.setMarkStyle(groupMark, {
      cornerRadius: null === (_b = this._spec.style) || void 0 === _b ? void 0 : _b.cornerRadius
    }, "normal", AttributeLevel.User_Mark), this._marks.addMark(groupMark), groupMark;
  }
  init(option) {
    super.init(option), this.initMark(), this.initSeriesDataflow(), this.initInteraction(), this.initTrigger();
  }
  initMark() {
    this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  _initBackgroundMarkStyle() {
    var _a, _b;
    this._backgroundMark && (this.setMarkStyle(this._backgroundMark, Object.assign({
      fillOpacity: (null === (_a = this._spec.style) || void 0 === _a ? void 0 : _a.fill) ? 1 : 0
    }, this._spec.style), "normal", AttributeLevel.User_Mark), (null !== (_b = this._spec.clip) && void 0 !== _b ? _b : this._getClipDefaultValue()) && this.setMarkStyle(this._backgroundMark, {
      strokeOpacity: 0
    }, "normal", AttributeLevel.Built_In));
  }
  _initForegroundMarkStyle() {
    this._foregroundMark && this.setMarkStyle(this._foregroundMark, Object.assign(Object.assign({}, this._spec.style), {
      fillOpacity: 0
    }), "normal", AttributeLevel.User_Mark);
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(null == prevSpec ? void 0 : prevSpec.style, null == spec ? void 0 : spec.style) || (result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  addSeries(s3) {
    s3 && (this._series.includes(s3) || this._series.push(s3));
  }
  removeSeries(s3) {
    if (!s3) return;
    const index = this._series.findIndex((s_) => s_ === s3);
    index >= 0 && this._series.splice(index, 1);
  }
  getSeries(opt = {}) {
    return this._series.filter((s3) => {
      var _a, _b;
      return (!opt.name || (null == s3 ? void 0 : s3.name) === opt.name) && (!opt.userId || array(opt.userId).includes(s3.userId)) && (!isValid_default(opt.specIndex) || !s3.getSpecIndex || array(opt.specIndex).includes(s3.getSpecIndex())) && (!opt.id || s3.id === opt.id) && (!opt.type || s3.type === opt.type) && (!opt.coordinateType || s3.coordinate === opt.coordinateType) && (!opt.dataName || (null === (_b = null === (_a = s3.getRawData) || void 0 === _a ? void 0 : _a.call(s3)) || void 0 === _b ? void 0 : _b.name) === opt.dataName);
    });
  }
  getSeriesInName(name) {
    return this.getSeries({
      name
    })[0];
  }
  getSeriesInUserId(userId) {
    return this.getSeries({
      userId
    })[0];
  }
  getSeriesInId(id2) {
    return this.getSeries({
      id: id2
    })[0];
  }
  getSeriesInType(type) {
    return this.getSeries({
      type
    });
  }
  getSeriesInCoordinateType(coordinateType) {
    return this.getSeries({
      coordinateType
    });
  }
  getSeriesInDataName(dataName) {
    return this.getSeries({
      dataName
    });
  }
  onRender(ctx) {
  }
  initSeriesDataflow() {
    const viewDataFilters = this._series.map((s3) => {
      var _a;
      return null !== (_a = s3.getViewDataFilter()) && void 0 !== _a ? _a : s3.getViewData();
    }).filter((v2) => !!v2);
    this._option.dataSet.multipleDataViewAddListener(viewDataFilters, "change", this.seriesDataFilterOver);
  }
  release() {
    super.release(), this._series = [];
  }
  createTrigger() {
    const triggerOptions = Object.assign(Object.assign({}, this._option), {
      model: this,
      interaction: this.interaction
    });
    this._trigger = new DimensionTrigger(triggerOptions);
  }
  initTrigger() {
    this._series.forEach((s3) => {
      s3.getMarksWithoutRoot().forEach((m5) => {
        this._trigger.registerMark(m5);
      });
    }), this._trigger.init();
  }
  initInteraction() {
    this._series.forEach((s3) => {
      s3.getMarksWithoutRoot().forEach((m5) => {
        for (const key in STATE_VALUE_ENUM_REVERSE) isEmpty_default(m5.stateStyle[STATE_VALUE_ENUM_REVERSE[key]]) || this.interaction.registerMark(STATE_VALUE_ENUM_REVERSE[key], m5);
      });
    });
  }
  compileMarks(group) {
    this.getMarks().forEach((m5) => {
      var _a;
      m5.compile({
        group
      }), null === (_a = m5.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      }).layout((group2, children, parentLayoutBounds, options) => {
      });
    });
  }
  compile() {
    var _a;
    null === (_a = this.animate) || void 0 === _a || _a.compile(), this.compileMarks();
  }
  onLayoutEnd(ctx) {
    this._series.forEach((s3) => s3.onLayoutEnd(ctx)), super.onLayoutEnd(ctx);
  }
};
Region.type = "region", Region.transformerConstructor = RegionSpecTransformer, Region.specKey = "region";

// node_modules/@visactor/vchart/esm/layout/util.js
function getPositionItems(items) {
  const startItems = [], middleItems = [], endItems = [];
  return items.forEach((item) => {
    isNil_default(item.getSpec().position) || "start" === item.getSpec().position ? startItems.push(item) : "middle" === item.getSpec().position ? middleItems.push(item) : "end" === item.getSpec().position && endItems.push(item);
  }), {
    startItems,
    endItems,
    middleItems
  };
}
function adjustItemsToCenter(allItems, isVertical3, containerLength) {
  isVertical3 ? allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().y + lastItem.getLayoutRect().height - items[0].getLayoutStartPoint().y, centerY = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x,
        y: item.getLayoutStartPoint().y + centerY
      });
    });
  }) : allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().x + lastItem.getLayoutRect().width - items[0].getLayoutStartPoint().x, centerX = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x + centerX,
        y: item.getLayoutStartPoint().y
      });
    });
  });
}
function alignSelfOfItems(allItems, isVertical3, maxSizes, sign4) {
  let maxSize;
  allItems.forEach((lineItems, index) => {
    lineItems.length > 1 && (maxSize = maxSizes[index], lineItems.forEach((item) => {
      if (!item.alignSelf || "start" === item.alignSelf) return;
      const pos = item.getLayoutStartPoint(), ratio = "middle" === item.alignSelf ? 0.5 : 1, delta = isVertical3 ? maxSize - (item.getLayoutRect().width + item.layoutPaddingLeft + item.layoutPaddingRight) : maxSize - (item.getLayoutRect().height + item.layoutPaddingTop + item.layoutPaddingBottom);
      isVertical3 ? item.setLayoutStartPosition({
        x: pos.x + sign4 * delta * ratio,
        y: pos.y
      }) : item.setLayoutStartPosition({
        x: pos.x,
        y: pos.y + sign4 * delta * ratio
      });
    }));
  });
}
function layoutLeftRightStartOrMiddleItems(items, layout2, limitHeight, isMiddle, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout2.rightCurrent : layout2.leftCurrent, preTop = layout2.topCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preTop + item.layoutOffsetY + item.layoutPaddingTop
      }), preTop += itemTotalHeight, preTop > limitHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preTop = layout2.topCurrent + itemTotalHeight, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: layout2.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxWidth = Math.max(maxWidth, itemTotalWidth), singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isMiddle && adjustItemsToCenter(allItems, true, limitHeight), isRight ? layout2.rightCurrent = preX + xSign * maxWidth : layout2.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutLeftRightEndItems(items, layout2, limitWidth, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout2.rightCurrent : layout2.leftCurrent, preBottom = layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      preBottom < itemTotalHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preBottom = layout2.bottomCurrent, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), maxWidth = Math.max(maxWidth, itemTotalWidth), preBottom -= itemTotalHeight, singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isRight ? layout2.rightCurrent = preX + xSign * maxWidth : layout2.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutTopBottomStartOrMiddleItems(items, layout2, limitWidth, isMiddle, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preLeft = layout2.leftCurrent, preY = isTop ? layout2.topCurrent : layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      item.setLayoutStartPosition({
        x: preLeft + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), preLeft += itemTotalWidth, preLeft > limitWidth && singleLineItems.length ? (maxHeights.push(maxHeight), preLeft = layout2.leftCurrent + itemTotalWidth, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout2.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxHeight = Math.max(maxHeight, itemTotalHeight), singleLineItems.push(item));
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isMiddle && adjustItemsToCenter(allItems, false, limitWidth), isTop ? layout2.topCurrent = preY + ySign * maxHeight : layout2.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutTopBottomEndItems(items, layout2, limitWidth, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preRight = layout2.rightCurrent, preY = isTop ? layout2.topCurrent : layout2.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout2.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      preRight < itemTotalWidth && singleLineItems.length ? (preRight = layout2.rightCurrent, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout2.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (singleLineItems.push(item), item.setLayoutStartPosition({
        x: preRight + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), maxHeight = Math.max(maxHeight, itemTotalHeight), preRight -= itemTotalWidth);
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isTop ? layout2.topCurrent = preY + ySign * maxHeight : layout2.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutLeftInlineItems(items, layout2, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout2, limitHeight, false, "left"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout2, limitHeight, true, "left"), endItems.length && layoutLeftRightEndItems(endItems, layout2, limitHeight, "left");
}
function layoutRightInlineItems(items, layout2, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout2, limitHeight, false, "right"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout2, limitHeight, true, "right"), endItems.length && layoutLeftRightEndItems(endItems, layout2, limitHeight, "right");
}
function layoutTopInlineItems(items, layout2, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout2, limitWidth, false, "top"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout2, limitWidth, true, "top"), endItems.length && layoutTopBottomEndItems(endItems, layout2, limitWidth, "top");
}
function layoutBottomInlineItems(items, layout2, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout2, limitWidth, false, "bottom"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout2, limitWidth, true, "bottom"), endItems.length && layoutTopBottomEndItems(endItems, layout2, limitWidth, "bottom");
}

// node_modules/@visactor/vchart/esm/layout/base-layout.js
var Layout = class {
  constructor(_spec, ctx) {
    this.leftCurrent = 0, this.topCurrent = 0, this.rightCurrent = 0, this.bottomCurrent = 0, this._onError = null == ctx ? void 0 : ctx.onError;
  }
  _layoutInit(_chart, items, chartLayoutRect, chartViewBox) {
    this._chartLayoutRect = chartLayoutRect, this._chartViewBox = chartViewBox, this.leftCurrent = chartLayoutRect.x, this.topCurrent = chartLayoutRect.y, this.rightCurrent = chartLayoutRect.x + chartLayoutRect.width, this.bottomCurrent = chartLayoutRect.height + chartLayoutRect.y, items.sort((a4, b2) => b2.layoutLevel - a4.layoutLevel);
  }
  _layoutNormalItems(items) {
    this.layoutNormalInlineItems(items.filter((x3) => "normal-inline" === x3.layoutType)), this.layoutNormalItems(items.filter((x3) => "normal" === x3.layoutType));
  }
  _groupItems(items) {
    const regionItems = items.filter((x3) => "region" === x3.layoutType), relativeItems = items.filter((x3) => "region-relative" === x3.layoutType), relativeOverlapItems = items.filter((x3) => "region-relative-overlap" === x3.layoutType), allRelatives = relativeItems.concat(relativeOverlapItems), overlapItems = {
      left: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      right: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      top: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      bottom: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      z: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      }
    };
    return relativeOverlapItems.forEach((i2) => {
      overlapItems[i2.layoutOrient].items.push(i2);
    }), {
      regionItems,
      relativeItems,
      relativeOverlapItems,
      allRelatives,
      overlapItems
    };
  }
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._layoutInit(_chart, items, chartLayoutRect, chartViewBox), this._layoutNormalItems(items);
    const layoutTemp = {
      left: this.leftCurrent,
      top: this.topCurrent,
      right: this.rightCurrent,
      bottom: this.bottomCurrent
    }, { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
    this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems), this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp), this.layoutAbsoluteItems(items.filter((x3) => "absolute" === x3.layoutType));
  }
  _processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }, allRelatives, layoutTemp) {
    if (allRelatives.some((i2) => i2.autoIndent)) {
      const { top, bottom, left: left2, right: right2 } = this._checkAutoIndent(allRelatives, layoutTemp);
      (top || bottom || left2 || right2) && (this.topCurrent = layoutTemp.top + top, this.bottomCurrent = layoutTemp.bottom - bottom, this.leftCurrent = layoutTemp.left + left2, this.rightCurrent = layoutTemp.right - right2, this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems));
    }
  }
  layoutNormalItems(normalItems) {
    normalItems.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "right" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "bottom" === item.layoutOrient && (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingRight,
        y: this.bottomCurrent + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom);
    });
  }
  layoutNormalInlineItems(normalItems) {
    const leftItems = normalItems.filter((item) => "left" === item.layoutOrient), rightItems = normalItems.filter((item) => "right" === item.layoutOrient), topItems = normalItems.filter((item) => "top" === item.layoutOrient), bottomItems = normalItems.filter((item) => "bottom" === item.layoutOrient), limitWidth = this._chartLayoutRect.width + this._chartLayoutRect.x, limitHeight = this._chartLayoutRect.height + this._chartLayoutRect.y;
    leftItems.length && layoutLeftInlineItems(leftItems, this, limitHeight), topItems.length && layoutTopInlineItems(topItems, this, limitWidth), rightItems.length && layoutRightInlineItems(rightItems, this, limitHeight), bottomItems.length && layoutBottomInlineItems(bottomItems, this, limitWidth);
  }
  _layoutRelativeOverlap(orient, info) {
    info.items.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      info.rect.width = Math.max(rect.width, info.rect.width), info.rect.height = Math.max(rect.height, info.rect.height);
    }), info.items.forEach((item) => {
      item.setLayoutRect(info.rect), "left" === orient ? item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft
      }) : "right" === orient ? item.setLayoutStartPosition({
        x: this.rightCurrent + item.layoutOffsetX + item.layoutPaddingLeft
      }) : "top" === orient ? item.setLayoutStartPosition({
        x: this.topCurrent + item.layoutOffsetX + item.layoutPaddingLeft
      }) : item.setLayoutStartPosition({
        x: this.bottomCurrent + item.layoutOffsetX + item.layoutPaddingLeft
      });
    }), "left" === orient ? this.leftCurrent += info.rect.width : "right" === orient ? this.rightCurrent -= info.rect.width : "top" === orient ? this.topCurrent += info.rect.height : this.bottomCurrent -= info.rect.height;
  }
  _layoutRelativeItem(item, layoutRect) {
    const rect = item.computeBoundsInRect(layoutRect);
    "left" === item.layoutOrient || "right" === item.layoutOrient ? item.setLayoutRect({
      width: rect.width
    }) : item.setLayoutRect({
      height: rect.height
    }), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
      x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "right" === item.layoutOrient ? (this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, item.setLayoutStartPosition({
      x: this.rightCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    })) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
      y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "bottom" === item.layoutOrient && (this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, item.setLayoutStartPosition({
      y: this.bottomCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }));
  }
  _layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight) {
    const regionWidth = Math.max(Math.min(regionRelativeTotalWidth, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxWidth) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0), regionHeight = Math.max(Math.min(regionRelativeTotalHeight, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxHeight) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0);
    return regionItems.forEach((region) => {
      region.setLayoutRect({
        width: regionWidth,
        height: regionHeight
      }), region.setLayoutStartPosition({
        x: this.leftCurrent + region.layoutOffsetX + region.layoutPaddingLeft,
        y: this.topCurrent + region.layoutOffsetY + region.layoutPaddingTop
      });
    }), {
      regionHeight,
      regionWidth
    };
  }
  layoutRegionItems(regionItems, regionRelativeItems, regionRelativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }) {
    let regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    regionRelativeItems.filter((x3) => "left" === x3.layoutOrient || "right" === x3.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("left", overlapItems.left), this._layoutRelativeOverlap("right", overlapItems.right), regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeItems.filter((x3) => "top" === x3.layoutOrient || "bottom" === x3.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("top", overlapItems.top), this._layoutRelativeOverlap("bottom", overlapItems.bottom), regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    const { regionWidth, regionHeight } = this._layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight);
    regionRelativeItems.concat(regionRelativeOverlapItems).forEach((item) => {
      if (["left", "right"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          height: relativeRegion.getLayoutRect().height
        }), item.setLayoutStartPosition({
          y: relativeRegion.getLayoutStartPoint().y + item.layoutOffsetY + item.layoutPaddingTop
        }), "right" === item.layoutOrient && item.setLayoutStartPosition({
          x: item.getLayoutStartPoint().x + regionWidth - regionRelativeTotalWidth
        });
      } else if (["top", "bottom"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          width: relativeRegion.getLayoutRect().width
        }), item.setLayoutStartPosition({
          x: relativeRegion.getLayoutStartPoint().x + item.layoutOffsetX + item.layoutPaddingLeft
        }), "bottom" === item.layoutOrient && item.setLayoutStartPosition({
          y: item.getLayoutStartPoint().y + regionHeight - regionRelativeTotalHeight
        });
      }
    });
  }
  layoutAbsoluteItems(absoluteItems) {
    absoluteItems.forEach((item) => {
      item.absoluteLayoutInRect(this._chartLayoutRect);
    });
  }
  filterRegionsWithID(items, id2) {
    var _a;
    const target = items.find((x3) => x3.getModelId() === id2);
    return target || (null !== (_a = this._onError) && void 0 !== _a ? _a : error)("can not find target region item, invalid id"), target;
  }
  getItemComputeLayoutRect(item) {
    return {
      width: this.rightCurrent - this.leftCurrent - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: this.bottomCurrent - this.topCurrent - item.layoutPaddingTop - item.layoutPaddingBottom
    };
  }
  _checkAutoIndent(items, layoutTemp) {
    const result2 = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    };
    return items.forEach((i2) => {
      if (!i2.getModelVisible() || !i2.autoIndent) return;
      const vOrH = "left" === i2.layoutOrient || "right" === i2.layoutOrient, itemOuter = i2.getLastComputeOutBounds(), outer = this._getOutInLayout(itemOuter, i2, layoutTemp);
      vOrH ? (result2.top = Math.max(result2.top, outer.top), result2.bottom = Math.max(result2.bottom, outer.bottom)) : (result2.left = Math.max(result2.left, outer.left), result2.right = Math.max(result2.right, outer.right));
    }), result2;
  }
  _getOutInLayout(itemOuter, i2, tempBorder) {
    const { x: x3, y: y3 } = i2.getLayoutStartPoint(), { width, height } = i2.getLayoutRect();
    return {
      left: tempBorder.left - (x3 - itemOuter.x1),
      right: x3 + width + itemOuter.x2 - tempBorder.right,
      top: tempBorder.top - (y3 - itemOuter.y1),
      bottom: y3 + height + itemOuter.y2 - tempBorder.bottom
    };
  }
};
Layout.type = "base";

// node_modules/@visactor/vchart/esm/mark/utils/common.js
var MultiDatumMark = ["line", "area", "trail"];
function isMultiDatumMark(type) {
  return MultiDatumMark.includes(type);
}

// node_modules/@visactor/vchart/esm/compile/mark/mark-state-manager.js
var MarkStateManager = class extends StateManager {
  getStateInfoList() {
    return this._stateInfoList;
  }
  constructor(option, mark) {
    super(option), this._stateInfoList = [], this._mark = mark;
  }
  _getDefaultStateMap() {
    return {
      markUpdateRank: 1
    };
  }
  getStateInfo(stateValue) {
    return this._stateInfoList.find((s3) => s3.stateValue === stateValue);
  }
  addStateInfo(stateInfo) {
    if (this.getStateInfo(stateInfo.stateValue)) return;
    stateInfo.level = stateInfo.level || 0;
    let needPush = true;
    for (let i2 = 0; i2 < this._stateInfoList.length; i2++) {
      const level = this._stateInfoList[i2].level;
      if (level && level > stateInfo.level) {
        this._stateInfoList.splice(i2, 0, stateInfo), needPush = false;
        break;
      }
    }
    needPush && this._stateInfoList.push(stateInfo);
  }
  _clearStateBeforeSet(state) {
    state.datums = null, state.items = null, state.fields = null, state.filter = null;
  }
  changeStateInfo(stateInfo) {
    const s3 = this.getStateInfo(stateInfo.stateValue);
    if (s3) {
      if (void 0 !== stateInfo.datums && (this._clearStateBeforeSet(s3), s3.datums = stateInfo.datums, s3.datumKeys = stateInfo.datumKeys), void 0 !== stateInfo.items && (this._clearStateBeforeSet(s3), s3.items = stateInfo.items), void 0 !== stateInfo.fields) if (this._clearStateBeforeSet(s3), null === stateInfo.fields) s3.fields = stateInfo.fields;
      else {
        s3.fields = s3.fields || {};
        for (const key in stateInfo.fields) {
          const new_f = stateInfo.fields[key];
          s3.fields[key] = s3.fields[key] || {};
          const old_f = s3.fields[key];
          isValid_default(new_f.domain) && (old_f.domain = new_f.domain), isValid_default(new_f.type) && (old_f.type = new_f.type);
        }
      }
      stateInfo.filter && (this._clearStateBeforeSet(s3), s3.filter = stateInfo.filter);
    } else this.addStateInfo(stateInfo);
  }
  clearStateInfo(stateValues) {
    stateValues.forEach((stateValue) => {
      this.getStateInfo(stateValue) && this.changeStateInfo({
        stateValue,
        datumKeys: null,
        datums: null,
        fields: null,
        items: null,
        filter: null,
        cache: {}
      });
    });
  }
  checkOneState(renderNode, datum, state, isMultiMark) {
    var _a;
    isMultiMark = isBoolean_default(isMultiDatumMark) ? isMultiMark : !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    let inState = false, stateChecked = false;
    if (isValid_default(state.datums) && state.datums.length > 0) inState = this.checkDatumState(state, datum, isMultiMark), stateChecked = true;
    else if (state.items) inState = null !== (_a = this.checkItemsState(state, renderNode)) && void 0 !== _a && _a, stateChecked = true;
    else if (state.fields) inState = this.checkFieldsState(state, datum, renderNode, isMultiMark), stateChecked = true;
    else if (!inState && state.filter) {
      const options = {
        mark: this._mark,
        renderNode,
        type: renderNode.mark.markType
      };
      inState = state.filter(datum, options), stateChecked = true;
    }
    return stateChecked ? inState ? "in" : "out" : "skip";
  }
  checkState(renderNode, datum) {
    const result2 = renderNode.getStates().filter((s3) => stateInDefaultEnum(s3)).map((s3) => [s3, 10]), isMultiMark = !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    for (let i2 = 0; i2 < this._stateInfoList.length; i2++) {
      const state = this._stateInfoList[i2], inOut = this.checkOneState(renderNode, datum, state, isMultiMark);
      "skip" !== inOut && ("in" === inOut && result2.push([state.stateValue, state.level]));
    }
    return result2.map((res) => res[0]);
  }
  checkDatumState(state, datum, isMultiMark) {
    let inState = false;
    const datum_v = isMultiMark ? datum[0] : datum;
    if (isArray_default(state.datums)) {
      const keys2 = state.datumKeys || Object.keys(state.datums[0]).filter((k3) => !k3.startsWith(PREFIX));
      inState = state.datums.some((d2) => isMultiMark && isArray_default(null == d2 ? void 0 : d2.items) ? keys2.every((k3) => {
        var _a, _b;
        return (null === (_b = null === (_a = null == d2 ? void 0 : d2.items) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b[k3]) === (null == datum_v ? void 0 : datum_v[k3]);
      }) : keys2.every((k3) => (null == d2 ? void 0 : d2[k3]) === (null == datum_v ? void 0 : datum_v[k3])));
    } else if (isObject_default(state.datums)) {
      inState = (state.datumKeys || Object.keys(state.datums).filter((k3) => !k3.startsWith(PREFIX))).every((k3) => {
        var _a, _b;
        return isMultiMark ? (null === (_a = state.datums.items) || void 0 === _a ? void 0 : _a[0][k3]) === datum_v[k3] : (null === (_b = state.datums) || void 0 === _b ? void 0 : _b[k3]) === datum_v[k3];
      });
    } else inState = datum === state.datums;
    return inState;
  }
  checkItemsState(state, item) {
    var _a;
    return null === (_a = state.items) || void 0 === _a ? void 0 : _a.includes(item);
  }
  checkFieldsState(state, datum, item, isMultiMark) {
    var _a;
    let inState = true;
    for (const key in state.fields) {
      const field5 = state.fields[key], type = field5.type, domain = field5.domain, datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
      if (isContinuous(type) && domain.length > 1) {
        if (this.checkLinearFieldState(domain, key, datum, item, isMultiMark)) {
          inState = false;
          break;
        }
        inState = true;
      } else {
        if (!domain.some((d2) => d2 === datum_v)) {
          inState = false;
          break;
        }
        inState = true;
      }
    }
    return inState;
  }
  checkLinearFieldState(domain, key, datum, item, isMultiMark) {
    var _a;
    const datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
    return datum_v < domain[0] || datum_v > domain[domain.length - 1];
  }
  updateLayoutState(noRender) {
    return this._stateMap.markUpdateRank++, this.updateState({
      markUpdateRank: this._stateMap.markUpdateRank
    }, noRender);
  }
  compileState(product2) {
    product2.state({
      callback: (datum, element) => this.checkState(element, datum)
    });
  }
};

// node_modules/@visactor/vchart/esm/compile/data/compilable-data.js
var CompilableData = class extends GrammarItem {
  getDataView() {
    return this._data;
  }
  setDataView(d2) {
    this._data = d2;
  }
  getLatestData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
  }
  constructor(option, dataView) {
    super(option), this.grammarType = GrammarType.data, this._data = null, this._data = dataView;
  }
  release() {
    super.release(), this._data = null;
  }
  updateData(noRender) {
    const product2 = this.getProduct(), data = this.getLatestData();
    return product2 && data && (product2.values(data), !noRender) ? this.getCompiler().renderAsync() : Promise.resolve();
  }
  _compileProduct() {
    const data = this.getLatestData();
    isNil_default(data) || (isNil_default(this.getProduct()) ? this._initProduct(data) : this._product.values(data));
  }
  _initProduct(data) {
    const view = this.getVGrammarView();
    if (!view || !data) return;
    const id2 = this.getProductId();
    this._product = view.data(data).id(id2), this._compiledProductId = id2;
  }
  generateProductId() {
    var _a;
    return `${null === (_a = this.getDataView()) || void 0 === _a ? void 0 : _a.name}`;
  }
  _lookupGrammar(id2) {
    var _a, _b;
    return null === (_b = null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getDataById) || void 0 === _b ? void 0 : _b.call(_a, id2);
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/mark-data.js
var MarkData = class extends CompilableData {
  constructor(option) {
    super(option), this._mark = option.mark;
  }
  setCompiledProductId(name) {
    this._compiledProductId = name;
  }
  generateProductId() {
    const name = super.generateProductId();
    return isValid_default(name) ? name : `${PREFIX}_markData_${this._mark.id}`;
  }
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct(data);
  }
};

// node_modules/@visactor/vchart/esm/compile/mark/compilable-mark.js
var __rest8 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var CompilableMark = class extends GrammarItem {
  getSkipTheme() {
    return this._skipTheme;
  }
  setSkipTheme(skipTheme) {
    this._skipTheme = skipTheme;
  }
  getSupport3d() {
    return this._support3d;
  }
  setSupport3d(support3d) {
    this._support3d = support3d;
  }
  getFacet() {
    return this._facet;
  }
  setFacet(facet) {
    this._facet = facet;
  }
  getInteractive() {
    return this._interactive;
  }
  setInteractive(interactive) {
    this._interactive = interactive;
  }
  getZIndex() {
    return this._zIndex;
  }
  setZIndex(zIndex) {
    this._zIndex = zIndex;
  }
  getVisible() {
    return this._visible;
  }
  setVisible(visible) {
    this._visible = visible;
  }
  getUserId() {
    return this._userId;
  }
  setUserId(userId) {
    isValid_default(userId) && (this._userId = userId);
  }
  getDataView() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  setDataView(d2, productId) {
    isNil_default(this._data) && this.initMarkData(Object.assign(Object.assign({}, this._option), {
      mark: this
    })), isValid_default(productId) && this._data.setCompiledProductId(productId), this._data.setDataView(d2);
  }
  getData() {
    return this._data;
  }
  setData(d2) {
    this._data = d2;
  }
  hasState(state) {
    return state in this.state.getStateMap();
  }
  getState(state) {
    return this.state.getStateMap()[state];
  }
  getAnimationConfig() {
    return this._animationConfig;
  }
  setAnimationConfig(config2) {
    this._animationConfig = config2;
  }
  setSkipBeforeLayouted(skip) {
    this._skipBeforeLayouted = skip;
  }
  getSkipBeforeLayouted() {
    return this._skipBeforeLayouted;
  }
  getMorph() {
    return this._morph;
  }
  setMorph(morph) {
    this._morph = morph;
  }
  getMorphKey() {
    return this._morphKey;
  }
  setMorphKey(morphKey) {
    this._morphKey = morphKey;
  }
  getMorphElementKey() {
    return this._morphElementKey;
  }
  setMorphElementKey(key) {
    this._morphElementKey = key;
  }
  getGroupKey() {
    return this._groupKey;
  }
  setGroupKey(groupKey) {
    this._groupKey = groupKey;
  }
  getProgressiveConfig() {
    return this._progressiveConfig;
  }
  setProgressiveConfig(config2) {
    this._progressiveConfig = config2;
  }
  setCustomizedShapeCallback(callback) {
    this._setCustomizedShape = callback;
  }
  setEnableSegments(enable) {
    this._enableSegments = enable;
  }
  constructor(option, name, model) {
    super(option), this.grammarType = GrammarType.mark, this.type = void 0, this.name = "mark", this._interactive = true, this._zIndex = LayoutZIndex.Mark, this._visible = true, this.stateStyle = {}, this._unCompileChannel = {}, this._skipBeforeLayouted = false, this._morph = false, this.name = name, this.model = model, this.key = option.key, this.state = new MarkStateManager(Object.assign(Object.assign({}, option), {
      stateKeyToSignalName: this.stateKeyToSignalName.bind(this)
    }), this), this._option.support3d && this.setSupport3d(true), this._option.skipTheme && this.setSkipTheme(true), this._event = new Event2(model.getOption().eventDispatcher, model.getOption().mode);
  }
  setTransform(transform29) {
    this._transform = transform29;
  }
  initMarkData(option) {
    this._data = new MarkData(option);
  }
  stateKeyToSignalName(key) {
    return `${PREFIX}_${this.type}_${this.id}_${key}`;
  }
  getAttribute(key, datum, state, opt) {
  }
  _compileProduct(option) {
    const product2 = this.getProduct();
    if (!this.getVisible()) return void (isValid_default(product2) && this.removeProduct());
    if (isValid_default(product2)) return;
    this.getCompiler().isInited && (this._initProduct(null == option ? void 0 : option.group), isNil_default(this._product) || (this.compileSignal(), this.compileData(), this.compileState(), this.compileEncode(), this.compileAnimation(), this.compileContext(), this.compileTransform()));
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.mark(this.type, null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
  generateProductId() {
    return this._userId ? `${this._userId}` : `${this.name}_${this.id}`;
  }
  compileData() {
    var _a;
    if (isNil_default(this._data)) return;
    this._data.compile();
    const dataProduct = this._data.getProduct();
    isValid_default(this._product) && isValid_default(dataProduct) && this._product.join(dataProduct, this.key, void 0, null !== (_a = this._groupKey) && void 0 !== _a ? _a : this._facet);
  }
  updateStaticEncode() {
    if (!this._product) return;
    const { enterStyles, updateStyles } = this._separateStyle();
    this._product.encodeState("group", enterStyles, true), this._product.encode(updateStyles, true);
  }
  _separateStyle() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, normalStyle = _a[_b], enterStyles = (__rest8(_a, ["symbol" == typeof _b ? _b : _b + ""]), this._option.noSeparateStyle ? null : {}), updateStyles = {};
    return Object.keys(normalStyle).forEach((key) => {
      this._unCompileChannel[key] || (this._option.noSeparateStyle || isStateAttrChangeable(key, normalStyle, this.getFacet()) ? updateStyles[key] = {
        callback: this.compileCommonAttributeCallback(key, "normal"),
        dependency: [this.stateKeyToSignalName("markUpdateRank")]
      } : enterStyles[key] = this.compileCommonAttributeCallback(key, "normal"));
    }), {
      enterStyles,
      updateStyles
    };
  }
  compileEncode() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, temp3 = (_a[_b], __rest8(_a, ["symbol" == typeof _b ? _b : _b + ""])), { enterStyles, updateStyles } = this._separateStyle();
    this._product.encode(updateStyles, true), this._product.encodeState("group", enterStyles, true), Object.keys(temp3).forEach((state) => {
      const styles = {};
      Object.keys(temp3[state]).forEach((key) => {
        this._unCompileChannel[key] || (styles[key] = {
          callback: this.compileCommonAttributeCallback(key, state),
          dependency: [this.stateKeyToSignalName("markUpdateRank")]
        });
      }), this._product.encodeState(state, styles, true);
    }), this._skipBeforeLayouted && this._product.layout({
      skipBeforeLayouted: this._skipBeforeLayouted
    });
  }
  compileState() {
    this.state.compileState(this._product);
  }
  compileAnimation() {
    var _a, _b;
    if (this._animationConfig) {
      let stateSignal;
      if ("component" === this.type) stateSignal = null === (_a = this.model.animate) || void 0 === _a ? void 0 : _a.getAnimationStateSignalName();
      else {
        const region = this.model.getRegion();
        stateSignal = null === (_b = region.animate) || void 0 === _b ? void 0 : _b.getAnimationStateSignalName();
      }
      this._product.animation(this._animationConfig), this._product.animationState({
        callback: (datum, element, parameters) => {
          var _a2;
          return null === (_a2 = parameters[stateSignal]) || void 0 === _a2 ? void 0 : _a2.callback(datum, element);
        },
        dependency: stateSignal
      }), this._animationConfig.normal && this._event.on(HOOK_EVENT.ANIMATION_END, ({ event }) => {
        event.mark === this.getProduct() && event.animationState === AnimationStateEnum.appear && this.runAnimationByState(AnimationStateEnum.normal);
      });
    }
  }
  compileContext() {
    const config2 = {
      interactive: this.getInteractive(),
      zIndex: this.getZIndex(),
      context: {
        markId: this.id,
        modelId: this.model.id,
        markUserId: this._userId,
        modelUserId: this.model.userId
      },
      skipTheme: this.getSkipTheme(),
      support3d: this.getSupport3d(),
      enableSegments: !!this._enableSegments
    };
    this._progressiveConfig && (config2.progressiveStep = this._progressiveConfig.progressiveStep, config2.progressiveThreshold = this._progressiveConfig.progressiveThreshold, config2.large = this._progressiveConfig.large, config2.largeThreshold = this._progressiveConfig.largeThreshold), this._morph && this._morphKey && (config2.morph = this._morph, config2.morphKey = this._morphKey, config2.morphElementKey = this._morphElementKey), this._setCustomizedShape && (config2.setCustomizedShape = this._setCustomizedShape), this._product.configure(config2);
  }
  compileSignal() {
    this.state.compile();
  }
  _computeAttribute(key, state) {
    return (datum, opt) => {
    };
  }
  compileCommonAttributeCallback(key, state) {
    const attributeFunctor = this._computeAttribute(key, state), opt = {
      mark: null,
      parent: null,
      element: null
    };
    return (datum, element) => (opt.mark = element.mark, opt.parent = element.mark.group, opt.element = element, attributeFunctor(datum, opt));
  }
  compileTransform() {
    var _a;
    (null === (_a = this._transform) || void 0 === _a ? void 0 : _a.length) && this.getProduct().transform(this._transform);
  }
  _lookupGrammar(id2) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getMarkById(id2);
  }
  updateState(newState, noRender) {
    return this.state.updateState(newState, noRender);
  }
  updateLayoutState(noRender, recursion) {
    return recursion && this.getMarks().length > 0 && this.getMarks().forEach((m5) => m5.state.updateLayoutState(true)), this.state.updateLayoutState(noRender);
  }
  updateMarkState(key) {
    if (!this._product) return;
    const stateInfo = this.state.getStateInfo(key);
    this._product.elements.forEach((e3) => {
      "in" === this.state.checkOneState(e3, e3.getDatum(), stateInfo) ? e3.addState(key) : e3.removeState(key);
    });
  }
  getMarks() {
    return [];
  }
  runAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.runAnimationByState(state);
  }
  stopAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.stopAnimationByState(state);
  }
  pauseAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.pauseAnimationByState(state);
  }
  resumeAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.resumeAnimationByState(state);
  }
  release() {
    super.release(), this.state.release();
  }
};

// node_modules/@visactor/vchart/esm/mark/base/base-mark.js
var __rest9 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var BaseMark = class extends CompilableMark {
  constructor(name, option) {
    var _a;
    super(option, name, option.model), this._extensionChannel = {}, this._computeExChannel = {}, this._attributeContext = option.attributeContext, null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
  }
  created() {
    this._initStyle();
  }
  initStyleWithSpec(spec, key) {
    spec && (isValid_default(spec.id) && (this._userId = spec.id), isBoolean_default(spec.interactive) && (this._interactive = spec.interactive), isValid_default(spec.zIndex) && this.setZIndex(spec.zIndex), isBoolean_default(spec.visible) && this.setVisible(spec.visible), this._initSpecStyle(spec, this.stateStyle, key));
  }
  convertAngleToRadian(styleConverter) {
    if (isNumber_default(styleConverter)) return degreeToRadian(styleConverter);
    if (styleConverter.scale) {
      const range2 = styleConverter.scale.range();
      return styleConverter.scale.range(range2.map(degreeToRadian)), styleConverter;
    }
    return "function" == typeof styleConverter ? (item, ctx, opt, source) => degreeToRadian(styleConverter(item, ctx, opt, source)) : styleConverter;
  }
  isUserLevel(level) {
    return [AttributeLevel.User_Mark, AttributeLevel.User_Series, AttributeLevel.User_Chart].includes(level);
  }
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style)) return;
    style = this._filterStyle(style, state, level, stateStyle), void 0 === stateStyle[state] && (stateStyle[state] = {});
    const isUserLevel = this.isUserLevel(level);
    Object.keys(style).forEach((attr) => {
      let attrStyle = style[attr];
      isNil_default(attrStyle) || (attrStyle = this._filterAttribute(attr, attrStyle, state, level, isUserLevel, stateStyle), this.setAttribute(attr, attrStyle, state, level, stateStyle));
    });
  }
  getStyle(key, state = "normal") {
    var _a;
    return null === (_a = this.stateStyle[state][key]) || void 0 === _a ? void 0 : _a.style;
  }
  _filterStyle(style, state, level, stateStyle = this.stateStyle) {
    return style;
  }
  _filterAttribute(attr, style, state, level, isUserLevel, stateStyle = this.stateStyle) {
    let newStyle = this._styleConvert(style);
    return isUserLevel && "angle" === attr && (newStyle = this.convertAngleToRadian(newStyle)), newStyle;
  }
  setReferer(mark, styleKey, state, stateStyle = this.stateStyle) {
    var _a;
    if (mark) if (styleKey && state) {
      const style = null !== (_a = stateStyle[state]) && void 0 !== _a ? _a : {
        [styleKey]: {}
      };
      stateStyle[state][styleKey] = Object.assign(Object.assign({}, style[styleKey]), {
        referer: mark
      });
    } else Object.entries(stateStyle).forEach(([state2, style]) => {
      Object.entries(style).forEach(([styleKey2, style2]) => {
        stateStyle[state2][styleKey2].referer = mark;
      });
    });
  }
  setPostProcess(key, postProcessFunc, state = "normal") {
    var _a;
    (null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key]) && (this.stateStyle[state][key].postProcess = postProcessFunc);
  }
  getAttribute(key, datum, state = "normal", opt) {
    return this._computeAttribute(key, state)(datum, opt);
  }
  setAttribute(attr, style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    var _a;
    void 0 === stateStyle[state] && (stateStyle[state] = {}), void 0 === stateStyle[state][attr] && (stateStyle[state][attr] = {
      level,
      style,
      referer: void 0
    });
    const attrLevel = null === (_a = stateStyle[state][attr]) || void 0 === _a ? void 0 : _a.level;
    isValid_default(attrLevel) && attrLevel <= level && mergeSpec(stateStyle[state][attr], {
      style,
      level
    }), "normal" !== state && attr in this._extensionChannel && this._extensionChannel[attr].forEach((key) => {
      void 0 === stateStyle[state][key] && (stateStyle[state][key] = stateStyle.normal[key]);
    });
  }
  _getDefaultStyle() {
    return {
      visible: true,
      x: 0,
      y: 0
    };
  }
  _styleConvert(style) {
    if (!style) return style;
    if (isValidScaleType(style.type) || style.scale) {
      const scale4 = createScaleWithSpec(style, {
        globalScale: this._option.globalScale,
        seriesId: this._option.seriesId
      });
      if (scale4) return {
        scale: scale4,
        field: style.field,
        changeDomain: style.changeDomain
      };
    }
    return style;
  }
  _computeAttribute(key, state) {
    var _a;
    let stateStyle = null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key];
    stateStyle || (stateStyle = this.stateStyle.normal[key]);
    const baseValueFunctor = this._computeStateAttribute(stateStyle, key, state), hasPostProcess = isFunction_default(null == stateStyle ? void 0 : stateStyle.postProcess), hasExCompute = key in this._computeExChannel;
    if (hasPostProcess && hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => {
        let baseValue = baseValueFunctor(datum, opt);
        return baseValue = stateStyle.postProcess(baseValue, datum, this._attributeContext, opt, this.getDataView()), exCompute(key, datum, state, opt, baseValue);
      };
    }
    if (hasPostProcess) return (datum, opt) => stateStyle.postProcess(baseValueFunctor(datum, opt), datum, this._attributeContext, opt, this.getDataView());
    if (hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => exCompute(key, datum, state, opt, baseValueFunctor(datum, opt));
    }
    return baseValueFunctor;
  }
  _computeStateAttribute(stateStyle, key, state) {
    var _a;
    return stateStyle ? stateStyle.referer ? stateStyle.referer._computeAttribute(key, state) : "function" == typeof stateStyle.style ? (datum, opt) => stateStyle.style(datum, this._attributeContext, opt, this.getDataView()) : GradientType.includes(stateStyle.style.gradient) ? this._computeGradientAttr(stateStyle.style) : ["outerBorder", "innerBorder"].includes(key) ? this._computeBorderAttr(stateStyle.style) : isValidScaleType(null === (_a = stateStyle.style.scale) || void 0 === _a ? void 0 : _a.type) ? (datum, opt) => stateStyle.style.scale.scale(datum[stateStyle.style.field]) : (datum, opt) => stateStyle.style : (datum, opt) => {
    };
  }
  _initStyle() {
    const defaultStyle = this._getDefaultStyle();
    this.setStyle(defaultStyle, "normal", 0);
  }
  _initSpecStyle(spec, stateStyle, key) {
    spec.style && this.setStyle(spec.style, "normal", AttributeLevel.User_Mark, stateStyle);
    const state = spec.state;
    state && Object.keys(state).forEach((key2) => {
      const stateTemp = state[key2];
      if ("style" in stateTemp) {
        const style = stateTemp.style;
        let stateInfo = {
          stateValue: key2
        };
        "level" in stateTemp && (stateInfo.level = stateTemp.level), "filter" in stateTemp && (stateInfo = isFunction_default(stateTemp.filter) ? Object.assign({
          filter: stateTemp.filter
        }, stateInfo) : Object.assign(Object.assign({}, stateTemp.filter), stateInfo)), this.state.addStateInfo(stateInfo), this.setStyle(style, key2, AttributeLevel.User_Mark, stateStyle);
      } else this.setStyle(stateTemp, key2, AttributeLevel.User_Mark, stateStyle);
    });
  }
  _computeGradientAttr(gradientStyle) {
    var _a, _b;
    const { gradient, scale: scale4, field: field5 } = gradientStyle, rest = __rest9(gradientStyle, ["gradient", "scale", "field"]);
    let colorScale = scale4, colorField = field5;
    if (!(scale4 && field5 || "series" !== this.model.modelType)) {
      const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
      scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField);
    }
    const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain()), mergedStyle = Object.assign(Object.assign({}, DEFAULT_GRADIENT_CONFIG[gradient]), rest);
    return (data, opt) => {
      const computeStyle = {}, markData = this.getDataView();
      return Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        "stops" === key ? computeStyle.stops = value.map((stop) => {
          const { opacity, color, offset } = stop;
          let computeColor = null != color ? color : null == colorScale ? void 0 : colorScale.scale(data[colorField]);
          return isFunction_default(color) && (computeColor = color(data, this._attributeContext, opt, markData)), isValid_default(opacity) && (computeColor = Color.SetOpacity(computeColor, opacity)), {
            offset: isFunction_default(offset) ? offset(data, this._attributeContext, opt, markData) : offset,
            color: computeColor || themeColor[0]
          };
        }) : isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, markData) : computeStyle[key] = value;
      }), computeStyle.gradient = gradient, computeStyle;
    };
  }
  _computeBorderAttr(borderStyle) {
    const { scale: scale4, field: field5 } = borderStyle, mergedStyle = __rest9(borderStyle, ["scale", "field"]);
    return (data, opt) => {
      var _a, _b, _c;
      const computeStyle = {};
      if (Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, this.getDataView()) : computeStyle[key] = value;
      }), "stroke" in computeStyle) GradientType.includes(null === (_c = mergedStyle.stroke) || void 0 === _c ? void 0 : _c.gradient) && (computeStyle.stroke = this._computeGradientAttr(mergedStyle.stroke)(data, opt));
      else {
        const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain());
        let colorScale = scale4, colorField = field5;
        if (!(scale4 && field5 || "series" !== this.model.modelType)) {
          const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
          scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField), computeStyle.stroke = (null == colorScale ? void 0 : colorScale.scale(data[colorField])) || themeColor[0];
        }
      }
      return computeStyle;
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/group.js
var GroupMark2 = class _GroupMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _GroupMark.type, this._marks = [];
  }
  getMarks() {
    return this._marks;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      clip: false
    });
  }
  isMarkExist(mark) {
    return void 0 !== this._marks.find((m5) => m5.id === mark.id || m5.name === mark.name);
  }
  addMark(mark) {
    return this.isMarkExist(mark) ? (warn("Mark already exists, add mark failed."), false) : (this._marks.push(mark), true);
  }
  removeMark(mark) {
    const index = this._marks.findIndex((m5) => m5.id === mark.id || m5.name === mark.name);
    return -1 === index ? (warn("Mark does not exists, removeMark failed."), false) : (this._marks.splice(index, 1), true);
  }
  getMarkInType(type) {
    return this._marks.filter((m5) => m5.type === type);
  }
  getMarkInId(id2) {
    return this._marks.find((m5) => m5.id === id2);
  }
  getMarkInName(name) {
    return this._marks.find((m5) => m5.name === name);
  }
  _compileProduct(option) {
    super._compileProduct(option), this._product.configure({
      zIndex: this.getZIndex()
    }), (null == option ? void 0 : option.ignoreChildren) || this.getMarks().forEach((mark) => {
      mark.getProduct() && mark.removeProduct(), mark.compile({
        group: this._product
      });
    });
  }
};
GroupMark2.type = "group";
var registerGroupMark = () => {
  registerGroupGraphic2(), Factory2.registerMark(GroupMark2.type, GroupMark2);
};

// node_modules/@visactor/vchart/esm/series/line/animation.js
var Appear_ClipIn = {
  type: "clipIn"
};
var Appear_FadeIn = {
  type: "fadeIn"
};
var Appear_Grow = (params2) => ({
  type: "horizontal" === params2.direction ? "growPointsXIn" : "growPointsYIn",
  options: {
    orient: "horizontal" === params2.direction ? "positive" : "negative"
  }
});
function linePresetAnimation(params2, preset) {
  switch (preset) {
    case "grow":
      return Appear_Grow(params2);
    case "fadeIn":
      return Appear_FadeIn;
    default:
      return Appear_ClipIn;
  }
}

// node_modules/@visactor/vchart/esm/animation/config.js
var DEFAULT_ANIMATION_CONFIG = {
  appear: {
    duration: 1e3,
    easing: "cubicOut"
  },
  update: {
    type: "update",
    duration: 300,
    easing: "linear"
  },
  enter: {
    duration: 300,
    easing: "linear"
  },
  exit: {
    duration: 300,
    easing: "linear"
  },
  disappear: {
    duration: 500,
    easing: "cubicIn"
  }
};
var ScaleInOutAnimation = {
  appear: {
    type: "scaleIn"
  },
  enter: {
    type: "scaleIn"
  },
  exit: {
    type: "scaleOut"
  },
  disappear: {
    type: "scaleOut"
  }
};
var FadeInOutAnimation = {
  appear: {
    type: "fadeIn"
  },
  enter: {
    type: "fadeIn"
  },
  exit: {
    type: "fadeOut"
  },
  disappear: {
    type: "fadeOut"
  }
};
var registerScaleInOutAnimation = () => {
  Factory2.registerAnimation("scaleInOut", () => ScaleInOutAnimation);
};
var registerFadeInOutAnimation = () => {
  Factory2.registerAnimation("fadeInOut", () => FadeInOutAnimation);
};
var registerCartesianGroupClipAnimation = () => {
  Factory2.registerAnimation("cartesianGroupClip", (params2) => ({
    appear: {
      custom: ClipDirectionAnimate,
      customParameters: (datum, element) => ({
        animationType: "in",
        group: element.getGraphicItem(),
        direction: params2.direction(),
        width: params2.width(),
        height: params2.height(),
        orient: params2.orient()
      })
    },
    disappear: {
      custom: ClipDirectionAnimate,
      customParameters: (datum, element) => ({
        animationType: "out",
        group: element.getGraphicItem(),
        direction: params2.direction(),
        width: params2.width(),
        height: params2.height(),
        orient: params2.orient()
      })
    }
  }));
};
var registerLineAnimation = () => {
  Factory2.registerAnimation("line", (params2, preset) => ({
    appear: linePresetAnimation(params2, preset),
    enter: {
      type: "fadeIn"
    },
    exit: {
      type: "fadeOut"
    },
    update: [{
      type: "update",
      options: {
        excludeChannels: ["points", "defined"]
      }
    }, {
      channel: ["points"],
      custom: TagPointsUpdate,
      duration: DEFAULT_ANIMATION_CONFIG.update.duration,
      easing: DEFAULT_ANIMATION_CONFIG.update.easing
    }],
    disappear: {
      type: "clipOut"
    }
  }));
};
var registerVGrammarCommonAnimation = () => {
  View.useRegisters([registerScaleInAnimation, registerScaleOutAnimation, registerFadeInAnimation, registerFadeOutAnimation, registerMoveInAnimation, registerMoveOutAnimation, registerRotateInAnimation, registerRotateOutAnimation, registerUpdateAnimation]);
};
var registerVGrammarRectAnimation = () => {
  View.useRegisters([registerGrowHeightInAnimation, registerGrowHeightOutAnimation, registerGrowWidthInAnimation, registerGrowWidthOutAnimation, registerGrowCenterInAnimation, registerGrowCenterOutAnimation]);
};
var registerVGrammarArcAnimation = () => {
  View.useRegisters([registerGrowRadiusInAnimation, registerGrowRadiusOutAnimation, registerGrowAngleInAnimation, registerGrowAngleOutAnimation]);
};
var registerVGrammarLineOrAreaAnimation = () => {
  View.useRegisters([registerGrowPointsInAnimation, registerGrowPointsOutAnimation, registerGrowPointsXInAnimation, registerGrowPointsXOutAnimation, registerGrowPointsYInAnimation, registerGrowPointsYOutAnimation, registerClipInAnimation, registerClipOutAnimation]);
};
var registerVGrammarPolygonAnimation = () => {
  View.useRegisters([registerGrowPointsInAnimation, registerGrowPointsOutAnimation]);
};

// node_modules/@visactor/vchart/esm/core/util.js
var VCHART_UTILS = {
  measureText
};

// node_modules/@visactor/vchart/esm/core/expression-function.js
var ExpressionFunction = class _ExpressionFunction {
  static instance() {
    return _ExpressionFunction.instance_ || (_ExpressionFunction.instance_ = new _ExpressionFunction()), _ExpressionFunction.instance_;
  }
  constructor() {
    this.functions = {};
  }
  registerFunction(name, fun) {
    name && fun && (this.functions[name] = fun);
  }
  unregisterFunction(name) {
    name && delete this.functions[name];
  }
  getFunction(name) {
    return this.functions[name] || null;
  }
  getFunctionNameList() {
    return Object.keys(this.functions);
  }
};

// node_modules/@visactor/vchart/esm/env/env.js
var registerBrowserEnv = () => {
  loadBrowserEnv(container);
};
var registerNodeEnv = () => {
  loadNodeEnv(container);
};

// node_modules/@visactor/vchart/esm/plugin/base/base-plugin-service.js
var BasePluginService = class {
  constructor() {
    this.id = createID(), this._plugins = [];
  }
  add(plugins) {
    if (!plugins || 0 === plugins.length) return null;
    const unloadedPlugins = [];
    return plugins.forEach((plugin) => {
      this._plugins.find((p2) => p2.id === plugin.id) ? warn("不要重复添加相同的plugin") : (this._plugins.push(plugin), unloadedPlugins.push(plugin), plugin.onAdd && plugin.onAdd(this));
    }), unloadedPlugins;
  }
  load(plugins) {
    const unloadedPlugins = this.add(plugins);
    unloadedPlugins && unloadedPlugins.length && this.activate(plugins);
  }
  activate(plugins) {
    plugins.length && plugins.forEach((plugin) => {
      plugin.init && plugin.init();
    });
  }
  get(id2) {
    return this._plugins.find((p2) => p2.id === id2);
  }
  getAll() {
    return this._plugins.slice();
  }
  dispose(pluginsId) {
    const plugin = this._plugins.find((p2) => p2.id === pluginsId);
    plugin && plugin.dispose && plugin.dispose(this);
  }
  disposeAll() {
    this._plugins.forEach((plugin) => {
      plugin.dispose && plugin.dispose(this);
    });
  }
};

// node_modules/@visactor/vchart/esm/plugin/chart/plugin-service.js
var ChartPluginService = class extends BasePluginService {
  constructor(globalInstance) {
    super(), this.globalInstance = globalInstance;
  }
  onInit(chartSpec) {
    this._plugins.forEach((plugin) => {
      plugin.onInit && plugin.onInit(this, chartSpec);
    });
  }
  onBeforeResize(width, height) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeResize && plugin.onBeforeResize(this, width, height);
    });
  }
  onAfterChartSpecTransform(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onAfterChartSpecTransform && plugin.onAfterChartSpecTransform(this, chartSpec, actionSource);
    });
  }
  onBeforeInitChart(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeInitChart && plugin.onBeforeInitChart(this, chartSpec, actionSource);
    });
  }
};

// node_modules/@visactor/vchart/esm/core/vchart.js
var __awaiter15 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest10 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var VChart = class _VChart {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      "function" == typeof fn ? fn() : console.error("Invalid function:", fn);
    });
  }
  static useChart(charts) {
    charts.forEach((c4) => Factory2.registerChart(c4.type, c4));
  }
  static useSeries(series2) {
    series2.forEach((s3) => Factory2.registerSeries(s3.type, s3));
  }
  static useComponent(components) {
    components.forEach((c4) => Factory2.registerComponent(c4.type, c4));
  }
  static useMark(marks) {
    marks.forEach((m5) => {
      var _a;
      return Factory2.registerMark(null !== (_a = m5.constructorType) && void 0 !== _a ? _a : m5.type, m5);
    });
  }
  static useLayout(layouts) {
    layouts.forEach((l2) => Factory2.registerLayout(l2.type, l2));
  }
  static registerDataSetTransform(name, transform29) {
    Factory2.registerTransform(name, transform29);
  }
  static registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  static unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  static getFunction(key) {
    return key ? ExpressionFunction.instance().getFunction(key) : null;
  }
  static getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  static registerMap(key, source, option) {
    const impl = Factory2.getImplementInKey("registerMap");
    impl && impl(key, source, option);
  }
  static unregisterMap(key) {
    const impl = Factory2.getImplementInKey("unregisterMap");
    impl && impl(key);
  }
  static getMap(key) {
    return getMapSource(key);
  }
  static hideTooltip(excludeId = []) {
    InstanceManager.forEach((instance) => {
      var _a;
      return null === (_a = null == instance ? void 0 : instance.hideTooltip) || void 0 === _a ? void 0 : _a.call(instance);
    }, excludeId);
  }
  static getLogger() {
    return Logger.getInstance();
  }
  getSpec() {
    return this._spec;
  }
  getSpecInfo() {
    return this._specInfo;
  }
  getDataSet() {
    return this._dataSet;
  }
  constructor(spec, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.id = createID(), this._userEvents = [], this._autoSize = true, this._option = {
      mode: RenderModeEnum["desktop-browser"],
      onError: (msg) => {
        throw new Error(msg);
      },
      optimize: {
        disableCheckGraphicWidthOutRange: true
      }
    }, this._observer = null, this._context = {}, this._onResize = debounce_default((...args) => {
      this._doResize();
    }, 100), this._option = merge(this._option, {
      animation: false !== spec.animation
    }, options), this._onError = null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError;
    const _h = this._option, { dom, renderCanvas, mode: mode2, stage, poptip: poptip2 } = _h, restOptions = __rest10(_h, ["dom", "renderCanvas", "mode", "stage", "poptip"]), isTrueBrowseEnv = isTrueBrowser(mode2);
    isTrueBrowseEnv && dom && (this._container = isString_default(dom) ? null === document || void 0 === document ? void 0 : document.getElementById(dom) : dom), renderCanvas && (this._canvas = renderCanvas), stage && (this._stage = stage), "node" === mode2 || this._container || this._canvas || this._stage ? (isTrueBrowseEnv ? registerBrowserEnv() : "node" === mode2 && registerNodeEnv(), this._viewBox = this._option.viewBox, this._currentThemeName = ThemeManager2.getCurrentThemeName(), this._setNewSpec(spec), this._updateCurrentTheme(), this._currentSize = this.getCurrentSize(), this._compiler = new Compiler({
      dom: null !== (_c = this._container) && void 0 !== _c ? _c : "none",
      canvas: renderCanvas
    }, Object.assign(Object.assign({
      mode: this._option.mode,
      stage,
      pluginList: false !== poptip2 ? ["poptipForText"] : []
    }, restOptions), {
      background: this._getBackground(),
      onError: this._onError
    })), this._compiler.setSize(this._currentSize.width, this._currentSize.height), this._eventDispatcher = new EventDispatcher(this, this._compiler), this._event = new Event2(this._eventDispatcher, mode2), this._compiler.initView(), null === (_d = this.getStage()) || void 0 === _d || _d.setTheme({
      text: {
        fontFamily: null === (_e = this._currentTheme) || void 0 === _e ? void 0 : _e.fontFamily
      }
    }), this._initDataSet(this._option.dataSet), this._autoSize = !!isTrueBrowseEnv && (null === (_g = null !== (_f = spec.autoFit) && void 0 !== _f ? _f : this._option.autoFit) || void 0 === _g || _g), this._bindResizeEvent(), this._bindVGrammarViewEvent(), this._initChartPlugin(), InstanceManager.registerInstance(this)) : null === (_b = this._option) || void 0 === _b || _b.onError("please specify container or renderCanvas!");
  }
  _setNewSpec(spec, forceMerge) {
    return !!spec && (isString_default(spec) && (spec = JSON.parse(spec)), forceMerge && this._originalSpec && (spec = mergeSpec({}, this._originalSpec, spec)), this._originalSpec = spec, this._spec = this._getSpecFromOriginalSpec(), true);
  }
  _getSpecFromOriginalSpec() {
    var _a;
    const spec = specTransform(this._originalSpec);
    return spec.data = null !== (_a = spec.data) && void 0 !== _a ? _a : [], spec;
  }
  _initChartSpec(spec, actionSource) {
    var _a;
    _VChart.getFunctionList() && _VChart.getFunctionList().length && (spec = functionTransform(spec, _VChart)), this._spec = spec, this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, {
      type: this._spec.type,
      getTheme: () => {
        var _a2;
        return null !== (_a2 = this._currentTheme) && void 0 !== _a2 ? _a2 : {};
      },
      animation: this._option.animation
    })), this._chartSpecTransformer.transformSpec(this._spec), this._chartPluginApply("onAfterChartSpecTransform", this._spec, actionSource), this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.transformModelSpec(this._spec), this._chartPluginApply("onAfterModelSpecTransform", this._spec, this._specInfo, actionSource);
  }
  _updateSpecInfo() {
    var _a;
    this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, {
      type: this._spec.type,
      getTheme: () => {
        var _a2;
        return null !== (_a2 = this._currentTheme) && void 0 !== _a2 ? _a2 : {};
      }
    })), this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.createSpecInfo(this._spec);
  }
  _initChart(spec) {
    var _a, _b;
    if (!this._compiler) return void (null === (_a = this._option) || void 0 === _a || _a.onError("compiler is not initialized"));
    const chart = Factory2.createChart(spec.type, spec, {
      type: spec.type,
      globalInstance: this,
      eventDispatcher: this._eventDispatcher,
      dataSet: this._dataSet,
      container: this._container,
      canvas: this._canvas,
      map: /* @__PURE__ */ new Map(),
      mode: this._option.mode || RenderModeEnum["desktop-browser"],
      modeParams: this._option.modeParams,
      getCompiler: () => this._compiler,
      performanceHook: this._option.performanceHook,
      viewBox: this._viewBox,
      animation: this._option.animation,
      getTheme: () => {
        var _a2;
        return null !== (_a2 = this._currentTheme) && void 0 !== _a2 ? _a2 : {};
      },
      getSpecInfo: () => {
        var _a2;
        return null !== (_a2 = this._specInfo) && void 0 !== _a2 ? _a2 : {};
      },
      layout: this._option.layout,
      onError: this._onError,
      disableTriggerEvent: true === this._option.disableTriggerEvent
    });
    chart ? (this._chart = chart, this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height), this._chart.created(), this._chart.init(), this._event.emit(ChartEvent.initialized, {})) : null === (_b = this._option) || void 0 === _b || _b.onError("init chart fail");
  }
  _releaseData() {
    this._dataSet && (this._dataSet.dataViewMap = {}, this._dataSet = null);
  }
  _bindVGrammarViewEvent() {
    this._compiler && !this._compiler.isReleased && (this._compiler.getVGrammarView().addEventListener(HOOK_EVENT.ALL_ANIMATION_END, () => {
      this._event.emit(ChartEvent.animationFinished, {});
    }), this._compiler.getVGrammarView().addEventListener(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER, () => {
      this._event.emit(ChartEvent.renderFinished, {});
    }));
  }
  _bindResizeEvent() {
    var _a;
    if (this._autoSize) {
      if (this._container) {
        const ResizeObserverWindow = window.ResizeObserver;
        this._observer = new ResizeObserverWindow(this._onResize), null === (_a = this._observer) || void 0 === _a || _a.observe(this._container);
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this._autoSize && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  getCurrentSize() {
    var _a, _b, _c, _d;
    return calculateChartSize(this._spec, {
      container: this._container,
      canvas: this._canvas,
      mode: this._option.mode || RenderModeEnum["desktop-browser"],
      modeParams: this._option.modeParams
    }, {
      width: null !== (_b = null === (_a = this._currentSize) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : DEFAULT_CHART_WIDTH,
      height: null !== (_d = null === (_c = this._currentSize) || void 0 === _c ? void 0 : _c.height) && void 0 !== _d ? _d : DEFAULT_CHART_HEIGHT
    });
  }
  _doResize() {
    const { width, height } = this.getCurrentSize();
    this._currentSize.width === width && this._currentSize.height === height || (this._currentSize = {
      width,
      height
    }, this.resize(width, height));
  }
  _initDataSet(dataSet) {
    this._dataSet = dataSet instanceof DataSet ? dataSet : new DataSet(), registerDataSetInstanceParser(this._dataSet, "dataview", dataViewParser), registerDataSetInstanceParser(this._dataSet, "array", arrayParser), registerDataSetInstanceTransform(this._dataSet, "stackSplit", stackSplit), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView);
    for (const key in Factory2.transforms) registerDataSetInstanceTransform(this._dataSet, key, Factory2.transforms[key]);
    for (const key in Factory2.dataParser) registerDataSetInstanceParser(this._dataSet, key, Factory2.dataParser[key]);
  }
  updateCustomConfigAndRerender(updateSpecResult, sync, option = {}) {
    if (!this._isReleased && updateSpecResult) return isFunction_default(updateSpecResult) && (updateSpecResult = updateSpecResult()), this._reCompile(updateSpecResult), sync ? this._renderSync(option) : this._renderAsync(option);
  }
  _updateCustomConfigAndRecompile(updateSpecResult, option = {}) {
    return !!updateSpecResult && (this._reCompile(updateSpecResult), this._beforeRender(option));
  }
  _reCompile(updateResult, morphConfig) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (updateResult.reMake) this._releaseData(), this._initDataSet(), this._chartSpecTransformer = null, this._chart.release(), this._chart = null, null === (_a = this._compiler) || void 0 === _a || _a.releaseGrammar(false === (null === (_b = this._option) || void 0 === _b ? void 0 : _b.animation) || false === (null === (_c = this._spec) || void 0 === _c ? void 0 : _c.animation)), this._userEvents.forEach((e3) => {
      var _a2;
      return null === (_a2 = this._event) || void 0 === _a2 ? void 0 : _a2.on(e3.eType, e3.query, e3.handler);
    }), updateResult.reSize && this._doResize();
    else if (updateResult.reCompile && (null === (_d = this._compiler) || void 0 === _d || _d.clear({
      chart: this._chart,
      vChart: this
    }, !this._option.animation || !this._spec.animation), null === (_e = this._compiler) || void 0 === _e || _e.compile({
      chart: this._chart,
      vChart: this
    }, {})), updateResult.reSize) {
      const { width, height } = this.getCurrentSize();
      this._chart.onResize(width, height, false), null === (_g = (_f = this._compiler).resize) || void 0 === _g || _g.call(_f, width, height, false);
    }
  }
  _beforeRender(option = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._isReleased) return false;
    if (this._chart) return true;
    const { transformSpec, actionSource } = option;
    return transformSpec && this._initChartSpec(this._spec, "render"), this._chartPluginApply("onBeforeInitChart", this._spec, actionSource), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeInitializeChart) || void 0 === _b || _b.call(_a), this._initChart(this._spec), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterInitializeChart) || void 0 === _d || _d.call(_c), !(!this._chart || !this._compiler) && (null === (_f = null === (_e = this._option.performanceHook) || void 0 === _e ? void 0 : _e.beforeCompileToVGrammar) || void 0 === _f || _f.call(_e), this._compiler.compile({
      chart: this._chart,
      vChart: this
    }, {
      performanceHook: this._option.performanceHook
    }), null === (_h = null === (_g = this._option.performanceHook) || void 0 === _g ? void 0 : _g.afterCompileToVGrammar) || void 0 === _h || _h.call(_g), true);
  }
  _afterRender() {
    return !this._isReleased && (this._updateAnimateState(), this._event.emit(ChartEvent.rendered, {}), true);
  }
  renderSync(morphConfig) {
    return this._renderSync({
      morphConfig,
      transformSpec: true,
      actionSource: "render"
    });
  }
  renderAsync(morphConfig) {
    return __awaiter15(this, void 0, void 0, function* () {
      return this._renderAsync({
        morphConfig,
        transformSpec: true,
        actionSource: "render"
      });
    });
  }
  _renderSync(option = {}) {
    var _a;
    const self = this;
    return this._beforeRender(option) ? (null === (_a = this._compiler) || void 0 === _a || _a.renderSync(option.morphConfig), this._afterRender(), self) : self;
  }
  _renderAsync(option = {}) {
    var _a;
    return __awaiter15(this, void 0, void 0, function* () {
      const self = this;
      return this._beforeRender(option) ? (yield null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.renderAsync(option.morphConfig), this._afterRender(), self) : self;
    });
  }
  _updateAnimateState() {
    var _a, _b;
    this._option.animation && (null === (_a = this._chart) || void 0 === _a || _a.getAllRegions().forEach((region) => {
      var _a2;
      null === (_a2 = region.animate) || void 0 === _a2 || _a2.updateAnimateState(AnimationStateEnum.update, true);
    }), null === (_b = this._chart) || void 0 === _b || _b.getAllComponents().forEach((component2) => {
      var _a2;
      null === (_a2 = component2.animate) || void 0 === _a2 || _a2.updateAnimateState(AnimationStateEnum.update, true);
    }));
  }
  release() {
    var _a, _b, _c, _d;
    (null === (_a = this._onResize) || void 0 === _a ? void 0 : _a.cancel) && this._onResize.cancel(), this._chartPluginApply("disposeAll"), this._chartSpecTransformer = null, null === (_b = this._chart) || void 0 === _b || _b.release(), null === (_c = this._compiler) || void 0 === _c || _c.release(), null === (_d = this._eventDispatcher) || void 0 === _d || _d.release(), this._unBindResizeEvent(), this._releaseData(), this._chart = null, this._compiler = null, this._spec = null, this._originalSpec = null, this._userEvents = null, this._event = null, this._eventDispatcher = null, this._isReleased = true, InstanceManager.unregisterInstance(this);
  }
  updateData(id2, data, options) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (isNil_default(this._dataSet)) return this;
      if (this._chart) return this._chart.updateData(id2, data, true, options), yield this._compiler.renderAsync(), this;
      this._spec.data = array(this._spec.data);
      const preDV = this._spec.data.find((dv) => dv.name === id2 || dv.id === id2);
      return preDV ? preDV.id === id2 ? preDV.values = data : preDV.name === id2 && preDV.parse(data, options) : isArray_default(data) ? this._spec.data.push({
        id: id2,
        values: data
      }) : this._spec.data.push(data), this;
    });
  }
  updateDataInBatches(list) {
    return __awaiter15(this, void 0, void 0, function* () {
      return this._chart ? (this._chart.updateFullData(list.map(({ id: id2, data, options }) => ({
        id: id2,
        values: data,
        parser: options
      }))), this._chart.updateGlobalScaleDomain(), yield this._compiler.renderAsync(), this) : (list.forEach(({ id: id2, data, options }) => {
        const preDV = this._spec.data.find((dv) => dv.name === id2);
        if (preDV) preDV.parse(data, options);
        else {
          const dataView = new DataView(this._dataSet, {
            name: id2
          });
          dataView.parse(data, options), this._spec.data.push(dataView);
        }
      }), this);
    });
  }
  updateDataSync(id2, data, options) {
    if (isNil_default(this._dataSet)) return this;
    if (this._chart) return this._chart.updateData(id2, data, true, options), this._compiler.renderSync(), this;
    const preDV = this._spec.data.find((dv) => dv.name === id2);
    if (preDV) preDV.parse(data, options);
    else {
      const dataView = new DataView(this._dataSet, {
        name: id2
      });
      dataView.parse(data, options), this._spec.data.push(dataView);
    }
    return this;
  }
  updateFullDataSync(data, reRender = true) {
    if (this._chart) return this._chart.updateFullData(data), reRender && this._compiler.renderSync(), this;
    return array(data).forEach((d2) => {
      var _a;
      const { id: id2, values, parser, fields: fields2 } = d2, preDV = this._spec.data.find((dv) => dv.name === id2);
      if (preDV) preDV.setFields(cloneDeep(fields2)), preDV.parse(values, cloneDeep(parser));
      else {
        const dataView = dataToDataView(d2, this._dataSet, this._spec.data, {
          onError: null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError
        });
        this._spec.data.push(dataView);
      }
    }), this;
  }
  updateFullData(data, reRender = true) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (this._chart) return this._chart.updateFullData(data), reRender && (yield this._compiler.renderAsync()), this;
      return array(data).forEach((d2) => {
        var _a;
        const { id: id2, values, parser, fields: fields2 } = d2, preDV = this._spec.data.find((dv) => dv.name === id2);
        if (preDV) preDV.setFields(cloneDeep(fields2)), preDV.parse(values, cloneDeep(parser));
        else {
          const dataView = dataToDataView(d2, this._dataSet, this._spec.data, {
            onError: null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError
          });
          this._spec.data.push(dataView);
        }
      }), this;
    });
  }
  updateSpec(spec, forceMerge = false, morphConfig) {
    return __awaiter15(this, void 0, void 0, function* () {
      const result2 = this._updateSpec(spec, forceMerge);
      return yield this.updateCustomConfigAndRerender(result2, false, {
        morphConfig,
        transformSpec: true,
        actionSource: "updateSpec"
      }), this;
    });
  }
  updateSpecSync(spec, forceMerge = false, morphConfig) {
    const result2 = this._updateSpec(spec, forceMerge);
    return this.updateCustomConfigAndRerender(result2, true, {
      morphConfig,
      transformSpec: true,
      actionSource: "updateSpec"
    }), this;
  }
  updateSpecAndRecompile(spec, forceMerge = false, option = {}) {
    const result2 = this._updateSpec(spec, forceMerge);
    return this._updateCustomConfigAndRecompile(result2, Object.assign({
      actionSource: "updateSpecAndRecompile"
    }, option));
  }
  _updateSpec(spec, forceMerge = false) {
    var _a, _b;
    const lastSpec = this._spec;
    if (!this._setNewSpec(spec, forceMerge)) return;
    isEqual(lastSpec.theme, this._spec.theme) || this._setCurrentTheme();
    const reSize = this._shouldChartResize(lastSpec);
    return null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b || _b.updateLayoutTag(), mergeUpdateResult(this._chart.updateSpec(this._spec), {
      change: reSize,
      reMake: false,
      reCompile: false,
      reSize
    });
  }
  updateModelSpec(filter2, spec, forceMerge = false, morphConfig) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (!spec || !this._spec) return this;
      if (isString_default(spec) && (spec = JSON.parse(spec)), isFunction_default(filter2) || mergeSpecWithFilter(this._spec, filter2, spec, forceMerge), this._chart) {
        const model = this._chart.getModelInFilter(filter2);
        if (model) return this._updateModelSpec(model, spec, false, forceMerge, morphConfig);
      }
      return this;
    });
  }
  updateModelSpecSync(filter2, spec, forceMerge = false, morphConfig) {
    if (!spec || !this._spec) return this;
    if (isString_default(spec) && (spec = JSON.parse(spec)), isFunction_default(filter2) || mergeSpecWithFilter(this._spec, filter2, spec, forceMerge), this._chart) {
      const model = this._chart.getModelInFilter(filter2);
      if (model) return this._updateModelSpec(model, spec, true, forceMerge, morphConfig);
    }
    return this;
  }
  _updateModelSpec(model, spec, sync = false, forceMerge = false, morphConfig) {
    forceMerge && (spec = mergeSpec({}, model.getSpec(), spec));
    const result2 = model.updateSpec(spec);
    return model.reInit(spec), (result2.change || result2.reCompile || result2.reMake || result2.reSize || result2.reRender) && this._chart.reDataFlow(), this.updateCustomConfigAndRerender(result2, sync, {
      morphConfig,
      transformSpec: false,
      actionSource: "updateModelSpec"
    });
  }
  resize(width, height) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter15(this, void 0, void 0, function* () {
      if (!this._chart || !this._compiler) return this;
      const chartCanvasRect = this._chart.getCanvasRect();
      return chartCanvasRect && chartCanvasRect.width === width && chartCanvasRect.height === height ? this : (this._chartPluginApply("onBeforeResize", width, height), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeResizeWithUpdate) || void 0 === _b || _b.call(_a), this._chart.onResize(width, height, false), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterResizeWithUpdate) || void 0 === _d || _d.call(_c), yield null === (_f = (_e = this._compiler).resize) || void 0 === _f ? void 0 : _f.call(_e, width, height), this._isReleased || this._event.emit(ChartEvent.afterResize, {
        chart: this._chart
      }), this);
    });
  }
  updateViewBox(viewBox, reRender = true, reLayout = true) {
    return this._chart && this._compiler ? (this._viewBox = viewBox, this._chart.updateViewBox(viewBox, reLayout), reLayout && (this._compiler.renderSync(), this._chart.onEvaluateEnd()), this._compiler.updateViewBox(viewBox, reRender), this) : this;
  }
  on(eType, query, handler) {
    var _a;
    this._userEvents && (this._userEvents.push({
      eType,
      query: "function" == typeof query ? null : query,
      handler: "function" == typeof query ? query : handler
    }), null === (_a = this._event) || void 0 === _a || _a.on(eType, query, handler));
  }
  off(eType, handler) {
    var _a;
    if (this._userEvents && 0 !== this._userEvents.length) if (handler) {
      const index = this._userEvents.findIndex((e3) => e3.eType === eType && e3.handler === handler);
      index >= 0 && (this._userEvents.splice(index, 1), null === (_a = this._event) || void 0 === _a || _a.off(eType, handler));
    } else this._userEvents.forEach((e3) => {
      var _a2;
      e3.eType === eType && (null === (_a2 = this._event) || void 0 === _a2 || _a2.off(eType, e3.handler));
    }), this._userEvents = this._userEvents.filter((e3) => e3.eType !== eType);
  }
  updateState(state, filter2) {
    this._chart && this._chart.updateState(state, filter2);
  }
  setSelected(datum, filter2, region) {
    this._chart && this._chart.setSelected(datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._chart && this._chart.setHovered(datum, filter2, region);
  }
  _updateCurrentTheme(nextThemeName) {
    var _a, _b;
    const optionTheme = this._option.theme, specTheme = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.theme;
    if (nextThemeName && (this._currentThemeName = nextThemeName), isEmpty_default(optionTheme) && isEmpty_default(specTheme)) this._currentTheme = getThemeObject(this._currentThemeName, true);
    else if (isString_default(optionTheme) && (!specTheme || isString_default(specTheme)) || isString_default(specTheme) && (!optionTheme || isString_default(optionTheme))) {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName, true), getThemeObject(optionTheme, true), getThemeObject(specTheme, true));
      this._currentTheme = finalTheme;
    } else {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName), getThemeObject(optionTheme), getThemeObject(specTheme));
      this._currentTheme = preprocessTheme(finalTheme, finalTheme.colorScheme);
    }
    setPoptipTheme(get_default(this._currentTheme, "component.poptip")), null === (_b = this._compiler) || void 0 === _b || _b.setBackground(this._getBackground());
  }
  _shouldChartResize(oldSpec) {
    var _a, _b;
    let resize = false;
    isNil_default(this._spec.width) ? this._spec.width = oldSpec.width : this._spec.width !== oldSpec.width && (resize = true), isNil_default(this._spec.height) ? this._spec.height = oldSpec.height : this._spec.height !== oldSpec.height && (resize = true);
    const lasAutoSize = this._autoSize;
    return this._autoSize = !!isTrueBrowser(this._option.mode) && (null === (_b = null !== (_a = this._spec.autoFit) && void 0 !== _a ? _a : this._option.autoFit) || void 0 === _b || _b), this._autoSize !== lasAutoSize && (resize = true), resize;
  }
  _getBackground() {
    return ("string" == typeof this._spec.background ? this._spec.background : null) || this._currentTheme.background || this._option.background;
  }
  getCurrentTheme() {
    return getThemeObject(this._currentThemeName);
  }
  getCurrentThemeName() {
    return this._currentThemeName;
  }
  setCurrentTheme(name) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (!ThemeManager2.themeExist(name)) return this;
      const result2 = this._setCurrentTheme(name);
      return yield this.updateCustomConfigAndRerender(result2, false, {
        transformSpec: false,
        actionSource: "setCurrentTheme"
      }), this;
    });
  }
  setCurrentThemeSync(name) {
    if (!ThemeManager2.themeExist(name)) return this;
    const result2 = this._setCurrentTheme(name);
    return this.updateCustomConfigAndRerender(result2, true, {
      transformSpec: false,
      actionSource: "setCurrentTheme"
    }), this;
  }
  _setCurrentTheme(name) {
    var _a;
    return this._updateCurrentTheme(name), this._initChartSpec(this._getSpecFromOriginalSpec(), "setCurrentTheme"), null === (_a = this._chart) || void 0 === _a || _a.setCurrentTheme(), {
      change: true,
      reMake: false
    };
  }
  _getTooltipComponent() {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().find((c4) => c4.type === ComponentTypeEnum.tooltip);
  }
  setTooltipHandler(tooltipHandler) {
    var _a, _b;
    this._context.tooltipHandler = tooltipHandler;
    const tooltip3 = this._getTooltipComponent();
    tooltip3 && (null === (_b = null === (_a = tooltip3.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), tooltip3.tooltipHandler = tooltipHandler);
  }
  getTooltipHandlerByUser() {
    var _a;
    return null === (_a = this._context) || void 0 === _a ? void 0 : _a.tooltipHandler;
  }
  getTooltipHandler() {
    const tooltip3 = this._getTooltipComponent();
    return tooltip3 ? tooltip3.tooltipHandler : this._context.tooltipHandler;
  }
  showTooltip(datum, options) {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = isValid_default(datum) && "none" !== (null == tooltip3 ? void 0 : tooltip3.showTooltip(datum, options))) && void 0 !== _a && _a;
  }
  hideTooltip() {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = null == tooltip3 ? void 0 : tooltip3.hideTooltip()) && void 0 !== _a && _a;
  }
  getLegendDataById(id2) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    return legendComponent ? legendComponent.getLegendData() : [];
  }
  getLegendDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c4) => c4.type === ComponentTypeEnum.discreteLegend);
    return legends[index] ? legends[index].getLegendData() : [];
  }
  getLegendSelectedDataById(id2) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    return legendComponent ? legendComponent.getSelectedData() : [];
  }
  getLegendSelectedDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c4) => c4.type === ComponentTypeEnum.discreteLegend);
    return legends[index] ? legends[index].getSelectedData() : [];
  }
  setLegendSelectedDataById(id2, selectedData) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    legendComponent && legendComponent.setSelectedData(selectedData);
  }
  setLegendSelectedDataByIndex(index = 0, selectedData) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c4) => c4.type === ComponentTypeEnum.discreteLegend);
    legends[index] && legends[index].setSelectedData(selectedData);
  }
  getDataURL() {
    var _a;
    return __awaiter15(this, void 0, void 0, function* () {
      const stage = this.getStage();
      if (this._chart && stage) {
        stage.render();
        const canvas = this._chart.getCanvas();
        return yield getCanvasDataURL(canvas, {
          onError: this._onError
        });
      }
      return null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined")), null;
    });
  }
  exportImg(name) {
    var _a, _b;
    return __awaiter15(this, void 0, void 0, function* () {
      if (!isTrueBrowser(this._option.mode)) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("non-browser environment can not export img")));
      const dataURL = yield this.getDataURL();
      dataURL ? URLToImage(name, dataURL) : null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined"));
    });
  }
  exportCanvas() {
    var _a;
    const stage = this.getStage();
    if (this._chart && stage) return stage.toCanvas();
    null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined"));
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._option.mode) return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("getImageBuffer() now only support node environment.")));
    const stage = this.getStage();
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined")), null;
  }
  setLayout(layout2) {
    var _a;
    this._option.layout = layout2, null === (_a = this._chart) || void 0 === _a || _a.setLayout(layout2);
  }
  reLayout() {
    var _a;
    null === (_a = this._chart) || void 0 === _a || _a.setLayoutTag(true);
  }
  getCompiler() {
    return this._compiler;
  }
  getChart() {
    return this._chart;
  }
  getStage() {
    return this._compiler.getStage();
  }
  getCanvas() {
    var _a;
    return null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getCanvas();
  }
  getContainer() {
    var _a;
    if (isValid_default(this._container)) return this._container;
    let canvasNode;
    return canvasNode = isString_default(this._canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(this._canvas) : this._canvas, isValid_default(canvasNode) ? canvasNode.parentElement : null === (_a = this.getCanvas()) || void 0 === _a ? void 0 : _a.parentElement;
  }
  getComponents() {
    return this._chart.getAllComponents();
  }
  setDimensionIndex(value, opt = {}) {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.setDimensionIndex(value, opt);
  }
  stopAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.stop();
  }
  pauseAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.pause();
  }
  resumeAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.resume();
  }
  convertDatumToPosition(datum, dataLinkInfo = {}, isRelativeToCanvas = false) {
    var _a;
    if (!this._chart) return null;
    if (isEmpty_default(datum)) return null;
    const { seriesId, seriesIndex = 0 } = dataLinkInfo;
    let series2;
    if (isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_a = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _a ? void 0 : _a[0]), series2) {
      const keys2 = Object.keys(datum), handledDatum = series2.getViewData().latestData.find((viewDatum) => keys2.every((k3) => viewDatum[k3] == datum[k3])), seriesLayoutStartPoint = series2.getRegion().getLayoutStartPoint();
      let point6;
      return point6 = handledDatum ? series2.dataToPosition(handledDatum) : series2.dataToPosition(datum), convertPoint(point6, seriesLayoutStartPoint, isRelativeToCanvas);
    }
    return null;
  }
  convertValueToPosition(value, dataLinkInfo, isRelativeToCanvas = false) {
    var _a, _b;
    if (!this._chart || isNil_default(value) || isEmpty_default(dataLinkInfo)) return null;
    if (!isArray_default(value)) {
      const { axisId, axisIndex } = dataLinkInfo;
      let axis2;
      if (isValid_default(axisId) ? axis2 = this._chart.getComponentsByKey("axes").find((s3) => s3.userId === axisId) : isValid_default(axisIndex) && (axis2 = null === (_a = this._chart.getComponentsByKey("axes")) || void 0 === _a ? void 0 : _a[axisIndex]), !axis2) return warn("Please check whether the `axisId` or `axisIndex` is set!"), null;
      const pointValue = null == axis2 ? void 0 : axis2.valueToPosition(value);
      if (isRelativeToCanvas) {
        const axisLayoutStartPoint = axis2.getLayoutStartPoint(), axisOrient = axis2.getOrient();
        return pointValue + ("bottom" === axisOrient || "top" === axisOrient ? axisLayoutStartPoint.x : axisLayoutStartPoint.y);
      }
      return pointValue;
    }
    const { seriesId, seriesIndex } = dataLinkInfo;
    let series2;
    return isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_b = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _b ? void 0 : _b[0]), series2 ? convertPoint(series2.valueToPosition(value[0], value[1]), series2.getRegion().getLayoutStartPoint(), isRelativeToCanvas) : (warn("Please check whether the `seriesId` or `seriesIndex` is set!"), null);
  }
  getFunction(key) {
    return ExpressionFunction.instance().getFunction(key);
  }
  registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  setRuntimeSpec(spec) {
    this._spec = spec, this._updateSpecInfo();
  }
  _initChartPlugin() {
    const pluginList = Factory2.getChartPlugins();
    pluginList.length > 0 && (this._chartPlugin = new ChartPluginService(this), this._chartPlugin.load(pluginList.map((p2) => new p2())), this._chartPluginApply("onInit", this._spec));
  }
  _chartPluginApply(funcName, ...args) {
    this._chartPlugin && this._chartPlugin[funcName] && this._chartPlugin[funcName].apply(this._chartPlugin, args);
  }
};
VChart.InstanceManager = InstanceManager, VChart.ThemeManager = ThemeManager2, VChart.globalConfig = {
  uniqueTooltip: true
}, VChart.Utils = VCHART_UTILS;
Factory2.registerRegion("region", Region), Factory2.registerLayout("base", Layout), registerGroupMark(), View.useRegisters([registerFilterTransform, registerMapTransform]), registerVGrammarCommonAnimation(), registerTheme(darkTheme2.name, darkTheme2), Logger.getInstance(LoggerLevel.Error);

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/query.js
var checkMediaQuery = (query, mediaInfo, globalInstance) => {
  for (const conditionKey in query) switch (conditionKey) {
    case "maxHeight":
      if (isValid_default(query.maxHeight) && mediaInfo.height > query.maxHeight) return false;
      break;
    case "minHeight":
      if (isValid_default(query.minHeight) && mediaInfo.height < query.minHeight) return false;
      break;
    case "maxWidth":
      if (isValid_default(query.maxWidth) && mediaInfo.width > query.maxWidth) return false;
      break;
    case "minWidth":
      if (isValid_default(query.minWidth) && mediaInfo.width < query.minWidth) return false;
      break;
    case "onResize":
      if (isValid_default(query.onResize) && !query.onResize(mediaInfo, globalInstance)) return false;
  }
  return true;
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/filter.js
var executeMediaQueryActionFilter = (filterType = "chart", filter2, action, query, chartSpec, chartSpecInfo) => {
  const result2 = executeMediaQueryActionFilterType(filterType, chartSpec, chartSpecInfo);
  return Object.assign(Object.assign({}, result2), {
    modelInfo: result2.modelInfo.filter((info) => !!isNil_default(filter2) || array(filter2).some((f2) => isFunction_default(f2) ? f2(info, action, query) : includeSpec(info.spec, f2)))
  });
};
var executeMediaQueryActionFilterType = (filterType = "chart", chartSpec, chartSpecInfo) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  const result2 = {
    modelInfo: []
  };
  if ("chart" === filterType) result2.isChart = true, result2.modelInfo.push({
    spec: chartSpec,
    type: "chart"
  });
  else if ("region" === filterType) result2.modelType = "region", result2.specKey = "region", null === (_a = chartSpec.region) || void 0 === _a || _a.forEach((regionSpec, i2) => {
    result2.modelInfo.push({
      spec: regionSpec,
      specPath: ["region", i2],
      specIndex: i2,
      type: "region"
    });
  });
  else if ("series" === filterType) result2.modelType = "series", result2.specKey = "series", null === (_b = chartSpec.series) || void 0 === _b || _b.forEach((seriesSpec, i2) => {
    result2.modelInfo.push({
      spec: seriesSpec,
      specPath: ["series", i2],
      specIndex: i2,
      type: seriesSpec.type
    });
  });
  else if (Object.values(SeriesTypeEnum).includes(filterType)) result2.modelType = "series", result2.specKey = "series", result2.type = filterType, null === (_c = chartSpec.series) || void 0 === _c || _c.forEach((seriesSpec, i2) => {
    seriesSpec.type === filterType && result2.modelInfo.push({
      spec: seriesSpec,
      specPath: ["series", i2],
      specIndex: i2,
      type: filterType
    });
  });
  else if (Object.values(ComponentTypeEnum).includes(filterType)) {
    result2.modelType = "component", result2.type = filterType, result2.specKey = null === (_d = Factory2.getComponentInKey(filterType)) || void 0 === _d ? void 0 : _d.specKey;
    const { specKey } = result2, infoList = array(null !== (_e = chartSpecInfo[specKey]) && void 0 !== _e ? _e : []);
    null === (_g = array(null !== (_f = chartSpec[specKey]) && void 0 !== _f ? _f : [])) || void 0 === _g || _g.forEach((componentSpec, i2) => {
      const specInfo = infoList[i2];
      specInfo.type === filterType && result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
        spec: componentSpec
      }));
    });
  } else {
    const componentTypes = Factory2.getComponents().filter(({ cmp }) => cmp.specKey === filterType).map(({ cmp }) => cmp.type);
    if (componentTypes.length > 0) {
      result2.modelType = "component";
      const specKey = filterType;
      result2.specKey = specKey;
      const infoList = array(null !== (_h = chartSpecInfo[specKey]) && void 0 !== _h ? _h : []);
      array(null !== (_j = chartSpec[specKey]) && void 0 !== _j ? _j : []).forEach((componentSpec, i2) => {
        const specInfo = infoList[i2];
        componentTypes.includes(specInfo.type) && result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
          spec: componentSpec
        }));
      });
    }
  }
  return result2;
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/util/action.js
var executeMediaQueryAction = (action, query, chartSpec, chartSpecInfo) => {
  const { spec, filter: filter2, filterType, forceAppend } = action, { isChart, modelType, specKey, type, modelInfo } = executeMediaQueryActionFilter(filterType, filter2, action, query, chartSpec, chartSpecInfo);
  if (0 === modelInfo.length && !forceAppend) return {
    chartSpec,
    hasChanged: false
  };
  const targetSpec = mergeSpec({}, chartSpec), newSpec = isFunction_default(spec) ? spec(modelInfo, action, query) : spec;
  for (const { spec: spec2, specPath } of modelInfo) {
    if (isChart) return {
      chartSpec: mergeSpec(targetSpec, newSpec),
      hasChanged: true
    };
    const modelSpec = mergeSpec({}, spec2, newSpec);
    setProperty(targetSpec, specPath, modelSpec);
  }
  if (0 === modelInfo.length && forceAppend) {
    const newSpecToAppend = Object.assign({
      type
    }, newSpec);
    isArray_default(targetSpec[specKey]) ? targetSpec[specKey].push(newSpecToAppend) : isNil_default(targetSpec[specKey]) ? targetSpec[specKey] = "component" === modelType ? newSpecToAppend : [newSpecToAppend] : targetSpec[specKey] = [targetSpec[specKey], newSpecToAppend];
  }
  return {
    chartSpec: targetSpec,
    hasChanged: true
  };
};

// node_modules/@visactor/vchart/esm/plugin/base/base-plugin.js
var BasePlugin = class {
  constructor(type) {
    this.id = createID(), this.name = `${type}_${this.id}`;
  }
  onAdd(service) {
    this.service = service;
  }
};

// node_modules/@visactor/vchart/esm/plugin/chart/media-query/media-query.js
var MediaQuery = class _MediaQuery extends BasePlugin {
  constructor() {
    super(_MediaQuery.type), this.type = "MediaQueryPlugin", this._currentMediaInfo = {}, this.currentActiveItems = /* @__PURE__ */ new Set(), this._initialized = false;
  }
  onInit(service, chartSpec) {
    if (!(null == chartSpec ? void 0 : chartSpec[_MediaQuery.specKey])) return;
    const { globalInstance } = service;
    this._option = {
      globalInstance: service.globalInstance,
      updateSpec: (spec, compile, render) => {
        render ? globalInstance.updateSpecSync(spec) : compile ? globalInstance.updateSpecAndRecompile(spec, false, {
          transformSpec: true
        }) : globalInstance.setRuntimeSpec(spec);
      }
    }, this._spec = chartSpec[_MediaQuery.specKey], this._initialized = true;
  }
  onBeforeResize(service, width, height) {
    this._initialized && this._changeSize(width, height, true, false);
  }
  onAfterChartSpecTransform(service, chartSpec, actionSource) {
    this._initialized && "setCurrentTheme" === actionSource && this._reInit(false, false);
  }
  onBeforeInitChart(service, chartSpec, actionSource) {
    if (!this._initialized) return;
    let resetMediaQuery, checkMediaQuery2;
    switch (actionSource) {
      case "render":
      case "updateModelSpec":
        resetMediaQuery = false, checkMediaQuery2 = true;
        break;
      case "updateSpec":
      case "setCurrentTheme":
        resetMediaQuery = true, checkMediaQuery2 = false;
        break;
      case "updateSpecAndRecompile":
        resetMediaQuery = false, checkMediaQuery2 = false;
    }
    if (resetMediaQuery && this.dispose(), this._initialized || this.onInit(service, chartSpec), resetMediaQuery || checkMediaQuery2) {
      const { width, height } = this._option.globalInstance.getCurrentSize();
      this._changeSize(width, height, false, false);
    }
  }
  _changeSize(width, height, compile, render) {
    return (this._currentMediaInfo.width !== width || this._currentMediaInfo.height !== height) && (this._currentMediaInfo.width = width, this._currentMediaInfo.height = height, this._applyQueries(compile, render));
  }
  _applyQueries(compile, render) {
    const changeToActive = [], changeToInactive = [];
    if (this._spec.forEach((item) => {
      const { hasChanged: hasChanged2, isActive } = this._check(item);
      hasChanged2 && (isActive ? changeToActive.push(item) : changeToInactive.push(item));
    }), !changeToActive.length && !changeToInactive.length) return false;
    let chartSpec, chartSpecInfo;
    this._baseChartSpec || (this._baseChartSpec = cloneDeepSpec(this._option.globalInstance.getSpec(), ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo());
    let hasChanged = false;
    return changeToInactive.length > 0 ? (chartSpec = cloneDeepSpec(this._baseChartSpec, ["data", _MediaQuery.specKey]), chartSpecInfo = this._baseChartSpecInfo, Array.from(this.currentActiveItems).forEach((item) => {
      if (changeToInactive.includes(item)) return void this.currentActiveItems.delete(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec;
    }), hasChanged = true) : (chartSpec = this._option.globalInstance.getSpec(), chartSpecInfo = this._option.globalInstance.getSpecInfo()), changeToActive.forEach((item) => {
      this.currentActiveItems.add(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render), true;
  }
  _check(item) {
    const { globalInstance } = this._option, isActive = checkMediaQuery(item.query, this._currentMediaInfo, globalInstance);
    return {
      isActive,
      hasChanged: isActive !== this.currentActiveItems.has(item)
    };
  }
  _apply(item, chartSpec, chartSpecInfo) {
    const { query, action } = item;
    let hasChanged = false;
    return array(action).forEach((actionItem) => {
      const result2 = executeMediaQueryAction(actionItem, query, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), {
      chartSpec,
      hasChanged
    };
  }
  _reInit(compile, render) {
    let chartSpec = this._option.globalInstance.getSpec();
    this._baseChartSpec = cloneDeepSpec(chartSpec, ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo();
    let hasChanged = false;
    this.currentActiveItems.forEach((item) => {
      const result2 = this._apply(item, chartSpec, this._baseChartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render);
  }
  dispose() {
    this._initialized = false, this._spec = [], this._option = void 0, this._currentMediaInfo = {}, this.currentActiveItems.clear();
  }
};
MediaQuery.pluginType = "chart", MediaQuery.specKey = "media", MediaQuery.type = "MediaQueryPlugin";

// node_modules/@visactor/vchart/esm/data/transforms/add-property.js
var addVChartProperty = (data, op) => {
  const context = op.beforeCall();
  return data.forEach((d2, i2) => op.call(d2, i2, context)), context.keyMap && (context.keyMap.clear(), context.keyMap = null), data;
};

// node_modules/@visactor/vchart/esm/interaction/config.js
function getDefaultInteractionConfigByMode(mode2) {
  return mode2 === RenderModeEnum["desktop-browser"] || mode2 === RenderModeEnum["desktop-miniApp"] ? {
    hover: {
      enable: true,
      trigger: "pointermove",
      triggerOff: "pointerleave"
    },
    select: {
      enable: true,
      trigger: "pointertap"
    }
  } : isMobileLikeMode(mode2) || isMiniAppLikeMode(mode2) ? {
    hover: {
      enable: true,
      trigger: ["pointerdown", "pointermove"],
      triggerOff: "pointerleave"
    },
    select: {
      enable: true,
      trigger: "tap"
    }
  } : null;
}

// node_modules/@visactor/vchart/esm/interaction/trigger.js
var Trigger = class {
  get hover() {
    return this._hover;
  }
  get select() {
    return this._select;
  }
  constructor(spec, option) {
    this._fields = null, this._marks = new MarkSet(), this._markReverse = new MarkSet(), this.onHover = (params2) => {
      this.filterEventMark(params2) ? (this._isHovered = true, this.hoverItem(params2)) : this._isHovered && (this._isHovered = false, this.unhoverItem());
    }, this.onUnHover = (params2) => {
      this.filterEventMark(params2) || this.interaction.filterEventMark(params2, STATE_VALUE_ENUM.STATE_HOVER) || this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0] && this.unhoverItem();
    }, this.onSelect = (params2) => {
      this.handleSingleEventSelect(params2);
    }, this.onUnSelect = (params2) => {
      this.interaction.filterEventMark(params2, STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
    }, this._spec = spec, this._option = option, this.event = new Event2(option.eventDispatcher, option.mode), this.interaction = option.interaction, this.initConfig(option.mode);
  }
  setStateKeys(fields2) {
    this._fields = fields2.slice();
  }
  registerMark(mark) {
    this._marks.addMark(mark), this._hover.enable && this.interaction.registerMark(STATE_VALUE_ENUM.STATE_HOVER, mark), this._select.enable && this.interaction.registerMark(STATE_VALUE_ENUM.STATE_SELECTED, mark);
  }
  init() {
    this.initEvent();
  }
  release() {
    this.releaseEvent(), this._marks.clear();
  }
  initEvent() {
    const event = this.event, { enable: hoverEnable, trigger: hoverTrigger, triggerOff: hoverTriggerOff } = this._hover, { enable: selectEnable, trigger: selectTrigger, triggerOff: selectTriggerOff } = this._select;
    hoverEnable && (array(hoverTrigger).forEach((trigger) => {
      event.on(trigger, {
        level: Event_Bubble_Level.chart
      }, this.onHover);
    }), hoverTriggerOff && "none" !== hoverTriggerOff && array(hoverTriggerOff).forEach((trigger) => {
      event.on(trigger, {
        level: Event_Bubble_Level.vchart,
        source: Event_Source_Type.chart
      }, this.onUnHover);
    })), selectEnable && (array(selectTrigger).forEach((trigger) => {
      event.on(trigger, {
        level: Event_Bubble_Level.mark
      }, this.onSelect);
    }), selectTriggerOff && "none" !== selectTriggerOff && array(selectTriggerOff).forEach((trigger) => {
      event.on(trigger, {
        level: Event_Bubble_Level.mark
      }, this.onUnSelect);
    }), selectTriggerOff || array(null != selectTriggerOff ? selectTriggerOff : selectTrigger).forEach((trigger) => {
      event.on(trigger, {
        level: Event_Bubble_Level.vchart
      }, this.onUnSelect);
    }));
  }
  releaseEvent() {
    this.event.release();
  }
  initConfig(mode2) {
    const defaultConfig = getDefaultInteractionConfigByMode(mode2);
    this._hover = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.hover), this._select = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.select);
    const hoverSpec = this._spec.hover;
    isBoolean_default(hoverSpec) ? this._hover.enable = hoverSpec : isObject_default(hoverSpec) && (this._hover.enable = true, this._hover = mergeSpec(this._hover, hoverSpec));
    const selectSpec = this._spec.select;
    isBoolean_default(selectSpec) ? this._select.enable = selectSpec : isObject_default(selectSpec) && (this._select.enable = true, this._select = mergeSpec(this._select, selectSpec));
  }
  hoverItem(params2) {
    const { datum } = params2, lastEl = this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0];
    params2.item !== lastEl && (this.interaction.exchangeEventElement(STATE_VALUE_ENUM.STATE_HOVER, params2.item), this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_HOVER), this.event.emit("hovered", {
      model: this._option.model,
      value: [datum]
    }));
  }
  unhoverItem() {
    const lastHoveredDatums = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_HOVER);
    this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_HOVER, true), this.event.emit("unhovered", {
      model: this._option.model,
      value: lastHoveredDatums
    });
  }
  handleSingleEventHover(params2) {
    this.filterEventMark(params2) ? this.hoverItem(params2) : this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0] && !this.interaction.filterEventMark(params2, STATE_VALUE_ENUM.STATE_HOVER) && this.unhoverItem();
  }
  selectItems(datums) {
    this.event.emit("selected", {
      model: this._option.model,
      value: datums
    });
  }
  clearSelectedItems() {
    const lastSelectedItem = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_SELECTED);
    this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_SELECTED, true), this.event.emit("unselected", {
      model: this._option.model,
      value: lastSelectedItem
    });
  }
  unselectItems(params2) {
    const { triggerOff } = this._select;
    "none" !== triggerOff && (this.interaction.removeEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params2.item), this.event.emit("unselected", {
      model: this._option.model,
      value: params2.item
    }));
  }
  handleSingleEventSelect(params2) {
    if (this.filterEventMark(params2)) if (params2.item.getStates().includes(STATE_VALUE_ENUM.STATE_SELECTED)) this.unselectItems(params2);
    else {
      if ("multiple" === this._select.mode) this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params2.item);
      else this.interaction.exchangeEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params2.item);
      this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_SELECTED);
      const items = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_SELECTED);
      this.selectItems(items);
    }
    else this.interaction.filterEventMark(params2, STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
  }
  filterEventMark(params2) {
    return !(!params2.mark || !this._marks.includes(params2.mark));
  }
  isDatumEqual(datumA, datumB) {
    return (this._fields ? this._fields : Object.keys(datumA)).every((f2) => datumA[f2] === datumB[f2]);
  }
};

// node_modules/@visactor/vchart/esm/model/tooltip-helper.js
var BaseTooltipHelper = class {
  constructor() {
    this.activeTriggerSet = {
      mark: /* @__PURE__ */ new Set(),
      dimension: /* @__PURE__ */ new Set()
    }, this.ignoreTriggerSet = {
      mark: /* @__PURE__ */ new Set(),
      dimension: /* @__PURE__ */ new Set()
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/utils/common.js
var getTooltipActualActiveType = (spec) => {
  var _a, _b;
  if (false === (null == spec ? void 0 : spec.visible)) return [];
  const activeTypeMap = {
    mark: false !== (null === (_a = null == spec ? void 0 : spec.mark) || void 0 === _a ? void 0 : _a.visible),
    dimension: false !== (null === (_b = null == spec ? void 0 : spec.dimension) || void 0 === _b ? void 0 : _b.visible)
  };
  return isValid_default(null == spec ? void 0 : spec.activeType) && Object.keys(activeTypeMap).forEach((t2) => {
    var _a2;
    activeTypeMap[t2] = null === (_a2 = null == spec ? void 0 : spec.activeType) || void 0 === _a2 ? void 0 : _a2.includes(t2);
  }), Object.keys(activeTypeMap).filter((t2) => activeTypeMap[t2]);
};
function isEmptyPos(params2) {
  return isNil_default(params2.mark) && isNil_default(params2.model) && isNil_default(params2.datum);
}

// node_modules/@visactor/vchart/esm/series/base/tooltip-helper.js
var BaseSeriesTooltipHelper = class extends BaseTooltipHelper {
  constructor(series2) {
    super(), this._getSeriesCacheInfo = () => {
      var _a, _b, _c;
      const { series: series3 } = this, _seriesField = series3.getSeriesField();
      return {
        seriesFields: isValid_default(_seriesField) ? array(_seriesField) : null !== (_a = series3.getSeriesKeys()) && void 0 !== _a ? _a : [],
        dimensionFields: null !== (_b = series3.getDimensionField()) && void 0 !== _b ? _b : [],
        measureFields: null !== (_c = series3.getMeasureField()) && void 0 !== _c ? _c : [],
        type: series3.type
      };
    }, this._getDimensionData = (datum) => {
      const { dimensionFields } = this._seriesCacheInfo;
      return dimensionFields[0] && (null == datum ? void 0 : datum[dimensionFields[0]]);
    }, this._getMeasureData = (datum) => {
      const { measureFields } = this._seriesCacheInfo;
      return measureFields[0] && (null == datum ? void 0 : datum[measureFields[0]]);
    }, this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a;
      for (const key of array(styleKey)) {
        const value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (isValid_default(value)) return value;
      }
      return defaultValue;
    }, this.contentKeyCallback = (datum, params2) => {
      const { dimensionFields, seriesFields } = this._seriesCacheInfo, subDimensionField = dimensionFields[dimensionFields.length - 1];
      return isValid_default(seriesFields[0]) && (null == datum ? void 0 : datum[seriesFields[0]]) ? null == datum ? void 0 : datum[seriesFields[0]] : (dimensionFields.length > 1 && (0 === seriesFields.length || this.series.getSeriesKeys().length), null == datum ? void 0 : datum[subDimensionField]);
    }, this.contentValueCallback = (datum, params2) => this._getMeasureData(datum), this.contentShapeTypeCallback = (datum, params2) => {
      var _a;
      return null !== (_a = this._getSeriesStyle(datum, "shape", null)) && void 0 !== _a ? _a : this._getSeriesStyle(datum, "symbolType", this.series.getDefaultShapeType());
    }, this.contentShapeColorCallback = (datum, params2) => this._getSeriesStyle(datum, ["fill", "stroke"]), this.titleValueCallback = (datum, params2) => this._getDimensionData(datum), this.series = series2, this.updateTooltipSpec();
  }
  updateTooltipSpec() {
    var _a, _b, _c, _d;
    const seriesTooltipSpec = null !== (_b = null === (_a = this.series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) && void 0 !== _b ? _b : {}, chartTooltipSpec = null !== (_d = null === (_c = this.series.getChart().getSpec()) || void 0 === _c ? void 0 : _c.tooltip) && void 0 !== _d ? _d : {}, spec = Object.assign(Object.assign({}, chartTooltipSpec), seriesTooltipSpec);
    ["mark", "dimension"].forEach((activeType) => {
      const pattern = spec[activeType];
      isValid_default(pattern) && (spec[activeType] = Object.assign(Object.assign({}, pattern), {
        title: isValid_default(pattern.title) ? isFunction_default(pattern.title) ? pattern.title : Object.assign(Object.assign({}, pattern.title), {
          seriesId: this.series.id
        }) : void 0,
        content: isValid_default(pattern.content) ? isFunction_default(pattern.content) ? pattern.content : array(pattern.content).map((line2) => isFunction_default(line2) ? line2 : Object.assign(Object.assign({}, line2), {
          seriesId: this.series.id
        })) : void 0
      }));
    }), this.spec = spec, this.activeType = getTooltipActualActiveType(spec), this._seriesCacheInfo = this._getSeriesCacheInfo();
  }
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    if ("mark" === activeType) return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.titleValueCallback,
        hasShape: false
      },
      content: [{
        seriesId: this.series.id,
        key: this.contentKeyCallback,
        value: this.contentValueCallback,
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }]
    };
    if ("dimension" === activeType && dimensionInfo) {
      const title3 = {
        key: void 0,
        value: this._getDimensionData,
        hasShape: false
      }, content = [];
      return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
        content.push({
          seriesId: series2.id,
          key: this.contentKeyCallback,
          value: this.contentValueCallback,
          hasShape: true,
          shapeType: this.contentShapeTypeCallback,
          shapeColor: this.contentShapeColorCallback,
          shapeStroke: this.contentShapeColorCallback,
          shapeHollow: false
        });
      })), {
        visible: true,
        activeType,
        title: title3,
        content
      };
    }
    return null;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/dimension-statistics.js
var methods3 = {
  min: (arr) => arr.length ? minInArray(arr.map((n2) => 1 * n2)) : 0,
  max: (arr) => arr.length ? maxInArray(arr.map((n2) => 1 * n2)) : 0,
  "array-min": (arr) => arr.length ? minInArray(arr.map((n2) => 1 * n2)) : 0,
  "array-max": (arr) => arr.length ? maxInArray(arr.map((n2) => 1 * n2)) : 0,
  values: (arr) => {
    const map4 = {}, res = [];
    for (const entry of arr) map4[entry] || (res.push(entry), map4[entry] = 1);
    return res;
  }
};
var dimensionStatistics = (data, op) => {
  var _a, _b;
  let fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length)) return {};
  fields2 = mergeFields([], fields2);
  const dataKey = "parser" === op.target ? "parserData" : "latestData", latestData = data[0][dataKey] ? data[0][dataKey] : data || [], dataFields = null === (_b = (_a = data[0]).getFields) || void 0 === _b ? void 0 : _b.call(_a);
  return dimensionStatisticsOfSimpleData(latestData, fields2, dataFields);
};
var dimensionStatisticsOfSimpleData = (latestData, fields2, dataFields) => {
  const result2 = {};
  let fValues = [], nextFValues = [];
  return fields2.forEach((f2) => {
    const key = f2.key;
    result2[key] = {};
    const dataFieldInKey = null == dataFields ? void 0 : dataFields[key], operations = f2.operations, isNumberField = operations.some((op) => "min" === op || "max" === op || "allValid" === op);
    let allValid = true;
    fValues.length = 0, latestData.forEach((d2) => {
      d2 && fValues.push(d2[key]);
    });
    const len = fValues.length;
    if (isNumberField) {
      nextFValues.length = 0, fValues.forEach((item, i2) => {
        couldBeValidNumber(item) && nextFValues.push(item);
      });
      const t2 = fValues;
      fValues = nextFValues, nextFValues = t2, allValid = fValues.length === len;
    } else fValues = operations.some((op) => "array-min" === op || "array-max" === op) ? fValues.reduce((res, entry) => (entry && entry.forEach((d2) => {
      couldBeValidNumber(d2) && res.push(d2);
    }), res), []) : fValues.filter((entry) => void 0 !== entry);
    operations.forEach((op) => {
      if (f2.customize) result2[key][op] = f2.customize;
      else {
        if (dataFieldInKey && dataFieldInKey.lockStatisticsByDomain && !isNil_default(dataFieldInKey.domain)) {
          if ("values" === op) return void (result2[key][op] = dataFieldInKey.domain.slice());
        } else if ("allValid" === op) return;
        result2[key][op] = methods3[op](fValues), "array-max" === op && (result2[key].max = result2[key][op]), "array-min" === op && (result2[key].min = result2[key][op]);
      }
    }), isNumberField && (result2[key].allValid = allValid);
  }), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/invalid-travel.js
var invalidTravel = (data, op) => {
  const { config: config2 } = op;
  if (!config2) return data;
  const { invalidType, checkField } = config2();
  return "zero" !== invalidType || data.forEach((datum) => {
    couldBeValidNumber(datum[checkField]) || (datum[checkField] = 0);
  }), data;
};

// node_modules/@visactor/vchart/esm/series/base/series-data.js
var SeriesData = class extends CompilableData {
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct([]);
  }
  generateProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.name;
  }
};

// node_modules/@visactor/vchart/esm/constant/hierarchy.js
var DEFAULT_HIERARCHY_DEPTH = `${PREFIX}_HIERARCHY_DEPTH`;
var DEFAULT_HIERARCHY_ROOT = `${PREFIX}_HIERARCHY_ROOT`;
var DEFAULT_HIERARCHY_ROOT_INDEX = `${PREFIX}_HIERARCHY_ROOT_INDEX`;

// node_modules/@visactor/vchart/esm/data/transforms/data-key.js
function initKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: !this._seriesField,
    defaultSeriesField: this._seriesField ? null : this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey)
  };
}
function addDataKey(d2, i2, context) {
  d2 && (context.needDefaultSeriesField && (d2[DEFAULT_DATA_SERIES_FIELD] = context.defaultSeriesField), d2[DEFAULT_DATA_INDEX] = i2, d2[DEFAULT_DATA_KEY] = context.getKey(d2, i2, context));
}
function initHierarchyKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: true,
    defaultSeriesField: this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey),
    categoryField: this.getCategoryField()
  };
}
function addHierarchyDataKey(d2, i2, context, depth = 0, root, rootIndex) {
  void 0 === rootIndex && (rootIndex = i2), addDataKey(d2, i2, context), d2[DEFAULT_HIERARCHY_DEPTH] = depth, d2[DEFAULT_HIERARCHY_ROOT] = root || d2[context.categoryField], d2[DEFAULT_HIERARCHY_ROOT_INDEX] = rootIndex, d2.children && d2.children.length && d2.children.forEach((_d, _i) => addHierarchyDataKey(_d, _i, context, d2[DEFAULT_HIERARCHY_DEPTH] + 1, d2[DEFAULT_HIERARCHY_ROOT], rootIndex));
}

// node_modules/@visactor/vchart/esm/animation/utils.js
var AnimationStates = ["appear", "enter", "update", "exit", "disappear", "normal"];
function animationConfig(defaultConfig = {}, userConfig, params2) {
  const config2 = {};
  for (let i2 = 0; i2 < AnimationStates.length; i2++) {
    const state = AnimationStates[i2], userStateConfig = userConfig ? userConfig[state] : void 0;
    if (false === userStateConfig) continue;
    if ("normal" === state) {
      userStateConfig && (config2.normal = userStateConfig);
      continue;
    }
    if ("update" !== state && !userStateConfig && !defaultConfig[state]) continue;
    let defaultStateConfig, stateConfig;
    (defaultStateConfig = isArray_default(defaultConfig[state]) ? defaultConfig[state] : [Object.assign(Object.assign({}, DEFAULT_ANIMATION_CONFIG[state]), defaultConfig[state])], "exit" === state && defaultStateConfig.forEach((exitConfig) => {
      exitConfig.controlOptions = {
        stopWhenStateChange: true
      };
    }), userStateConfig) ? (stateConfig = isArray_default(userStateConfig) ? userStateConfig.map((userConfig2, i3) => {
      var _a;
      let singleConfig = userConfig2;
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }) : defaultStateConfig.map((stateConfig2, i3) => {
      var _a;
      let singleConfig = mergeSpec({}, defaultStateConfig[i3], userStateConfig);
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }), config2[state] = stateConfig) : config2[state] = defaultStateConfig;
  }
  return config2.state = config2.update, config2;
}
function userAnimationConfig(markName, spec, ctx) {
  var _a, _b, _c, _d, _e;
  const userConfig = {};
  return spec.animationAppear && (userConfig.appear = null !== (_a = spec.animationAppear[markName]) && void 0 !== _a ? _a : spec.animationAppear), spec.animationDisappear && (userConfig.disappear = null !== (_b = spec.animationDisappear[markName]) && void 0 !== _b ? _b : spec.animationDisappear), spec.animationEnter && (userConfig.enter = null !== (_c = spec.animationEnter[markName]) && void 0 !== _c ? _c : spec.animationEnter), spec.animationExit && (userConfig.exit = null !== (_d = spec.animationExit[markName]) && void 0 !== _d ? _d : spec.animationExit), spec.animationUpdate && (userConfig.update = null !== (_e = spec.animationUpdate[markName]) && void 0 !== _e ? _e : spec.animationUpdate), spec.animationNormal && spec.animationNormal[markName] && (userConfig.normal = spec.animationNormal[markName]), uniformAnimationConfig(userConfig, ctx);
}
function produceOneByOne(stateConfig, dataIndex, dataCount) {
  const { oneByOne, duration, delay, delayAfter } = stateConfig;
  return stateConfig.delay = (datum, element, params2) => {
    const index = dataIndex(datum), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelay = isFunction_default(delay) ? delay(datum, element, params2) : isValidNumber_default(delay) ? delay : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    return false === oneByOneTime ? userDelay : (oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelay + index * (durationTime + oneByOneTime));
  }, stateConfig.delayAfter = (datum, element, params2) => {
    const index = dataIndex(datum), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelayAfter = isFunction_default(delayAfter) ? delayAfter(datum, element, params2) : isValidNumber_default(delayAfter) ? delayAfter : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    if (false === oneByOneTime) return userDelayAfter;
    return oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelayAfter + ((dataCount ? dataCount() : element.mark.elements.length) - index) * (durationTime + oneByOneTime);
  }, delete stateConfig.oneByOne, stateConfig;
}
function defaultDataIndex(datum) {
  return null == datum ? void 0 : datum[DEFAULT_DATA_INDEX];
}
function shouldMarkDoMorph(spec, markName) {
  var _a, _b, _c, _d, _e;
  if (false === spec.animation) return false;
  if (false === (null === (_a = spec.morph) || void 0 === _a ? void 0 : _a.enable)) return false;
  const appearAnimationEnabled = false !== (null !== (_c = null === (_b = spec.animationAppear) || void 0 === _b ? void 0 : _b[markName]) && void 0 !== _c ? _c : spec.animationAppear), updateAnimationEnabled = false !== (null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d[markName]) && void 0 !== _e ? _e : spec.animationUpdate);
  return !(!appearAnimationEnabled || !updateAnimationEnabled);
}
function isTimeLineAnimation(animationConfig2) {
  return isValid_default(animationConfig2.timeSlices);
}
function isChannelAnimation(animationConfig2) {
  return !isTimeLineAnimation(animationConfig2) && isValid_default(animationConfig2.channel);
}
function uniformAnimationConfig(config2, ctx) {
  return config2 ? (traverseSpec(config2 = cloneDeep(config2), (node) => {
    var _a;
    if (isFunction_default(node) && (null === (_a = node.prototype) || void 0 === _a ? void 0 : _a.constructor) !== node) {
      return (...args) => node(...args, ctx);
    }
    return node;
  }), config2) : config2;
}
function traverseSpec(spec, transform29) {
  if (isArray_default(spec)) spec.forEach((i2, index) => {
    spec[index] = transform29(spec[index], index), traverseSpec(spec[index], transform29);
  });
  else if (isObject_default(spec)) for (const key in spec) spec[key] = transform29(spec[key], key), traverseSpec(spec[key], transform29);
}
function isAnimationEnabledForSeries(series2) {
  return false !== series2.getSpec().animation && isValid_default(series2.getRegion().animate);
}

// node_modules/@visactor/vchart/esm/series/base/base-series-transformer.js
var BaseSeriesSpecTransformer = class extends BaseModelSpecTransformer {
  constructor() {
    super(...arguments), this.markLabelSpec = {};
  }
  getLabelSpec(markName) {
    return this.markLabelSpec[markName];
  }
  setLabelSpec(markName, label) {
    this.markLabelSpec[markName] = array(label);
  }
  addLabelSpec(markName, label, head = false) {
    this.markLabelSpec[markName] || (this.markLabelSpec[markName] = []), head ? this.markLabelSpec[markName].unshift(label) : this.markLabelSpec[markName].push(label);
  }
  getTheme(spec, chartSpec) {
    var _a;
    const direction2 = getDirectionFromSeriesSpec(spec), chartTheme = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getTheme(), { markByName: markByName2, mark } = chartTheme, type = this._option.type, theme2 = transformSeriesThemeToMerge(get_default(chartTheme, `series.${type}`), type, mark, markByName2), themeWithDirection = transformSeriesThemeToMerge(get_default(chartTheme, `series.${type}_${direction2}`), `${type}_${direction2}`, mark, markByName2);
    return mergeSpec({}, theme2, themeWithDirection);
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    const result2 = super.transformSpec(spec, chartSpec, chartSpecInfo);
    return this._transformLabelSpec(result2.spec), Object.assign(Object.assign({}, result2), {
      markLabelSpec: this.markLabelSpec
    });
  }
  _transformLabelSpec(spec) {
  }
  _addMarkLabelSpec(spec, markName, labelSpecKey = "label", styleHandlerName = "initLabelMarkStyle", hasAnimation, head) {
    const labelSpec = null == spec ? void 0 : spec[labelSpecKey];
    (null == labelSpec ? void 0 : labelSpec.visible) && this.addLabelSpec(markName, Object.assign(Object.assign({
      animation: null != hasAnimation ? hasAnimation : spec.animation
    }, labelSpec), {
      getStyleHandler: (series2) => {
        var _a;
        return null === (_a = series2[styleHandlerName]) || void 0 === _a ? void 0 : _a.bind(series2);
      }
    }), head);
  }
  _getDefaultSpecFromChart(chartSpec) {
    var _a;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, { outerRadius, innerRadius } = chartSpec;
    return isValid_default(outerRadius) && (spec.outerRadius = outerRadius), isValid_default(innerRadius) && (spec.innerRadius = innerRadius), Object.keys(spec).length > 0 ? spec : void 0;
  }
};

// node_modules/@visactor/vchart/esm/series/base/base-series.js
var BaseSeries = class extends BaseModel {
  getTrigger() {
    return this._trigger;
  }
  getRegion() {
    return this._region;
  }
  getLayoutStartPoint() {
    return this._region.getLayoutStartPoint();
  }
  getRootMark() {
    return this._rootMark;
  }
  getRawData() {
    return this._rawData;
  }
  getViewDataFilter() {
    return this._viewDataFilter;
  }
  getViewData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  getViewDataProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getProductId();
  }
  getViewDataStatistics() {
    return this._viewDataStatistics;
  }
  getViewStackData() {
    return this._viewStackData;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field5) {
    isValid_default(field5) && (this._seriesField = field5, this.getMarks().filter((m5) => m5.getDataView() === this.getViewData()).forEach((m5) => {
      m5.setFacet(this._seriesField);
    }));
  }
  getGroups() {
    return this._groups;
  }
  getStack() {
    return this._stack;
  }
  getStackValue() {
    var _a;
    return null !== (_a = this._spec.stackValue) && void 0 !== _a ? _a : `${PREFIX}_series_${this.type}`;
  }
  getPercent() {
    return this._percent;
  }
  getStackOffsetSilhouette() {
    return this._stackOffsetSilhouette;
  }
  get tooltipHelper() {
    return this._tooltipHelper || this.initTooltip(), this._tooltipHelper;
  }
  getInvalidType() {
    return this._invalidType;
  }
  setInvalidType(t2) {
    var _a;
    this._invalidType = t2, null === (_a = this.getViewData()) || void 0 === _a || _a.reRunAllTransform();
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "series", this.type = "series", this.layoutType = "absolute", this.modelType = "series", this.name = void 0, this.transformerConstructor = BaseSeriesSpecTransformer, this.coordinate = "none", this._region = null, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: null,
      height: null
    }, this.getLayoutRect = () => {
      var _a2, _b;
      return {
        width: null !== (_a2 = this._layoutRect.width) && void 0 !== _a2 ? _a2 : this._region.getLayoutRect().width,
        height: null !== (_b = this._layoutRect.height) && void 0 !== _b ? _b : this._region.getLayoutRect().height
      };
    }, this._rootMark = null, this._seriesMark = null, this._viewDataMap = /* @__PURE__ */ new Map(), this._viewDataFilter = null, this._data = null, this._percent = false, this._stackOffsetSilhouette = false, this.layoutZIndex = 0, this._invalidType = "break", this._getInvalidDefined = (datum) => couldBeValidNumber(datum[this.getStackValueField()]), this._region = options.region, this._dataSet = options.dataSet, (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.name) && (this.name = this._spec.name);
  }
  created() {
    super.created(), this._buildMarkAttributeContext(), this.initData(), this.initGroups(), this.initStatisticalData(), this.event.emit(ChartEvent.afterInitData, {
      model: this
    }), this.initTrigger(), this.initRootMark(), this.initMark();
    const hasAnimation = isAnimationEnabledForSeries(this);
    this._initExtensionMark({
      hasAnimation
    }), this.initMarkStyle(), this.initMarkState(), hasAnimation && this.initAnimation(), this.afterInitMark(), this.initEvent(), this.event.emit(ChartEvent.afterInitEvent, {
      model: this
    });
  }
  _buildMarkAttributeContext() {
    this._markAttributeContext = {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      },
      seriesColor: (seriesValue) => {
        var _a;
        return isNil_default(seriesValue) && (seriesValue = this.getSeriesKeys()[0]), null === (_a = this._option.globalScale.getScale("color")) || void 0 === _a ? void 0 : _a.scale(seriesValue);
      },
      getRegion: () => this._region
    };
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setSeriesField(this._spec.seriesField), isBoolean_default(this._spec.stack) && (this._stack = this._spec.stack), isBoolean_default(this._spec.percent) && (this._percent = this._spec.percent, this._stack = this._spec.percent || this._stack), isBoolean_default(this._spec.stackOffsetSilhouette) && (this._stackOffsetSilhouette = this._spec.stackOffsetSilhouette, this._stack = this._spec.stackOffsetSilhouette || this._stack), isValid_default(this._spec.stackValue) && (this._stack = true), isNil_default(this._stack) && this._supportStack && this._seriesField && (this._stack = true), isValid_default(this._spec.invalidType) && (this._invalidType = this._spec.invalidType);
  }
  initData() {
    var _a, _b, _c, _d, _e, _f;
    const d2 = null !== (_a = this._spec.data) && void 0 !== _a ? _a : this._option.getSeriesData(this._spec.dataId, this._spec.dataIndex);
    if (d2 && (this._rawData = dataToDataView(d2, this._dataSet, this._option.sourceDataList, {
      onError: null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError
    })), null === (_d = null === (_c = this._rawData) || void 0 === _c ? void 0 : _c.target) || void 0 === _d || _d.addListener("change", this.rawDataUpdate.bind(this)), this._addDataIndexAndKey(), this._rawData) {
      this._stack && (this._viewDataFilter = dataViewFromDataView(this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewDataFilter`
      }));
      const viewData = dataViewFromDataView(this._stack ? this._viewDataFilter : this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewData`
      });
      this._data = new SeriesData(this._option, viewData), this._stack && this._viewDataFilter.target.removeListener("change", viewData.reRunAllTransform);
    }
    "zero" === this._invalidType && (null === (_e = this._rawData) || void 0 === _e ? void 0 : _e.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "invalidTravel", invalidTravel), null === (_f = this._rawData) || void 0 === _f || _f.transform({
      type: "invalidTravel",
      options: {
        config: () => ({
          invalidType: this._invalidType,
          checkField: this.getStackValueField()
        })
      }
    }, false));
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = {
      fields: groupFields
    });
  }
  initStatisticalData() {
    this._data && this._statisticViewData();
  }
  getRawDataStatisticsByField(field5, isNumeric2) {
    var _a, _b;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field5]) {
      if (this._viewDataStatistics && (!this._viewDataFilter || this._viewDataFilter.transformsArr.length <= 1) && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field5])) this._rawStatisticsCache[field5] = this._viewDataStatistics.latestData[field5];
      else if (this._rawData) {
        const fieldInfo = null === (_b = this._rawData.getFields()) || void 0 === _b ? void 0 : _b[field5];
        fieldInfo && fieldInfo.lockStatisticsByDomain && fieldInfo.domain ? (this._rawStatisticsCache[field5] = {}, isNumeric2 ? (this._rawStatisticsCache[field5].min = minInArray(fieldInfo.domain), this._rawStatisticsCache[field5].max = maxInArray(fieldInfo.domain)) : this._rawStatisticsCache[field5].values = fieldInfo.domain) : this._rawStatisticsCache[field5] = dimensionStatisticsOfSimpleData(this._rawData.latestData, [{
          key: field5,
          operations: isNumeric2 ? ["min", "max"] : ["values"]
        }])[field5];
      }
    }
    return isNumeric2 && (isNil_default(this._rawStatisticsCache[field5].min) || isNil_default(this._rawStatisticsCache[field5].max)) && (this._rawStatisticsCache[field5].min = minInArray(this._rawStatisticsCache[field5].values), this._rawStatisticsCache[field5].max = maxInArray(this._rawStatisticsCache[field5].values)), this._rawStatisticsCache[field5];
  }
  _statisticViewData() {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const viewDataStatisticsName = `${this.type}_${this.id}_viewDataStatic`;
    this._viewDataStatistics = new DataView(this._dataSet, {
      name: viewDataStatisticsName
    }), this._viewDataStatistics.parse([this._data.getDataView()], {
      type: "dataview"
    }), this._viewDataStatistics.transform({
      type: "dimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), this._data.getDataView().target.removeListener("change", this._viewDataStatistics.reRunAllTransform), this._stack && this.createdStackData();
  }
  createStatisticalData(dataName, rawData, staticFields) {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse([rawData], {
      type: "dataview"
    }), data.transform({
      type: "dimensionStatistics",
      options: {
        operations: ["max", "min", "values"],
        fields: () => {
          var _a;
          const fields2 = mergeFields(this.getStatisticFields(), null !== (_a = null == staticFields ? void 0 : staticFields(rawData.name)) && void 0 !== _a ? _a : []);
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), data;
  }
  createdStackData() {
    const dataName = `${this.type}_${this.id}_viewStackData`;
    this._viewStackData = new DataView(this._dataSet, {
      name: dataName
    }), this._viewStackData.parse([this._viewDataFilter], {
      type: "dataview"
    }), this._viewStackData.transform({
      type: "stackSplit",
      options: {
        fields: this.getStackGroupFields()
      }
    }, false);
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  generateDefaultDataKey(dataKey) {
    var _a;
    return isNil_default(dataKey) ? (datum, index, context) => {
      if (false === this._spec.animation) {
        const v2 = this._noAnimationDataKey(datum, index);
        if (void 0 !== v2) return v2;
      }
      const { keyMap: keyMap2 } = context, seriesDataKey = this._getSeriesDataKey(datum);
      return void 0 === keyMap2.get(seriesDataKey) ? (keyMap2.set(seriesDataKey, 0), seriesDataKey) : (keyMap2.set(seriesDataKey, keyMap2.get(seriesDataKey) + 1), `${seriesDataKey}_${keyMap2.get(seriesDataKey)}`);
    } : isString_default(dataKey) ? (datum) => datum[dataKey] : isArray_default(dataKey) && dataKey.every((d2) => isString_default(d2)) ? (datum) => dataKey.map((k3) => datum[k3]).join("-") : isFunction_default(dataKey) ? (datum, index) => dataKey(datum, index) : (null === (_a = this._option) || void 0 === _a || _a.onError(`invalid dataKey: ${dataKey}`), (datum, index) => {
    });
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false));
  }
  updateRawData(d2) {
    this._rawData && this._rawData.updateRawData(d2);
  }
  rawDataUpdate(d2) {
    var _a;
    null === (_a = this._rawDataStatistics) || void 0 === _a || _a.reRunAllTransform(), this._rawStatisticsCache = null, this.event.emit(ChartEvent.rawDataUpdate, {
      model: this
    });
  }
  viewDataFilterOver(d2) {
    this.event.emit(ChartEvent.viewDataFilterOver, {
      model: this
    });
  }
  viewDataUpdate(d2) {
    var _a;
    this.event.emit(ChartEvent.viewDataUpdate, {
      model: this
    }), null === (_a = this._data) || void 0 === _a || _a.updateData(), this._viewDataStatistics && this._viewDataStatistics.reRunAllTransform();
  }
  viewDataStatisticsUpdate(d2) {
    this.event.emit(ChartEvent.viewDataStatisticsUpdate, {
      model: this
    });
  }
  getDatumPositionValue(datum, field5) {
    return !datum || isNil_default(field5) ? null : datum[field5];
  }
  getDatumPositionValues(datum, fields2) {
    return !datum || isNil_default(fields2) ? [] : isString_default(fields2) ? [datum[fields2]] : fields2.map((f2) => datum[f2]);
  }
  setValueFieldToStack() {
  }
  setValueFieldToPercent() {
  }
  setValueFieldToStackOffsetSilhouette() {
  }
  initRootMark() {
    var _a, _b;
    this._rootMark = this._createMark({
      type: "group",
      name: `seriesGroup_${this.type}_${this.id}`
    }, {
      parent: null === (_b = (_a = this._region).getGroupMark) || void 0 === _b ? void 0 : _b.call(_a),
      dataView: false
    }), this._rootMark.setZIndex(this.layoutZIndex);
  }
  _initExtensionMark(options) {
    var _a;
    this._spec.extensionMark && (null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((m5, i2) => {
      this._createExtensionMark(m5, null, `${PREFIX}_series_${this.id}_extensionMark`, i2, options);
    }));
  }
  _createExtensionMark(spec, parentMark, namePrefix, index, options) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: `${namePrefix}_${index}`
    }, {
      skipBeforeLayouted: true,
      markSpec: spec,
      parent: parentMark,
      dataView: false,
      customShape: null == spec ? void 0 : spec.customShape
    });
    if (mark) {
      if (options.hasAnimation) {
        const config2 = animationConfig({}, userAnimationConfig(spec.type, spec, this._markAttributeContext));
        mark.setAnimationConfig(config2);
      }
      if ("group" === spec.type) namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s3, i2) => {
        this._createExtensionMark(s3, mark, namePrefix, i2, options);
      });
      else if (!(parentMark || isNil_default(spec.dataId) && isNil_default(spec.dataIndex))) {
        const dataView = this._option.getSeriesData(spec.dataId, spec.dataIndex);
        dataView === this._rawData ? mark.setDataView(this.getViewData(), this.getViewDataProductId()) : mark.setDataView(dataView);
      }
    }
  }
  _updateExtensionMarkSpec(lastSpec) {
    var _a;
    null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((spec, i2) => {
      var _a2;
      const mark = this._marks.getMarkWithInfo({
        name: `${this.type}_${this.id}_extensionMark_${i2}`
      });
      mark && (lastSpec && isEqual(null === (_a2 = lastSpec.extensionMark) || void 0 === _a2 ? void 0 : _a2[i2], spec) || (this.initMarkStyleWithSpec(mark, spec), mark.updateStaticEncode(), mark.updateLayoutState()));
    });
  }
  getStackData() {
    var _a;
    return null === (_a = this._viewStackData) || void 0 === _a ? void 0 : _a.latestData;
  }
  initTrigger() {
    const triggerSpec = {
      hover: this._spec.hover,
      select: this._spec.select
    }, triggerOptions = Object.assign(Object.assign({}, this._option), {
      model: this,
      interaction: this._region.interaction
    });
    this._trigger = new Trigger(triggerSpec, triggerOptions);
  }
  initAnimation() {
  }
  initMarkState() {
    this.initSeriesStyleState();
  }
  initSeriesStyleState() {
    var _a;
    const seriesStyle = this._spec.seriesStyle;
    if (!seriesStyle || !seriesStyle.length) return;
    const groupBy2 = null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD;
    this.getMarksWithoutRoot().forEach((mark) => {
      const filterMap = {}, attrMap = {}, markStyle = {};
      seriesStyle.forEach((item) => {
        var _a2;
        const style2 = null === (_a2 = item[mark.name]) || void 0 === _a2 ? void 0 : _a2.style;
        style2 && (filterMap[item.name] = true, markStyle[item.name] = markStyle[item.name] || {}, Object.keys(style2).forEach((key) => {
          attrMap[key] = true, markStyle[item.name][key] = style2[key];
        }));
      }), mark.state.addStateInfo({
        stateValue: DEFAULT_SERIES_STYLE_NAME,
        level: -1,
        filter: (datum) => Array.isArray(datum) ? 0 !== datum.length && true === filterMap[datum[0][groupBy2]] : true === filterMap[datum[groupBy2]]
      });
      const style = {};
      Object.keys(attrMap).forEach((key) => {
        style[key] = (datum) => {
          var _a2, _b;
          let style2;
          if (Array.isArray(datum)) {
            if (0 === datum.length) return;
            style2 = null === (_a2 = markStyle[datum[0][groupBy2]]) || void 0 === _a2 ? void 0 : _a2[key];
          }
          return style2 = null === (_b = markStyle[datum[groupBy2]]) || void 0 === _b ? void 0 : _b[key], style2 || mark.getAttribute(key, datum);
        };
      }), this.setMarkStyle(mark, style, DEFAULT_SERIES_STYLE_NAME);
    });
  }
  afterInitMark() {
    var _a, _b, _c;
    this.event.emit(ChartEvent.afterInitMark, {
      model: this
    }), this.setSeriesField(this._spec.seriesField);
    let animationThreshold = null !== (_a = this._spec.animationThreshold) && void 0 !== _a ? _a : Number.MAX_SAFE_INTEGER;
    this.getMarks().forEach((m5) => {
      var _a2, _b2;
      (null === (_b2 = null === (_a2 = m5.stateStyle) || void 0 === _a2 ? void 0 : _a2.normal) || void 0 === _b2 ? void 0 : _b2.lineWidth) && m5.setAttribute("stroke", this.getColorAttribute(), "normal", AttributeLevel.Base_Series);
      const config2 = m5.getProgressiveConfig();
      config2 && (config2.large && config2.largeThreshold && (animationThreshold = Math.min(animationThreshold, config2.largeThreshold)), config2.progressiveThreshold && (animationThreshold = Math.min(animationThreshold, config2.progressiveThreshold)));
    }), (null === (_c = null === (_b = this._rawData) || void 0 === _b ? void 0 : _b.latestData) || void 0 === _c ? void 0 : _c.length) >= animationThreshold && (this._spec.animation = false);
  }
  getMarksWithoutRoot() {
    return this.getMarks().filter((m5) => !m5.name.includes("seriesGroup"));
  }
  getMarksInType(type) {
    return this._marks.getMarksInType(type);
  }
  getMarkInName(name) {
    return this._marks.get(name);
  }
  getMarkInId(markId) {
    return this.getMarks().find((m5) => m5.id === markId);
  }
  initEvent() {
    var _a, _b, _c;
    this._trigger.init(), null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.target.addListener("change", this.viewDataUpdate.bind(this)), null === (_c = this._viewDataStatistics) || void 0 === _c || _c.target.addListener("change", this.viewDataStatisticsUpdate.bind(this));
  }
  _releaseEvent() {
    super._releaseEvent(), this._trigger.release();
  }
  initTooltip() {
    this._tooltipHelper = new BaseSeriesTooltipHelper(this);
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    var _a, _b;
    const result2 = super._compareSpec(spec, prevSpec), currentKeys = Object.keys(prevSpec || {}).sort(), nextKeys = Object.keys(spec || {}).sort();
    return isEqual(currentKeys, nextKeys) ? ((ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
      data: true
    }).invalidType = true, spec.invalidType !== prevSpec.invalidType && (result2.reCompile = true), ignoreCheckKeys.extensionMark = true, (array(spec.extensionMark).length !== array(prevSpec.extensionMark).length || (null === (_a = prevSpec.extensionMark) || void 0 === _a ? void 0 : _a.some((mark, index) => mark.type !== spec.extensionMark[index].type || mark.id !== spec.extensionMark[index].id))) && (result2.reMake = true), result2.reMake ? result2 : ((null === (_b = prevSpec.extensionMark) || void 0 === _b ? void 0 : _b.some((mark, index) => mark.visible !== spec.extensionMark[index].visible)) && (result2.reCompile = true), this._marks.getMarks().some((m5) => {
      var _a2, _b2;
      return ignoreCheckKeys[m5.name] = true, (null === (_a2 = prevSpec[m5.name]) || void 0 === _a2 ? void 0 : _a2.visible) !== (null === (_b2 = spec[m5.name]) || void 0 === _b2 ? void 0 : _b2.visible);
    }) && (result2.reCompile = true), currentKeys.some((k3) => !ignoreCheckKeys[k3] && !isEqual(spec[k3], prevSpec[k3])) ? (result2.reMake = true, result2) : result2)) : (result2.reMake = true, result2);
  }
  _updateSpecData() {
    !this._rawData || !this._spec.data || this._spec.data instanceof DataView || updateDataViewInData(this._rawData, this._spec.data, true);
  }
  reInit(spec) {
    super.reInit(spec);
    const marks = this.getMarksWithoutRoot();
    marks.forEach((mark) => {
      this._spec[mark.name] && this.initMarkStyleWithSpec(mark, this._spec[mark.name]);
    }), this.initMarkStyle(), marks.forEach((mark) => {
      mark.updateStaticEncode(), mark.updateLayoutState(true);
    }), this._updateExtensionMarkSpec(spec), this._updateSpecData(), this._tooltipHelper && this._tooltipHelper.updateTooltipSpec();
  }
  onEvaluateEnd(ctx) {
    this._data.updateData();
  }
  onRender(ctx) {
  }
  release() {
    var _a, _b, _c;
    super.release(), this._viewDataMap.clear();
    const transformIndex = null === (_b = null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.transformsArr) || void 0 === _b ? void 0 : _b.findIndex((t2) => "addVChartProperty" === t2.type);
    transformIndex >= 0 && this._rawData.transformsArr.splice(transformIndex, 1), null === (_c = this._data) || void 0 === _c || _c.release(), this._dataSet = this._data = this._rawData = this._rawDataStatistics = this._spec = this._region = this._viewDataStatistics = this._viewStackData = null;
  }
  setLayoutStartPosition(pos) {
    isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y);
  }
  setLayoutRect({ width, height }, levelMap) {
    isValidNumber_default(width) && (this._layoutRect.width = width), isValidNumber_default(height) && (this._layoutRect.height = height);
  }
  getSeriesKeys() {
    var _a, _b;
    return this._seriesField ? null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b;
      return null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  _getSeriesInfo(field5, keys2) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys2.map((key) => ({
      key,
      style: this.getSeriesStyle({
        [field5]: key
      }),
      shapeType: defaultShapeType
    }));
  }
  getSeriesInfoInField(field5) {
    var _a, _b;
    return this._getSeriesInfo(field5, null !== (_b = null === (_a = this.getRawDataStatisticsByField(field5)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : []);
  }
  getSeriesInfoList() {
    var _a;
    return this._getSeriesInfo(null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD, this.getSeriesKeys());
  }
  _getDefaultColorScale() {
    var _a, _b;
    const colorDomain = this.getDefaultColorDomain(), colorRange = this._getDataScheme();
    return null === (_b = (_a = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _b ? void 0 : _b.call(_a, colorRange);
  }
  _getDataScheme() {
    return getDataScheme(this.getColorScheme(), this.type);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesField ? null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesField]) || void 0 === _b ? void 0 : _b.values : [];
  }
  getColorAttribute() {
    var _a, _b;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_b = this._seriesField) && void 0 !== _b ? _b : DEFAULT_DATA_SERIES_FIELD
    };
  }
  getDimensionField() {
    return [];
  }
  getMeasureField() {
    return [];
  }
  onMarkPositionUpdate() {
    this.onMarkTreePositionUpdate(this.getMarksWithoutRoot());
  }
  onMarkTreePositionUpdate(marks) {
  }
  _createMark(markInfo, option = {}) {
    var _a, _b, _c, _d;
    const { key, groupKey, skipBeforeLayouted, themeSpec = {}, markSpec, dataView, dataProductId, parent, isSeriesMark, depend, progressive, support3d = this._spec.support3d || !!this._spec.zField, morph = false, customShape } = option, m5 = super._createMark(markInfo, {
      key: null != key ? key : this._getDataIdKey(),
      support3d,
      seriesId: this.id,
      attributeContext: this._markAttributeContext
    });
    if (isValid_default(m5)) {
      this._marks.addMark(m5, {
        name: markInfo.name
      }), isSeriesMark && (this._seriesMark = m5), isNil_default(parent) ? null === (_a = this._rootMark) || void 0 === _a || _a.addMark(m5) : false !== parent && parent.addMark(m5), isNil_default(dataView) ? (m5.setDataView(this.getViewData(), this.getViewDataProductId()), m5.setSkipBeforeLayouted(true)) : false !== dataView && m5.setDataView(dataView, dataProductId), isBoolean_default(skipBeforeLayouted) && m5.setSkipBeforeLayouted(skipBeforeLayouted), isValid_default(depend) && m5.setDepend(...array(depend));
      const spec = this.getSpec() || {};
      m5.setMorph(morph), m5.setMorphKey((null === (_b = spec.morph) || void 0 === _b ? void 0 : _b.morphKey) || `${this._specIndex}`), m5.setMorphElementKey(null !== (_d = null === (_c = spec.morph) || void 0 === _c ? void 0 : _c.morphElementKey) && void 0 !== _d ? _d : option.defaultMorphElementKey), isNil_default(progressive) || m5.setProgressiveConfig(progressive), isNil_default(groupKey) || m5.setGroupKey(groupKey), customShape && m5.setCustomizedShapeCallback(customShape), this.initMarkStyleWithSpec(m5, mergeSpec({}, themeSpec, markSpec || spec[m5.name]));
    }
    return m5;
  }
  _getDataIdKey() {
    var _a;
    return null !== (_a = super._getDataIdKey()) && void 0 !== _a ? _a : DEFAULT_DATA_KEY;
  }
  _getSeriesDataKey(datum) {
    let key = "";
    if (!datum) return key;
    const dimensionFields = this.getDimensionField();
    key = dimensionFields.map((field5) => datum[field5]).join("_");
    const seriesField = this.getSeriesField();
    return seriesField && !dimensionFields.includes(seriesField) && (key += `_${datum[seriesField]}`), key;
  }
  addViewDataFilter(option) {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.transform(option, false);
  }
  reFilterViewData() {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.reRunAllTransform();
  }
  reTransformViewData() {
    var _a, _b;
    null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  fillData() {
    var _a;
    null === (_a = this.getRawData()) || void 0 === _a || _a.reRunAllTransform();
  }
  compile() {
    this.compileData();
  }
  getDefaultShapeType() {
    return "circle";
  }
  getFieldAlias(field5) {
    var _a;
    return field5 !== STACK_FIELD_END && field5 !== STACK_FIELD_END_PERCENT && field5 !== STACK_FIELD_START && field5 !== STACK_FIELD_START_PERCENT || (field5 = this.getStackValueField()), null !== (_a = getFieldAlias(this.getRawData(), field5)) && void 0 !== _a ? _a : field5;
  }
  getMarkInfoList() {
    var _a;
    const list = super.getMarkInfoList();
    return list.length ? list : Object.values(null !== (_a = seriesMarkInfoMap[this.type]) && void 0 !== _a ? _a : {});
  }
  _getInvalidConnectType() {
    return "zero" === this._invalidType ? "zero" : "link" === this._invalidType ? "connect" : "none";
  }
};
BaseSeries.mark = baseSeriesMark, BaseSeries.transformerConstructor = BaseSeriesSpecTransformer;

// node_modules/@visactor/vchart/esm/series/util/utils.js
function isPolarAxisSeries(type) {
  return [SeriesTypeEnum.rose, SeriesTypeEnum.radar, SeriesTypeEnum.circularProgress].includes(type);
}
function sortDataInAxisHelper(axisHelper, field5, dataList) {
  const scale4 = axisHelper.getScale(0), isRevert = "isInverse" in axisHelper && axisHelper.isInverse();
  isContinuous(scale4.type) ? dataList.sort((datumA, datumB) => (datumA[field5] - datumB[field5]) * (isRevert ? -1 : 1)) : dataList.sort((datumA, datumB) => (scale4._index.get(datumA[field5]) - scale4._index.get(datumB[field5])) * (isRevert ? -1 : 1));
}
function getGroupAnimationParams(series2) {
  return {
    dataIndex: (datum) => {
      var _a, _b;
      const indexField = "horizontal" === series2.direction ? series2.fieldY[0] : series2.fieldX[0], indexValue = null == datum ? void 0 : datum[indexField], scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).indexOf(indexValue) || 0;
    },
    dataCount: () => {
      var _a, _b, _c;
      const scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return null !== (_c = (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).length) && void 0 !== _c ? _c : 0;
    }
  };
}

// node_modules/@visactor/vchart/esm/series/cartesian/cartesian.js
var CartesianSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "cartesian", this._bandPosition = 0.5, this._scaleConfig = {
      bandPosition: this._bandPosition
    }, this._direction = "vertical", this._sortDataByAxis = false, this._getInvalidDefined = (datum) => {
      var _a, _b;
      return !((null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.isContinuous) && !couldBeValidNumber(datum[this._specXField[0]])) && !((null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.isContinuous) && !couldBeValidNumber(datum[this._specYField[0]]));
    };
  }
  _buildScaleConfig() {
    this._scaleConfig = {
      bandPosition: this._bandPosition
    };
  }
  get fieldX() {
    return this._fieldX;
  }
  setFieldX(f2) {
    this._fieldX = array(f2);
  }
  get fieldY() {
    return this._fieldY;
  }
  setFieldY(f2) {
    this._fieldY = array(f2);
  }
  get fieldZ() {
    return this._fieldZ;
  }
  setFieldZ(f2) {
    this._fieldZ = f2 && array(f2);
  }
  get fieldX2() {
    return this._fieldX2;
  }
  setFieldX2(f2) {
    this._fieldX2 = f2;
  }
  get fieldY2() {
    return this._fieldY2;
  }
  setFieldY2(f2) {
    this._fieldY2 = f2;
  }
  get direction() {
    return this._direction;
  }
  get scaleX() {
    return this._scaleX;
  }
  setScaleX(s3) {
    this._scaleX = s3;
  }
  get scaleY() {
    return this._scaleY;
  }
  setScaleY(s3) {
    this._scaleY = s3;
  }
  get scaleZ() {
    return this._scaleZ;
  }
  setScaleZ(s3) {
    this._scaleZ = s3;
  }
  getXAxisHelper() {
    return this._xAxisHelper;
  }
  setXAxisHelper(h2) {
    this._xAxisHelper = h2, this.onXAxisHelperUpdate();
  }
  getYAxisHelper() {
    return this._yAxisHelper;
  }
  setYAxisHelper(h2) {
    this._yAxisHelper = h2, this.onYAxisHelperUpdate();
  }
  getZAxisHelper() {
    return this._zAxisHelper;
  }
  setZAxisHelper(h2) {
    this._zAxisHelper = h2, this.onYAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  getStatisticFields() {
    var _a, _b, _c;
    const fields2 = [];
    return (null === (_a = this.getXAxisHelper()) || void 0 === _a ? void 0 : _a.getScale) && (this._fieldX2 ? [...this._fieldX, this._fieldX2] : this._fieldX).forEach((f2) => {
      const result2 = {
        key: f2,
        operations: []
      };
      isContinuous(this.getXAxisHelper().getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), (null === (_b = this.getYAxisHelper()) || void 0 === _b ? void 0 : _b.getScale) && (this._fieldY2 ? [...this._fieldY, this._fieldY2] : this._fieldY).forEach((f2) => {
      const result2 = {
        key: f2,
        operations: []
      };
      isContinuous(this.getYAxisHelper().getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), this._fieldZ && (null === (_c = this.getZAxisHelper()) || void 0 === _c ? void 0 : _c.getScale) && this._fieldZ.forEach((f2) => {
      const result2 = {
        key: f2,
        operations: []
      };
      isContinuous(this.getZAxisHelper().getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), this.getStack() && fields2.push({
      key: this.getStackValueField(),
      operations: ["allValid"]
    }), fields2;
  }
  getGroupFields() {
    return "vertical" === this.direction ? this._fieldX : this._fieldY;
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getStackValue() {
    var _a;
    return null !== (_a = this._spec.stackValue) && void 0 !== _a ? _a : `${PREFIX}_series_${this.type}_${("horizontal" === this.direction ? this.getXAxisHelper() : this.getYAxisHelper()).getAxisId()}`;
  }
  getStackValueField() {
    return "vertical" === this.direction ? array(this._spec.yField)[0] : array(this._spec.xField)[0];
  }
  setValueFieldToStack() {
    "vertical" === this.direction ? (this.setFieldY(STACK_FIELD_END), this.setFieldY2(STACK_FIELD_START)) : (this.setFieldX(STACK_FIELD_END), this.setFieldX2(STACK_FIELD_START));
  }
  setValueFieldToPercent() {
    "vertical" === this.direction ? (this.setFieldY(STACK_FIELD_END_PERCENT), this.setFieldY2(STACK_FIELD_START_PERCENT)) : (this.setFieldX(STACK_FIELD_END_PERCENT), this.setFieldX2(STACK_FIELD_START_PERCENT));
  }
  setValueFieldToStackOffsetSilhouette() {
    "vertical" === this.direction ? (this.setFieldY(STACK_FIELD_END_OffsetSilhouette), this.setFieldY2(STACK_FIELD_START_OffsetSilhouette)) : (this.setFieldX(STACK_FIELD_END_OffsetSilhouette), this.setFieldX2(STACK_FIELD_START_OffsetSilhouette));
  }
  onXAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onYAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onZAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setFieldX(this._spec.xField), this.setFieldY(this._spec.yField), this.setFieldZ(this._spec.zField), this._specXField = array(this._spec.xField), this._specYField = array(this._spec.yField), isValid_default(this._spec.direction) && (this._direction = this._spec.direction), this.setFieldX2(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.x2Field), this.setFieldY2(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.y2Field), this._stack && this.setValueFieldToStack(), this._percent && this.setValueFieldToPercent(), this._stackOffsetSilhouette && this.setValueFieldToStackOffsetSilhouette(), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  dataToPosition(datum) {
    return datum ? {
      x: this.dataToPositionX(datum),
      y: this.dataToPositionY(datum)
    } : null;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToX = this.valueToPositionX.bind(this), this._markAttributeContext.valueToY = this.valueToPositionY.bind(this), this._markAttributeContext.xBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getXAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.yBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getYAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this);
  }
  valueToPosition(xValue, yValue) {
    return {
      x: this.valueToPositionX(xValue),
      y: this.valueToPositionY(yValue)
    };
  }
  _axisPosition(helper, value, datum) {
    return this._scaleConfig.datum = datum, helper.isContinuous ? helper.valueToPosition(value, this._scaleConfig) : helper.dataToPosition(array(value), this._scaleConfig);
  }
  valueToPositionX(value, datum) {
    return this._axisPosition(this._xAxisHelper, value, datum);
  }
  valueToPositionY(value, datum) {
    return this._axisPosition(this._yAxisHelper, value, datum);
  }
  dataToPositionX(datum) {
    if (this._positionXEncoder) return this._positionXEncoder(datum);
    if (!this._xAxisHelper) return this._positionXEncoder = (datum2) => Number.NaN, Number.NaN;
    const fields2 = this._xAxisHelper.getFields ? this._xAxisHelper.getFields() : this._fieldX;
    return fields2 && 0 !== fields2.length ? (this._xAxisHelper.isContinuous ? this._positionXEncoder = (datum2) => (this._scaleConfig.datum = datum2, this._xAxisHelper.valueToPosition(this.getDatumPositionValue(datum2, fields2[0]), this._scaleConfig)) : this._positionXEncoder = (datum2) => (this._scaleConfig.datum = datum2, this._xAxisHelper.dataToPosition(array(this.getDatumPositionValues(datum2, fields2)), this._scaleConfig)), this._positionXEncoder(datum)) : (this._positionXEncoder = (datum2) => null, null);
  }
  dataToPositionY(datum) {
    if (this._positionYEncoder) return this._positionYEncoder(datum);
    if (!this._yAxisHelper) return this._positionYEncoder = (datum2) => Number.NaN, Number.NaN;
    const fields2 = this._yAxisHelper.getFields ? this._yAxisHelper.getFields() : this._fieldY;
    return fields2 && 0 !== fields2.length ? (this._yAxisHelper.isContinuous ? this._positionYEncoder = (datum2) => (this._scaleConfig.datum = datum2, this._yAxisHelper.valueToPosition(this.getDatumPositionValue(datum2, fields2[0]), this._scaleConfig)) : this._positionYEncoder = (datum2) => (this._scaleConfig.datum = datum2, this._yAxisHelper.dataToPosition(array(this.getDatumPositionValues(datum2, fields2)), this._scaleConfig)), this._positionYEncoder(datum)) : (this._positionYEncoder = (datum2) => null, null);
  }
  dataToPositionZ(datum) {
    if (!this._zAxisHelper) return Number.NaN;
    const { dataToPosition } = this._zAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldZ), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionX1(datum) {
    return this._xAxisHelper ? this._fieldX2 && this._fieldX2 in datum ? this.valueToPositionX(this.getDatumPositionValues(datum, this._fieldX2)) : this.valueToPositionX(0) : Number.NaN;
  }
  dataToPositionY1(datum) {
    return this._yAxisHelper ? this._fieldY2 && this._fieldY2 in datum ? this.valueToPositionY(this.getDatumPositionValues(datum, this._fieldY2)) : this.valueToPositionY(0) : Number.NaN;
  }
  positionToData(p2) {
    return p2 ? {
      x: this.positionToDataX(p2.x),
      y: this.positionToDataY(p2.y)
    } : null;
  }
  positionToDataX(xPos) {
    return this._scaleX ? this._scaleX.invert(xPos) : null;
  }
  positionToDataY(yPos) {
    return this._scaleY ? this._scaleY.invert(yPos) : null;
  }
  getRegionRectLeft() {
    if (!this._xAxisHelper) return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[0];
  }
  getRegionRectRight() {
    if (!this._xAxisHelper) return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[1];
  }
  afterInitMark() {
    super.afterInitMark(), this.setFieldX(this._fieldX), this.setFieldY(this._fieldY), this._trigger.setStateKeys([...this._fieldX, ...this._fieldY]), this._buildScaleConfig();
  }
  getDimensionField() {
    return "vertical" === this._direction ? this._specXField : this._specYField;
  }
  getMeasureField() {
    return "vertical" === this._direction ? this._specYField : this._specXField;
  }
  viewDataUpdate(d2) {
    super.viewDataUpdate(d2), this.sortDataByAxis && this._sortDataInAxisDomain();
  }
  _sortDataInAxisDomain() {
    var _a, _b, _c;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && (sortDataInAxisHelper("horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper, "horizontal" === this._direction ? this._fieldY[0] : this._fieldX[0], this.getViewData().latestData), null === (_c = this._data) || void 0 === _c || _c.updateData(true));
  }
  reInit(spec) {
    this._positionXEncoder && (this._positionXEncoder = null), this._positionYEncoder && (this._positionYEncoder = null), super.reInit(spec);
  }
};

// node_modules/@visactor/vchart/esm/typings/interpolate.js
var DEFAULT_SMOOTH_INTERPOLATE = "monotone";
var DEFAULT_LINEAR_INTERPOLATE = "linear";

// node_modules/@visactor/vchart/esm/typings/line-stroke.js
var DEFAULT_CLOSE_STROKE_JOIN = "bevel";

// node_modules/@visactor/vchart/esm/series/mixin/line-mixin.js
var LineLikeSeriesMixin = class {
  addSamplingCompile() {
    if (this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "vertical" === this._direction ? width : height,
        factor: this._spec.samplingFactor,
        yfield: "vertical" === this._direction ? fieldsY[0] : fieldsX[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  addOverlapCompile() {
    var _a;
    if (this._spec.markOverlap) {
      const overlapTrans = [];
      overlapTrans.push({
        type: "markoverlap",
        direction: "horizontal" === this._direction && "cartesian" === this.coordinate ? 2 : 1,
        delta: this._spec.pointDis,
        deltaMul: this._spec.pointDisMul,
        groupBy: this._seriesField
      }), null === (_a = this._symbolMark) || void 0 === _a || _a.getProduct().transform(overlapTrans);
    }
  }
  reCompileSampling() {
    this._spec.sampling && this.compile();
  }
  initLineMark(progressive, isSeriesMark) {
    var _a;
    return this._lineMark = this._createMark(lineLikeSeriesMark.line, {
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: null == isSeriesMark || isSeriesMark,
      progressive,
      customShape: null === (_a = this._spec.line) || void 0 === _a ? void 0 : _a.customShape
    }), this._lineMark;
  }
  initLineMarkStyle(direction2, areaCurveType) {
    var _a, _b;
    const lineMark = this._lineMark;
    if (lineMark) {
      if (this.setMarkStyle(lineMark, {
        stroke: this.getColorAttribute()
      }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(lineMark, {
        defined: this._getInvalidDefined,
        connectedType: this._getInvalidConnectType()
      }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
        filter: (param) => param.model === this
      }, () => {
        this.encodeDefined(lineMark, "defined");
      }), "polar" === this.coordinate) this.setMarkStyle(lineMark, {
        lineJoin: DEFAULT_CLOSE_STROKE_JOIN,
        curveType: DEFAULT_LINEAR_INTERPOLATE,
        closePath: true
      }, "normal", AttributeLevel.Series);
      else {
        const userCurveType = null != areaCurveType ? areaCurveType : null === (_b = null === (_a = this.getSpec().line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "vertical" === direction2 ? "monotoneX" : "monotoneY" : userCurveType;
        this.setMarkStyle(lineMark, {
          curveType
        }, "normal", AttributeLevel.Built_In);
      }
      this.setMarkStyle(lineMark, {
        x: this.dataToPositionX.bind(this),
        y: this.dataToPositionY.bind(this),
        z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
      }, "normal", AttributeLevel.Series), this._trigger.registerMark(lineMark);
    }
    return lineMark;
  }
  _getEventElement(params2, reverse2 = false) {
    let data = [];
    return params2.dimensionInfo.some((df) => (df.data.some((dd) => dd.series === this && (data = dd.datum, true)), !data.length)), data;
  }
  _dimensionTrigger(params2) {
    const elements = this._getEventElement(params2);
    switch (params2.action) {
      case "enter":
        this._symbolActiveMark.getDataView().parse(elements), this._symbolActiveMark.getData().updateData(false);
        break;
      case "leave":
        this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(false);
    }
  }
  initSymbolMark(progressive, isSeriesMark) {
    var _a, _b, _c;
    if (false !== (null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.visible) && (this._symbolMark = this._createMark(lineLikeSeriesMark.point, {
      morph: shouldMarkDoMorph(this._spec, lineLikeSeriesMark.point.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      progressive,
      isSeriesMark: !!isSeriesMark,
      customShape: null === (_b = this._spec.point) || void 0 === _b ? void 0 : _b.customShape
    })), true === this._spec.activePoint) {
      const activeData = new DataView(this._option.dataSet, {
        name: `${PREFIX}_series_${this.id}_active_point`
      });
      activeData.parse([]), this._symbolActiveMark = this._createMark({
        name: "active_point",
        type: "symbol"
      }, {
        morph: false,
        groupKey: this._seriesField,
        isSeriesMark: false,
        dataView: activeData,
        parent: this._region.getInteractionMark(),
        customShape: null === (_c = this._spec.point) || void 0 === _c ? void 0 : _c.customShape
      }), this._symbolActiveMark.setVisible(false);
    }
    return this._symbolMark;
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    if (!symbolMark) return this._initSymbolActiveMarkAlone(), symbolMark;
    if (this._initSymbolMark(symbolMark), this._trigger.registerMark(symbolMark), this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover) {
      this._symbolActiveMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this));
      for (const state in this._symbolMark.stateStyle) {
        this._symbolActiveMark.stateStyle[state] = {};
        for (const key in this._symbolMark.stateStyle[state]) this._symbolActiveMark.stateStyle[state][key] = {
          style: null,
          level: AttributeLevel.Series,
          referer: symbolMark
        };
      }
      this._symbolActiveMark.state.changeStateInfo({
        stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
        filter: () => true
      });
    }
    return symbolMark;
  }
  _initSymbolMark(symbolMark) {
    symbolMark && (this.setMarkStyle(symbolMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
      visible: this._getInvalidDefined
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(symbolMark, "visible");
    }), this.setMarkStyle(symbolMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, "normal", AttributeLevel.Series));
  }
  _initSymbolActiveMarkAlone() {
    var _a, _b;
    const symbolMark = this._symbolActiveMark;
    symbolMark && (this._initSymbolMark(symbolMark), symbolMark && (null === (_b = null === (_a = this._spec[lineLikeSeriesMark.point.name]) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.dimension_hover) && (symbolMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this)), this.initMarkStyleWithSpec(symbolMark, mergeSpec({}, this._spec[lineLikeSeriesMark.point.name], {
      visible: true
    })), this._symbolActiveMark.state.changeStateInfo({
      stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
      filter: () => true
    })));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    labelMark && ("symbol" !== (null === (_a = labelMark.getTarget()) || void 0 === _a ? void 0 : _a.type) && labelMark.setRule("line-data"), this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(labelMark, "visible");
    }));
  }
  initLineLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getSeriesField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  encodeDefined(mark, attr) {
    var _a, _b, _c, _d, _e, _f;
    if (!mark) return;
    const statistics2 = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[this.getStackValueField()];
    if ("zero" === this._invalidType || statistics2 && (null == statistics2 ? void 0 : statistics2.allValid)) {
      if (true === (null === (_d = null === (_c = mark.stateStyle.normal) || void 0 === _c ? void 0 : _c[attr]) || void 0 === _d ? void 0 : _d.style)) return;
      this.setMarkStyle(mark, {
        [attr]: true
      }, "normal", AttributeLevel.Series);
    } else {
      if (true !== (null === (_f = null === (_e = mark.stateStyle.normal) || void 0 === _e ? void 0 : _e[attr]) || void 0 === _f ? void 0 : _f.style)) return;
      this.setMarkStyle(mark, {
        [attr]: this._getInvalidDefined
      }, "normal", AttributeLevel.Series);
    }
    mark.getProduct() && mark.compileEncode();
  }
};

// node_modules/@visactor/vchart/esm/mark/base/base-line.js
var BaseLineMark = class extends BaseMark {
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style)) return;
    void 0 === stateStyle[state] && (stateStyle[state] = {});
    const ignoreAttributes = this._getIgnoreAttributes(), segmentAttributes = ["strokeWidth", "lineWidth", "lineDash", "strokeDash", "lineJoin", "stroke", "strokeOpacity", "opacity", "fill", "fillOpacity", "texture", "texturePadding", "textureSize", "textureColor"], isUserLevel = this.isUserLevel(level);
    let enableSegments = false;
    Object.keys(style).forEach((attr) => {
      const attrStyle = style[attr];
      if (isNil_default(attrStyle) || ignoreAttributes.includes(attr)) return;
      isUserLevel && segmentAttributes.includes(attr) && (isValidScaleType(null == attrStyle ? void 0 : attrStyle.type) || (null == attrStyle ? void 0 : attrStyle.scale) || isFunction_default(attrStyle)) && (enableSegments = true);
      let styleConverter = this._styleConvert(attrStyle);
      isUserLevel && "angle" === attr && (styleConverter = this.convertAngleToRadian(styleConverter)), this.setAttribute(attr, styleConverter, state, level, stateStyle);
    }), enableSegments && this.setEnableSegments(enableSegments);
  }
};

// node_modules/@visactor/vchart/esm/mark/line.js
var LineMark = class _LineMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _LineMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 1
    });
  }
  _getIgnoreAttributes() {
    var _a, _b;
    return (null === (_a = this.model) || void 0 === _a ? void 0 : _a.type) === SeriesTypeEnum.radar && "polar" === (null === (_b = this.model) || void 0 === _b ? void 0 : _b.coordinate) ? [] : ["fill", "fillOpacity"];
  }
};
LineMark.type = "line";
var registerLineMark = () => {
  Factory2.registerMark(LineMark.type, LineMark), registerLineGraphic2(), registerVGrammarLineOrAreaAnimation();
};

// node_modules/@visactor/vchart/esm/mark/symbol.js
var BaseSymbolMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      size: 1,
      symbolType: "circle",
      fill: void 0,
      lineWidth: 0
    });
  }
};
var SymbolMark = class _SymbolMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _SymbolMark.type;
  }
};
SymbolMark.type = "symbol";
var registerSymbolMark = () => {
  Factory2.registerMark(SymbolMark.type, SymbolMark), registerSymbolGraphic2();
};

// node_modules/@visactor/vchart/esm/series/mixin/line-mixin-transformer.js
var LineLikeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible) ? this._addMarkLabelSpec(spec, "point") : this._addMarkLabelSpec(spec, "line"), this._addMarkLabelSpec(spec, "line", "lineLabel", "initLineLabelMarkStyle", void 0, true);
  }
};

// node_modules/@visactor/vchart/esm/series/line/line.js
var LineSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.line, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "line";
    this.initLineMark(progressive, "line" === seriesMark), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initTooltip() {
    super.initTooltip(), this._lineMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._lineMark), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
  }
  initMarkStyle() {
    this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const lineAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._lineMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("line")) || void 0 === _c ? void 0 : _c(lineAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    var _a;
    const isLineAsSeriesMark = "point" !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.seriesMark);
    return (attribute) => {
      var _a2, _b;
      return isLineAsSeriesMark && "fill" === attribute && (attribute = "stroke"), null !== (_b = null === (_a2 = this._seriesMark) || void 0 === _a2 ? void 0 : _a2.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._lineMark, this._symbolMark];
  }
};
LineSeries.type = SeriesTypeEnum.line, LineSeries.mark = lineSeriesMark, LineSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(LineSeries, LineLikeSeriesMixin);
var registerLineSeries = () => {
  registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerSymbolMark(), registerLineAnimation(), registerScaleInOutAnimation(), Factory2.registerSeries(LineSeries.type, LineSeries);
};

// node_modules/@visactor/vchart/esm/chart/chart-meta/data.js
var ChartData = class {
  get dataList() {
    return this._dataArr;
  }
  constructor(dataSet, onError) {
    this._dataArr = [], this._onError = onError, this._dataSet = dataSet;
  }
  parseData(dataSpec) {
    this._dataArr = [];
    const list = array(dataSpec);
    for (let i2 = 0; i2 < list.length; i2++) this._dataArr.push(dataToDataView(list[i2], this._dataSet, this._dataArr, {
      onError: this._onError
    }));
  }
  updateData(dataSpec, fullUp = false, forceMerge = true) {
    const list = array(dataSpec);
    return (!fullUp || list.length === this._dataArr.length) && (this._dataValueForEach(list, (_data, dv) => {
      dv.markRunning();
    }), this._dataValueForEach(list, (data, dv) => {
      updateDataViewInData(dv, data, forceMerge);
    }), true);
  }
  _dataValueForEach(list, callBack) {
    list.forEach((data, i2) => {
      if (data instanceof DataView) return;
      const dv = this.getSeriesData(data.id, i2);
      dv && callBack(data, dv, i2);
    });
  }
  getSeriesData(id2, index) {
    var _a, _b;
    if (!this._dataArr.length) return null;
    if ("string" == typeof id2) {
      const metchData = this._dataArr.filter((data) => data.name === id2);
      return metchData[0] ? metchData[0] : (null === (_a = this._onError) || void 0 === _a || _a.call(this, `no data matches dataId ${id2}!`), null);
    }
    return "number" == typeof index ? this._dataArr[index] ? this._dataArr[index] : (null === (_b = this._onError) || void 0 === _b || _b.call(this, `no data matches dataIndex ${index}!`), null) : this._dataArr[0];
  }
};

// node_modules/@visactor/vchart/esm/scale/global-scale.js
var GlobalScale = class {
  constructor(spec, chart) {
    this._scaleSpecMap = /* @__PURE__ */ new Map(), this._scaleMap = /* @__PURE__ */ new Map(), this._modelScaleSpecMap = /* @__PURE__ */ new Map(), this._markAttributeScaleMap = /* @__PURE__ */ new Map(), this._spec = null, this._chart = null, this.getStatisticalFields = (dataId) => {
      const result2 = [];
      return this._scaleSpecMap.forEach((v2, k3) => {
        isDataDomainSpec(v2.domain) && v2.domain.forEach((spec2) => {
          spec2.dataId === dataId && spec2.fields.forEach((key) => {
            mergeFields(result2, [{
              key,
              operations: isContinuous(v2.type) ? ["max", "min"] : ["values"]
            }]);
          });
        });
      }), this._markAttributeScaleMap.forEach((specList, scaleName) => {
        const scale4 = this.getScale(scaleName);
        specList.forEach((spec2) => {
          this._getSeriesBySeriesId(spec2.seriesId).getRawData().name === dataId && spec2.field && mergeFields(result2, [{
            key: spec2.field,
            operations: isContinuous(scale4.type) ? ["max", "min"] : ["values"]
          }]);
        });
      }), result2;
    }, this._spec = spec, this._chart = chart, this._setAttrFromSpec();
  }
  _createFromSpec(s3) {
    if (!s3.id) return null;
    let scale4 = this._scaleMap.get(s3.id);
    return scale4 || (scale4 = "ordinal" === s3.type && "color" === s3.id ? createScale2("colorOrdinal") : createScale2(s3.type)), scale4 ? (isArray_default(s3.range) && scale4.range(s3.range), isArray_default(s3.domain) && (isDataDomainSpec(s3.domain) || scale4.domain(s3.domain)), s3.specified && scale4.specified && scale4.specified(s3.specified), scale4) : null;
  }
  _setAttrFromSpec() {
    var _a;
    if (!(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.length)) return;
    const newScaleMap = /* @__PURE__ */ new Map(), newScaleSpecMap = /* @__PURE__ */ new Map();
    this._spec.forEach((s3) => {
      const scale4 = this._createFromSpec(s3);
      scale4 && (newScaleMap.set(s3.id, scale4), newScaleSpecMap.set(s3.id, s3));
    }), this._modelScaleSpecMap.forEach((s3) => {
      const scale4 = this._createFromSpec(s3);
      scale4 && (newScaleMap.set(s3.id, scale4), newScaleSpecMap.set(s3.id, s3));
    }), this._scaleSpecMap = newScaleSpecMap, this._scaleMap = newScaleMap;
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (isEqual(spec, this._spec)) return result2;
    result2.change = true;
    for (let i2 = 0; i2 < spec.length; i2++) {
      const s3 = spec[i2], scale4 = this._scaleMap.get(s3.id);
      if (!scale4) return result2.reMake = true, result2;
      const lastSpec = this._spec.find((_s) => _s.id === s3.id);
      if (!lastSpec.id) return result2.reMake = true, result2;
      if (lastSpec.type !== s3.type) return result2.reMake = true, result2;
      s3.range && !isEqual(s3.range, scale4.range()) && (scale4.range(s3.range), result2.reRender = true), isDataDomainSpec(s3.domain) ? result2.reRender = true : isEqual(s3.domain, scale4.domain()) || (scale4.domain(s3.domain), result2.reRender = true), this._scaleSpecMap.set(s3.id, s3);
    }
    return this._spec = spec, result2;
  }
  registerModelScale(spec) {
    const scale4 = this._createFromSpec(spec);
    scale4 && (this._modelScaleSpecMap.set(spec.id, spec), this._scaleSpecMap.set(spec.id, spec), this._scaleMap.set(spec.id, scale4));
  }
  removeModelScale(filter2) {
    this._modelScaleSpecMap.forEach((spec) => {
      filter2(spec) && (this._modelScaleSpecMap.delete(spec.id), this._scaleSpecMap.delete(spec.id), this._scaleMap.delete(spec.id));
    });
  }
  getScale(user_id) {
    return this._scaleMap.get(user_id);
  }
  getScaleSpec(user_id) {
    return this._scaleSpecMap.get(user_id);
  }
  _getSeriesByRawDataId(id2) {
    const series2 = this._chart.getAllSeries();
    for (let i2 = 0; i2 < series2.length; i2++) {
      const s3 = series2[i2];
      if (s3.getRawData().name === id2) return s3;
    }
    return null;
  }
  _getSeriesBySeriesId(id2) {
    const series2 = this._chart.getAllSeries();
    for (let i2 = 0; i2 < series2.length; i2++) {
      const s3 = series2[i2];
      if (s3.id === id2) return s3;
    }
    return null;
  }
  updateScaleDomain(defaultDomain) {
    this._scaleSpecMap.forEach((scaleSpec, id2) => {
      const scale4 = this._scaleMap.get(id2);
      if (!scale4) return;
      if (!isDataDomainSpec(scaleSpec.domain)) return scaleSpec.domain && 0 !== scaleSpec.domain.length || scale4.domain(defaultDomain), void this._updateMarkScale(id2, scale4, scale4.domain().slice());
      let domain;
      domain = isContinuous(scaleSpec.type) ? [null, null] : /* @__PURE__ */ new Set(), scaleSpec.domain.forEach((spec) => {
        const series2 = this._getSeriesByRawDataId(spec.dataId);
        if (!series2) return;
        const isContinuousField = isContinuous(scaleSpec.type);
        spec.fields.forEach((key) => {
          const statistics2 = series2.getRawDataStatisticsByField(key, isContinuousField);
          statistics2 && (isContinuousField ? (isNil_default(domain[0]) ? domain[0] = statistics2.min : domain[0] = Math.min(statistics2.min, domain[0]), isNil_default(domain[1]) ? domain[1] = statistics2.max : domain[1] = Math.max(statistics2.max, domain[1])) : statistics2.values.forEach((value) => {
            domain.add(value);
          }));
        });
      });
      const scaleDomain = domain;
      isContinuous(scaleSpec.type) || (domain = Array.from(domain)), scale4.domain(domain), this._updateMarkScale(id2, scale4, scaleDomain);
    });
  }
  _updateMarkScale(id2, scale4, domain) {
    const list = this._markAttributeScaleMap.get(id2);
    list && 0 !== list.length && list.forEach((info) => {
      if (!info.field || !info.markScale || info.markScale === scale4) return;
      if (isNil_default(info.changeDomain) || "none" === info.changeDomain || isNil_default(info.seriesId)) return void (isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain)));
      const series2 = this._getSeriesBySeriesId(info.seriesId), isContinuousScale = isContinuous(scale4.type), statistics2 = series2.getRawDataStatisticsByField(info.field, isContinuousScale);
      if (!isEmpty_default(statistics2)) return "expand" === info.changeDomain ? (isContinuousScale ? (domain[0] = Math.min(domain[0], statistics2.min), domain[1] = Math.max(domain[1], statistics2.max)) : (statistics2.values.forEach((value) => {
        domain.add(value);
      }), domain = Array.from(domain)), void info.markScale.domain(domain)) : void ("replace" !== info.changeDomain || (isContinuousScale ? info.markScale.domain([statistics2.min, statistics2.max]) : info.markScale.domain(statistics2.values)));
      isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain));
    });
  }
  registerMarkAttributeScale(spec, seriesId) {
    const scale4 = this._scaleMap.get(spec.scale);
    let list = this._markAttributeScaleMap.get(spec.scale);
    list || (list = [], this._markAttributeScaleMap.set(spec.scale, list));
    let markScale = scale4;
    return (isNil_default(spec.field) || !isNil_default(spec.changeDomain) && "none" !== spec.changeDomain && !isNil_default(seriesId)) && (markScale = scale4.clone()), list.push(Object.assign(Object.assign({}, spec), {
      seriesId,
      markScale
    })), markScale;
  }
};

// node_modules/@visactor/vchart/esm/chart/stack.js
var Stack = class {
  constructor(chart) {
    this.stackRegion = ({ model }) => {
      const series2 = model.getSeries();
      if (!series2.some((s3) => s3.getStack())) return;
      const hasTotalLabel = series2.some((s3) => {
        var _a, _b;
        return null === (_b = null === (_a = s3.getSpec()) || void 0 === _a ? void 0 : _a.totalLabel) || void 0 === _b ? void 0 : _b.visible;
      }), hasPercent = hasTotalLabel || series2.some((s3) => s3.getPercent()), hasOffsetSilhouette = series2.some((s3) => s3.getStackOffsetSilhouette()), stackValueGroup = getRegionStackGroup(model, true);
      for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stack(stackValueGroup[stackValue].nodes[key], model.getStackInverse(), hasPercent);
      if (hasOffsetSilhouette) for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackOffsetSilhouette(stackValueGroup[stackValue].nodes[key]);
      hasTotalLabel && model.getSeries().forEach((s3) => {
        const stackData = s3.getStackData(), stackValue = s3.getStackValue(), stackValueField = s3.getStackValueField();
        stackData && stackValueField && stackTotal(stackValueGroup[stackValue], stackValueField);
      });
    }, this._chart = chart;
  }
  init() {
    this._chart.getAllRegions().forEach((r2) => {
      r2.event.on(ChartEvent.regionSeriesDataFilterOver, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === r2.id
      }, this.stackRegion);
    });
  }
  stackAll() {
    this._chart.getAllRegions().forEach((r2) => {
      this.stackRegion({
        model: r2
      });
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/base/base-chart.js
var __rest11 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var BaseChart = class extends CompilableBase {
  getSpec() {
    return this._spec;
  }
  setSpec(s3) {
    this._spec = s3;
  }
  getOption() {
    return this._option;
  }
  getLayoutRect() {
    return this._layoutRect;
  }
  getViewRect() {
    return this._viewRect;
  }
  getLayoutTag() {
    return this._layoutTag;
  }
  setLayoutTag(tag, morphConfig, reLayout = true) {
    var _a;
    return this._layoutTag = tag, (null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView()) && (this.getCompiler().getVGrammarView().updateLayoutTag(), tag && reLayout && this.getCompiler().renderAsync(morphConfig)), this._layoutTag;
  }
  getEvent() {
    return this._event;
  }
  get chartData() {
    return this._chartData;
  }
  constructor(spec, option) {
    var _a, _b, _c, _d;
    super(option), this.type = "chart", this.id = createID(), this._regions = [], this._series = [], this._components = [], this._layoutRect = {
      x: 0,
      y: 0,
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewRect = {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewBox = {
      x1: 0,
      y1: 0,
      x2: DEFAULT_CHART_WIDTH,
      y2: DEFAULT_CHART_HEIGHT
    }, this._layoutTag = true, this._idMap = /* @__PURE__ */ new Map(), this.state = {
      layoutUpdateRank: 1
    }, this.padding = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }, this.getAllSeries = () => {
      var _a2;
      return null !== (_a2 = this._series) && void 0 !== _a2 ? _a2 : [];
    }, this.getRegionsInIndex = (index) => index && 0 !== index.length ? this._regions.filter((_r, i2) => index.includes(i2)) : [this._regions[0]], this.getAllRegions = () => this._regions, this.getRegionsInIds = (ids) => ids ? this._regions.filter((r2) => ids.includes(r2.id)) : [], this.getRegionsInQuerier = (region) => region ? this._regions.filter((r2, index) => array(region).some((regionFilter) => isValid_default(regionFilter.regionId) && regionFilter.regionId === r2.userId || regionFilter.regionIndex === index)) : this._regions, this.getRegionsInUserId = (userId) => {
      if (userId) return this._regions.find((r2) => r2.userId === userId);
    }, this.getRegionsInUserIdOrIndex = (user_ids, index) => this.getAllRegions().filter((r2) => (null == user_ids ? void 0 : user_ids.length) ? r2.userId && user_ids.includes(r2.userId) : !(null == index ? void 0 : index.length) || index.includes(r2.getSpecIndex())), this.getComponents = () => this._components, this.getSeriesInIndex = (index) => index && 0 !== index.length ? this._series.filter((_r, i2) => index.includes(i2)) : [this._series[0]], this.getSeriesInIds = (ids) => ids ? this._series.filter((r2) => ids.includes(r2.id)) : [], this.getSeriesInUserId = (userId) => {
      if (userId) return this._series.find((r2) => r2.userId === userId);
    }, this.getSeriesInUserIdOrIndex = (user_ids, index) => this.getAllSeries().filter((s3) => (null == user_ids ? void 0 : user_ids.length) ? s3.userId && user_ids.includes(s3.userId) : !(null == index ? void 0 : index.length) || index.includes(s3.getSpecIndex())), this.getComponentByIndex = (key, index) => {
      const components = this._components.filter((c4) => (c4.specKey || c4.type) === key);
      if (components && 0 !== components.length) return components[index];
    }, this.getComponentsByKey = (key) => this._components.filter((c4) => (c4.specKey || c4.type) === key), this.getComponentByUserId = (userId) => {
      const component2 = this._components.find((s3) => s3.userId === userId);
      if (component2) return component2;
    }, this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = spec.padding) && void 0 !== _a ? _a : option.getTheme().padding), this._event = new Event2(option.eventDispatcher, option.mode), this._dataSet = option.dataSet, this._chartData = new ChartData(this._dataSet, null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError), this._modelOption = Object.assign(Object.assign({}, option), {
      mode: this._option.mode,
      map: this._idMap,
      getChartLayoutRect: () => this._layoutRect,
      getChartViewRect: () => this._viewRect,
      getChart: () => this,
      globalScale: this._globalScale,
      onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError,
      disableTriggerEvent: true === (null === (_d = this._option) || void 0 === _d ? void 0 : _d.disableTriggerEvent),
      getSeriesData: this._chartData.getSeriesData.bind(this._chartData)
    }), this._spec = spec;
  }
  created() {
    this._transformer = new this.transformerConstructor({
      type: this.type,
      seriesType: this.seriesType,
      getTheme: this._option.getTheme,
      animation: this._option.animation
    }), this._chartData.parseData(this._spec.data), this._createGlobalScale(), this._spec.background && "object" == typeof this._spec.background && this._createBackground(), this._createLayout(), this._transformer.forEachRegionInSpec(this._spec, this._createRegion.bind(this)), this._transformer.forEachSeriesInSpec(this._spec, this._createSeries.bind(this)), this._transformer.forEachComponentInSpec(this._spec, this._createComponent.bind(this), this._option.getSpecInfo());
  }
  init() {
    this._regions.forEach((r2) => r2.init({})), this._series.forEach((s3) => s3.init({})), this._components.forEach((c4) => c4.init({
      dataSet: this._dataSet
    })), this._initEvent(), this._canStack && (this._stack = new Stack(this), this._stack.init()), this.reDataFlow();
  }
  reDataFlow() {
    this._series.forEach((s3) => {
      var _a;
      return null === (_a = s3.getRawData()) || void 0 === _a ? void 0 : _a.markRunning();
    }), this._series.forEach((s3) => s3.fillData()), this.updateGlobalScaleDomain();
  }
  onResize(width, height, reRender = true) {
    const canvasRect = {
      width,
      height
    };
    this._canvasRect = canvasRect, this._updateLayoutRect(this._option.viewBox), this.setLayoutTag(true, null, reRender);
  }
  updateViewBox(viewBox, reLayout) {
    this._option.viewBox = viewBox, this._updateLayoutRect(viewBox), this.setLayoutTag(true, null, reLayout);
  }
  _createBackground() {
    const backgroundStyle = convertBackgroundSpec(this._spec.background);
    backgroundStyle && (this._backgroundMark = Factory2.createMark("group", "chart-background", {
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._globalScale
    }), this._backgroundMark.created(), this._backgroundMark.setStyle(Object.assign(Object.assign({}, backgroundStyle), {
      x: () => this._viewBox.x1,
      y: () => this._viewBox.y1,
      width: () => this._viewBox.x2 - this._viewBox.x1,
      height: () => this._viewBox.y2 - this._viewBox.y1
    })));
  }
  _createRegion(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest11(specInfo, ["spec"]), region = new constructor(spec, Object.assign(Object.assign({}, this._modelOption), others));
    region && (region.created(), this._regions.push(region));
  }
  _createSeries(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest11(specInfo, ["spec"]);
    let region;
    if (isValid_default(spec.regionId) ? region = this.getRegionsInUserId(spec.regionId) : isValid_default(spec.regionIndex) && (region = this.getRegionsInIndex([spec.regionIndex])[0]), !region && !(region = this._regions[0])) return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      type: spec.type,
      region,
      globalScale: this._globalScale,
      sourceDataList: this._chartData.dataList
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
  getSeriesById(id2) {
    return this._series.find((x3) => x3.id === id2);
  }
  _createComponent(constructor, specInfo) {
    const component2 = constructor.createComponent(specInfo, Object.assign(Object.assign({}, this._modelOption), {
      type: constructor.type,
      getAllRegions: this.getAllRegions,
      getRegionsInIndex: this.getRegionsInIndex,
      getRegionsInIds: this.getRegionsInIds,
      getRegionsInUserIdOrIndex: this.getRegionsInUserIdOrIndex,
      getAllSeries: this.getAllSeries,
      getSeriesInIndex: this.getSeriesInIndex,
      getSeriesInIds: this.getSeriesInIds,
      getSeriesInUserIdOrIndex: this.getSeriesInUserIdOrIndex,
      getAllComponents: this.getComponents,
      getComponentByIndex: this.getComponentByIndex,
      getComponentByUserId: this.getComponentByUserId,
      getComponentsByKey: this.getComponentsByKey
    }));
    component2 && (component2.created(), this._components.push(component2));
  }
  getAllComponents() {
    return this._components;
  }
  getAllModels() {
    return [].concat(this.getAllSeries(), this.getAllComponents(), this.getAllRegions());
  }
  getModelInFilter(filter2) {
    if (isString_default(filter2)) return this.getAllModels().find((m5) => m5.userId === filter2);
    if (isFunction_default(filter2)) return this.getAllModels().find((m5) => filter2(m5));
    let index = 0;
    return this.getAllModels().find((m5) => {
      var _a;
      if ((null !== (_a = m5.specKey) && void 0 !== _a ? _a : m5.type) === filter2.type) {
        if (index === filter2.index) return true;
        index++;
      }
      return false;
    });
  }
  _createLayout() {
    this._updateLayoutRect(this._option.viewBox), this._initLayoutFunc();
  }
  setLayout(layout2) {
    this._option.layout = layout2, this._initLayoutFunc();
  }
  _initLayoutFunc() {
    var _a, _b, _c;
    if (this._layoutFunc = this._option.layout, !this._layoutFunc) {
      let use3dLayout = false;
      (this._spec.zField || this._spec.series && this._spec.series.some((s3) => s3.zField)) && (use3dLayout = true);
      const constructor = Factory2.getLayoutInKey(null !== (_b = null === (_a = this._spec.layout) || void 0 === _a ? void 0 : _a.type) && void 0 !== _b ? _b : use3dLayout ? "layout3d" : "base");
      if (constructor) {
        const layout2 = new constructor(this._spec.layout, {
          onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError
        });
        this._layoutFunc = layout2.layoutItems.bind(layout2);
      }
    }
  }
  layout(params2) {
    var _a, _b, _c, _d;
    if (null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeLayoutWithSceneGraph) || void 0 === _b || _b.call(_a), this.getLayoutTag()) {
      this._event.emit(ChartEvent.layoutStart, {
        chart: this
      }), this.onLayoutStart(params2);
      const elements = this.getLayoutElements();
      this._layoutFunc(this, elements, this._layoutRect, this._viewBox), this._event.emit(ChartEvent.afterLayout, {
        elements
      }), this.setLayoutTag(false), this.onLayoutEnd(params2), this._event.emit(ChartEvent.layoutEnd, {
        chart: this
      });
    }
    null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterLayoutWithSceneGraph) || void 0 === _d || _d.call(_c);
  }
  onLayoutStart(option) {
    this.getAllModels().forEach((element) => element.onLayoutStart(this._layoutRect, this._viewRect, option));
  }
  onLayoutEnd(option) {
    this.getAllModels().forEach((element) => element.onLayoutEnd(option));
  }
  onEvaluateEnd(option) {
    [...this._components, ...this._regions, ...this._series].forEach((element) => element.onEvaluateEnd(option));
  }
  getLayoutElements() {
    return this.getAllModels().map((i2) => i2.layout).filter((i2) => !!i2);
  }
  getModelById(id2) {
    const model = this._idMap.get(id2);
    if (model && model instanceof BaseModel) return model;
  }
  getModelByUserId(userId) {
    const series2 = this._series.find((s3) => s3.userId === userId);
    if (series2) return series2;
    const region = this._regions.find((s3) => s3.userId === userId);
    if (region) return region;
    const component2 = this._components.find((s3) => s3.userId === userId);
    return component2 || void 0;
  }
  getAllMarks() {
    return Array.from(this._idMap.values()).filter((item) => item && item instanceof BaseMark);
  }
  getMarkById(id2) {
    const mark = this._idMap.get(id2);
    if (mark && mark instanceof BaseMark) return mark;
  }
  updateData(id2, data, updateGlobalScale = true, options) {
    const dv = this._dataSet.getDataView(id2);
    dv && (dv.markRunning(), dv.parseNewData(data, options)), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  updateFullData(data, updateGlobalScale = true) {
    array(data).forEach((d2) => {
      const dv = this._dataSet.getDataView(d2.id);
      dv && dv.markRunning();
    }), array(data).forEach((d2) => {
      const dv = this._dataSet.getDataView(d2.id);
      dv && updateDataViewInData(dv, d2, true);
    }), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  onRender(option) {
  }
  setCanvasRect(width, height) {
    this._canvasRect = {
      width,
      height
    };
  }
  getCanvasRect() {
    return this._canvasRect || (this._canvasRect = calculateChartSize(this._spec, this._option, {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    })), this._canvasRect;
  }
  getSeriesData(id2, index) {
    return this._chartData.getSeriesData(id2, index);
  }
  _transformSpecScale() {
    var _a, _b;
    const scales = null !== (_a = this._spec.scales) && void 0 !== _a ? _a : [];
    let colorScaleSpec = scales.find((s3) => "color" === s3.id);
    const colorScheme3 = this.getColorScheme();
    if (!colorScaleSpec && (colorScaleSpec = {
      type: "ordinal",
      id: "color",
      domain: null,
      range: null
    }, scales.push(colorScaleSpec), this._spec.color)) {
      const colorSpec = this._spec.color;
      if (isArray_default(colorSpec)) colorScaleSpec.range = colorSpec;
      else {
        const tempSpec = colorSpec;
        Object.prototype.hasOwnProperty.call(tempSpec, "type") && (colorScaleSpec.type = tempSpec.type), Object.prototype.hasOwnProperty.call(tempSpec, "domain") && (colorScaleSpec.domain = tempSpec.domain), Object.prototype.hasOwnProperty.call(tempSpec, "range") && (colorScaleSpec.range = tempSpec.range), Object.prototype.hasOwnProperty.call(tempSpec, "specified") && (colorScaleSpec.specified = tempSpec.specified);
      }
    }
    return (null === (_b = colorScaleSpec.range) || void 0 === _b ? void 0 : _b.length) || (colorScaleSpec.range = getDataScheme(colorScheme3), colorScaleSpec.rangeTheme = true), scales;
  }
  _createGlobalScale() {
    this._globalScale = new GlobalScale(this._transformSpecScale(), this), this._modelOption.globalScale = this._globalScale;
  }
  updateGlobalScaleDomain() {
    const domainSet = /* @__PURE__ */ new Set();
    this._series.forEach((s3) => {
      const keys2 = s3.getSeriesKeys();
      keys2 && keys2.forEach((k3) => domainSet.add(k3));
    });
    const domain = Array.from(domainSet);
    this._globalScale.updateScaleDomain(domain);
  }
  updateGlobalScale(result2) {
    mergeUpdateResult(result2, this._globalScale.updateSpec(this._transformSpecScale()));
  }
  updateGlobalScaleTheme() {
    const colorSpec = this._globalScale.getScaleSpec("color"), colorScheme3 = this.getColorScheme();
    colorSpec.rangeTheme && (colorSpec.range = getDataScheme(colorScheme3), this._globalScale.getScale("color").range(colorSpec.range));
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (this.setLayoutTag(true, null, false), spec.type !== this.type) return result2.reMake = true, result2;
    const currentKeys = Object.keys(this._spec).sort(), nextKeys = Object.keys(spec).sort();
    if (JSON.stringify(currentKeys) !== JSON.stringify(nextKeys)) return result2.reMake = true, result2;
    const oldSpec = this._spec;
    return this._spec = spec, this.updateChartConfig(result2, oldSpec), result2.reMake ? result2 : (this.updateGlobalScale(result2), result2.reMake ? result2 : (this.updateRegionSpec(result2), result2.reMake ? result2 : (this.updateComponentSpec(result2), result2.reMake ? result2 : (this.updateSeriesSpec(result2), result2.reMake ? result2 : (this.updateDataSpec(result2), result2.reMake || this.updateGlobalScaleDomain(), result2)))));
  }
  updateChartConfig(result2, oldSpec) {
    var _a, _b;
    this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = this._spec.padding) && void 0 !== _a ? _a : null === (_b = this._option) || void 0 === _b ? void 0 : _b.getTheme().padding), this._updateLayoutRect(this._viewBox), isEqual(this._spec.background, oldSpec.background) || (result2.reMake = true);
  }
  updateDataSpec(result2) {
    this._spec.data && this._chartData.updateData(this._spec.data, false, true);
  }
  updateRegionSpec(result2) {
    var _a;
    (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.region) && (this._spec.region.length === this._regions.length ? this._regions.forEach((r2) => {
      mergeUpdateResult(result2, r2.updateSpec(this._spec.region[r2.getSpecIndex()]));
    }) : result2.reMake = true);
  }
  updateComponentSpec(result2) {
    const componentCache = {};
    this._components.forEach((c4) => {
      var _a, _b;
      const compSpecKey = c4.specKey || c4.type, cmpSpec = null !== (_a = this._spec[compSpecKey]) && void 0 !== _a ? _a : {};
      isArray_default(cmpSpec) ? (componentCache[compSpecKey] = componentCache[compSpecKey] || {
        specCount: cmpSpec.length,
        componentCount: 0
      }, componentCache[compSpecKey].componentCount++, mergeUpdateResult(result2, c4.updateSpec(null !== (_b = cmpSpec[c4.getSpecIndex()]) && void 0 !== _b ? _b : {}, cmpSpec))) : mergeUpdateResult(result2, c4.updateSpec(cmpSpec));
    });
    for (const key in componentCache) if (Object.prototype.hasOwnProperty.call(componentCache, key)) {
      const element = componentCache[key];
      element.componentCount !== element.specCount && (result2.reMake = true);
    }
  }
  updateSeriesSpec(result2) {
    this._spec.series.length === this._series.length ? this._series.forEach((s3) => {
      const spec = this._spec.series[s3.getSpecIndex()];
      mergeUpdateResult(result2, s3.updateSpec(spec));
    }) : result2.reMake = true;
  }
  getCanvas() {
    var _a, _b;
    return null !== (_b = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getCanvas()) && void 0 !== _b ? _b : null;
  }
  _updateLayoutRect(viewBox) {
    let viewRect = this.getCanvasRect();
    if (viewBox) {
      this._viewBox = viewBox;
      const { x1: x14 = 0, y1: y14 = 0, x2: x23, y2: y23 } = viewBox;
      viewRect = {
        width: x23 - x14,
        height: y23 - y14
      };
    } else this._viewBox = {
      x1: 0,
      y1: 0,
      x2: viewRect.width,
      y2: viewRect.height
    };
    this._viewRect = viewRect, this.padding = calcPadding(this._paddingSpec, viewRect, viewRect), this._layoutRect.width = viewRect.width - this.padding.left - this.padding.right, this._layoutRect.height = viewRect.height - this.padding.top - this.padding.bottom, this._layoutRect.x = this.padding.left, this._layoutRect.y = this.padding.top, this._event.emit(ChartEvent.layoutRectUpdate, {});
  }
  setCurrentTheme() {
    this.updateChartConfig({
      change: true,
      reMake: false
    }, this._spec), this.setLayoutTag(true, null, false), this.updateGlobalScaleTheme(), this._regions.forEach((r2) => r2.reInit(r2.getSpecInfo().spec)), this._series.forEach((s3) => s3.reInit(s3.getSpecInfo().spec)), this._components.forEach((c4) => c4.reInit(c4.getSpecInfo().spec));
  }
  clear() {
    this.getAllModels().forEach((i2) => {
      var _a;
      return null === (_a = i2.clear) || void 0 === _a ? void 0 : _a.call(i2);
    });
  }
  compile() {
    this.compileBackground(), this.compileLayout(), this.compileRegions(), this.compileSeries(), this.compileComponents();
  }
  afterCompile() {
    this.getAllRegions().forEach((r2) => {
      var _a;
      null === (_a = r2.afterCompile) || void 0 === _a || _a.call(r2);
    }), this.getAllSeries().forEach((s3) => {
      var _a;
      null === (_a = s3.afterCompile) || void 0 === _a || _a.call(s3);
    }), this.getAllComponents().forEach((c4) => {
      var _a;
      null === (_a = c4.afterCompile) || void 0 === _a || _a.call(c4);
    });
  }
  compileLayout() {
    const { width, height } = this.getCanvasRect();
    this.getCompiler().setSize(width, height);
  }
  compileBackground() {
    var _a;
    this._backgroundMark && (this._backgroundMark.compile(), null === (_a = this._backgroundMark.getProduct()) || void 0 === _a || _a.configure({
      context: {
        model: this
      }
    }).layout(() => {
    }));
  }
  compileRegions() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeRegionCompile) || void 0 === _b || _b.call(_a), this.getAllRegions().forEach((r2) => {
      r2.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterRegionCompile) || void 0 === _d || _d.call(_c);
  }
  compileSeries() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeSeriesCompile) || void 0 === _b || _b.call(_a), this.getAllSeries().forEach((s3) => {
      s3.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterSeriesCompile) || void 0 === _d || _d.call(_c);
  }
  compileComponents() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeComponentCompile) || void 0 === _b || _b.call(_a), this.getAllComponents().forEach((c4) => {
      c4.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterComponentCompile) || void 0 === _d || _d.call(_c);
  }
  release() {
    [...this._components, ...this._regions, ...this._series].forEach((m5) => {
      m5.beforeRelease();
    }), super.release(), this.clear(), [...this._components, ...this._regions, ...this._series].forEach((m5) => {
      m5.release();
    }), this._components = this._regions = this._series = [], this._spec = {}, this._dataSet = this._globalScale = this._layoutFunc = null, this._layoutTag = false, this._idMap.clear();
  }
  onLayout(srView) {
    const root = srView.rootMark;
    this.layout({
      group: root,
      srView
    });
  }
  updateState(state, filter2) {
    const seriesArr = this.getAllSeries();
    for (const key in state) {
      if (isEmpty_default(state[key])) continue;
      const stateSpec = state[key];
      let stateInfo = {
        stateValue: key
      };
      stateInfo = isFunction_default(stateSpec.filter) ? Object.assign({
        filter: stateSpec.filter
      }, stateInfo) : Object.assign(Object.assign({}, stateSpec.filter), stateInfo), stateSpec.level && (stateInfo.level = stateSpec.level), seriesArr.forEach((series2) => {
        series2.getMarks().forEach((m5) => {
          m5.stateStyle[key] && (filter2 && !filter2(series2, m5, key) || (m5.state.changeStateInfo(stateInfo), m5.updateMarkState(key)));
        });
      });
    }
  }
  setSelected(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_SELECTED, true, datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_HOVER, true, datum, filter2, region);
  }
  _initEvent() {
    [ChartEvent.dataZoomChange, ChartEvent.scrollBarChange].forEach((event) => {
      this._event.on(event, ({ value }) => {
        if (!value.filterData) return;
        this._disableMarkAnimation(["exit", "update"]);
        const enableMarkAnimate = () => {
          this._enableMarkAnimation(["exit", "update"]), this._event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
        };
        this._event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
      });
    });
  }
  _enableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product2 = mark.getProduct();
      product2 && product2.animate && product2.animate.enableAnimationState(states);
    });
  }
  _disableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product2 = mark.getProduct();
      product2 && product2.animate && product2.animate.disableAnimationState(states);
    });
  }
  _setStateInDatum(stateKey, checkReverse, datum, filter2, region) {
    const keys2 = (datum = datum ? array(datum) : null) ? Object.keys(datum[0]) : null;
    this.getRegionsInQuerier(region).forEach((r2) => {
      datum ? (r2.getSeries().forEach((s3) => {
        s3.getMarks().forEach((m5) => {
          if (m5.getProduct() && (!filter2 || isFunction_default(filter2) && filter2(s3, m5))) {
            const isCollect = m5.getProduct().isCollectionMark(), elements = m5.getProduct().elements;
            let pickElements = elements;
            if (isCollect) pickElements = elements.filter((e3) => {
              const elDatum = e3.getDatum();
              datum.every((d2, index) => keys2.every((k3) => d2[k3] == elDatum[index][k3]));
            });
            else if (datum.length > 1) {
              const datumTemp = datum.slice();
              pickElements = elements.filter((e3) => {
                if (0 === datumTemp.length) return false;
                const elDatum = e3.getDatum(), index = datumTemp.findIndex((d2) => keys2.every((k3) => d2[k3] == elDatum[k3]));
                return index >= 0 && (datumTemp.splice(index, 1), true);
              });
            } else {
              const el = elements.find((e3) => keys2.every((k3) => datum[0][k3] == e3.getDatum()[k3]));
              el && (pickElements = [el]);
            }
            pickElements.forEach((element) => {
              r2.interaction.addEventElement(stateKey, element);
            });
          }
        });
      }), checkReverse && r2.interaction.reverseEventElement(stateKey)) : r2.interaction.clearEventElement(stateKey, true);
    });
  }
  setDimensionIndex(value, opt) {
    var _a, _b, _c, _d;
    let dimensionInfo = null;
    Array.from(this._event.getComposedEventMap().values()).forEach((e3) => {
      const { eventType, event } = e3;
      if (eventType === DimensionEventEnum.dimensionHover || eventType === DimensionEventEnum.dimensionClick) {
        const info = event.dispatch(value, opt);
        (null == info ? void 0 : info.length) && (dimensionInfo = info);
      }
    });
    const isUnableValue = isNil_default(value) || !dimensionInfo || dimensionInfo.every((d2) => isDiscrete(d2.axis.getScale().type) && isNil_default(d2.index));
    if (false !== opt.tooltip) {
      const tooltip3 = this._components.find((c4) => c4.type === ComponentTypeEnum.tooltip);
      if (null == tooltip3 ? void 0 : tooltip3.getVisible()) if (isUnableValue) null === (_b = (_a = tooltip3).hideTooltip) || void 0 === _b || _b.call(_a);
      else {
        const dataFilter = {};
        dimensionInfo.forEach((d2) => {
          const { axis: axis2, value: value2, data } = d2, isY = "left" === axis2.getOrient() || "right" === axis2.getOrient();
          data.forEach((d3) => {
            isY ? dataFilter[d3.series.fieldY[0]] = value2 : dataFilter[d3.series.fieldX[0]] = value2;
          });
        }), tooltip3.showTooltip(dataFilter, opt.showTooltipOption);
      }
    }
    if (false !== opt.crosshair) {
      const crosshair2 = this._components.find((c4) => c4.type === ComponentTypeEnum.cartesianCrosshair);
      crosshair2 && crosshair2.clearAxisValue && crosshair2.setAxisValue && (isUnableValue ? (null === (_c = crosshair2.clearAxisValue) || void 0 === _c || _c.call(crosshair2), null === (_d = crosshair2.hide) || void 0 === _d || _d.call(crosshair2)) : dimensionInfo.forEach((d2) => {
        const { axis: axis2, value: value2 } = d2;
        crosshair2.clearAxisValue(), crosshair2.setAxisValue(value2, axis2), crosshair2.layoutByValue();
      }));
    }
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
};

// node_modules/@visactor/vchart/esm/chart/base/base-chart-transformer.js
var BaseChartSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type, this.seriesType = option.seriesType;
  }
  initChartSpec(chartSpec) {
    return this.transformSpec(chartSpec), this.transformModelSpec(chartSpec);
  }
  transformSpec(chartSpec) {
    chartSpec.region && 0 !== chartSpec.region.length || (chartSpec.region = [{}]), has_default(chartSpec, "tooltip") || (chartSpec.tooltip = {}), isValid_default(chartSpec.stackInverse) && chartSpec.region.forEach((r2) => !isValid_default(r2.stackInverse) && (r2.stackInverse = chartSpec.stackInverse));
  }
  transformModelSpec(chartSpec) {
    return this.createSpecInfo(chartSpec, (constructor, specInfo, chartSpecInfo) => {
      const { spec, specPath, specInfoPath, type } = specInfo, transformResult = new constructor.transformerConstructor({
        type,
        getTheme: this._option.getTheme
      }).transformSpec(spec, chartSpec, chartSpecInfo);
      setProperty(chartSpec, specPath, transformResult.spec), setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), transformResult));
    });
  }
  createSpecInfo(chartSpec, transform29) {
    var _a;
    transform29 || (transform29 = (constructor, specInfo, chartSpecInfo) => {
      const { spec, specPath, specInfoPath, type } = specInfo, transformer2 = new constructor.transformerConstructor({
        type,
        getTheme: this._option.getTheme
      });
      setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), {
        theme: transformer2.getTheme(spec, chartSpec)
      }));
    });
    const currentChartSpecInfo = {};
    let region;
    return this.forEachRegionInSpec(chartSpec, transform29, currentChartSpecInfo), this.forEachSeriesInSpec(chartSpec, transform29, currentChartSpecInfo), null === (_a = currentChartSpecInfo.series) || void 0 === _a || _a.forEach(({ spec: { regionId, regionIndex } }, i2) => {
      var _a2, _b, _c;
      isValid_default(regionId) ? region = null === (_a2 = currentChartSpecInfo.region) || void 0 === _a2 ? void 0 : _a2.find(({ spec }) => spec.id === regionId) : isValid_default(regionIndex) && (region = null === (_b = currentChartSpecInfo.region) || void 0 === _b ? void 0 : _b[regionIndex]), (region || (region = null === (_c = currentChartSpecInfo.region) || void 0 === _c ? void 0 : _c[0])) && (region.seriesIndexes || (region.seriesIndexes = []), region.seriesIndexes.push(i2));
    }), this.forEachComponentInSpec(chartSpec, transform29, currentChartSpecInfo), currentChartSpecInfo;
  }
  _isValidSeries(seriesType) {
    return true;
  }
  _getDefaultSeriesSpec(chartSpec) {
    var _a, _b, _c, _d;
    return {
      dataKey: chartSpec.dataKey,
      hover: chartSpec.hover,
      select: chartSpec.select,
      label: chartSpec.label,
      seriesStyle: chartSpec.seriesStyle,
      animation: null !== (_a = chartSpec.animation) && void 0 !== _a ? _a : this._option.animation,
      animationThreshold: null !== (_b = chartSpec.animationThreshold) && void 0 !== _b ? _b : null === (_d = (_c = this._option).getTheme) || void 0 === _d ? void 0 : _d.call(_c).animationThreshold,
      animationAppear: chartSpec.animationAppear,
      animationDisappear: chartSpec.animationDisappear,
      animationEnter: chartSpec.animationEnter,
      animationUpdate: chartSpec.animationUpdate,
      animationExit: chartSpec.animationExit,
      animationNormal: chartSpec.animationNormal,
      extensionMark: chartSpec.extensionMark,
      large: chartSpec.large,
      largeThreshold: chartSpec.largeThreshold,
      progressiveStep: chartSpec.progressiveStep,
      progressiveThreshold: chartSpec.progressiveThreshold,
      background: chartSpec.seriesBackground,
      invalidType: chartSpec.invalidType,
      seriesField: chartSpec.seriesField,
      morph: chartSpec.morph
    };
  }
  forEachRegionInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.region) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getRegionInType("region"), {
      spec,
      specIndex: index,
      specPath: ["region", index],
      type: "region"
    }, chartSpecInfo));
  }
  forEachSeriesInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.series) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getSeriesInType(spec.type), {
      spec,
      specIndex: index,
      specPath: ["series", index],
      type: spec.type
    }, chartSpecInfo));
  }
  forEachComponentInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a, _b, _c, _d;
    const results = [], components = Factory2.getComponents();
    let cartesianAxis, polarAxis, geoCoordinate, label, totalLabel2;
    const noAxisComponents = [];
    for (let index = 0; index < components.length; index++) {
      const { cmp, alwaysCheck } = components[index];
      cmp.type.startsWith(ComponentTypeEnum.cartesianAxis) ? cartesianAxis = cmp : cmp.type.startsWith(ComponentTypeEnum.polarAxis) ? polarAxis = cmp : cmp.type === ComponentTypeEnum.geoCoordinate ? geoCoordinate = cmp : (alwaysCheck || chartSpec[null !== (_a = cmp.specKey) && void 0 !== _a ? _a : cmp.type]) && (cmp.type === ComponentTypeEnum.label ? label = cmp : cmp.type === ComponentTypeEnum.totalLabel && (totalLabel2 = cmp), noAxisComponents.push(cmp));
    }
    let hasInitAxis = false;
    if (cartesianAxis) {
      const infoList = cartesianAxis.getSpecInfo(chartSpec);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    if (polarAxis && !hasInitAxis) {
      const infoList = polarAxis.getSpecInfo(chartSpec);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    return geoCoordinate && !hasInitAxis && (null === (_b = geoCoordinate.getSpecInfo(chartSpec)) || void 0 === _b || _b.forEach((info) => {
      results.push(callbackfn(geoCoordinate, info, chartSpecInfo));
    })), label && chartSpecInfo && (null === (_c = label.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _c || _c.forEach((info) => {
      results.push(callbackfn(label, info, chartSpecInfo));
    })), totalLabel2 && chartSpecInfo && (null === (_d = totalLabel2.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _d || _d.forEach((info) => {
      results.push(callbackfn(totalLabel2, info, chartSpecInfo));
    })), noAxisComponents.forEach((C2) => {
      var _a2;
      null === (_a2 = C2.getSpecInfo(chartSpec)) || void 0 === _a2 || _a2.forEach((info) => {
        results.push(callbackfn(C2, info, chartSpecInfo));
      });
    }), results;
  }
};

// node_modules/@visactor/vchart/esm/chart/cartesian/cartesian-transformer.js
var CartesianChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return true;
  }
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      xField: spec.xField,
      yField: spec.yField,
      zField: spec.zField,
      seriesField: spec.seriesField,
      seriesStyle: spec.seriesStyle,
      direction: spec.direction,
      stack: spec.stack,
      percent: spec.percent,
      stackOffsetSilhouette: spec.stackOffsetSilhouette,
      totalLabel: spec.totalLabel,
      sortDataByAxis: spec.sortDataByAxis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    if (super.transformSpec(spec), this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        x: false,
        y: false,
        z: false
      };
      spec.axes.forEach((axis2) => {
        const { orient } = axis2;
        "top" !== orient && "bottom" !== orient || (haxAxes.x = true), "left" !== orient && "right" !== orient || (haxAxes.y = true), "z" === orient && (haxAxes.z = true), get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
      }), haxAxes.x || spec.axes.push({
        orient: "bottom"
      }), haxAxes.y || spec.axes.push({
        orient: "left"
      }), spec.zField && !haxAxes.z && spec.axes.push({
        orient: "z"
      });
    }
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/line/line-transformer.js
var LineChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      line: spec.line,
      seriesMark: null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "line",
      activePoint: spec.activePoint,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap,
      lineLabel: spec.lineLabel
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/line/line.js
var LineChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LineChartSpecTransformer, this.type = "line", this.seriesType = SeriesTypeEnum.line, this._canStack = true;
  }
};
LineChart.type = "line", LineChart.seriesType = SeriesTypeEnum.line, LineChart.view = "singleDefault", LineChart.transformerConstructor = LineChartSpecTransformer;
var registerLineChart = () => {
  registerLineSeries(), Factory2.registerChart(LineChart.type, LineChart);
};

// node_modules/@visactor/vchart/esm/mark/area.js
var AreaMark = class _AreaMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _AreaMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
  _getIgnoreAttributes() {
    return [];
  }
};
AreaMark.type = "area";
var registerAreaMark = () => {
  Factory2.registerMark(AreaMark.type, AreaMark), registerAreaGraphic2(), registerVGrammarLineOrAreaAnimation();
};

// node_modules/@visactor/vchart/esm/series/area/tooltip-helpter.js
var AreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a, _b, _c, _d;
      for (const key of array(styleKey)) {
        let value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (false !== value || "fill" !== key && "stroke" !== key || (value = "fill" === key ? null === (_c = null === (_b = this.series.getSeriesStyle(datum)) || void 0 === _b ? void 0 : _b("stroke")) || void 0 === _c ? void 0 : _c[0] : null === (_d = this.series.getSeriesStyle(datum)) || void 0 === _d ? void 0 : _d("fill")), isValid_default(value)) return value;
      }
      return defaultValue;
    };
  }
};

// node_modules/@visactor/vchart/esm/series/area/animation.js
var Appear_ClipIn2 = {
  type: "clipIn"
};
var Appear_Grow2 = (params2) => ({
  type: "horizontal" === params2.direction ? "growPointsXIn" : "growPointsYIn",
  options: {
    orient: "horizontal" === params2.direction ? "positive" : "negative"
  }
});
var Appear_FadeIn2 = {
  type: "fadeIn"
};
function areaPresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "grow":
      return Appear_Grow2(params2);
    case "fadeIn":
      return Appear_FadeIn2;
    default:
      return Appear_ClipIn2;
  }
}
var registerAreaAnimation = () => {
  Factory2.registerAnimation("area", (params2, preset) => ({
    appear: areaPresetAnimation(params2, preset),
    enter: {
      type: "fadeIn"
    },
    exit: {
      type: "fadeOut"
    },
    disappear: {
      type: "clipOut"
    }
  })), registerLineAnimation(), registerScaleInOutAnimation();
};

// node_modules/@visactor/vchart/esm/series/area/area-transformer.js
var AreaSeriesSpecTransformer = class extends LineLikeSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    super._transformLabelSpec(spec), this._addMarkLabelSpec(spec, "area", "areaLabel", "initLineLabelMarkStyle", void 0, true);
    false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible) || this._addMarkLabelSpec(spec, "area");
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
    var _a, _b, _c, _d, _e;
    super._transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo);
    const { area: area2 = {}, line: line2 = {}, seriesMark = "area" } = spec, isAreaVisible = false !== area2.visible && false !== (null === (_a = area2.style) || void 0 === _a ? void 0 : _a.visible), isLineVisible = false !== line2.visible && false !== (null === (_b = line2.style) || void 0 === _b ? void 0 : _b.visible);
    area2.interactive = !(!area2.interactive && null !== (_c = line2.interactive) && void 0 !== _c && !_c), area2.support3d = !(!area2.support3d && !line2.support3d), area2.zIndex = isValid_default(area2.zIndex) || isValid_default(line2.zIndex) ? Math.max(null !== (_d = area2.zIndex) && void 0 !== _d ? _d : 0, null !== (_e = line2.zIndex) && void 0 !== _e ? _e : 0) : void 0, area2.style && delete area2.style.stroke, area2.state && Object.keys(area2.state).forEach((state) => {
      "style" in area2.state[state] ? delete area2.state[state].style.stroke : delete area2.state[state].stroke;
    });
    let mainSpec = area2, subSpec = line2;
    ("line" === seriesMark || isLineVisible && !isAreaVisible) && (mainSpec = line2, subSpec = area2), area2.style = mergeSpec({}, subSpec.style, mainSpec.style), area2.state = mergeSpec({}, subSpec.state, mainSpec.state), isAreaVisible || (area2.style.fill = false), isLineVisible || (area2.style.stroke = false), area2.visible = !(!isAreaVisible && !isLineVisible), spec.area = area2, spec.line = line2;
  }
};

// node_modules/@visactor/vchart/esm/series/area/area.js
var AreaSeries = class _AreaSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.area, this.transformerConstructor = AreaSeriesSpecTransformer, this._supportStack = true, this._sortDataByAxis = false;
  }
  initMark() {
    var _a, _b, _c, _d, _e;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, isAreaVisible = false !== (null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible), seriesMark = null !== (_d = this._spec.seriesMark) && void 0 !== _d ? _d : "area";
    this._areaMark = this._createMark(_AreaSeries.mark.area, {
      groupKey: this._seriesField,
      defaultMorphElementKey: this.getDimensionField()[0],
      progressive,
      isSeriesMark: isAreaVisible && "point" !== seriesMark,
      customShape: null === (_e = this._spec.area) || void 0 === _e ? void 0 : _e.customShape
    }), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "vertical" === this._direction ? "monotoneX" : "monotoneY" : userCurveType, areaMark = this._areaMark;
    areaMark && ("vertical" === this._direction ? this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      y1: (datum) => {
        var _a2, _b2;
        return valueInScaleRange(this.dataToPositionY1(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
      },
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      x1: (datum) => {
        var _a2, _b2;
        return valueInScaleRange(this.dataToPositionX1(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
      },
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
      orient: this._direction
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined,
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      curveType
    }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(areaMark), Object.keys(areaMark.stateStyle).forEach((state) => {
      areaMark.stateStyle[state].stroke && areaMark.setPostProcess("stroke", (result2) => [result2, false, false, false], state);
    })), this.initLineMarkStyle(this._direction, userCurveType), this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const areaAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._lineMark && this._lineMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("line")) || void 0 === _b ? void 0 : _b(areaAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._areaMark && this._areaMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("area")) || void 0 === _c ? void 0 : _c(areaAnimationParams, appearPreset), userAnimationConfig("area", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  initTooltip() {
    this._tooltipHelper = new AreaSeriesTooltipHelper(this), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark), this._lineMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._lineMark), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
  }
  viewDataStatisticsUpdate(d2) {
    super.viewDataStatisticsUpdate(d2), this.encodeDefined(this._areaMark, "defined");
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d, _e;
      const seriesMarkType = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area";
      let result2 = null !== (_c = null === (_b = this._seriesMark) || void 0 === _b ? void 0 : _b.getAttribute(attribute, datum)) && void 0 !== _c ? _c : void 0;
      return "fill" !== attribute || result2 && "line" !== seriesMarkType || (attribute = "stroke", result2 = null !== (_e = null === (_d = this._seriesMark) || void 0 === _d ? void 0 : _d.getAttribute(attribute, datum)) && void 0 !== _e ? _e : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
AreaSeries.type = SeriesTypeEnum.area, AreaSeries.mark = areaSeriesMark, AreaSeries.transformerConstructor = AreaSeriesSpecTransformer, mixin(AreaSeries, LineLikeSeriesMixin);
var registerAreaSeries = () => {
  registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerAreaMark(), registerSymbolMark(), registerAreaAnimation(), Factory2.registerSeries(AreaSeries.type, AreaSeries);
};

// node_modules/@visactor/vchart/esm/chart/area/area-transformer.js
var AreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      line: spec.line,
      area: spec.area,
      seriesMark: null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "area",
      activePoint: spec.activePoint,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap,
      areaLabel: spec.areaLabel
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/area/area.js
var AreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = AreaChartSpecTransformer, this.type = "area", this.seriesType = SeriesTypeEnum.area, this._canStack = true;
  }
};
AreaChart.type = "area", AreaChart.seriesType = SeriesTypeEnum.area, AreaChart.view = "singleDefault", AreaChart.transformerConstructor = AreaChartSpecTransformer;
var registerAreaChart = () => {
  registerAreaSeries(), Factory2.registerChart(AreaChart.type, AreaChart);
};

// node_modules/@visactor/vchart/esm/series/bar/animation.js
function barGrowOption(barParams, isOverall = true) {
  return (datum, element, params2) => {
    const field5 = "vertical" === barParams.direction ? barParams.yField : barParams.xField, data = null == datum ? void 0 : datum[field5];
    return "vertical" === barParams.direction ? {
      overall: isOverall ? barParams.growFrom() : isOverall,
      orient: data > 0 ? "negative" : "positive"
    } : {
      overall: !!isOverall && barParams.growFrom(),
      orient: data > 0 ? "positive" : "negative"
    };
  };
}
var barGrowIn = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: barGrowOption(params2, isOverall)
});
var barGrowOut = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthOut" : "growHeightOut",
  options: barGrowOption(params2, isOverall)
});
var Appear_FadeIn3 = {
  type: "fadeIn"
};
var Appear_ScaleIn = {
  type: "growCenterIn"
};
function barPresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn3;
    case "scaleIn":
      return Appear_ScaleIn;
    default:
      return barGrowIn(params2);
  }
}
var registerBarAnimation = () => {
  Factory2.registerAnimation("bar", (params2, preset) => ({
    appear: barPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2)
  }));
};
var registerBar3dAnimation = () => {
  Factory2.registerAnimation("bar3d", (params2, preset) => ({
    appear: barPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2)
  }));
};

// node_modules/@visactor/vchart/esm/mark/rect.js
var RectMark = class _RectMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RectMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      lineWidth: 0
    });
  }
};
RectMark.type = "rect";
var registerRectMark = () => {
  Factory2.registerMark(RectMark.type, RectMark), registerRectGraphic2(), registerVGrammarRectAnimation();
};

// node_modules/@visactor/vchart/esm/series/util/stack.js
function stackWithMinHeight(stackCache, stackInverse, context) {
  if (stackCache.values.length > 0) {
    let lastY, seriesInfo = stackCache.series;
    stackInverse && (seriesInfo = seriesInfo.slice().reverse()), seriesInfo.forEach(({ s: s3, values }, sIndex) => {
      var _a, _b;
      const barMinHeight = s3.getSpec().barMinHeight, seriesScale = null === (_b = (_a = s3[context.axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = s3[context.axisHelper].isInverse();
      for (let index = 0; index < values.length; index++) {
        const obj = values[stackInverse ? values.length - 1 - index : index], y14 = valueInScaleRange(s3[context.startMethod](obj), seriesScale);
        let y3 = valueInScaleRange(s3[context.endMethod](obj), seriesScale);
        0 === index && 0 === sIndex && (lastY = y14);
        let height = Math.abs(y14 - y3);
        height < barMinHeight && (height = barMinHeight);
        let flag = 1;
        y3 < y14 ? flag = -1 : y3 === y14 && (flag = context.isVertical ? inverse ? 1 : -1 : inverse ? -1 : 1), y3 = lastY + flag * height, obj[context.start] = lastY, obj[context.end] = y3, lastY = y3;
      }
    });
  }
  for (const key in stackCache.nodes) stackWithMinHeight(stackCache.nodes[key], stackInverse, context);
}

// node_modules/@visactor/vchart/esm/series/bar/bar-transformer.js
var BarSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar");
  }
};

// node_modules/@visactor/vchart/esm/series/bar/bar.js
var BarSeries = class _BarSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar, this._barMarkName = "bar", this._barMarkType = "rect", this.transformerConstructor = BarSeriesSpecTransformer, this._supportStack = true, this._bandPosition = 0;
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._initBarBackgroundMark(progressive), this._barMark = this._createMark(Object.assign(Object.assign({}, _BarSeries.mark.bar), {
      name: this._barMarkName,
      type: this._barMarkType
    }), {
      morph: shouldMarkDoMorph(this._spec, this._barMarkName),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      progressive,
      customShape: null === (_a = this._spec.bar) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  _initBarBackgroundMark(progressive) {
    var _a, _b;
    (null === (_a = this._spec.barBackground) || void 0 === _a ? void 0 : _a.visible) && (this._barBackgroundMark = this._createMark(_BarSeries.mark.barBackground, {
      dataView: this._barBackgroundViewData.getDataView(),
      dataProductId: this._barBackgroundViewData.getProductId(),
      progressive,
      customShape: null === (_b = this._spec.barBackground) || void 0 === _b ? void 0 : _b.customShape
    }));
  }
  initMarkStyle() {
    this._barMark && (this.setMarkStyle(this._barMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(this._barMark));
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  initTooltip() {
    super.initTooltip(), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark);
  }
  _statisticViewData() {
    var _a, _b;
    if (super._statisticViewData(), !(null === (_a = this._spec.barBackground) || void 0 === _a ? void 0 : _a.visible)) return;
    registerDataSetInstanceTransform(this._option.dataSet, "addVChartProperty", addVChartProperty), registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", ([data], op) => {
      var _a2;
      let dataCollect = [{}];
      const fields2 = this.getDimensionField();
      for (let i2 = 0; i2 < fields2.length; i2++) {
        const field5 = fields2[i2], values = null === (_a2 = data.latestData[field5]) || void 0 === _a2 ? void 0 : _a2.values;
        if (!(null == values ? void 0 : values.length)) continue;
        const newDataCollect = [];
        for (let j2 = 0; j2 < values.length; j2++) for (let k3 = 0; k3 < dataCollect.length; k3++) newDataCollect.push(Object.assign(Object.assign({}, dataCollect[k3]), {
          [field5]: values[j2]
        }));
        dataCollect = newDataCollect;
      }
      return dataCollect;
    });
    const barBackgroundData = new DataView(this._option.dataSet).parse([this._viewDataStatistics], {
      type: "dataview"
    }).transform({
      type: "dimensionItems"
    }, false).transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false);
    null === (_b = this._viewDataStatistics) || void 0 === _b || _b.target.addListener("change", barBackgroundData.reRunAllTransform), this._barBackgroundViewData = new SeriesData(this._option, barBackgroundData);
  }
  init(option) {
    var _a, _b;
    super.init(option), "vertical" === this.direction ? "band" === (null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle() : "band" === (null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle();
  }
  _shouldDoPreCalculate() {
    const region = this.getRegion();
    return this._stack && region.getSeries().filter((s3) => s3.type === this.type && s3.getSpec().barMinHeight).length;
  }
  _calculateStackRectPosition(isVertical3) {
    const region = this.getRegion();
    if (region._bar_series_position_calculated) return;
    let start, end, startMethod, endMethod, axisHelper;
    region._bar_series_position_calculated = true, isVertical3 ? (start = RECT_Y1, end = RECT_Y, startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (start = RECT_X1, end = RECT_X, startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const stackValueGroup = getRegionStackGroup(region, false, (s3) => s3.type === this.type);
    for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackWithMinHeight(stackValueGroup[stackValue].nodes[key], region.getStackInverse(), {
      isVertical: isVertical3,
      start,
      end,
      startMethod,
      endMethod,
      axisHelper
    });
  }
  _calculateRectPosition(datum, isVertical3) {
    var _a, _b;
    let startMethod, endMethod, axisHelper;
    isVertical3 ? (startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const seriesScale = null === (_b = (_a = this[axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = this[axisHelper].isInverse(), barMinHeight = this._spec.barMinHeight, y14 = valueInScaleRange(this[startMethod](datum), seriesScale), y3 = valueInScaleRange(this[endMethod](datum), seriesScale);
    let height = Math.abs(y14 - y3);
    height < barMinHeight && (height = barMinHeight);
    let flag = 1;
    return y3 < y14 ? flag = -1 : y3 === y14 && (flag = isVertical3 ? inverse ? 1 : -1 : inverse ? -1 : 1), y14 + flag * height;
  }
  _dataToPosX(datum) {
    return this.dataToPositionX(datum);
  }
  _dataToPosX1(datum) {
    return this.dataToPositionX1(datum);
  }
  _dataToPosY(datum) {
    return this.dataToPositionY(datum);
  }
  _dataToPosY1(datum) {
    return this.dataToPositionY1(datum);
  }
  initBandRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    "horizontal" === this.direction ? this.setMarkStyle(this._barMark, {
      x: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, false) : valueInScaleRange(this._dataToPosX(datum), xScale),
      x1: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X1]) : valueInScaleRange(this._dataToPosX1(datum), xScale),
      y: (datum) => this._getPosition(this.direction, datum),
      height: () => this._getBarWidth(this._yAxisHelper)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
      x: (datum) => this._getPosition(this.direction, datum),
      y: (datum, ctx, opt, dataView) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, true) : valueInScaleRange(this._dataToPosY(datum), yScale),
      y1: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y1]) : valueInScaleRange(this._dataToPosY1(datum), yScale),
      width: () => this._getBarWidth(this._xAxisHelper)
    }, "normal", AttributeLevel.Series), this._initBarBackgroundMarkStyle();
  }
  _initBarBackgroundMarkStyle() {
    var _a, _b, _c, _d;
    if (!this._barBackgroundMark) return;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    "horizontal" === this.direction ? this.setMarkStyle(this._barBackgroundMark, {
      x: () => {
        const range2 = xScale.range();
        return Math.min(range2[0], range2[range2.length - 1]);
      },
      x1: () => {
        const range2 = xScale.range();
        return Math.max(range2[0], range2[range2.length - 1]);
      },
      y: (datum) => this._getPosition(this.direction, datum),
      height: () => this._getBarWidth(this._yAxisHelper)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barBackgroundMark, {
      x: (datum) => this._getPosition(this.direction, datum),
      y: () => {
        const range2 = yScale.range();
        return Math.min(range2[0], range2[range2.length - 1]);
      },
      y1: () => {
        const range2 = yScale.range();
        return Math.max(range2[0], range2[range2.length - 1]);
      },
      width: () => this._getBarWidth(this._xAxisHelper)
    }, "normal", AttributeLevel.Series);
  }
  initLinearRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    "vertical" === this.direction ? this.setMarkStyle(this._barMark, {
      x: (datum) => valueInScaleRange(this.dataToPositionX(datum), xScale),
      x1: (datum) => valueInScaleRange(this.dataToPositionX1(datum), xScale),
      y: (datum, ctx, opt, dataView) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, true) : valueInScaleRange(this.dataToPositionY(datum), yScale),
      y1: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y1]) : valueInScaleRange(this.dataToPositionY1(datum), yScale)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
      x: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, false) : valueInScaleRange(this.dataToPositionX(datum), xScale),
      x1: (datum) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X1]) : valueInScaleRange(this.dataToPositionX1(datum), xScale),
      y: (datum) => valueInScaleRange(this.dataToPositionY(datum), yScale),
      y1: (datum) => valueInScaleRange(this.dataToPositionY1(datum), yScale)
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const barAnimationParams = {
      yField: this._fieldY[0],
      xField: this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("bar")) || void 0 === _b ? void 0 : _b(barAnimationParams, appearPreset), userAnimationConfig(this._barMarkName, this._spec, this._markAttributeContext), animationParams));
  }
  _getBarWidth(axisHelper) {
    var _a, _b;
    const hasBarWidth = void 0 !== this._spec.barWidth, bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _b ? _b : 6;
    if (hasBarWidth) return getActualNumValue(this._spec.barWidth, bandWidth);
    const hasBarMinWidth = void 0 !== this._spec.barMinWidth, hasBarMaxWidth = void 0 !== this._spec.barMaxWidth;
    let width = bandWidth;
    return hasBarMinWidth && (width = Math.max(width, getActualNumValue(this._spec.barMinWidth, bandWidth))), hasBarMaxWidth && (width = Math.min(width, getActualNumValue(this._spec.barMaxWidth, bandWidth))), width;
  }
  _getPosition(direction2, datum) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    let axisHelper, sizeAttribute, dataToPosition;
    "horizontal" === direction2 ? (axisHelper = this.getYAxisHelper(), sizeAttribute = "height", dataToPosition = this.dataToPositionY.bind(this)) : (axisHelper = this.getXAxisHelper(), sizeAttribute = "width", dataToPosition = this.dataToPositionX.bind(this));
    const scale4 = axisHelper.getScale(0), size = this._barMark.getAttribute(sizeAttribute, datum), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _b ? _b : 6;
    if ((null === (_d = null === (_c = this._groups) || void 0 === _c ? void 0 : _c.fields) || void 0 === _d ? void 0 : _d.length) > 1 && isValid_default(this._spec.barGapInGroup)) {
      const groupFields = this._groups.fields, barInGroup = array(this._spec.barGapInGroup);
      let totalWidth = 0, offSet = 0;
      for (let index = groupFields.length - 1; index >= 1; index--) {
        const groupField = groupFields[index], groupValues = null !== (_h = null === (_g = null === (_f = null === (_e = this.getViewDataStatistics()) || void 0 === _e ? void 0 : _e.latestData) || void 0 === _f ? void 0 : _f[groupField]) || void 0 === _g ? void 0 : _g.values) && void 0 !== _h ? _h : [], groupCount = groupValues.length, gap = getActualNumValue(null !== (_j = barInGroup[index - 1]) && void 0 !== _j ? _j : last(barInGroup), bandWidth), i2 = groupValues.indexOf(datum[groupField]);
        index === groupFields.length - 1 ? (totalWidth += groupCount * size + (groupCount - 1) * gap, offSet += i2 * (size + gap)) : (offSet += i2 * (totalWidth + gap), totalWidth += totalWidth + (groupCount - 1) * gap);
      }
      return scale4.scale(datum[groupFields[0]]) + axisHelper.getBandwidth(0) / 2 - totalWidth / 2 + offSet;
    }
    const continuous = isContinuous(scale4.type || "band");
    return dataToPosition(datum) + 0.5 * (bandWidth - size) + (continuous ? -bandWidth / 2 : 0);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx);
    this.getRegion()._bar_series_position_calculated = false, this._spec.sampling && this.compile();
  }
  compile() {
    if (super.compile(), this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "vertical" === this._direction ? width : height,
        factor: this._spec.samplingFactor,
        yfield: "vertical" === this._direction ? fieldsY[0] : fieldsX[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._barMark];
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.compile();
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  viewDataUpdate(d2) {
    var _a, _b, _c;
    super.viewDataUpdate(d2), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._barBackgroundViewData) || void 0 === _c || _c.updateData();
  }
  release() {
    var _a;
    super.release(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.release(), this._barBackgroundViewData = null;
  }
};
BarSeries.type = SeriesTypeEnum.bar, BarSeries.mark = barSeriesMark, BarSeries.transformerConstructor = BarSeriesSpecTransformer;
var registerBarSeries = () => {
  registerSampleTransform(), registerRectMark(), registerBarAnimation(), Factory2.registerSeries(BarSeries.type, BarSeries);
};

// node_modules/@visactor/vchart/esm/chart/bar/bar-transformer.js
var BarChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barWidth: spec.barWidth,
      barMaxWidth: spec.barMaxWidth,
      barMinWidth: spec.barMinWidth,
      barGapInGroup: spec.barGapInGroup,
      barMinHeight: spec.barMinHeight,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      barBackground: spec.barBackground
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/bar/bar.js
var BarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BarChartSpecTransformer, this.type = "bar", this.seriesType = SeriesTypeEnum.bar, this._canStack = true;
  }
};
BarChart.type = "bar", BarChart.seriesType = SeriesTypeEnum.bar, BarChart.view = "singleDefault", BarChart.transformerConstructor = BarChartSpecTransformer;
var registerBarChart = () => {
  registerBarSeries(), Factory2.registerChart(BarChart.type, BarChart);
};

// node_modules/@visactor/vchart/esm/mark/rect-3d.js
var Rect3dMark = class _Rect3dMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _Rect3dMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      length: 3
    });
  }
};
Rect3dMark.type = "rect3d";
var registerRect3dMark = () => {
  Factory2.registerMark(Rect3dMark.type, Rect3dMark), registerRect3dGraphic2(), registerVGrammarRectAnimation();
};

// node_modules/@visactor/vchart/esm/series/bar/bar-3d.js
var Bar3dSeries = class extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar3d, this._barMarkName = "bar3d", this._barMarkType = "rect3d";
  }
};
Bar3dSeries.type = SeriesTypeEnum.bar3d, Bar3dSeries.mark = bar3dSeriesMark;
var registerBar3dSeries = () => {
  registerBar3dAnimation(), registerRect3dMark(), Factory2.registerSeries(Bar3dSeries.type, Bar3dSeries);
};

// node_modules/@visactor/vchart/esm/chart/bar/3d/bar-3d-transformer.js
var Bar3dChartSpecTransformer = class extends BarChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barWidth: spec.barWidth,
      barMaxWidth: spec.barMaxWidth,
      barMinWidth: spec.barMinWidth,
      barGapInGroup: spec.barGapInGroup
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/bar/3d/bar-3d.js
var Bar3dChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Bar3dChartSpecTransformer, this.type = "bar3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Bar3dChart.type = "bar3d", Bar3dChart.seriesType = SeriesTypeEnum.bar3d, Bar3dChart.view = "singleDefault", Bar3dChart.transformerConstructor = Bar3dChartSpecTransformer;
var registerBar3dChart = () => {
  registerBar3dSeries(), Factory2.registerChart(Bar3dChart.type, Bar3dChart);
};

// node_modules/@visactor/vchart/esm/constant/scatter.js
var SCATTER_DEFAULT_SIZE = 10;
var SCATTER_DEFAULT_RANGE_SIZE = [10, 20];
var SCATTER_DEFAULT_SIZE_SCALE_TYPE = ScaleEnum.Linear;
var SCATTER_DEFAULT_SHAPE = "circle";
var SCATTER_DEFAULT_SHAPE_SCALE_TYPE = ScaleEnum.Ordinal;
var SCATTER_DEFAULT_RANGE_SHAPE = ["circle", "square", "triangle", "diamond", "star"];

// node_modules/@visactor/vchart/esm/series/scatter/animation.js
var scatterPresetAnimation = (_params, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "scaleIn"
};
var registerScatterAnimation = () => {
  Factory2.registerAnimation("scatter", (params2, preset) => Object.assign({
    appear: scatterPresetAnimation(0, preset)
  }, ScaleInOutAnimation));
};

// node_modules/@visactor/vchart/esm/series/scatter/scatter-transformer.js
var ScatterSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "point");
  }
};

// node_modules/@visactor/vchart/esm/series/scatter/scatter.js
var ScatterSeries = class _ScatterSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.scatter, this.transformerConstructor = ScatterSeriesSpecTransformer, this._invalidType = "zero";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
  }
  _getSeriesAttribute(field5, spec, { defaultScaleType, defaultRange }, key) {
    var _a, _b, _c, _d;
    if (isFunction_default(spec)) return spec;
    if (isArray_default(spec)) {
      if (isNil_default(field5)) return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), spec;
      if ("ordinal" !== defaultScaleType && spec.length > 2) return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`;
      return this._option.globalScale.registerModelScale({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field5]
        }],
        range: spec
      }), {
        scale: scaleName,
        field: field5
      };
    }
    if (isObject_default(spec)) {
      if (isNil_default(field5)) return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field5]
        }],
        range: defaultRange
      }, spec);
      return this._option.globalScale.registerModelScale(visualSpec), {
        scale: visualSpec.id,
        field: field5
      };
    }
    return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), spec;
  }
  getSizeAttribute(field5, sizeSpec) {
    return isNil_default(sizeSpec) ? SCATTER_DEFAULT_SIZE : isNumber_default(sizeSpec) ? sizeSpec : isString_default(sizeSpec) && isNumeric_default(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field5, sizeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SIZE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SIZE
    }, "size");
  }
  getShapeAttribute(field5, shapeSpec) {
    return isNil_default(shapeSpec) ? SCATTER_DEFAULT_SHAPE : isString_default(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field5, shapeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SHAPE
    }, "shape");
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._symbolMark = this._createMark(_ScatterSeries.mark.point, {
      morph: shouldMarkDoMorph(this._spec, _ScatterSeries.mark.point.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      progressive,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  initMarkStyle() {
    this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._symbolMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
      visible: this._getInvalidDefined
    }), this.setMarkStyle(symbolMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
      fill: this.getColorAttribute(),
      size: isNumber_default(this._size) || isFunction_default(this._size) ? this._size : SCATTER_DEFAULT_SIZE,
      symbolType: isString_default(this._shape) || isFunction_default(this._shape) ? this._shape : SCATTER_DEFAULT_SHAPE
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), (isValid_default(this._sizeField) || isValid_default(this._size)) && this.setMarkStyle(symbolMark, {
      size: this.getSizeAttribute(this._sizeField, this._size)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), (isValid_default(this._shapeField) || isValid_default(this._shape)) && this.setMarkStyle(symbolMark, {
      symbolType: this.getShapeAttribute(this._shapeField, this._shape)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), this._trigger.registerMark(symbolMark));
  }
  initTooltip() {
    super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
  }
  viewDataStatisticsUpdate(d2) {
    super.viewDataStatisticsUpdate(d2);
    const allValid = [this.getDimensionField()[0], this.getStackValueField()].every((field5) => {
      var _a, _b, _c;
      return field5 && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field5]) || void 0 === _c ? void 0 : _c.allValid);
    });
    "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
      visible: true
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
      visible: this._getInvalidDefined
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  handleZoom(e3) {
    var _a, _b;
    this.getMarksWithoutRoot().forEach((mark) => {
      const vGrammarMark = mark.getProduct();
      if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
      vGrammarMark.elements.forEach((el, i2) => {
        const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
        newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
      });
    });
    const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
    vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
  }
  handlePan(e3) {
    var _a, _b;
    this.getMarksWithoutRoot().forEach((mark) => {
      const vGrammarMark = mark.getProduct();
      if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
      vGrammarMark.elements.forEach((el, i2) => {
        const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
        newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
      });
    });
    const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
    vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._symbolMark];
  }
};
ScatterSeries.type = SeriesTypeEnum.scatter, ScatterSeries.mark = scatterSeriesMark, ScatterSeries.transformerConstructor = ScatterSeriesSpecTransformer;
var registerScatterSeries = () => {
  registerSymbolMark(), registerScatterAnimation(), Factory2.registerSeries(ScatterSeries.type, ScatterSeries);
};

// node_modules/@visactor/vchart/esm/chart/scatter/scatter-transformer.js
var ScatterChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      size: spec.size,
      sizeField: spec.sizeField,
      shape: spec.shape,
      shapeField: spec.shapeField
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/scatter/scatter.js
var ScatterChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = ScatterChartSpecTransformer, this.type = "scatter", this.seriesType = SeriesTypeEnum.scatter, this._canStack = true;
  }
};
ScatterChart.type = "scatter", ScatterChart.seriesType = SeriesTypeEnum.scatter, ScatterChart.view = "singleDefault", ScatterChart.transformerConstructor = ScatterChartSpecTransformer;
var registerScatterChart = () => {
  registerScatterSeries(), Factory2.registerChart(ScatterChart.type, ScatterChart);
};

// node_modules/@visactor/vgrammar-projection/es/projections.js
var defaultPath = path_default();
var projections = {};
var projectionProperties = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "precision", "reflectX", "reflectY", "parallels", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
function create(type, constructor) {
  return function projectionGenerator() {
    const p2 = constructor();
    return p2.type = type, p2.path = path_default().projection(p2), p2.copy = p2.copy || function() {
      const c4 = projectionGenerator();
      return projectionProperties.forEach((prop) => {
        p2[prop] && c4[prop](p2[prop]());
      }), c4.path.pointRadius(p2.path.pointRadius()), c4;
    }, p2;
  };
}
function projection3(type, proj) {
  type && isString_default(type) || error2("Projection type must be a name string.");
  const projectionType = type.toLowerCase();
  return arguments.length > 1 && (projections[projectionType] = create(projectionType, proj)), projections[projectionType] || null;
}
var builtInProjections = {
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default2,
  mercator: mercator_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
Object.keys(builtInProjections).forEach((projectionType) => {
  projection3(projectionType, builtInProjections[projectionType]);
});

// node_modules/@visactor/vgrammar-projection/es/projection.js
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
function featurize(f2) {
  return f2.type === FeatureCollection ? f2.features : array(f2).filter((d2) => !isNil_default(d2)).map((d2) => d2.type === Feature ? d2 : {
    type: Feature,
    geometry: d2
  });
}
function collectGeoJSON(data) {
  const arrayData = array(data);
  return 1 === arrayData.length ? arrayData[0] : {
    type: FeatureCollection,
    features: arrayData.reduce((a4, f2) => a4.concat(featurize(f2)), [])
  };
}
function create2(type) {
  const constructor = projection3((type || "mercator").toLowerCase());
  return constructor || error2("Unrecognized projection type: " + type), constructor();
}
function set(proj, key, value) {
  isFunction_default(proj[key]) && proj[key](value);
}
var projectionOptions = projectionProperties.concat(["pointRadius", "fit", "extent", "size"]);
function parseProjection(spec, view) {
  let refs = [];
  return spec ? (Object.keys(spec).forEach((key) => {
    projectionOptions.includes(key) && (refs = refs.concat(parseFunctionType(spec[key], view)));
  }), refs) : refs;
}
var Projection = class extends GrammarBase {
  constructor(view) {
    super(view), this.grammarType = "projection";
  }
  parse(spec) {
    return super.parse(spec), this.pointRadius(spec.pointRadius), this.size(spec.size), this.extent(spec.extent), this.fit(spec.fit), this.configure(spec), this.commit(), this;
  }
  pointRadius(pointRadius) {
    return isNil_default(this.spec.pointRadius) || this.detach(parseFunctionType(this.spec.pointRadius, this.view)), this.spec.pointRadius = pointRadius, this.attach(parseFunctionType(pointRadius, this.view)), this.commit(), this;
  }
  size(data) {
    return isNil_default(this.spec.size) || this.detach(parseFunctionType(this.spec.size, this.view)), this.spec.size = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  extent(data) {
    return isNil_default(this.spec.extent) || this.detach(parseFunctionType(this.spec.extent, this.view)), this.spec.extent = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  fit(data) {
    return isNil_default(this.spec.fit) || this.detach(parseFunctionType(this.spec.fit, this.view)), this.spec.fit = data, this.attach(parseFunctionType(data, this.view)), this.commit(), this;
  }
  configure(config2) {
    return this.detach(parseProjection(this.spec, this.view)), isNil_default(config2) ? this.spec = {
      type: this.spec.type,
      fit: this.spec.fit,
      extent: this.spec.extent,
      size: this.spec.size,
      pointRadius: this.spec.pointRadius
    } : (Object.assign(this.spec, config2), this.attach(parseProjection(this.spec, this.view))), this.commit(), this;
  }
  evaluate(upstream, parameters) {
    if (this.projection && this.projection.type === this.spec.type || (this.projection = create2(this.spec.type), this.projection.type = this.spec.type), projectionProperties.forEach((prop) => {
      isNil_default(this.spec[prop]) || set(this.projection, prop, invokeFunctionType(this.spec[prop], parameters, projection3));
    }), isNil_default(this.spec.pointRadius) || this.projection.path.pointRadius(invokeFunctionType(this.spec.pointRadius, parameters, projection3)), !(isNil_default(this.spec.fit) || isNil_default(this.spec.extent) && isNil_default(this.spec.size))) {
      const data = collectGeoJSON(invokeFunctionType(this.spec.fit, parameters, projection3));
      this.spec.extent ? this.projection.fitExtent(invokeFunctionType(this.spec.extent, parameters, projection3), data) : this.spec.size && this.projection.fitSize(invokeFunctionType(this.spec.size, parameters, projection3), data);
    }
    return this.projection;
  }
  output() {
    return this.projection;
  }
};

// node_modules/@visactor/vgrammar-projection/es/index.js
var registerProjection = () => {
  Factory.registerGrammar("projection", Projection, "projections");
};

// node_modules/@visactor/vchart/esm/data/transforms/lookup.js
var lookup = (data, opt) => {
  if (!opt.from || !opt.from()) return data;
  const fields2 = opt.fields, key = opt.key, values = opt.values, defaultValue = opt.default, as = opt.as || [fields2], index = opt.from().reduce(function(map4, obj) {
    return obj[fields2] && map4.set(obj[fields2], obj), map4;
  }, /* @__PURE__ */ new Map());
  let set2;
  if (isFunction_default(opt.set)) set2 = function(d2) {
    const v2 = index.get(d2[key]);
    opt.set(d2, v2);
  };
  else if (values) {
    const m5 = values.length;
    set2 = function(d2) {
      const v2 = index.get(d2[key]);
      if (isNil_default(v2)) for (let i2 = 0; i2 < m5; ++i2) d2[as[i2]] = defaultValue;
      else for (let i2 = 0; i2 < m5; ++i2) d2[as[i2]] = v2[values[i2]];
    };
  } else set2 = function(d2) {
    const v2 = index.get(d2[key]);
    d2[as[0]] = isValid_default(v2) ? v2 : defaultValue;
  };
  return 0 === data.length ? [] : data.map((d2) => (set2(d2), d2));
};

// node_modules/@visactor/vchart/esm/series/geo/geo.js
var GeoSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.geo, this.coordinate = "geo", this._nameProperty = "name";
  }
  getMapViewData() {
    var _a;
    return null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView();
  }
  get nameField() {
    return this._nameField;
  }
  set nameField(f2) {
    this._nameField = f2;
  }
  get valueField() {
    return this._valueField;
  }
  set valueField(f2) {
    this._valueField = f2;
  }
  getNameProperty() {
    return this._nameProperty;
  }
  getCentroidProperty() {
    return this._centroidProperty;
  }
  getCoordinateHelper() {
    return this._coordinateHelper;
  }
  setCoordinateHelper(h2) {
    this._coordinateHelper = h2;
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  getGroupFields() {
    return null;
  }
  dataToPosition(datum) {
    var _a;
    let result2 = null;
    if (!datum) return result2;
    const { dataToPosition, latitudeField, longitudeField } = this._coordinateHelper;
    if (result2 = this.nameToPosition(datum), null === result2) {
      const lonValue = longitudeField ? null == datum ? void 0 : datum[longitudeField] : Number.NaN, latValue = latitudeField ? null == datum ? void 0 : datum[latitudeField] : Number.NaN;
      result2 = null !== (_a = null == dataToPosition ? void 0 : dataToPosition([lonValue, latValue])) && void 0 !== _a ? _a : null;
    }
    return result2;
  }
  nameToPosition(datum) {
    var _a, _b;
    const name = this.getDatumName(datum);
    if (isNil_default(name)) return null;
    const mapData = null === (_b = null === (_a = this.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.filter((data) => this.getDatumName(data) === name)[0];
    if (isNil_default(mapData)) return null;
    const { dataToPosition } = this._coordinateHelper, center2 = this.getDatumCenter(mapData), pos = null == dataToPosition ? void 0 : dataToPosition(center2);
    return isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) ? null : pos;
  }
  dataToLatitude(latValue) {
    if (!this._coordinateHelper) return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(latValue);
  }
  dataToLongitude(lonValue) {
    if (!this._coordinateHelper) return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(lonValue);
  }
  valueToPosition(lonValue, latValue) {
    return {
      x: this.dataToLongitude(lonValue),
      y: this.dataToLatitude(latValue)
    };
  }
  positionToData(p2) {
  }
  latitudeToData(lat) {
  }
  longitudeToData(lon) {
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionZ(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  release() {
    super.release(), this._mapViewData.release(), this._mapViewData = this._mapViewDataStatistics = null;
  }
  getStackGroupFields() {
    return [this._nameField];
  }
  getStackValueField() {
    return this._spec.valueField;
  }
  compileData() {
    var _a;
    null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
  }
  initStatisticalData() {
    if (super.initStatisticalData(), this._mapViewData) {
      const viewDataName = `${PREFIX}_series_${this.id}_mapViewDataStatic`;
      this._mapViewDataStatistics = this.createStatisticalData(viewDataName, this._mapViewData.getDataView()), this._mapViewData.getDataView().target.removeListener("change", this._mapViewDataStatistics.reRunAllTransform);
    }
  }
  getSeriesKeys() {
    var _a, _b, _c, _d, _e;
    return this._seriesField ? null !== (_e = null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : null === (_d = null === (_c = this._mapViewDataStatistics) || void 0 === _c ? void 0 : _c.latestData[this._seriesField]) || void 0 === _d ? void 0 : _d.values) && void 0 !== _e ? _e : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_a = this._mapViewData.getDataView()) || void 0 === _a || _a.reRunAllTransform(), null === (_b = this._mapViewDataStatistics) || void 0 === _b || _b.reRunAllTransform();
  }
  getActiveMarks() {
    return [];
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/map.js
var DEFAULT_MAP_LOOK_UP_KEY = `${PREFIX}_MAP_LOOK_UP_KEY`;
var map3 = (data, opt) => (data.features && data.features.forEach((f2, index) => {
  var _a, _b;
  f2[DEFAULT_DATA_INDEX] = index, opt.nameMap ? f2[DEFAULT_MAP_LOOK_UP_KEY] = opt.nameMap[null === (_a = f2.properties) || void 0 === _a ? void 0 : _a[opt.nameProperty]] : f2[DEFAULT_MAP_LOOK_UP_KEY] = null === (_b = f2.properties) || void 0 === _b ? void 0 : _b[opt.nameProperty];
}), data.features);

// node_modules/@visactor/vchart/esm/series/map/tooltip-helper.js
var MapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.titleValueCallback = (datum) => {
      var _a;
      const series2 = this.series;
      return null !== (_a = this._getDimensionData(datum)) && void 0 !== _a ? _a : series2.getDatumName(datum);
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/path.js
var PathMark = class _PathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _PathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0,
      path: ""
    });
  }
};
PathMark.type = "path";
var registerPathMark = () => {
  Factory2.registerMark(PathMark.type, PathMark), registerPathGraphic2();
};

// node_modules/@visactor/vchart/esm/component/geo/projection.js
var Projection2 = class {
  constructor(projectionSpec) {
    this.projection = projection3(projectionSpec.type)();
  }
  fit(start, size, features) {
    const fitData = {
      type: "FeatureCollection",
      features
    };
    this.projection.fitExtent([start, size], fitData);
  }
  center(center2) {
    var _a, _b;
    null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.center) || void 0 === _b || _b.call(_a, center2);
  }
  project(point6) {
    var _a;
    return null === (_a = this.projection) || void 0 === _a ? void 0 : _a.call(this, point6);
  }
  shape(data) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.path) || void 0 === _b ? void 0 : _b.call(_a, data);
  }
  invert(point6) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.invert) || void 0 === _b ? void 0 : _b.call(_a, point6);
  }
  scale(scale4) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === scale4) return this.projection.scale();
      this.projection.scale(scale4);
    }
  }
  translate(point6) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === point6) return this.projection.translate();
      this.projection.translate(point6);
    }
  }
  evaluate(start, size, features) {
    const tmp = this.projection.copy();
    return null == tmp ? void 0 : tmp.fitExtent([start, size], {
      type: "FeatureCollection",
      features
    });
  }
};

// node_modules/@visactor/vchart/esm/plugin/components/plugin-service.js
var ComponentPluginService = class extends BasePluginService {
  constructor(component2) {
    super(), this.component = component2;
  }
};

// node_modules/@visactor/vchart/esm/component/util.js
function getComponentThemeFromOption(type, chartTheme) {
  return get_default(chartTheme, `component.${type}`);
}

// node_modules/@visactor/vchart/esm/component/axis/util.js
var DEFAULT_TITLE_STYLE = {
  left: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  right: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  radius: {},
  angle: {}
};
function transformAxisLineStyle(lineCfg) {
  return (lineCfg = transformComponentStyle(lineCfg)).startSymbol = transformComponentStyle(lineCfg.startSymbol), lineCfg.endSymbol = transformComponentStyle(lineCfg.endSymbol), lineCfg;
}
function getAxisLabelOffset(axisSpec) {
  let labelOffset = 0;
  return get_default(axisSpec, "tick.visible") && (labelOffset += get_default(axisSpec, "tick.tickSize")), get_default(axisSpec, "label.visible") && (labelOffset += get_default(axisSpec, "label.space")), labelOffset;
}
function getLinearAxisSpecDomain(axisSpec, defaultDomain) {
  var _a, _b, _c, _d, _e, _f;
  return {
    min: null !== (_c = null !== (_a = axisSpec.min) && void 0 !== _a ? _a : null === (_b = axisSpec.range) || void 0 === _b ? void 0 : _b.min) && void 0 !== _c ? _c : null == defaultDomain ? void 0 : defaultDomain.min,
    max: null !== (_f = null !== (_d = axisSpec.max) && void 0 !== _d ? _d : null === (_e = axisSpec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null == defaultDomain ? void 0 : defaultDomain.max
  };
}
function isValidCartesianAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "top" === orient || "bottom" === orient || "left" === orient || "right" === orient || "z" === orient;
}
function isValidPolarAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "angle" === orient || "radius" === orient;
}
var getCartesianAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : ["linear", "log", "symlog"].includes(type) ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = isXAxis(orient) ? getComponentThemeFromOption("axisX", chartTheme) : isYAxis(orient) ? getComponentThemeFromOption("axisY", chartTheme) : getComponentThemeFromOption("axisZ", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var getPolarAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : "linear" === type ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = getComponentThemeFromOption("angle" === orient ? "axisAngle" : "axisRadius", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var isDiscreteAxis = (axisType) => "band" === axisType || "ordinal" === axisType || "point" === axisType;

// node_modules/@visactor/vchart/esm/component/crosshair/util.js
function limitTagInBounds(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1: x14, y1: y14, x2: x23, y2: y23 } = shape.AABBBounds, { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  let dx = 0, dy = 0;
  x14 < regionMinX && (dx = regionMinX - x14), y14 < regionMinY && (dy = regionMinY - y14), x23 > regionMaxX && (dx = regionMaxX - x23), y23 > regionMaxY && (dy = regionMaxY - y23), dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}
function getDatumByValue(data, value, startField, endField) {
  let left2 = 0, right2 = data.length - 1;
  for (; left2 <= right2; ) {
    const mid = Math.floor((left2 + right2) / 2), record = data[mid];
    if (record[startField] <= value && record[endField || startField] >= value) return record;
    record[startField] > value ? right2 = mid - 1 : left2 = mid + 1;
  }
  return null;
}
var getCartesianCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, xField, yField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, xAxis = axes.find((axis2) => isXAxis(axis2.orient));
  let newXField;
  newXField = isValid_default(xAxis) ? mergeSpec({}, isDiscreteAxis(xAxis.type) ? bandField : linearField, xField) : xField;
  const yAxis = axes.find((axis2) => isYAxis(axis2.orient));
  let newYField;
  return newYField = isValid_default(yAxis) ? mergeSpec({}, isDiscrete(yAxis.type) ? bandField : linearField, yField) : yField, {
    xField: newXField,
    yField: newYField
  };
};
var getPolarCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, categoryField, valueField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, angleAxis = axes.find((axis2) => "angle" === axis2.orient);
  let newAngleField;
  newAngleField = isValid_default(angleAxis) ? mergeSpec({}, isDiscreteAxis(angleAxis.type) ? bandField : linearField, categoryField) : categoryField;
  const radiusAxis = axes.find((axis2) => "radius" === axis2.orient);
  let newRadiusField;
  return newRadiusField = isValid_default(radiusAxis) ? mergeSpec({}, isDiscrete(radiusAxis.type) ? bandField : linearField, valueField) : valueField, {
    categoryField: newAngleField,
    valueField: newRadiusField
  };
};

// node_modules/@visactor/vchart/esm/component/data-zoom/util.js
var dataFilterWithNewDomain = (data, op) => {
  const { getNewDomain, isContinuous: isContinuous2, field: field5 } = op, datumField = field5(), newDomain = getNewDomain();
  if (isNil_default(newDomain) || isNil_default(datumField)) return data;
  if (0 === newDomain.length) return [];
  let filter2 = null;
  return filter2 = isContinuous2() ? (d2) => d2[datumField] >= newDomain[0] && d2[datumField] <= newDomain[1] : (d2) => newDomain.indexOf(d2[datumField] + "") >= 0 || newDomain.indexOf(d2[datumField]) >= 0, data.filter(filter2);
};
var dataFilterComputeDomain = (data, op) => {
  const { stateFields, valueFields, dataCollection } = op.input, { stateField, valueField } = op.output, resultObj = {}, resultData = [];
  return dataCollection.forEach((dv, i2) => {
    var _a;
    if (isNil_default(stateFields[i2])) return;
    const stateFieldInfo = null === (_a = dv.getFields()) || void 0 === _a ? void 0 : _a[stateFields[i2]];
    stateFieldInfo && stateFieldInfo.lockStatisticsByDomain && stateFieldInfo.domain.forEach((d2) => {
      resultObj[d2] = 0;
    }), dv.latestData.forEach((d2) => {
      array(stateFields[i2]).forEach((state) => {
        isNil_default(d2[state]) || (isNil_default(resultObj[d2[state]]) && (resultObj[d2[state]] = 0), isNil_default(valueFields[i2]) || (resultObj[d2[state]] += isNaN(parseFloat(d2[valueFields[i2]])) ? 1 : parseFloat(d2[valueFields[i2]])));
      });
    });
  }), Object.keys(resultObj).forEach((d2, i2) => {
    const res = {
      [stateField]: d2
    };
    valueField && (res[valueField] = resultObj[d2]), resultData.push(res);
  }), resultData;
};
var getDataFilterTheme = (orient, type, chartTheme) => {
  const theme2 = getComponentThemeFromOption(type, chartTheme), directionTheme = theme2[getDirectionByOrient(orient)], finalTheme = mergeSpec({}, theme2, directionTheme);
  return delete finalTheme.horizontal, delete finalTheme.vertical, finalTheme;
};

// node_modules/@visactor/vchart/esm/component/legend/util.js
function transformLegendTitleAttributes(title3) {
  var _a, _b;
  const transformedTitle = Object.assign({}, title3);
  return isEmpty_default(title3.style) || (transformedTitle.textStyle = transformToGraphic(title3.style)), isEmpty_default(title3.textStyle) || mergeSpec(transformedTitle.textStyle, transformToGraphic(title3.textStyle)), (null === (_a = title3.shape) || void 0 === _a ? void 0 : _a.style) && transformToGraphic(transformedTitle.shape.style), (null === (_b = title3.background) || void 0 === _b ? void 0 : _b.style) && transformToGraphic(transformedTitle.background.style), transformedTitle;
}
function getLayout(spec) {
  return "bottom" === spec.orient || "top" === spec.orient ? "horizontal" : "vertical";
}

// node_modules/@visactor/vchart/esm/component/base/util.js
function getComponentThemeFromGlobalTheme(type, chartTheme, componentSpec, chartSpec) {
  switch (type) {
    case ComponentTypeEnum.cartesianBandAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "band", chartTheme);
    case ComponentTypeEnum.cartesianLinearAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "linear", chartTheme);
    case ComponentTypeEnum.cartesianLogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "log", chartTheme);
    case ComponentTypeEnum.cartesianSymlogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "symlog", chartTheme);
    case ComponentTypeEnum.cartesianAxis:
    case ComponentTypeEnum.cartesianTimeAxis:
      return getCartesianAxisTheme(getOrient(componentSpec), void 0, chartTheme);
    case ComponentTypeEnum.polarBandAxis:
      return getPolarAxisTheme(componentSpec.orient, "band", chartTheme);
    case ComponentTypeEnum.polarLinearAxis:
      return getPolarAxisTheme(componentSpec.orient, "linear", chartTheme);
    case ComponentTypeEnum.polarAxis:
      return getPolarAxisTheme(componentSpec.orient, void 0, chartTheme);
    case ComponentTypeEnum.cartesianCrosshair:
      return getCartesianCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.polarCrosshair:
      return getPolarCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.colorLegend:
    case ComponentTypeEnum.sizeLegend:
      return getComponentThemeFromOption(`${type}.${getLayout(componentSpec)}`, chartTheme);
    case ComponentTypeEnum.dataZoom:
    case ComponentTypeEnum.scrollBar:
      return getDataFilterTheme(getOrient(componentSpec), type, chartTheme);
    default:
      return getComponentThemeFromOption(type, chartTheme);
  }
}

// node_modules/@visactor/vchart/esm/component/base/base-component-transformer.js
var BaseComponentSpecTransformer = class extends BaseModelSpecTransformer {
  getTheme(spec, chartSpec) {
    return getComponentThemeFromGlobalTheme(this.type, this._option.getTheme(), spec, chartSpec);
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const { spec: newSpec, theme: theme2 } = super._mergeThemeToSpec(spec, chartSpec);
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
  _adjustPadding(spec) {
    const { padding, noOuterPadding = true, orient } = spec;
    noOuterPadding && padding && orient && (spec.padding = Object.assign(Object.assign({}, normalizeLayoutPaddingSpec(padding)), {
      [orient]: 0
    }));
  }
};

// node_modules/@visactor/vchart/esm/component/base/base-component.js
var __rest12 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var BaseComponent = class extends LayoutModel {
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest12(specInfo, ["spec"]);
    return new this(spec, Object.assign(Object.assign({}, options), others));
  }
  getRegions() {
    return this._regions;
  }
  created() {
    this.initLayout(), super.created(), this.pluginService = new ComponentPluginService(this);
  }
  constructor(spec, options) {
    super(spec, options), this.name = "component", this.modelType = "component", this.transformerConstructor = BaseComponentSpecTransformer, this._delegateEvent = (component2, event, type, item = null, datum = null) => {
      var _a, _b;
      this.event.emit(type, {
        model: this,
        node: component2,
        event,
        item,
        datum,
        source: Event_Source_Type.chart,
        chart: null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b ? void 0 : _b.getChart()
      }, "model");
    }, this._option.animation && (this.animate = new AnimateManager({
      getCompiler: options.getCompiler
    }));
  }
  initLayout() {
    var _a;
    super.initLayout(), this._regions = null !== (_a = this._regions) && void 0 !== _a ? _a : this._option.getRegionsInIndex(), this._layout && (this._layout.layoutBindRegionID = this._regions.map((x3) => null == x3 ? void 0 : x3.id));
  }
  changeRegions(regions) {
    throw new Error("Method not implemented.");
  }
  _getNeedClearVRenderComponents() {
    throw new Error("Method not implemented.");
  }
  onRender(ctx) {
    throw new Error("Method not implemented.");
  }
  getVRenderComponents() {
    return this._getNeedClearVRenderComponents();
  }
  callPlugin(cb) {
    this.pluginService && this.pluginService.getAll().forEach((plugin) => cb(plugin));
  }
  eventPos(markEventParams) {
    return {
      x: markEventParams.event.viewX - this.getLayoutStartPoint().x,
      y: markEventParams.event.viewY - this.getLayoutStartPoint().y
    };
  }
  getContainer() {
    var _a;
    return this._container || (this._container = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance.getStage().find((node) => "root" === node.name, true)), this._container;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || (result2.reMake = ["seriesId", "seriesIndex", "regionId", "regionIndex"].some((k3) => isEqual(null == prevSpec ? void 0 : prevSpec[k3], spec[k3]))), (null == prevSpec ? void 0 : prevSpec.visible) !== spec.visible && (result2.reCompile = true), result2;
  }
  release() {
    super.release(), this.clear();
  }
  clear() {
    var _a;
    const components = this._getNeedClearVRenderComponents();
    components && components.length && components.forEach((c4) => {
      var _a2;
      c4 && (null === (_a2 = this.getContainer()) || void 0 === _a2 || _a2.removeChild(c4), c4 = null);
    }), this._container = null, null === (_a = this.pluginService) || void 0 === _a || _a.disposeAll(), this.pluginService = null;
  }
  compile() {
    this.compileMarks();
  }
  compileMarks(group) {
    this.getMarks().forEach((m5) => {
      var _a;
      m5.compile({
        group
      }), null === (_a = m5.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      });
    });
  }
  getBoundsInRect(rect, fullRect) {
    return {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
};
BaseComponent.transformerConstructor = BaseComponentSpecTransformer;

// node_modules/@visactor/vchart/esm/component/common/trigger/desktop.js
var DeskTopTrigger = class {
  parserScrollEvent(e3) {
    return e3 ? !(e3.ctrlKey || 0 === e3.deltaY && 0 === e3.deltaX) && (e3.scrollX = e3.deltaX, e3.scrollY = e3.deltaY, e3) : e3;
  }
  parserZoomEvent(e3) {
    if (!e3) return e3;
    const zoom = Math.pow(1.0005, -e3.deltaY * Math.pow(16, e3.deltaMode));
    return e3.zoomDelta = zoom, e3.zoomX = e3.canvasX, e3.zoomY = e3.canvasY, e3;
  }
  clearZoom() {
  }
  clearScroll() {
  }
  clearDrag() {
  }
  parserDragEvent() {
    return true;
  }
};

// node_modules/@visactor/vchart/esm/component/common/trigger/mobile.js
var MobileTrigger = class {
  constructor() {
    this._lastScale = 0;
  }
  clearZoom() {
    this._lastScale = 0, this.pointerId = null;
  }
  parserDragEvent(event) {
    return this.pointerId ? this.pointerId === event.pointerId : (this.pointerId = event.pointerId, true);
  }
  parserZoomEvent(event) {
    const scale4 = event.scale;
    if (0 === this._lastScale) return this._lastScale = scale4, event;
    event.zoomDelta = scale4 / this._lastScale;
    const center2 = event.center;
    return event.zoomX = center2.x, event.zoomY = center2.y, this._lastScale = scale4, event;
  }
  parserScrollEvent(event) {
    return event;
  }
  clearScroll() {
  }
  clearDrag() {
  }
};

// node_modules/@visactor/vchart/esm/component/common/trigger/config.js
function getDefaultTriggerEventByMode(mode2) {
  return mode2 === RenderModeEnum["desktop-browser"] || mode2 === RenderModeEnum["desktop-miniApp"] ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup",
    zoom: "wheel",
    zoomEnd: "pointerup",
    scroll: "wheel",
    trigger: DeskTopTrigger
  } : isMobileLikeMode(mode2) || isMiniAppLikeMode(mode2) ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup",
    zoom: "pinch",
    zoomEnd: "pinchend",
    scroll: "pan",
    scrollEnd: "panend",
    trigger: MobileTrigger
  } : null;
}

// node_modules/@visactor/vchart/esm/interaction/zoom/zoomable.js
var delayMap4 = {
  debounce: debounce_default,
  throttle: throttle_default
};
var Zoomable = class {
  constructor() {
    this._isGestureListener = false;
  }
  initZoomable(evt, mode2 = RenderModeEnum["desktop-browser"]) {
    this._eventObj = evt, this._renderMode = mode2, this._gestureController = this._option.getChart().getVGrammarView().renderer._gestureController, this._isGestureListener = isMobileLikeMode(this._renderMode) || isMiniAppLikeMode(this._renderMode), getDefaultTriggerEventByMode(this._renderMode) && (this._clickEnable = true, this._zoomableTrigger = new (this._getZoomTriggerEvent("trigger"))());
  }
  _getZoomTriggerEvent(type) {
    return getDefaultTriggerEventByMode(this._renderMode)[type];
  }
  _zoomEventDispatch(params2, regionOrSeries, callback) {
    if (!this._isGestureListener && !params2.event) return;
    const event = this._isGestureListener ? params2 : params2.event.clone();
    this._zoomableTrigger.parserZoomEvent(event);
    const { zoomDelta, zoomX, zoomY } = event;
    isNil_default(zoomDelta) || pointInRect({
      x: zoomX,
      y: zoomY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false) && (this._clickEnable = false, callback && callback({
      zoomDelta,
      zoomX,
      zoomY
    }, event), this._eventObj.emit("zoom", {
      scale: event.zoomDelta,
      scaleCenter: {
        x: event.zoomX,
        y: event.zoomY
      },
      model: this
    }));
  }
  _getRegionOrSeriesLayout(rs) {
    "region" !== rs.type && (rs = rs.getRegion());
    const { x: x3, y: y3, width, height } = rs.layout.getLayout();
    return {
      x1: x3,
      y1: y3,
      x2: x3 + width,
      y2: y3 + height
    };
  }
  _bindZoomEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, zoomParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoom")] : [this._getZoomTriggerEvent("zoom"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], zoomEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoomEnd")] : [this._getZoomTriggerEvent("zoomEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...zoomEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearZoom();
    }, delayTime)), event.on(...zoomParams, delayMap4[delayType]((params2) => {
      this._zoomEventDispatch(params2, regionOrSeries, callback);
    }, delayTime));
  }
  initZoomEventOfSeries(s3, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && this._bindZoomEventAsRegion(s3.event, s3, callback, option);
  }
  initZoomEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r2) => {
      filter2 ? r2.getSeries().forEach((s3) => {
        filter2(s3) && this._bindZoomEventAsRegion(s3.event, s3, callback, option);
      }) : this._bindZoomEventAsRegion(this._eventObj, r2, callback, option);
    });
  }
  _scrollEventDispatch(params2, regionOrSeries, callback) {
    let stopBubble = false;
    if (!this._isGestureListener && (!params2.event || this._option.disableTriggerEvent)) return stopBubble;
    const event = this._isGestureListener ? params2 : params2.event;
    this._zoomableTrigger.parserScrollEvent(event);
    const { scrollX, scrollY, canvasX, canvasY } = event;
    return isNil_default(scrollX) && isNil_default(scrollY) ? stopBubble : pointInRect({
      x: canvasX,
      y: canvasY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false) ? (this._clickEnable = false, callback && (stopBubble = callback({
      scrollX,
      scrollY
    }, event)), this._eventObj.emit("scroll", {
      scrollX,
      scrollY,
      model: this
    }), stopBubble) : stopBubble;
  }
  _bindScrollEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, scrollParams = this._isGestureListener ? [this._getZoomTriggerEvent("scroll")] : [this._getZoomTriggerEvent("scroll"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], scrollEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("scrollEnd")] : [this._getZoomTriggerEvent("scrollEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...scrollEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearScroll();
    }, delayTime)), event.on(...scrollParams, delayMap4[delayType]((params2) => this._scrollEventDispatch(params2, regionOrSeries, callback), delayTime));
  }
  initScrollEventOfSeries(s3, callback, option) {
    getDefaultTriggerEventByMode(this._renderMode) && this._bindScrollEventAsRegion(s3.event, s3, callback, option);
  }
  initScrollEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r2) => {
      filter2 ? r2.getSeries().forEach((s3) => {
        filter2(s3) && this._bindScrollEventAsRegion(s3.event, s3, callback, option);
      }) : this._bindScrollEventAsRegion(this._eventObj, r2, callback, option);
    });
  }
  _bindDragEventAsRegion(eventObj, regionOrSeries, callback, option) {
    eventObj.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.chart
    }, (params2) => {
      if (!params2.event) return;
      const { event } = params2;
      pointInRect({
        x: event.canvasX,
        y: event.canvasY
      }, this._getRegionOrSeriesLayout(regionOrSeries), false) && this._handleDrag(params2, callback, option);
    }), eventObj.on("click", {
      level: Event_Bubble_Level.chart
    }, () => !this._clickEnable);
  }
  initDragEventOfSeries(s3, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && s3.event.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.model,
      filter: ({ model }) => (null == model ? void 0 : model.id) === s3.id
    }, (params2) => {
      this._handleDrag(params2, callback, option);
    });
  }
  initDragEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r2) => {
      filter2 ? r2.getSeries().forEach((s3) => {
        filter2(s3) && (s3.event.on(this._getZoomTriggerEvent("start"), {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s3.id
        }, (params2) => {
          this._handleDrag(params2, callback);
        }), s3.event.on("click", {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s3.id
        }, () => !this._clickEnable));
      }) : this._bindDragEventAsRegion(this._eventObj, r2, callback, option);
    });
  }
  _handleDrag(params2, callback, option) {
    var _a, _b, _c;
    if (this._option.disableTriggerEvent) return;
    if (this._clickEnable = true, !this._zoomableTrigger.parserDragEvent(params2.event)) return;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, realTime = null === (_c = null == option ? void 0 : option.realTime) || void 0 === _c || _c, move = this._getZoomTriggerEvent("move"), end = this._getZoomTriggerEvent("end"), event = params2.event;
    let moveX = event.canvasX, moveY = event.canvasY, upX = event.canvasX, upY = event.canvasY;
    const mouseup = delayMap4[delayType]((params3) => {
      this._clickEnable = false;
      const event2 = params3.event, delta = [event2.canvasX - upX, event2.canvasY - upY];
      upX = event2.canvasX, upY = event2.canvasY, !realTime && callback && callback(delta, params3.event), this._eventObj.emit("panend", {
        delta,
        model: this
      }), this._zoomableTrigger.pointerId = null, this._eventObj.off(move, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.chart
      }, mousemove), this._eventObj.off(end, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.window
      }, mouseup);
    }, delayTime), mousemove = delayMap4[delayType]((params3) => {
      if (!this._zoomableTrigger.parserDragEvent(params3.event)) return;
      this._clickEnable = false;
      const event2 = params3.event, delta = [event2.canvasX - moveX, event2.canvasY - moveY];
      moveX = event2.canvasX, moveY = event2.canvasY, realTime && callback && callback(delta, params3.event), this._eventObj.emit("panmove", {
        delta,
        model: this
      });
    }, delayTime);
    this._eventObj.on(move, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, mousemove), this._eventObj.on(end, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, mouseup);
  }
};

// node_modules/@visactor/vchart/esm/component/geo/geo-coordinate.js
function projectionName(key, id2) {
  return `${PREFIX}_${id2}_${key}`;
}
var GeoCoordinate = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.geoCoordinate, this.name = ComponentTypeEnum.geoCoordinate, this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Mark, this._projectionSpec = {
      name: projectionName(this.type, this.id),
      type: "mercator"
    }, this._actualScale = 1, this._initialScale = 1, this.effect = {
      scaleUpdate: () => {
        this.coordinateHelper();
      }
    }, this._handleChartZoom = (params2, event) => {
      var _a, _b, _c, _d, _e, _f;
      let scale4 = params2.zoomDelta;
      const _lastActualScale = this._actualScale;
      return this._actualScale *= scale4, this._actualScale < (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.min) ? (this._actualScale = null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min, scale4 = (null === (_c = this._spec.zoomLimit) || void 0 === _c ? void 0 : _c.min) / _lastActualScale) : this._actualScale > (null === (_d = this._spec.zoomLimit) || void 0 === _d ? void 0 : _d.max) && (this._actualScale = null === (_e = this._spec.zoomLimit) || void 0 === _e ? void 0 : _e.max, scale4 = (null === (_f = this._spec.zoomLimit) || void 0 === _f ? void 0 : _f.max) / _lastActualScale), event && (event.zoomDelta = scale4), this.zoom(scale4, [params2.zoomX, params2.zoomY]), scale4;
    }, this.pan = (delta = [0, 0]) => {
      var _a, _b, _c;
      const t2 = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.translate()) && void 0 !== _b ? _b : [0, 0];
      let t_x = t2[0], t_y = t2[1];
      t_x += delta[0], t_y += delta[1], null === (_c = this._projection) || void 0 === _c || _c.translate([t_x, t_y]);
    };
  }
  get longitudeField() {
    return this._longitudeField;
  }
  get latitudeField() {
    return this._latitudeField;
  }
  get projectionSpec() {
    return this._projectionSpec;
  }
  setProjection(projectionSpec) {
    this._projectionSpec = Object.assign(Object.assign({}, projectionSpec), {
      name: this._projectionSpec.name
    });
  }
  getZoom() {
    return this._actualScale;
  }
  static getSpecInfo(chartSpec) {
    if (isNil_default(chartSpec)) return null;
    const specInfos = [];
    return chartSpec.region.forEach((r2, i2) => {
      if ("geo" === r2.coordinate) {
        const spec = Object.assign(Object.assign({}, r2), {
          padding: 0
        });
        specInfos.push({
          spec,
          regionIndex: i2,
          type: ComponentTypeEnum.geoCoordinate,
          specInfoPath: ["region", i2, "geoCoordinate"]
        });
      }
    }), specInfos;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this._spec.roam && this.initZoomable(this.event, this._option.mode), this._projectionSpec = mergeSpec(this._projectionSpec, this._spec.projection), this._projectionSpec.zoom > (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.max) && (this._projectionSpec.zoom = this._spec.zoomLimit.max), this._projectionSpec.zoom < (null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min) && (this._projectionSpec.zoom = this._spec.zoomLimit.min), this._actualScale = null !== (_c = this._projectionSpec.zoom) && void 0 !== _c ? _c : 1, this._initialScale = this._actualScale, this._longitudeField = this._spec.longitudeField, this._latitudeField = this._spec.latitudeField;
  }
  created() {
    super.created(), this._regions = this._option.getRegionsInIndex([this._option.regionIndex]), this.initProjection(), this.coordinateHelper(), this.initEvent(), this._initCenterCache();
  }
  dispatchZoom(zoomDelta, center2) {
    const scaleCenter = center2 || {
      x: this.getLayoutStartPoint().x + this.getLayoutRect().width / 2,
      y: this.getLayoutStartPoint().y + this.getLayoutRect().height / 2
    }, scale4 = this._handleChartZoom({
      zoomDelta,
      zoomX: scaleCenter.x,
      zoomY: scaleCenter.y
    });
    1 !== scale4 && this.event.emit("zoom", {
      scale: scale4,
      scaleCenter,
      model: this
    });
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this)), this._spec.roam && (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom), this.initDragEventOfRegions(this._regions, () => true, this.pan), this._regions.forEach((r2) => {
      r2.getSeries().forEach((s3) => {
        s3.event.on("zoom", (e3) => (s3.handleZoom(e3), true)), s3.event.on("panmove", (e3) => (s3.handlePan(e3), true));
      });
    }));
  }
  initProjection() {
    var _a;
    this._projection = new Projection2(this._projectionSpec), null !== this._projection.projection || null === (_a = this._option) || void 0 === _a || _a.onError("unsupported projection type!");
  }
  coordinateHelper() {
    const helper = {
      longitudeField: this._longitudeField,
      latitudeField: this._latitudeField,
      dataToPosition: this.dataToPosition.bind(this),
      dataToLongitude: this.dataToLongitude.bind(this),
      dataToLatitude: this.dataToLatitude.bind(this),
      shape: this.shape.bind(this),
      getCoordinateId: () => this.id
    };
    this._regions.forEach((r2) => {
      r2.getSeries().forEach((s3) => {
        s3.type === SeriesTypeEnum.map ? s3.setCoordinateHelper(helper) : (s3.setXAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s3.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s3.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          getFields: () => [this._longitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })), s3.setYAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s3.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s3.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          getFields: () => [this._latitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })));
      });
    });
  }
  onLayoutEnd(ctx) {
    this.setLayoutRect(this._regions[0].getLayoutRect()), this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint());
    const { width, height } = this.getLayoutRect(), { translate: translate2, scale: scale4, center: center2 } = this.evaluateProjection([0, 0], [width, height]);
    translate2 && this._projection.translate(translate2), scale4 && this._projection.scale(scale4), center2 && this._projection.center(center2), eachSeries(this._regions, (s3) => {
      var _a;
      if (s3.type === SeriesTypeEnum.map) {
        s3.areaPath.clear();
        const pathGroup = null === (_a = s3.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
        pathGroup && pathGroup.attribute.postMatrix && pathGroup.setAttributes({
          postMatrix: new Matrix()
        });
      }
    }), this._actualScale = this._initialScale, super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  collectFeatures() {
    const features = [];
    return this._regions.forEach((r2) => {
      r2.getSeries().forEach((s3) => {
        var _a, _b;
        s3.type === SeriesTypeEnum.map && features.push(...null !== (_b = null === (_a = s3.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []);
      });
    }), features;
  }
  dataToPosition(values = []) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([values[0], values[1]]);
    return {
      x: null == point6 ? void 0 : point6[0],
      y: null == point6 ? void 0 : point6[1]
    };
  }
  dataToLatitude(lat) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([0, lat]);
    return null == point6 ? void 0 : point6[1];
  }
  dataToLongitude(lon) {
    var _a;
    const point6 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([lon, 0]);
    return null == point6 ? void 0 : point6[0];
  }
  zoom(p2, anchor = [0, 0]) {
    var _a, _b, _c, _d, _e, _f;
    let s3 = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.scale()) && void 0 !== _b ? _b : 0;
    const t2 = null !== (_d = null === (_c = this._projection) || void 0 === _c ? void 0 : _c.translate()) && void 0 !== _d ? _d : [0, 0];
    let t_x = t2[0], t_y = t2[1];
    s3 *= p2, t_x -= (anchor[0] - t_x) * (p2 - 1), t_y -= (anchor[1] - t_y) * (p2 - 1), null === (_e = this._projection) || void 0 === _e || _e.scale(s3), null === (_f = this._projection) || void 0 === _f || _f.translate([t_x, t_y]);
  }
  shape(datum) {
    return this._projection.shape(datum);
  }
  invert(point6) {
    return this._projection.invert(point6);
  }
  evaluateProjection(start, size) {
    var _a;
    const evaluated = this._projection.evaluate(start, size, this.collectFeatures());
    let translate2 = evaluated.translate();
    const scale4 = evaluated.scale() * this._initialScale, center2 = null !== (_a = this._projectionSpec.center) && void 0 !== _a ? _a : evaluated.invert([size[0] / 2, size[1] / 2]);
    return center2 && (translate2 = [size[0] / 2, size[1] / 2]), {
      translate: translate2,
      scale: scale4,
      center: center2
    };
  }
  _initCenterCache() {
    this._centerCache || (this._centerCache = /* @__PURE__ */ new Map()), this._regions.forEach((r2) => {
      r2.getSeries().forEach((s3) => {
        var _a, _b;
        if ("map" === s3.type) {
          (null !== (_b = null === (_a = s3.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []).forEach((feature3 = {}) => {
            const key = feature3[s3.getDimensionField()[0]] || feature3[DEFAULT_MAP_LOOK_UP_KEY], center2 = s3.getDatumCenter(feature3);
            key && isValid_default(center2) && this._centerCache.set(key, {
              x: center2[0],
              y: center2[1]
            });
          });
        }
      });
    });
  }
  release() {
    super.release(), this._centerCache && this._centerCache.clear(), this._centerCache = null;
  }
};
GeoCoordinate.type = ComponentTypeEnum.geoCoordinate, mixin(GeoCoordinate, Zoomable);
var registerGeoCoordinate = () => {
  Factory2.registerComponent(GeoCoordinate.type, GeoCoordinate);
};

// node_modules/@visactor/vchart/esm/series/map/map-transformer.js
var MapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "area", void 0, void 0, false);
  }
};

// node_modules/@visactor/vchart/esm/series/map/map.js
var MapSeries = class _MapSeries extends GeoSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.map, this.transformerConstructor = MapSeriesSpecTransformer, this._areaCache = /* @__PURE__ */ new Map();
  }
  getNameMap() {
    return this._nameMap;
  }
  get areaPath() {
    return this._areaCache;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.map = this._spec.map, this._nameMap = this._spec.nameMap, this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty), this._spec.centroidProperty && (this._centroidProperty = this._spec.centroidProperty), this.map || null === (_a = this._option) || void 0 === _a || _a.onError(`map type '${this.map}' is not specified !`), geoSourceMap.get(this.map) || null === (_b = this._option) || void 0 === _b || _b.onError(`'${this.map}' data is not registered !`);
  }
  initData() {
    var _a, _b;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView), registerDataSetInstanceTransform(this._dataSet, "map", map3), registerDataSetInstanceTransform(this._dataSet, "lookup", lookup);
    const features = geoSourceMap.get(this.map);
    features || null === (_a = this._option) || void 0 === _a || _a.onError("no valid map data found!");
    const mapData = new DataView(this._dataSet, {
      name: `map_${this.id}_data`
    });
    mapData.parse([features], {
      type: "dataview"
    }).transform({
      type: "copyDataView",
      options: {
        deep: true
      },
      level: TransformLevel.copyDataView
    }).transform({
      type: "map",
      options: {
        nameMap: this._nameMap,
        nameProperty: this._nameProperty
      }
    }).transform({
      type: "lookup",
      options: {
        from: () => {
          var _a2;
          return null === (_a2 = this._data) || void 0 === _a2 ? void 0 : _a2.getLatestData();
        },
        key: DEFAULT_MAP_LOOK_UP_KEY,
        fields: this._nameField,
        set: (feature3, datum) => {
          datum && Object.keys(datum).forEach((key) => {
            key in feature3 || (feature3[key] = datum[key]);
          });
        }
      }
    }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", mapData.reRunAllTransform), this._mapViewData = new SeriesData(this._option, mapData);
  }
  initMark() {
    this._pathMark = this._createMark(_MapSeries.mark.area, {
      morph: shouldMarkDoMorph(this._spec, _MapSeries.mark.area.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this.getDimensionField()[0],
      isSeriesMark: true,
      skipBeforeLayouted: true,
      dataView: this._mapViewData.getDataView(),
      dataProductId: this._mapViewData.getProductId()
    });
  }
  initMarkStyle() {
    const pathMark = this._pathMark;
    pathMark && (this.setMarkStyle(pathMark, {
      fill: (datum) => {
        var _a, _b, _c, _d;
        return isValid_default(datum[null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD]) ? (null !== (_b = this._option.globalScale.getScale("color")) && void 0 !== _b ? _b : this._getDefaultColorScale()).scale(datum[null !== (_c = this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD]) : null === (_d = this._spec) || void 0 === _d ? void 0 : _d.defaultFillColor;
      },
      path: this.getPath.bind(this)
    }, "normal", AttributeLevel.Series), pathMark.setPostProcess("fill", (result2) => isValid_default(result2) ? result2 : this._spec.defaultFillColor), this.setMarkStyle(pathMark, {
      smoothScale: true
    }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(pathMark));
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => this.getDatumName(datum),
      x: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
      },
      y: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
      }
    }));
  }
  initAnimation() {
    var _a;
    this._pathMark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig("area", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new MapSeriesTooltipHelper(this), this._pathMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pathMark);
  }
  getPath(datum) {
    var _a;
    const area2 = this._areaCache.get(datum[DEFAULT_DATA_INDEX]);
    if (area2) return area2.shape;
    const shape = null === (_a = this._coordinateHelper) || void 0 === _a ? void 0 : _a.shape(datum);
    return this._areaCache.set(datum[DEFAULT_DATA_INDEX], {
      shape
    }), shape;
  }
  onEvaluateEnd() {
    this._mapViewData.updateData();
  }
  getDimensionField() {
    return [this.nameField];
  }
  getMeasureField() {
    return [this.valueField];
  }
  release() {
    super.release(), this._areaCache.clear(), this._nameMap = {}, this._trigger = this._mapViewData = null;
  }
  handleZoom(e3) {
    var _a, _b, _c;
    const { scale: scale4, scaleCenter } = e3;
    if (1 === scale4) return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.scale(scale4, scale4, scaleCenter));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
  }
  handlePan(e3) {
    var _a, _b, _c;
    const { delta } = e3;
    if (0 === delta[0] && 0 === delta[1]) return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.translate(delta[0], delta[1]));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
  }
  getDatumCenter(datum) {
    var _a, _b, _c, _d;
    return this._centroidProperty && (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._centroidProperty]) ? null === (_b = datum.properties) || void 0 === _b ? void 0 : _b[this._centroidProperty] : isValidNumber_default(datum.centroidX * datum.centroidY) ? [datum.centroidX, datum.centroidY] : (null === (_c = datum.properties) || void 0 === _c ? void 0 : _c.center) ? datum.properties.center : (null === (_d = datum.properties) || void 0 === _d ? void 0 : _d.centroid) ? datum.properties.centroid : [Number.NaN, Number.NaN];
  }
  getDatumName(datum) {
    var _a, _b, _c, _d;
    return datum[this.nameField] ? datum[this.nameField] : (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._nameProperty]) ? (null === (_b = this._spec) || void 0 === _b ? void 0 : _b.nameMap) ? null !== (_c = this._spec.nameMap[datum.properties[this._nameProperty]]) && void 0 !== _c ? _c : "" : null !== (_d = datum.properties[this._nameProperty]) && void 0 !== _d ? _d : "" : "";
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  viewDataUpdate(d2) {
    var _a, _b, _c;
    super.viewDataUpdate(d2), null === (_b = null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._mapViewData) || void 0 === _c || _c.updateData();
  }
  _getDataIdKey() {
    return DEFAULT_DATA_INDEX;
  }
  getActiveMarks() {
    return [this._pathMark];
  }
};
MapSeries.type = SeriesTypeEnum.map, MapSeries.mark = mapSeriesMark, MapSeries.transformerConstructor = MapSeriesSpecTransformer;
var registerMapSeries = () => {
  registerProjection(), registerGeoCoordinate(), registerPathMark(), Factory2.registerSeries(MapSeries.type, MapSeries), Factory2.registerImplement("registerMap", registerMapSource), Factory2.registerImplement("unregisterMap", unregisterMapSource), registerFadeInOutAnimation();
};

// node_modules/@visactor/vchart/esm/data/transforms/waterfall.js
var waterfall2 = (lastData, op) => {
  if (!lastData || 0 === lastData.length) return lastData;
  const { indexField, valueField, startAs, endAs, total: totalSpec, seriesField, seriesFieldName, groupData: groupData2 } = op, totalData = [], { dimensionValues, dimensionData } = groupData2().latestData, indexValues = Array.from(dimensionValues[indexField]);
  let temp3 = {
    start: 0,
    end: 0,
    lastIndex: null
  };
  return indexValues.forEach((key, index) => {
    const total = {
      start: temp3.end,
      end: temp3.end,
      lastIndex: temp3.lastIndex,
      lastEnd: temp3.end,
      index: key,
      isTotal: false
    };
    dimensionData[key].forEach((d2) => {
      let isTotalTag = false;
      if (totalSpec && "end" !== totalSpec.type) {
        if ("field" === totalSpec.type || "custom" === totalSpec.type) {
          if (d2[totalSpec.tagField]) if (isTotalTag = true, "custom" === totalSpec.type) {
            const { start, end } = totalSpec.product(d2, temp3);
            d2[startAs] = start, d2[endAs] = end, total.end = end, total.start = start;
          } else {
            let start = 0, end = total.end;
            if (totalSpec.collectCountField && !isNil_default(d2[totalSpec.collectCountField])) {
              const startIndex = totalData.length - +d2[totalSpec.collectCountField], endIndex = totalData.length - 1;
              startIndex < 0 ? console.warn("total.collectCountField error") : start = totalData[startIndex].start, endIndex < 0 ? console.warn("total.collectCountField error") : end = totalData[endIndex].end;
            } else totalSpec.startField && !isNil_default(d2[totalSpec.startField]) && (start = +d2[totalSpec.startField]), totalSpec.valueField && !isNil_default(d2[totalSpec.valueField]) && (end = precisionAdd(start, +d2[totalSpec.valueField]));
            d2[startAs] = start, d2[endAs] = end, d2[valueField] = end - start, total.start = start, total.end = end;
          }
        }
      } else index === indexValues.length - 1 && (total.start = 0, d2[startAs] = total.start, d2[endAs] = total.end, isTotalTag = true);
      isTotalTag || (d2[startAs] = +total.end, d2[endAs] = precisionAdd(d2[startAs], +d2[valueField]), total.end = d2[endAs]), total.isTotal = isTotalTag, (isNil_default(seriesField) || seriesField === WaterfallDefaultSeriesField) && (d2[WaterfallDefaultSeriesField] = isTotalTag ? seriesFieldName.total : +d2[valueField] >= 0 ? seriesFieldName.increase : seriesFieldName.decrease);
    }), temp3 = Object.assign(Object.assign({}, total), {
      lastIndex: key
    }), totalData.push(total);
  }), totalData;
};
var waterfallFillTotal = (data, op) => {
  if (!data) return data;
  const { indexField, valueField, total, seriesField } = op, totalData = {
    [indexField]: (null == total ? void 0 : total.text) || "total",
    [valueField]: data.reduce((pre, cur) => precisionAdd(pre, +cur[valueField]), 0)
  };
  return seriesField && (totalData[seriesField] = "total"), data.push(totalData), data;
};

// node_modules/@visactor/vchart/esm/series/waterfall/animation.js
var Appear_FadeIn4 = {
  type: "fadeIn"
};
var Appear_ScaleIn2 = {
  type: "growCenterIn"
};
function waterfallPresetAnimation(params2, preset) {
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn4;
    case "scaleIn":
      return Appear_ScaleIn2;
    default:
      return barGrowIn(params2, false);
  }
}
var registerWaterfallAnimation = () => {
  Factory2.registerAnimation("waterfall", (params2, preset) => ({
    appear: waterfallPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2, false)
  }));
};

// node_modules/@visactor/vchart/esm/mark/rule.js
var RuleMark = class _RuleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RuleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x1: 0,
      y1: 0
    });
  }
};
RuleMark.type = "rule";
var registerRuleMark = () => {
  Factory2.registerMark(RuleMark.type, RuleMark), registerRuleGraphic();
};

// node_modules/@visactor/vchart/esm/data/transforms/dimension-data.js
var dimensionTree = (data, op) => {
  if (!op.fields) return data;
  const dimensionValues = {};
  return {
    dimensionValues,
    dimensionData: groups(data.map((d2) => d2.latestData).flat(), op.fields, dimensionValues)
  };
};
function groups(data, fields2, dimensionValues) {
  if (0 === fields2.length) return data;
  const first = fields2[0], _rest = fields2.slice(1);
  dimensionValues[first] = /* @__PURE__ */ new Set();
  const grouped = groupBy(data, first, dimensionValues[first]);
  return _rest.length ? mapValues(grouped, (value, key) => groups(value, _rest, dimensionValues)) : grouped;
}
function groupBy(data, field5, set2) {
  const groups2 = {};
  return data.forEach((d2) => {
    const key = d2[field5];
    groups2[key] || (groups2[key] = [], set2.add(key)), groups2[key].push(d2);
  }), groups2;
}
function mapValues(target, fn) {
  return Object.keys(target).reduce((result2, key) => (result2[key] = fn(target[key], key), result2), {});
}

// node_modules/@visactor/vchart/esm/series/base/group.js
var Group2 = class {
  get fields() {
    return this._fields;
  }
  get groupData() {
    return this._groupData;
  }
  constructor(fields2) {
    this._fields = [], this._fields = fields2;
  }
  initData(viewData, dataSet) {
    const dataName = viewData.name, groupData2 = new DataView(dataSet instanceof DataSet ? dataSet : viewData.dataSet);
    groupData2.name = dataName, groupData2.parse([viewData], {
      type: "dataview"
    }), registerDataSetInstanceTransform(dataSet, "dimensionTree", dimensionTree), groupData2.transform({
      type: "dimensionTree",
      options: {
        fields: this._fields
      }
    }, false), groupData2.target.addListener("change", this.groupDataUpdate.bind(this)), this._groupData = groupData2;
  }
  groupDataUpdate() {
  }
  getGroupValueInField(field5) {
    var _a, _b, _c;
    const values = null === (_c = null === (_b = null === (_a = this.groupData) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.dimensionValues) || void 0 === _c ? void 0 : _c[field5];
    return values ? Array.from(values) : [];
  }
};

// node_modules/@visactor/vchart/esm/series/waterfall/waterfall-transformer.js
var WaterfallSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar"), this._addMarkLabelSpec(spec, "bar", "stackLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/waterfall/waterfall.js
var WaterfallSeries = class _WaterfallSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.waterfall, this.transformerConstructor = WaterfallSeriesSpecTransformer, this._stack = false, this._leaderLineMark = null, this._stackLabelMark = null, this._labelMark = null;
  }
  getTotalData() {
    var _a;
    return null === (_a = this._totalData) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = new Group2(groupFields), this._data && this._groups.initData(this._data.getDataView(), this._dataSet));
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setValueFieldToStack(), this._fieldX = [this._fieldX[0]], this._fieldY = [this._fieldY[0]], isNil_default(this._seriesField) && (this._seriesField = WaterfallDefaultSeriesField);
  }
  getSeriesKeys() {
    return this._seriesField === WaterfallDefaultSeriesField ? [this._theme.seriesFieldName.increase, this._theme.seriesFieldName.decrease, this._theme.seriesFieldName.total] : super.getSeriesKeys();
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "waterfallFillTotal", waterfallFillTotal), registerDataSetInstanceTransform(this._dataSet, "waterfall", waterfall2), (isNil_default(this._spec.total) || "end" === this._spec.total.type) && (null === (_a = this._rawData) || void 0 === _a || _a.transform({
      type: "waterfallFillTotal",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        total: this._spec.total
      }
    }, false));
    const totalData = dataViewFromDataView(this.getViewData(), this._dataSet, {
      name: `${PREFIX}_series_${this.id}_totalData`
    });
    this.getViewData().target.removeListener("change", totalData.reRunAllTransform), this._totalData = new SeriesData(this._option, totalData), totalData.transform({
      type: "waterfall",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        startAs: STACK_FIELD_START,
        endAs: STACK_FIELD_END,
        total: this._spec.total,
        groupData: () => this.getGroups().groupData
      }
    }, false);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const waterfallAnimationParams = {
      yField: "horizontal" === this.direction ? this._fieldY[0] : this.getStackValueField(),
      xField: "horizontal" === this.direction ? this.getStackValueField() : this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("waterfall")) || void 0 === _c ? void 0 : _c(waterfallAnimationParams, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._leaderLineMark && this._leaderLineMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("leaderLine", this._spec, this._markAttributeContext)));
  }
  viewDataUpdate(d2) {
    this._totalData.getDataView().reRunAllTransform(), this._totalData.updateData(), super.viewDataUpdate(d2);
  }
  addViewDataFilter(_option) {
  }
  reFilterViewData() {
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._totalData.updateData();
  }
  initMark() {
    var _a;
    super.initMark();
    const leaderLine = this._createMark(_WaterfallSeries.mark.leaderLine, {
      key: "index",
      customShape: null === (_a = this._spec.leaderLine) || void 0 === _a ? void 0 : _a.customShape
    });
    leaderLine && (this._leaderLineMark = leaderLine, leaderLine.setDataView(this._totalData.getDataView(), this._totalData.getProductId()));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    if (labelMark) {
      if (!this._labelMark && (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.visible)) return super.initLabelMarkStyle(labelMark), void (this._labelMark = labelMark);
      this._stackLabelMark = labelMark, labelMark.skipEncode = true, labelMark.setRule("stackLabel"), labelMark.setDataView(this._totalData.getDataView(), this._totalData.getProductId()), this.setMarkStyle(labelMark, {
        text: (datum) => {
          var _a2;
          return "absolute" === (null === (_a2 = this._spec.stackLabel) || void 0 === _a2 ? void 0 : _a2.valueType) ? datum.end : precisionSub(datum.end, datum.start);
        }
      });
    }
  }
  totalPositionX(datum, field5, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._xAxisHelper;
    return "vertical" === this._direction ? dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("width", datum) * (0.5 - pos) : valueInScaleRange(dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }));
  }
  totalPositionY(datum, field5, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return "vertical" === this._direction ? valueInScaleRange(dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    })) : dataToPosition([datum[field5]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("height", datum) * (0.5 - pos);
  }
  initMarkStyle() {
    super.initMarkStyle(), this._leaderLineMark && ("vertical" === this._direction ? this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => !isNil_default(datum.lastIndex),
      x: (datum) => datum.lastIndex ? this.totalPositionX(datum, "lastIndex", 1) : 0,
      x1: (datum) => this.totalPositionX(datum, "index", 0),
      y: (datum) => this.totalPositionY(datum, "lastEnd", 0),
      y1: (datum) => this.totalPositionY(datum, datum.isTotal ? "end" : "start", 0)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => !isNil_default(datum.lastIndex),
      x: (datum) => this.totalPositionX(datum, "lastEnd", 0),
      x1: (datum) => this.totalPositionX(datum, datum.isTotal ? "end" : "start", 0),
      y: (datum) => datum.lastIndex ? this.totalPositionY(datum, "lastIndex", 1) : 0,
      y1: (datum) => this.totalPositionY(datum, "index", 0)
    }, "normal", AttributeLevel.Series));
  }
};
WaterfallSeries.type = SeriesTypeEnum.waterfall, WaterfallSeries.mark = waterfallSeriesMark, WaterfallSeries.transformerConstructor = WaterfallSeriesSpecTransformer;
var registerWaterfallSeries = () => {
  registerRuleMark(), registerRectMark(), registerWaterfallAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(WaterfallSeries.type, WaterfallSeries);
};

// node_modules/@visactor/vchart/esm/constant/box-plot.js
var BOX_PLOT_OUTLIER_VALUE_FIELD = `${PREFIX}_BOX_PLOT_OUTLIER_VALUE`;
var BOX_PLOT_TOOLTIP_KEYS;
!function(BOX_PLOT_TOOLTIP_KEYS2) {
  BOX_PLOT_TOOLTIP_KEYS2.OUTLIER = "outlier", BOX_PLOT_TOOLTIP_KEYS2.MAX = "max", BOX_PLOT_TOOLTIP_KEYS2.MIN = "min", BOX_PLOT_TOOLTIP_KEYS2.MEDIAN = "median", BOX_PLOT_TOOLTIP_KEYS2.Q1 = "q1", BOX_PLOT_TOOLTIP_KEYS2.Q3 = "q3", BOX_PLOT_TOOLTIP_KEYS2.SERIES_FIELD = "seriesField";
}(BOX_PLOT_TOOLTIP_KEYS || (BOX_PLOT_TOOLTIP_KEYS = {}));

// node_modules/@visactor/vchart/esm/data/transforms/box-plot.js
var foldOutlierData = (data, op) => {
  const result2 = [], { outliersField, dimensionField } = op;
  return (data[0].latestData || []).forEach((d2) => {
    let outlierValues = d2[outliersField];
    isArray_default(outlierValues) || (outlierValues = [outlierValues]), result2.push(...outlierValues.map((v2) => {
      const resData = {
        [BOX_PLOT_OUTLIER_VALUE_FIELD]: v2
      };
      return dimensionField.forEach((field5) => {
        resData[field5] = d2[field5];
      }), resData;
    }));
  }), result2;
};

// node_modules/@visactor/vchart/esm/series/box-plot/tooltip-helper.js
var BoxPlotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.getContentKey = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER) return this.series.getOutliersField();
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return this.series.getSeriesField();
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return this.series.getMinField();
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return this.series.getMaxField();
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return this.series.getMedianField();
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return this.series.getQ1Field();
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return this.series.getQ3Field();
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return this.series.getSeriesField();
      }
      return null;
    }, this.getContentValue = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER) return datum[BOX_PLOT_OUTLIER_VALUE_FIELD];
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return datum[this.series.getSeriesField()];
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return datum[this.series.getMinField()];
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return datum[this.series.getMaxField()];
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return datum[this.series.getMedianField()];
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return datum[this.series.getQ1Field()];
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return datum[this.series.getQ3Field()];
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return datum[this.series.getSeriesField()];
      }
      return null;
    }, this.contentShapeColorCallback = (datum) => "line" === this.series.getShaftShape() ? this.series.getMarkInName("boxPlot").getAttribute("stroke", datum) : this.series.getMarkInName("boxPlot").getAttribute("fill", datum), this.getOutlierFillColor = (datum) => {
      var _a;
      const outliersStyle = this.series.getOutliersStyle();
      return null !== (_a = null == outliersStyle ? void 0 : outliersStyle.fill) && void 0 !== _a ? _a : this.series.getMarkInName("outlier").getAttribute("fill", datum);
    }, this.isOutlierMark = (datum) => isValid_default(datum[BOX_PLOT_OUTLIER_VALUE_FIELD]);
  }
  getDefaultTooltipPattern(activeType) {
    return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.titleValueCallback,
        hasShape: false
      },
      content: [{
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.getOutlierFillColor,
        shapeStroke: this.getOutlierFillColor,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MAX),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MAX),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q3),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q3),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MEDIAN),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MEDIAN),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q1),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q1),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MIN),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MIN),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD),
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }]
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/box-plot.js
var BoxPlotMark = class _BoxPlotMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _BoxPlotMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 2,
      boxWidth: 30,
      shaftWidth: 20,
      shaftShape: "line"
    });
  }
  _initProduct(group) {
    const shaftShape = this.getStyle("shaftShape"), view = this.getVGrammarView(), id2 = this.getProductId(), glyphType = "bar" === shaftShape ? "barBoxplot" : "boxplot", direction2 = this.getStyle("direction");
    this._product = view.glyph(glyphType, null != group ? group : view.rootMark).id(id2).configureGlyph({
      direction: direction2
    }), this._compiledProductId = id2;
  }
};
BoxPlotMark.type = "boxPlot";
var registerBoxPlotMark = () => {
  Factory2.registerMark(BoxPlotMark.type, BoxPlotMark), registerBoxplotGlyph(), registerBarBoxplotGlyph();
};

// node_modules/@visactor/vchart/esm/series/box-plot/box-plot.js
var BoxPlotSeries = class _BoxPlotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.boxPlot;
  }
  getMinField() {
    return this._minField;
  }
  getMaxField() {
    return this._maxField;
  }
  getQ1Field() {
    return this._q1Field;
  }
  getMedianField() {
    return this._medianField;
  }
  getQ3Field() {
    return this._q3Field;
  }
  getOutliersField() {
    return this._outliersField;
  }
  getShaftShape() {
    return this._shaftShape;
  }
  getBoxFillColor() {
    return this._boxFillColor;
  }
  getStrokeColor() {
    return this._strokeColor;
  }
  getOutliersStyle() {
    return this._outliersStyle;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec();
    const boxPlotStyle = null !== (_b = null === (_a = this._spec.boxPlot) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this._minField = this._spec.minField, this._maxField = this._spec.maxField, this._q1Field = this._spec.q1Field, this._medianField = this._spec.medianField, this._q3Field = this._spec.q3Field, this._outliersField = this._spec.outliersField, this._lineWidth = null !== (_c = boxPlotStyle.lineWidth) && void 0 !== _c ? _c : 2, this._boxWidth = boxPlotStyle.boxWidth, this._shaftShape = null !== (_d = boxPlotStyle.shaftShape) && void 0 !== _d ? _d : "line", this._shaftWidth = boxPlotStyle.shaftWidth, this._boxFillColor = boxPlotStyle.boxFill, this._strokeColor = boxPlotStyle.stroke, this._shaftFillOpacity = "bar" === this._shaftShape ? null !== (_e = boxPlotStyle.shaftFillOpacity) && void 0 !== _e ? _e : 0.5 : void 0, this._outliersStyle = this._spec.outliersStyle;
  }
  initMark() {
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._boxPlotMark = this._createMark(_BoxPlotSeries.mark.boxPlot, {
      isSeriesMark: true,
      progressive
    }), this._outlierMark = this._createMark(_BoxPlotSeries.mark.outlier, {
      progressive,
      key: DEFAULT_DATA_INDEX,
      dataView: this._outlierDataView.getDataView(),
      dataProductId: this._outlierDataView.getProductId()
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const boxPlotMark = this._boxPlotMark;
    if (boxPlotMark) {
      const commonBoxplotStyles = {
        direction: this._direction,
        lineWidth: this._lineWidth,
        shaftShape: this._shaftShape,
        fill: null !== (_a = this._boxFillColor) && void 0 !== _a ? _a : "line" === this._shaftShape ? "#FFF" : this.getColorAttribute(),
        minMaxFillOpacity: this._shaftFillOpacity,
        stroke: null !== (_b = this._strokeColor) && void 0 !== _b ? _b : "line" === this._shaftShape ? this.getColorAttribute() : "#000"
      }, boxPlotMarkStyles = "vertical" === this._direction ? Object.assign(Object.assign({
        x: this.dataToPositionX.bind(this)
      }, commonBoxplotStyles), {
        boxWidth: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Width: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      }) : Object.assign(Object.assign({
        y: this.dataToPositionY.bind(this)
      }, commonBoxplotStyles), {
        boxHeight: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Height: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      });
      this.setMarkStyle(boxPlotMark, boxPlotMarkStyles, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(boxPlotMark);
    }
    const outlierMark = this._outlierMark;
    outlierMark && (this.setMarkStyle(outlierMark, {
      fill: null !== (_d = null === (_c = this._outliersStyle) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : this.getColorAttribute(),
      size: isNumber_default(null === (_e = this._outliersStyle) || void 0 === _e ? void 0 : _e.size) ? this._outliersStyle.size : 10,
      symbolType: "circle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(outlierMark));
  }
  initBoxPlotMarkStyle() {
    var _a, _b;
    const boxPlotMark = this._boxPlotMark, axisHelper = "vertical" === this._direction ? this._yAxisHelper : this._xAxisHelper;
    if (boxPlotMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_a = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _a ? void 0 : _a.call(axisHelper, 0);
      this.setMarkStyle(boxPlotMark, {
        min: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._minField), {
          bandPosition: this._bandPosition
        }), scale4),
        q1: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q1Field), {
          bandPosition: this._bandPosition
        }), scale4),
        median: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._medianField), {
          bandPosition: this._bandPosition
        }), scale4),
        q3: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q3Field), {
          bandPosition: this._bandPosition
        }), scale4),
        max: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._maxField), {
          bandPosition: this._bandPosition
        }), scale4)
      }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    const outlierMark = this._outlierMark;
    if (outlierMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_b = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _b ? void 0 : _b.call(axisHelper, 0), outlierMarkPositionChannel = "vertical" === this._direction ? {
        x: this.dataToPositionX.bind(this),
        y: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      } : {
        y: this.dataToPositionY.bind(this),
        x: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      };
      this.setMarkStyle(outlierMark, outlierMarkPositionChannel, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
  }
  initData() {
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "foldOutlierData", foldOutlierData), registerDataSetInstanceTransform(this._dataSet, "addVChartProperty", addVChartProperty);
    const outlierDataView = new DataView(this._dataSet, {
      name: `${this.type}_outlier_${this.id}_data`
    });
    outlierDataView.parse([this.getViewData()], {
      type: "dataview"
    }), outlierDataView.name = `${PREFIX}_series_${this.id}_outlierData`, outlierDataView.transform({
      type: "foldOutlierData",
      options: {
        dimensionField: "vertical" === this._direction ? this._fieldX : this._fieldY,
        outliersField: this._outliersField
      }
    }), outlierDataView.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false), this._outlierDataView = new SeriesData(this._option, outlierDataView);
  }
  init(option) {
    super.init(option), this.initBoxPlotMarkStyle();
  }
  _getMarkWidth() {
    if (this._autoBoxWidth) return this._autoBoxWidth;
    const bandAxisHelper = "vertical" === this._direction ? this._xAxisHelper : this._yAxisHelper, xField = "vertical" === this._direction ? this._fieldX : this._fieldY, autoBoxWidth = bandAxisHelper.getBandwidth(xField.length - 1) / xField.length;
    return this._autoBoxWidth = autoBoxWidth, this._autoBoxWidth;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._autoBoxWidth = null;
  }
  _initAnimationSpec(config2 = {}) {
    const newConfig = merge({}, config2);
    return ["appear", "enter", "update", "exit", "disappear"].forEach((state) => {
      newConfig[state] && "scaleIn" === newConfig[state].type ? newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleIn" : "barBoxplotScaleIn" : newConfig[state] && "scaleOut" === newConfig[state].type && (newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleOut" : "barBoxplotScaleOut");
    }), newConfig;
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const animationParams = getGroupAnimationParams(this);
    if (this._boxPlotMark) {
      const newDefaultConfig = this._initAnimationSpec(null === (_a = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a ? void 0 : _a()), newConfig = this._initAnimationSpec(userAnimationConfig("boxPlot", this._spec, this._markAttributeContext));
      this._boxPlotMark.setAnimationConfig(animationConfig(newDefaultConfig, newConfig, animationParams));
    }
    if (this._outlierMark) {
      const outlierMarkUserAnimation = {
        appear: null === (_b = this._spec.animationAppear) || void 0 === _b ? void 0 : _b.symbol,
        disappear: null === (_c = this._spec.animationDisappear) || void 0 === _c ? void 0 : _c.symbol,
        enter: null === (_d = this._spec.animationEnter) || void 0 === _d ? void 0 : _d.symbol,
        exit: null === (_e = this._spec.animationExit) || void 0 === _e ? void 0 : _e.symbol,
        update: null === (_f = this._spec.animationUpdate) || void 0 === _f ? void 0 : _f.symbol
      };
      this._outlierMark.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _g ? void 0 : _g(), outlierMarkUserAnimation, animationParams));
    }
  }
  initTooltip() {
    this._tooltipHelper = new BoxPlotSeriesTooltipHelper(this), this._boxPlotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._boxPlotMark), this._outlierMark && this._tooltipHelper.activeTriggerSet.mark.add(this._outlierMark);
  }
  getStatisticFields() {
    const fields2 = super.getStatisticFields(), outliersField = fields2.find((f2) => f2.key === this._outliersField);
    return outliersField && (outliersField.operations = ["array-min", "array-max"]), fields2;
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._outlierDataView.updateData();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._boxPlotMark];
  }
};
BoxPlotSeries.type = SeriesTypeEnum.boxPlot, BoxPlotSeries.mark = boxPlotSeriesMark;
var registerBoxplotSeries = () => {
  registerBoxPlotMark(), registerSymbolMark(), registerScaleInOutAnimation(), Factory2.registerSeries(BoxPlotSeries.type, BoxPlotSeries);
};

// node_modules/@visactor/vchart/esm/mark/text.js
var TextMark = class _TextMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _TextMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      angle: 0,
      textAlign: "center",
      lineWidth: 0,
      textConfig: []
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    "rich" === this.getStyle("textType") ? this._product = view.mark(GrammarMarkType.richtext, null != group ? group : view.rootMark).id(id2) : this._product = view.mark(GrammarMarkType.text, null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
};
TextMark.type = "text";
var registerTextMark = () => {
  Factory2.registerMark(TextMark.type, TextMark), registerTextGraphic2(), registerRichTextGraphic();
};

// node_modules/@visactor/vchart/esm/series/util/label-mark.js
function setRectLabelPos(component2, labelMark, position, offset, x3, x14, y3, y14, direction2) {
  component2.setMarkStyle(labelMark, {
    textAlign: (datum) => {
      if ("vertical" === direction2()) return "center";
      const _x = x3(datum), _x1 = x14(datum);
      if ("middle" === position) return "center";
      if (_x >= _x1) {
        if ("start" === position) return "left";
        if ("end" === position) return "right";
        if ("outside" === position) return "left";
      } else {
        if ("start" === position) return "right";
        if ("end" === position) return "left";
        if ("outside" === position) return "right";
      }
      return "center";
    },
    textBaseline: (datum) => {
      if ("horizontal" === direction2()) return "middle";
      const _y = y3(datum), _y1 = y14(datum);
      if ("middle" === position) return "middle";
      if (_y1 >= _y) {
        if ("start" === position) return "bottom";
        if ("end" === position) return "top";
        if ("outside" === position) return "bottom";
      } else {
        if ("start" === position) return "top";
        if ("end" === position) return "bottom";
        if ("outside" === position) return "top";
      }
      return "middle";
    }
  }), component2.setMarkStyle(labelMark, {
    x: (datum) => {
      const d2 = direction2(), _x = x3(datum), _x1 = x14(datum);
      if ("vertical" === d2) return (_x + _x1) / 2;
      if ("middle" === position) return (_x + _x1) / 2;
      if (_x >= _x1) {
        if ("start" === position) return _x1 + offset;
        if ("end" === position) return _x - offset;
        if ("outside" === position) return _x + offset;
      } else {
        if ("start" === position) return _x1 - offset;
        if ("end" === position) return _x + offset;
        if ("outside" === position) return _x - offset;
      }
      return (_x + _x1) / 2;
    },
    y: (datum) => {
      const d2 = direction2(), _y = y3(datum), _y1 = y14(datum);
      if ("horizontal" === d2) return (_y + _y1) / 2;
      if ("middle" === position) return (_y + _y1) / 2;
      if (_y >= _y1) {
        if ("start" === position) return _y1 + offset;
        if ("end" === position) return _y - offset;
        if ("outside" === position) return _y + offset;
      } else {
        if ("start" === position) return _y1 - offset;
        if ("end" === position) return _y + offset;
        if ("outside" === position) return _y - offset;
      }
      return (_y + _y1) / 2;
    }
  }, "normal", AttributeLevel.Series);
}

// node_modules/@visactor/vchart/esm/series/range-column/tooltip-helper.js
var RangeColumnSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType) {
    return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.titleValueCallback,
        hasShape: false
      },
      content: [{
        key: this.contentKeyCallback,
        value: (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]],
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }]
    };
  }
};

// node_modules/@visactor/vchart/esm/series/range-column/animation.js
var rangeColumnGrowIn = (params2) => ({
  type: "growCenterIn",
  options: {
    direction: "horizontal" === params2.direction ? "x" : "y"
  }
});
var Appear_FadeIn5 = {
  type: "fadeIn"
};
var rangeColumnGrowOut = (params2) => ({
  type: "growCenterOut",
  options: {
    direction: "horizontal" === params2.direction ? "x" : "y"
  }
});
function rangeColumnPresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn5 : rangeColumnGrowIn(params2);
}
var registerRangeColumnAnimation = () => {
  Factory2.registerAnimation("rangeColumn", (params2, preset) => ({
    appear: rangeColumnPresetAnimation(params2, preset),
    enter: rangeColumnGrowIn(params2),
    exit: rangeColumnGrowOut(params2),
    disappear: rangeColumnGrowOut(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/range-column/range-column-transformer.js
var RangeColumnSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    var _a;
    "bothEnd" !== (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.position) && this._addMarkLabelSpec(spec, "bar");
  }
};

// node_modules/@visactor/vchart/esm/series/range-column/range-column.js
var RangeColumnSeries = class _RangeColumnSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn, this._barMarkType = "rect", this._barName = SeriesTypeEnum.bar, this.transformerConstructor = RangeColumnSeriesSpecTransformer, this._stack = false;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    this._initBarBackgroundMark();
    const labelPosition = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position;
    this._barMark = this._createMark(_RangeColumnSeries.mark.bar, {
      morph: shouldMarkDoMorph(this._spec, _RangeColumnSeries.mark.bar.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.customShape
    }), false !== (null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.visible) && "bothEnd" === labelPosition && (false !== (null === (_e = null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.minLabel) || void 0 === _e ? void 0 : _e.visible) && (this._minLabelMark = this._createMark(_RangeColumnSeries.mark.minLabel, {
      markSpec: null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.minLabel
    })), false !== (null === (_h = null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.maxLabel) || void 0 === _h ? void 0 : _h.visible) && (this._maxLabelMark = this._createMark(_RangeColumnSeries.mark.maxLabel, {
      markSpec: null === (_j = this._spec.label) || void 0 === _j ? void 0 : _j.maxLabel
    })));
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.initMarkStyle();
    const minLabelMark = this._minLabelMark, minLabelSpec = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.minLabel;
    if (minLabelMark) {
      this.setMarkStyle(minLabelMark, {
        fill: null !== (_c = null === (_b = null == minLabelSpec ? void 0 : minLabelSpec.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
        text: (datum) => {
          const min4 = "horizontal" === this._spec.direction ? datum[this._spec.xField[0]] : datum[this._spec.yField[0]];
          return (null == minLabelSpec ? void 0 : minLabelSpec.formatMethod) ? minLabelSpec.formatMethod(min4, datum) : min4;
        }
      });
      const position = null !== (_d = null == minLabelSpec ? void 0 : minLabelSpec.position) && void 0 !== _d ? _d : "end", offset = null !== (_e = null == minLabelSpec ? void 0 : minLabelSpec.offset) && void 0 !== _e ? _e : "vertical" === this._direction ? -20 : -25;
      setRectLabelPos(this, minLabelMark, position, offset, (datum) => this._barMark.getAttribute("x", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum), (datum) => this._barMark.getAttribute("y", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum), () => this._direction);
    }
    const maxLabelMark = this._maxLabelMark, maxLabelSpec = null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.maxLabel;
    if (maxLabelMark) {
      this.setMarkStyle(maxLabelMark, {
        fill: null !== (_h = null === (_g = null == maxLabelSpec ? void 0 : maxLabelSpec.style) || void 0 === _g ? void 0 : _g.fill) && void 0 !== _h ? _h : this.getColorAttribute(),
        text: (datum) => {
          const max4 = "horizontal" === this._spec.direction ? datum[this._spec.xField[1]] : datum[this._spec.yField[1]];
          return (null == maxLabelSpec ? void 0 : maxLabelSpec.formatMethod) ? maxLabelSpec.formatMethod(max4, datum) : max4;
        }
      });
      const position = null !== (_j = null == maxLabelSpec ? void 0 : maxLabelSpec.position) && void 0 !== _j ? _j : "start", offset = null !== (_k = null == maxLabelSpec ? void 0 : maxLabelSpec.offset) && void 0 !== _k ? _k : "vertical" === this._direction ? -20 : -25;
      setRectLabelPos(this, maxLabelMark, position, offset, (datum) => this._barMark.getAttribute("x", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum), (datum) => this._barMark.getAttribute("y", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum), () => this._direction);
    }
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this.setMarkStyle(labelMark, {
      text: (datum) => {
        let min4, max4;
        return "horizontal" === this._spec.direction ? (min4 = datum[this._spec.xField[0]], max4 = datum[this._spec.xField[1]]) : (min4 = datum[this._spec.yField[0]], max4 = datum[this._spec.yField[1]]), min4 + "-" + max4;
      },
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), this._labelMark = labelMark);
  }
  _dataToPosX(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosX1(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY1(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
      bandPosition: this._bandPosition
    });
  }
  initAnimation() {
    var _a, _b, _c, _d, _e;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rangeColumn")) || void 0 === _c ? void 0 : _c({
      direction: this.direction
    }, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._minLabelMark && this._minLabelMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams)), this._maxLabelMark && this._maxLabelMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams));
  }
  initTooltip() {
    this._tooltipHelper = new RangeColumnSeriesTooltipHelper(this), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark), this._minLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._minLabelMark), this._maxLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._maxLabelMark), this._labelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._labelMark);
  }
};
RangeColumnSeries.type = SeriesTypeEnum.rangeColumn, RangeColumnSeries.mark = rangeColumnSeriesMark, RangeColumnSeries.transformerConstructor = RangeColumnSeriesSpecTransformer;
var registerRangeColumnSeries = () => {
  registerRectMark(), registerTextMark(), registerRangeColumnAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(RangeColumnSeries.type, RangeColumnSeries);
};

// node_modules/@visactor/vchart/esm/series/range-column/3d/range-column-3d.js
var RangeColumn3dSeries = class extends RangeColumnSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn3d, this._barMarkType = "rect3d", this._barName = SeriesTypeEnum.bar3d;
  }
};
RangeColumn3dSeries.type = SeriesTypeEnum.rangeColumn3d, RangeColumn3dSeries.mark = rangeColumn3dSeriesMark;
var registerRangeColumn3dSeries = () => {
  registerRect3dMark(), Factory2.registerSeries(RangeColumn3dSeries.type, RangeColumn3dSeries);
};

// node_modules/@visactor/vchart/esm/series/range-area/tooltip-helper.js
var RangeAreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    if ("mark" === activeType) return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.titleValueCallback,
        hasShape: false
      },
      content: [{
        key: this.contentKeyCallback,
        value: this.contentValueCallback,
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }]
    };
    if ("dimension" === activeType && dimensionInfo) {
      const title3 = {
        key: void 0,
        value: this._getDimensionData,
        hasShape: false
      }, content = [];
      return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
        "rangeArea" === series2.type && content.push({
          seriesId: series2.id,
          key: this.contentKeyCallback,
          value: (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]],
          hasShape: true,
          shapeType: this.contentShapeTypeCallback,
          shapeColor: this.contentShapeColorCallback,
          shapeStroke: this.contentShapeColorCallback,
          shapeHollow: false
        });
      })), {
        visible: true,
        activeType,
        title: title3,
        content
      };
    }
    return null;
  }
};

// node_modules/@visactor/vchart/esm/series/range-area/range-area.js
var RangeAreaSeries = class _RangeAreaSeries extends AreaSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeArea;
  }
  initMark() {
    var _a;
    this._areaMark = this._createMark(_RangeAreaSeries.mark.area, {
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "vertical" === this._direction ? "monotoneX" : "monotoneY" : userCurveType, areaMark = this._areaMark;
    areaMark && ("vertical" === this._direction ? this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      y1: (datum) => {
        if (!this._yAxisHelper) return Number.NaN;
        const { dataToPosition } = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
          bandPosition: this._bandPosition
        });
      },
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      x1: (datum) => {
        if (!this._xAxisHelper) return Number.NaN;
        const { dataToPosition } = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
          bandPosition: this._bandPosition
        });
      },
      y: this.dataToPositionY.bind(this),
      orient: this._direction
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      fill: this.getColorAttribute(),
      stroke: false
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined,
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      curveType
    }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(areaMark));
  }
  initTooltip() {
    this._tooltipHelper = new RangeAreaSeriesTooltipHelper(this), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark);
  }
  viewDataStatisticsUpdate(d2) {
    super.viewDataStatisticsUpdate(d2), this.encodeDefined(this._areaMark, "defined");
  }
};
RangeAreaSeries.type = SeriesTypeEnum.rangeArea, RangeAreaSeries.mark = rangeAreaSeriesMark;
var registerRangeAreaSeries = () => {
  registerAreaMark(), Factory2.registerSeries(RangeAreaSeries.type, RangeAreaSeries);
};

// node_modules/@visactor/vchart/esm/series/polar/polar.js
var PolarSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "polar", this._outerRadius = POLAR_DEFAULT_RADIUS, this._innerRadius = 0, this._angleField = [], this._radiusField = [], this._sortDataByAxis = false, this._getInvalidDefined = (datum) => !(this.angleAxisHelper.isContinuous && !couldBeValidNumber(datum[this._angleField[0]])) && !(this.radiusAxisHelper.isContinuous && !couldBeValidNumber(datum[this._radiusField[0]]));
  }
  get outerRadius() {
    return this._outerRadius;
  }
  get innerRadius() {
    return this._innerRadius;
  }
  getAngleField() {
    return this._angleField;
  }
  setAngleField(f2) {
    return this._angleField = isValid_default(f2) ? array(f2) : [], this._angleField;
  }
  getRadiusField() {
    return this._radiusField;
  }
  setRadiusField(f2) {
    return this._radiusField = isValid_default(f2) ? array(f2) : [], this._radiusField;
  }
  get innerRadiusField() {
    return this._innerRadiusField;
  }
  setInnerRadiusField(f2) {
    return this._innerRadiusField = array(f2), this._innerRadiusField;
  }
  get radiusScale() {
    return this._radiusScale;
  }
  setRadiusScale(s3) {
    return this._radiusScale = s3, s3;
  }
  get angleScale() {
    return this._angleScale;
  }
  setAngleScale(s3) {
    return this._angleScale = s3, s3;
  }
  get angleAxisHelper() {
    return this._angleAxisHelper;
  }
  set angleAxisHelper(h2) {
    this._angleAxisHelper = h2, this.onAngleAxisHelperUpdate();
  }
  get radiusAxisHelper() {
    return this._radiusAxisHelper;
  }
  set radiusAxisHelper(h2) {
    this._radiusAxisHelper = h2, this.onRadiusAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this), this._markAttributeContext.getCenter = () => this.angleAxisHelper.center(), this._markAttributeContext.getLayoutRadius = () => this._computeLayoutRadius();
  }
  valueToPosition(angleValue, radiusValue) {
    if (isNil_default(angleValue) || isNil_default(radiusValue) || !this.angleAxisHelper || !this.radiusAxisHelper) return {
      x: Number.NaN,
      y: Number.NaN
    };
    const angle2 = this.angleAxisHelper.dataToPosition(array(angleValue)), radius = this.radiusAxisHelper.dataToPosition(array(radiusValue));
    return this.angleAxisHelper.coordToPoint({
      angle: angle2,
      radius
    });
  }
  dataToPosition(datum) {
    return datum && this.angleAxisHelper && this.radiusAxisHelper ? this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getDatumPositionValues(datum, this._radiusField)) : {
      x: Number.NaN,
      y: Number.NaN
    };
  }
  dataToPositionX(datum) {
    return this.dataToPosition(datum).x;
  }
  dataToPositionY(datum) {
    return this.dataToPosition(datum).y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  positionToData(p2) {
  }
  radiusToData(r2) {
  }
  angleToData(a4) {
  }
  getStatisticFields() {
    var _a, _b;
    const fields2 = [];
    return (null === (_a = this.radiusAxisHelper) || void 0 === _a ? void 0 : _a.getScale) && this._radiusField.forEach((f2) => {
      const result2 = {
        key: f2,
        operations: []
      };
      isContinuous(this.radiusAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), (null === (_b = this.angleAxisHelper) || void 0 === _b ? void 0 : _b.getScale) && this._angleField.forEach((f2) => {
      const result2 = {
        key: f2,
        operations: []
      };
      isContinuous(this.angleAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), fields2;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isValid_default(this._spec.outerRadius) && (this._outerRadius = this._spec.outerRadius), isValid_default(this._spec.radius) && (this._outerRadius = this._spec.radius), isValid_default(this._spec.innerRadius) && (this._innerRadius = this._spec.innerRadius), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  onRadiusAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onAngleAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  afterInitMark() {
    super.afterInitMark(), this._trigger.setStateKeys([...this._angleField, ...this._radiusField]);
  }
  _computeLayoutRadius() {
    const { width, height } = this._region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  fillData() {
    super.fillData(), this.sortDataByAxis && this._sortDataInAxisDomain();
  }
  _sortDataInAxisDomain() {
    var _a, _b;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && sortDataInAxisHelper(this.angleAxisHelper, this._angleField[0], this.getViewData().latestData);
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/pie.js
function transformInvalidValue(value) {
  return couldBeValidNumber(value) ? Number.parseFloat(value) : 0;
}
var pie2 = (originData, op) => {
  const data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length) return data;
  const { angleField, startAngle, endAngle, minAngle, asStartAngle, asEndAngle, asMiddleAngle, asRadian, asRatio, asQuadrant, asK } = op, appendArcInfo = (data2, startAngle2, angle2) => {
    data2[asStartAngle] = startAngle2, data2[asEndAngle] = startAngle2 + angle2, data2[asMiddleAngle] = startAngle2 + angle2 / 2, data2[asRadian] = angle2, data2[asQuadrant] = computeQuadrant(startAngle2 + angle2 / 2);
  };
  let total = 0, max4 = -1 / 0;
  for (let index = 0; index < data.length; index++) {
    const angleFieldValue = transformInvalidValue(data[index][angleField]);
    total += angleFieldValue, max4 = Math.max(angleFieldValue, max4), data[index][ARC_TRANSFORM_VALUE] = angleFieldValue;
  }
  const angleRange = endAngle - startAngle;
  let lastAngle = startAngle, restAngle = angleRange, largeThanMinAngleTotal = 0;
  if (data.forEach((d2) => {
    const angleFieldValue = d2[ARC_TRANSFORM_VALUE], ratio = total ? angleFieldValue / total : 0;
    let radian = ratio * angleRange;
    radian < minAngle ? (radian = minAngle, restAngle -= minAngle) : largeThanMinAngleTotal += angleFieldValue;
    const dStartAngle = lastAngle, dEndAngle = lastAngle + radian;
    d2[asRatio] = ratio, d2[asK] = max4 ? angleFieldValue / max4 : 0, appendArcInfo(d2, dStartAngle, radian), lastAngle = dEndAngle;
  }), restAngle < angleRange) if (restAngle <= 1e-3) {
    const angle2 = angleRange / data.length;
    data.forEach((d2, index) => {
      appendArcInfo(d2, startAngle + index * angle2, angle2);
    });
  } else {
    const unitRadian = restAngle / largeThanMinAngleTotal;
    lastAngle = startAngle, data.forEach((d2) => {
      const angle2 = d2[asRadian] === minAngle ? minAngle : d2[ARC_TRANSFORM_VALUE] * unitRadian;
      appendArcInfo(d2, lastAngle, angle2), lastAngle += angle2;
    });
  }
  return 0 !== total && (data[data.length - 1][asEndAngle] = endAngle), data;
};

// node_modules/@visactor/vchart/esm/series/pie/animation/animation.js
function pieGrowOption(pieParams, isOverall, state) {
  return (datum, element, params2) => isOverall ? "radius" === pieParams.growField ? {
    overall: 0
  } : {
    overall: pieParams.growFrom(datum, element, state)
  } : {
    overall: false
  };
}
var Appear_Grow3 = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  options: pieGrowOption(params2, true, AnimationStateEnum.appear)
});
var Appear_FadeIn6 = {
  type: "fadeIn"
};
var pieEnter = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.enter)
});
var pieExit = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
var pieDisappear = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
function piePresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn6;
    case "growRadius":
      return Appear_Grow3(Object.assign(Object.assign({}, params2), {
        growField: "radius"
      }));
    default:
      return Appear_Grow3(Object.assign(Object.assign({}, params2), {
        growField: "angle"
      }));
  }
}
var registerPieAnimation = () => {
  Factory2.registerAnimation("pie", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset),
    enter: pieEnter(params2),
    exit: pieExit(params2),
    disappear: pieDisappear(params2)
  }));
};
var registerPie3dAnimation = () => {
  Factory2.registerAnimation("pie3d", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset),
    enter: pieEnter(params2),
    exit: pieExit(params2),
    disappear: pieDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/pie/animation/centerOffset.js
function centerOffsetConfig(mark, originalConfig) {
  var _a, _b, _c, _d;
  const offset = null !== (_b = null === (_a = originalConfig.options) || void 0 === _a ? void 0 : _a.distance) && void 0 !== _b ? _b : 10, duration = isValidNumber_default(originalConfig.duration) ? originalConfig.duration / 2 : 1e3, easing = null !== (_c = originalConfig.options.easing) && void 0 !== _c ? _c : "cubicOut";
  return {
    oneByOne: originalConfig.oneByOne,
    loop: null !== (_d = originalConfig.loop) && void 0 !== _d && _d,
    timeSlices: [{
      duration,
      effects: {
        easing,
        channel: {
          x: {
            from: (datum) => mark.getAttribute("x", datum),
            to: (datum) => mark.getAttribute("x", datum) + polarToCartesian2({
              angle: datum[ARC_MIDDLE_ANGLE],
              radius: offset
            }).x
          },
          y: {
            from: (datum) => mark.getAttribute("y", datum),
            to: (datum) => mark.getAttribute("y", datum) + polarToCartesian2({
              angle: datum[ARC_MIDDLE_ANGLE],
              radius: offset
            }).y
          }
        }
      }
    }, {
      duration,
      effects: {
        easing,
        channel: {
          x: {
            to: (datum) => mark.getAttribute("x", datum),
            from: (datum) => mark.getAttribute("x", datum) + polarToCartesian2({
              angle: datum[ARC_MIDDLE_ANGLE],
              radius: offset
            }).x
          },
          y: {
            to: (datum) => mark.getAttribute("y", datum),
            from: (datum) => mark.getAttribute("y", datum) + polarToCartesian2({
              angle: datum[ARC_MIDDLE_ANGLE],
              radius: offset
            }).y
          }
        }
      }
    }]
  };
}

// node_modules/@visactor/vchart/esm/mark/arc.js
var BaseArcMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = ArcMark.type, this._unCompileChannel = {
      centerOffset: true,
      radiusOffset: true
    }, this.computeOuterRadius = (key, datum, states = "normal", opt, superValue) => {
      var _a;
      return superValue + (null !== (_a = this.getAttribute("radiusOffset", datum, states, opt)) && void 0 !== _a ? _a : 0);
    }, this.computeCenter = (key, datum, states = "normal", opt, center2) => center2 + polarToCartesian2({
      angle: datum[ARC_MIDDLE_ANGLE],
      radius: this.getAttribute("centerOffset", datum, states, opt)
    })[key], this._computeExChannel.x = this.computeCenter, this._computeExChannel.y = this.computeCenter, this._computeExChannel.outerRadius = this.computeOuterRadius, this._extensionChannel.centerOffset = ["x", "y"], this._extensionChannel.radiusOffset = ["outerRadius"];
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      startAngle: 0,
      endAngle: 0,
      outerRadius: 0,
      innerRadius: 0,
      cornerRadius: 0,
      lineWidth: 0
    });
  }
};
var ArcMark = class _ArcMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _ArcMark.type;
  }
};
ArcMark.type = "arc";
var registerArcMark = () => {
  registerArcGraphic2(), registerVGrammarArcAnimation(), Factory2.registerMark(ArcMark.type, ArcMark);
};

// node_modules/@visactor/vchart/esm/series/pie/pie-transformer.js
var PieSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie");
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec);
      newSpec = mergeSpec({}, this._theme, specFromChart, spec), "inside" === newSpec.label.position ? newSpec.label = mergeSpec({}, this._theme.innerLabel, newSpec.label) : newSpec.label = mergeSpec({}, this._theme.outerLabel, newSpec.label);
    }
    return {
      spec: newSpec,
      theme: theme2
    };
  }
};

// node_modules/@visactor/vchart/esm/series/pie/pie.js
var BasePieSeries = class _BasePieSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.transformerConstructor = PieSeriesSpecTransformer, this._pieMarkName = "pie", this._pieMarkType = "arc", this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._pieMark = null, this._labelMark = null, this._labelLineMark = null, this.dataToCentralPosition = (datum) => {
      const angle2 = datum[ARC_MIDDLE_ANGLE];
      if (isNil_default(angle2)) return null;
      const radius = this.computeDatumRadius(datum), innerRadius = this.computeDatumInnerRadius(datum), center2 = this.computeCenter(datum), delta = polarToCartesian2({
        angle: angle2,
        radius: (radius + innerRadius) / 2
      });
      return {
        x: center2.x + delta.x,
        y: center2.y + delta.y
      };
    };
  }
  get center() {
    var _a, _b, _c, _d;
    return {
      x: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerX) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2,
      y: null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.centerY) && void 0 !== _d ? _d : this._region.getLayoutRect().height / 2
    };
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => {
        var _a, _b;
        return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
      },
      y: () => {
        var _a, _b;
        return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
      }
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._centerOffset = null !== (_a = this._spec.centerOffset) && void 0 !== _a ? _a : 0, this._cornerRadius = null !== (_b = this._spec.cornerRadius) && void 0 !== _b ? _b : 0;
    const normalized = normalizeStartEndAngle(isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : this._startAngle, isValid_default(this._spec.endAngle) ? degreeToRadian(this._spec.endAngle) : this._endAngle);
    this._startAngle = normalized.startAngle, this._endAngle = normalized.endAngle, this._padAngle = isValid_default(this._spec.padAngle) ? degreeToRadian(this._spec.padAngle) : 0, this.setAngleField(this._spec.valueField || this._spec.angleField), this._spec.categoryField && this.setSeriesField(this._spec.categoryField), this._radiusField = [], this._specAngleField = this._angleField.slice(), this._specRadiusField = [];
  }
  initData() {
    super.initData();
    const viewData = this.getViewData();
    if (!viewData) return;
    registerDataSetInstanceTransform(this._dataSet, "pie", pie2), viewData.transform({
      type: "pie",
      options: {
        angleField: this._angleField[0],
        startAngle: this._startAngle,
        endAngle: this._endAngle,
        minAngle: isValid_default(this._spec.minAngle) ? degreeToRadian(this._spec.minAngle) : 0,
        asStartAngle: ARC_START_ANGLE,
        asEndAngle: ARC_END_ANGLE,
        asRatio: ARC_RATIO,
        asMiddleAngle: ARC_MIDDLE_ANGLE,
        asRadian: ARC_RADIAN,
        asQuadrant: ARC_QUADRANT,
        asK: ARC_K
      }
    }, false);
    const viewDataLabel = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataLabel`
    });
    viewDataLabel.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataLabel = new SeriesData(this._option, viewDataLabel);
  }
  initMark() {
    var _a;
    this._pieMark = this._createMark(Object.assign(Object.assign({}, _BasePieSeries.mark.pie), {
      name: this._pieMarkName,
      type: this._pieMarkType
    }), {
      morph: shouldMarkDoMorph(this._spec, this._pieMarkName),
      defaultMorphElementKey: this._seriesField,
      key: DEFAULT_DATA_KEY,
      groupKey: this._seriesField,
      skipBeforeLayouted: true,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.pie) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  startAngleScale(datum) {
    return field2(ARC_START_ANGLE)(datum);
  }
  endAngleScale(datum) {
    return field2(ARC_END_ANGLE)(datum);
  }
  initMarkStyle() {
    const pieMark = this._pieMark;
    pieMark && (this.setMarkStyle(pieMark, {
      x: () => {
        var _a, _b;
        return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
      },
      y: () => {
        var _a, _b;
        return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
      },
      fill: this.getColorAttribute(),
      outerRadius: isSpecValueWithScale(this._outerRadius) ? this._outerRadius : () => this.computeLayoutRadius() * this._outerRadius,
      innerRadius: isSpecValueWithScale(this._innerRadius) ? this._innerRadius : () => this.computeLayoutRadius() * this._innerRadius,
      cornerRadius: () => this.computeLayoutRadius() * this._cornerRadius,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      padAngle: this._padAngle,
      centerOffset: this._centerOffset
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(pieMark));
  }
  initTooltip() {
    super.initTooltip(), this._pieMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pieMark);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (super.initMarkStyleWithSpec(mark, spec, key), mark.name === this._pieMarkName) {
      const pieSpec = this.getSpec()[mark.name];
      if (pieSpec) for (const state in pieSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(pieSpec.state[state]), state, AttributeLevel.User_Mark);
    }
  }
  initLabelMarkStyle(textMark) {
    var _a, _b, _c, _d, _e, _f;
    textMark && this.setMarkStyle(textMark, {
      visible: field2(DEFAULT_LABEL_VISIBLE).bind(this),
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: (null === (_b = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) || this.getColorAttribute(),
      angle: null === (_d = null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.angle,
      limit: null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.limit,
      z: this.dataToPositionZ.bind(this)
    });
  }
  afterInitMark() {
    super.afterInitMark(), this._trigger.setStateKeys([this._seriesField, ...this._radiusField]);
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataLabel.getDataView()) || void 0 === _a || _a.target.addListener("change", this.viewDataLabelUpdate.bind(this));
  }
  initGroups() {
  }
  onLayoutEnd(ctx) {
    this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), super.onLayoutEnd(ctx);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return this._specAngleField;
  }
  viewDataLabelUpdate() {
    this.event.emit(ChartEvent.viewDataLabelUpdate, {
      model: this
    }), this._viewDataLabel.updateData();
  }
  generateRadiusStyle(spec) {
    if (!spec) return;
    const style = {};
    return spec.outerRadius && (style.outerRadius = () => this.computeLayoutRadius() * spec.outerRadius), spec.innerRadius && (style.innerRadius = () => this.computeLayoutRadius() * spec.innerRadius), spec.cornerRadius && (style.cornerRadius = () => this.computeLayoutRadius() * spec.cornerRadius), style;
  }
  computeLayoutRadius() {
    const { width, height } = this._region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  computeCenter(datum) {
    return {
      x: this._pieMark.getAttribute("x", datum, "normal"),
      y: this._pieMark.getAttribute("y", datum, "normal")
    };
  }
  getRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.outerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.outerRadius;
    return null != styleRadius ? styleRadius : this._outerRadius;
  }
  getInnerRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.innerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.innerRadius;
    return null != styleRadius ? styleRadius : this._innerRadius;
  }
  computeRadius(r2, k3) {
    return this.computeLayoutRadius() * r2 * (isNil_default(k3) ? 1 : k3) + this._centerOffset;
  }
  computeDatumRadius(datum, state) {
    return this.computeLayoutRadius() * this.getRadius(state) + this._centerOffset;
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    (ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
      data: true
    }).centerX = true, ignoreCheckKeys.centerX = true, ignoreCheckKeys.centerY = true, ignoreCheckKeys.centerOffset = true, ignoreCheckKeys.radius = true, ignoreCheckKeys.innerRadius = true, ignoreCheckKeys.cornerRadius = true, ignoreCheckKeys.startAngle = true, ignoreCheckKeys.endAngle = true, ignoreCheckKeys.padAngle = true;
    const { centerX, centerY, centerOffset, radius, innerRadius, cornerRadius, startAngle, endAngle, padAngle } = prevSpec, result2 = super._compareSpec(spec, prevSpec, ignoreCheckKeys);
    return (spec = null != spec ? spec : {}).centerY === centerY && spec.centerX === centerX && spec.centerOffset === centerOffset && spec.radius === radius && spec.innerRadius === innerRadius && spec.cornerRadius === cornerRadius && spec.startAngle === startAngle && spec.endAngle === endAngle && spec.padAngle === padAngle || (result2.reRender = true, result2.change = true), result2;
  }
  computeDatumInnerRadius(datum, state) {
    return this.computeLayoutRadius() * this.getInnerRadius(state) + this._centerOffset;
  }
  dataToPosition(datum) {
    const angle2 = datum[ARC_MIDDLE_ANGLE];
    if (isNil_default(angle2)) return null;
    const radius = this.computeDatumRadius(datum), center2 = this.computeCenter(datum), delta = polarToCartesian2({
      angle: angle2,
      radius
    });
    return {
      x: center2.x + delta.x,
      y: center2.y + delta.y
    };
  }
  initAnimation() {
    var _a, _b;
    const animationParams = {
      growFrom: (datum, element, state) => {
        var _a2;
        if (state === AnimationStateEnum.appear) return this._startAngle;
        if (state === AnimationStateEnum.disappear) return this._endAngle;
        const outState = [AnimationStateEnum.disappear, AnimationStateEnum.exit], markElements = element.mark.elements, data = datum, dataIndex = null == data ? void 0 : data[DEFAULT_DATA_INDEX];
        if (void 0 === markElements.find((e3) => {
          var _a3;
          return (null === (_a3 = e3.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        })) return this._startAngle;
        if (void 0 === markElements.find((e3) => {
          var _a3;
          return (null === (_a3 = e3.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) > dataIndex;
        })) return this._endAngle;
        const prevMarkElement = [...markElements].reverse().find((e3) => {
          var _a3;
          return (null === (_a3 = e3.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        });
        return outState.includes(state) ? null === (_a2 = null == prevMarkElement ? void 0 : prevMarkElement.getNextGraphicAttributes()) || void 0 === _a2 ? void 0 : _a2.endAngle : null == prevMarkElement ? void 0 : prevMarkElement.getGraphicAttribute("endAngle", true);
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._pieMark) {
      const pieAnimationConfig = animationConfig(null === (_b = Factory2.getAnimationInKey("pie")) || void 0 === _b ? void 0 : _b(animationParams, appearPreset), userAnimationConfig("pie", this._spec, this._markAttributeContext));
      pieAnimationConfig.normal && pieAnimationConfig.normal.type && (pieAnimationConfig.normal = centerOffsetConfig(this._pieMark, pieAnimationConfig.normal)), this._pieMark.setAnimationConfig(pieAnimationConfig);
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  getActiveMarks() {
    return [this._pieMark];
  }
};
BasePieSeries.transformerConstructor = PieSeriesSpecTransformer, BasePieSeries.mark = pieSeriesMark;
var PieSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie;
  }
};
PieSeries.type = SeriesTypeEnum.pie;
var registerPieSeries = () => {
  registerArcMark(), registerPieAnimation(), Factory2.registerSeries(PieSeries.type, PieSeries);
};

// node_modules/@visactor/vchart/esm/mark/arc-3d.js
var Arc3dMark = class _Arc3dMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _Arc3dMark.type, this._support3d = true;
  }
};
Arc3dMark.type = "arc3d";
var registerArc3dMark = () => {
  registerVGrammarArcAnimation(), registerArc3dGraphic2(), Factory2.registerMark(Arc3dMark.type, Arc3dMark);
};

// node_modules/@visactor/vchart/esm/series/pie/3d/pie-3d-transformer.js
var Pie3dSeriesSpecTransformer = class extends PieSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie3d");
  }
};

// node_modules/@visactor/vchart/esm/series/pie/3d/pie-3d.js
var Pie3dSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie3d, this._pieMarkName = "pie3d", this._pieMarkType = "arc3d", this.transformerConstructor = Pie3dSeriesSpecTransformer;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._angle3d = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.angle3d) && void 0 !== _b ? _b : -Math.PI / 3;
  }
  initMarkStyle() {
    super.initMarkStyle();
    const pieMark = this._pieMark;
    pieMark && this.setMarkStyle(pieMark, {
      beta: () => this._angle3d
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(textMark) {
    if (!textMark) return;
    super.initLabelMarkStyle(textMark);
    const params3d = {};
    textMark.setSupport3d(true), params3d.beta = this._angle3d, params3d.anchor3d = (datum) => {
      var _a, _b, _c, _d;
      return [null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2, null !== (_d = null === (_c = this._center) || void 0 === _c ? void 0 : _c.y) && void 0 !== _d ? _d : this._region.getLayoutRect().height / 2];
    }, params3d.angle = (datum) => {
      var _a;
      const angle2 = datum[ARC_MIDDLE_ANGLE];
      return "inside" === (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position) ? radianToDegree(angle2) : 0;
    }, this.setMarkStyle(textMark, Object.assign(Object.assign({}, params3d), {
      z: 100
    }), void 0, AttributeLevel.Mark);
  }
};
Pie3dSeries.type = SeriesTypeEnum.pie3d, Pie3dSeries.mark = pie3dSeriesMark, Pie3dSeries.transformerConstructor = Pie3dSeriesSpecTransformer;
var registerPie3dSeries = () => {
  registerPie3dAnimation(), registerArc3dMark(), Factory2.registerSeries(Pie3dSeries.type, Pie3dSeries);
};

// node_modules/@visactor/vchart/esm/series/rose/animation.js
var Appear_Grow4 = (params2) => {
  const from = "angle" === params2.growField ? 0 : params2.innerRadius;
  return "angle" === params2.growField ? {
    type: "angle" === params2.growField ? "growAngleIn" : "growRadiusIn"
  } : {
    channel: {
      innerRadius: {
        from,
        to: (datum, element) => element.getGraphicAttribute("innerRadius")
      },
      outerRadius: {
        from,
        to: (datum, element) => element.getGraphicAttribute("outerRadius")
      }
    }
  };
};
var Appear_FadeIn7 = {
  type: "fadeIn"
};
var roseEnter = (params2) => ({
  type: "angle" === params2.growField ? "growAngleIn" : "growRadiusIn"
});
var roseExit = (params2) => ({
  type: "angle" === params2.growField ? "growAngleOut" : "growRadiusOut"
});
var roseDisappear = (params2) => ({
  type: "angle" === params2.growField ? "growAngleOut" : "growRadiusOut"
});
function rosePresetAnimation(params2, preset) {
  if (false === preset) return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn7;
    case "growAngle":
      return Appear_Grow4(Object.assign(Object.assign({}, params2), {
        growField: "angle"
      }));
    default:
      return Appear_Grow4(Object.assign(Object.assign({}, params2), {
        growField: "radius"
      }));
  }
}
var registerRoseAnimation = () => {
  Factory2.registerAnimation("rose", (params2, preset) => ({
    appear: rosePresetAnimation(params2, preset),
    enter: roseEnter(params2),
    exit: roseExit(params2),
    disappear: roseDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/polar/rose-like/rose-like.js
var RoseLikeSeries = class extends PolarSeries {
  getStackGroupFields() {
    return this._angleField;
  }
  getStackValueField() {
    return array(this._spec.valueField)[0] || array(this._spec.radiusField)[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setAngleField(this._spec.categoryField || this._spec.angleField), this.setRadiusField(this._spec.valueField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice(), this.setInnerRadiusField(this._spec.valueField || this._spec.radiusField), this._stack && this.setValueFieldToStack(), this._percent && this.setValueFieldToPercent();
  }
  setValueFieldToStack() {
    this.setRadiusField(STACK_FIELD_END), this.setInnerRadiusField(STACK_FIELD_START);
  }
  setValueFieldToPercent() {
    this.setRadiusField(STACK_FIELD_END_PERCENT), this.setInnerRadiusField(STACK_FIELD_START_PERCENT);
  }
  getDimensionField() {
    return this._specAngleField;
  }
  getMeasureField() {
    return this._specRadiusField;
  }
  getDefaultShapeType() {
    return "square";
  }
};

// node_modules/@visactor/vchart/esm/series/rose/rose-transformer.js
var RoseSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "rose");
  }
};

// node_modules/@visactor/vchart/esm/series/rose/rose.js
var RoseSeries = class _RoseSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rose, this.transformerConstructor = RoseSeriesSpecTransformer, this._supportStack = true, this._roseMark = null, this._labelMark = null;
  }
  initMark() {
    this.initRoseMark();
  }
  initMarkStyle() {
    this.initRoseMarkStyle();
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  initRoseMark() {
    var _a;
    this._roseMark = this._createMark(_RoseSeries.mark.rose, {
      morph: shouldMarkDoMorph(this._spec, _RoseSeries.mark.rose.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.rose) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  getRoseAngle() {
    var _a, _b, _c;
    return null !== (_c = null === (_b = (_a = this.angleAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _c ? _c : 0.5;
  }
  startAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  endAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + this.getRoseAngle() - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  initRoseMarkStyle() {
    const roseMark = this._roseMark;
    roseMark && (this.setMarkStyle(roseMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      fill: this.getColorAttribute(),
      outerRadius: (datum) => valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]), this.radiusAxisHelper.getScale(0)),
      innerRadius: (datum) => {
        var _a;
        if (!this._stack) return 0;
        const stackStart = valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._innerRadiusField[0]]]), this.radiusAxisHelper.getScale(0));
        return stackStart <= Number.MIN_VALUE ? this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0) : stackStart;
      }
    }), this._trigger.registerMark(roseMark));
  }
  initTooltip() {
    super.initTooltip(), this._roseMark && this._tooltipHelper.activeTriggerSet.mark.add(this._roseMark);
  }
  initLabelMarkStyle(textMark) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    textMark && this.setMarkStyle(textMark, {
      visible: null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.visible,
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: (null === (_d = null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.fill) || this.getColorAttribute(),
      angle: null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.angle,
      limit: null === (_h = null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.limit,
      z: 0
    });
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._roseMark) {
      const animationParams = {
        innerRadius: () => {
          var _a2;
          return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
        }
      };
      this._roseMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rose")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("rose", this._spec, this._markAttributeContext)));
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._roseMark];
  }
};
RoseSeries.type = SeriesTypeEnum.rose, RoseSeries.mark = roseSeriesMark, RoseSeries.transformerConstructor = RoseSeriesSpecTransformer;
var registerRoseSeries = () => {
  Factory2.registerSeries(RoseSeries.type, RoseSeries), registerArcMark(), registerRoseAnimation();
};

// node_modules/@visactor/vchart/esm/series/polar/animation.js
var PolarPointUpdate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2);
    const pointToCoord = this.params.pointToCoord, coordToPoint = this.params.coordToPoint;
    isFunction_default(pointToCoord) && isFunction_default(coordToPoint) || (this.valid = false), this._pointToCoord = pointToCoord, this._coordToPoint = coordToPoint;
  }
  getEndProps() {
    return false === this.valid ? {} : this._coordToPoint({
      angle: this._toAngle,
      radius: this._toRadius
    });
  }
  onBind() {
    const { angle: fromAngle, radius: fromRadius } = this._pointToCoord(this.from);
    isValidNumber_default(fromAngle * fromRadius) || (this.valid = false), this._fromAngle = fromAngle, this._fromRadius = fromRadius;
    const { angle: toAngle, radius: toRadius } = this._pointToCoord(this.to);
    isValidNumber_default(toAngle * toRadius) || (this.valid = false), this._toAngle = toAngle, this._toRadius = toRadius;
  }
  onUpdate(end, ratio, out) {
    if (false !== this.valid) if (end) {
      const { x: x3, y: y3 } = this.getEndProps();
      out.x = x3, out.y = y3;
    } else {
      const { x: x3, y: y3 } = this._coordToPoint({
        angle: this._fromAngle + (this._toAngle - this._fromAngle) * ratio,
        radius: this._fromRadius + (this._toRadius - this._fromRadius) * ratio
      });
      out.x = x3, out.y = y3;
    }
  }
};
var PolarTagPointsUpdate = class extends TagPointsUpdate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2);
    const pointToCoord = this.params.pointToCoord, coordToPoint = this.params.coordToPoint;
    this._pointToCoord = pointToCoord, this._coordToPoint = coordToPoint;
  }
  onUpdate(end, ratio, out) {
    this.points = this.points.map((point6, index) => {
      const newPoint = this.polarPointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return newPoint.context = point6.context, newPoint;
    }), out.points = this.points;
  }
  polarPointInterpolation(pointA, pointB, ratio) {
    const polarPointA0 = this._pointToCoord(pointA), polarPointA1 = this._pointToCoord({
      x: pointA.x1,
      y: pointA.y1
    }), polarPointB0 = this._pointToCoord(pointB), polarPointB1 = this._pointToCoord({
      x: pointB.x1,
      y: pointB.y1
    }), angle0 = polarPointA0.angle + (polarPointB0.angle - polarPointA0.angle) * ratio, radius0 = polarPointA0.radius + (polarPointB0.radius - polarPointA0.radius) * ratio, angle1 = polarPointA1.angle + (polarPointB1.angle - polarPointA1.angle) * ratio, radius1 = polarPointA1.radius + (polarPointB1.radius - polarPointA1.radius) * ratio, { x: x3, y: y3 } = this._coordToPoint({
      angle: angle0,
      radius: radius0
    }), { x: x14, y: y14 } = this._coordToPoint({
      angle: angle1,
      radius: radius1
    }), point6 = new Point(x3, y3, x14, y14);
    return point6.defined = pointB.defined, point6;
  }
};

// node_modules/@visactor/vchart/esm/series/radar/animation.js
var radarFadeAnimation = (animationType) => ({
  type: "in" === animationType ? "fadeIn" : "fadeOut"
});
var radarGrowAnimation = (params2, animationType) => ({
  type: "in" === animationType ? "growPointsIn" : "growPointsOut",
  options: () => ({
    center: params2.center()
  })
});
function radarPresetAnimation(params2, preset, animationType) {
  return "fadeIn" === preset ? radarFadeAnimation(animationType) : radarGrowAnimation(params2, animationType);
}
var radarSymbolMoveAnimation = (params2, animationType) => {
  const xFrom = () => {
    var _a;
    return null === (_a = params2.center()) || void 0 === _a ? void 0 : _a.x;
  }, xTo = (datum, element) => element.getGraphicAttribute("x"), yFrom = () => {
    var _a;
    return null === (_a = params2.center()) || void 0 === _a ? void 0 : _a.y;
  }, yTo = (datum, element) => element.getGraphicAttribute("y");
  return "in" === animationType ? {
    channel: {
      x: {
        from: xFrom,
        to: xTo
      },
      y: {
        from: yFrom,
        to: yTo
      }
    }
  } : {
    channel: {
      x: {
        from: xTo,
        to: xFrom
      },
      y: {
        from: yTo,
        to: yFrom
      }
    }
  };
};
function radarSymbolPresetAnimation(params2, preset, animationType) {
  return "fadeIn" === preset ? radarFadeAnimation(animationType) : radarSymbolMoveAnimation(params2, animationType);
}
var radarGroupClipAnimation = (params2, animationType) => ({
  custom: ClipAngleAnimate,
  customParameters: (datum, element) => {
    var _a;
    return {
      group: element.getGraphicItem(),
      startAngle: null !== (_a = params2.startAngle) && void 0 !== _a ? _a : Math.PI / 2,
      orient: "clockwise",
      center: params2.center(),
      radius: params2.radius(),
      animationType
    };
  }
});
var registerRadarAnimation = () => {
  Factory2.registerAnimation("radar", (params2, preset) => ({
    appear: "clipIn" === preset ? void 0 : radarPresetAnimation(params2, preset, "in"),
    enter: radarPresetAnimation(params2, preset, "in"),
    exit: radarPresetAnimation(params2, preset, "out"),
    disappear: "clipIn" === preset ? void 0 : radarPresetAnimation(params2, preset, "out"),
    update: [{
      options: {
        excludeChannels: ["points", "defined"]
      }
    }, {
      channel: ["points"],
      custom: PolarTagPointsUpdate,
      customParameters: params2,
      duration: DEFAULT_ANIMATION_CONFIG.update.duration,
      easing: DEFAULT_ANIMATION_CONFIG.update.easing
    }]
  })), Factory2.registerAnimation("radarSymbol", (params2, preset) => ({
    appear: "clipIn" === preset ? void 0 : radarSymbolPresetAnimation(params2, preset, "in"),
    enter: {
      type: "scaleIn"
    },
    exit: {
      type: "scaleOut"
    },
    disappear: "clipIn" === preset ? void 0 : radarSymbolPresetAnimation(params2, preset, "out"),
    update: [{
      options: {
        excludeChannels: ["x", "y"]
      }
    }, {
      channel: ["x", "y"],
      custom: PolarPointUpdate,
      customParameters: params2,
      duration: DEFAULT_ANIMATION_CONFIG.update.duration,
      easing: DEFAULT_ANIMATION_CONFIG.update.easing
    }]
  })), Factory2.registerAnimation("radarGroup", (params2, preset) => ({
    appear: radarGroupClipAnimation(params2, "in"),
    disappear: radarGroupClipAnimation(params2, "out")
  }));
};

// node_modules/@visactor/vchart/esm/series/radar/radar.js
var RadarSeries = class _RadarSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.radar, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  initGroups() {
  }
  compile() {
    super.compile(), this.addOverlapCompile();
  }
  initMark() {
    var _a, _b, _c, _d;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, isAreaVisible = false !== (null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible), seriesMark = null !== (_d = this._spec.seriesMark) && void 0 !== _d ? _d : "area";
    this.initAreaMark(progressive, isAreaVisible && "area" === seriesMark), this.initLineMark(progressive, "line" === seriesMark || "area" === seriesMark && !isAreaVisible), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    this.initAreaMarkStyle(), this.initLineMarkStyle(), this.initSymbolMarkStyle();
  }
  initAreaMark(progressive, isSeriesMark) {
    var _a;
    this._areaMark = this._createMark(_RadarSeries.mark.area, {
      progressive,
      isSeriesMark,
      customShape: null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.customShape
    });
  }
  initAreaMarkStyle() {
    const areaMark = this._areaMark;
    areaMark && (this.setMarkStyle(areaMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: (datum) => datum && this.angleAxisHelper && this.radiusAxisHelper ? this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this._stack ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).x : Number.NaN,
      y1: (datum) => {
        if (!datum || !this.angleAxisHelper || !this.radiusAxisHelper) return Number.NaN;
        return this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this._stack ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).y;
      },
      fill: this.getColorAttribute(),
      curveType: DEFAULT_LINEAR_INTERPOLATE,
      closePath: true
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined,
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(areaMark, "defined");
    }), this._trigger.registerMark(areaMark));
  }
  initTooltip() {
    super.initTooltip(), this._lineMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._lineMark), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      center: () => {
        var _a2;
        return null === (_a2 = this.angleAxisHelper) || void 0 === _a2 ? void 0 : _a2.center();
      },
      radius: () => {
        const rect = this.getLayoutRect();
        return Math.min(rect.width, rect.height);
      },
      startAngle: isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : POLAR_START_RADIAN,
      pointToCoord: (point6) => {
        var _a2;
        return null === (_a2 = this.angleAxisHelper) || void 0 === _a2 ? void 0 : _a2.pointToCoord(point6);
      },
      coordToPoint: (coord) => this.angleAxisHelper.coordToPoint(coord)
    }, appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("radarGroup")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext)));
    [[this._areaMark, "radar"], [this._lineMark, "radar"], [this._symbolMark, "radarSymbol"]].forEach(([mark, animation]) => {
      if (isValid_default(mark)) {
        const getAnimation = Factory2.getAnimationInKey(animation);
        mark.setAnimationConfig(animationConfig(null == getAnimation ? void 0 : getAnimation(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
      }
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d;
      let result2 = null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
      return "fill" !== attribute || result2 || (attribute = "stroke", result2 = null !== (_d = null === (_c = this._seriesMark) || void 0 === _c ? void 0 : _c.getAttribute(attribute, datum)) && void 0 !== _d ? _d : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
RadarSeries.type = SeriesTypeEnum.radar, RadarSeries.mark = radarSeriesMark, RadarSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(RadarSeries, LineLikeSeriesMixin);
var registerRadarSeries = () => {
  registerMarkOverlapTransform(), registerAreaMark(), registerLineMark(), registerSymbolMark(), registerRadarAnimation(), Factory2.registerSeries(RadarSeries.type, RadarSeries);
};

// node_modules/@visactor/vchart/esm/series/dot/tooltip-helper.js
var DotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  updateTooltipSpec() {
    var _a;
    super.updateTooltipSpec(), isValid_default(null === (_a = this.spec) || void 0 === _a ? void 0 : _a.mark) && (this.spec.mark.updateContent = (prev, datum, params2) => {
      const childrenContent = [], childrenPrev = prev.filter((p2) => "children" === p2.key);
      return childrenPrev.length > 0 && childrenPrev[0].value.forEach((element) => {
        let flag = true;
        for (const key in element) childrenContent.push({
          shapeType: "circle",
          hasShape: flag,
          shapeColor: this.contentShapeColorCallback(datum[0].datum[0]),
          shapeStroke: this.contentShapeColorCallback(datum[0].datum[0]),
          key,
          value: element[key] + ""
        }), flag = false;
      }), prev.concat(childrenContent);
    });
  }
  getDefaultTooltipPattern(activeType) {
    return "mark" === activeType ? {
      visible: true,
      activeType,
      title: {
        key: "event info",
        value: "event info"
      },
      content: [{
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: (datum) => datum.type,
        value: (datum) => datum.id
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "event_time",
        value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d", datum.event_time)
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "action_type",
        value: (datum) => datum.action_type
      }, {
        shapeType: "square",
        hasShape: true,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "children",
        value: (datum) => datum.children
      }],
      updateContent: (prev, datum, params2) => {
        const childrenContent = [];
        return prev[3].value.forEach((element) => {
          let flag = true;
          for (const key in element) childrenContent.push({
            shapeType: "circle",
            hasShape: flag,
            shapeColor: this.contentShapeColorCallback(datum[0].datum[0]),
            shapeStroke: this.contentShapeColorCallback(datum[0].datum[0]),
            key,
            value: element[key] + ""
          }), flag = false;
        }), prev.concat(childrenContent);
      }
    } : null;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/obj-flat.js
var objFlat = (data, op) => {
  var _a;
  const dataCollect = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data || [], result2 = [];
  return dataCollect.forEach((datum) => {
    const dataKey = {};
    for (const key in datum) key !== op && (dataKey[key] = datum[key]);
    const dataOp = datum[op];
    null == dataOp || dataOp.forEach((d2) => {
      result2.push(Object.assign({}, dataKey, d2));
    });
  }), result2;
};

// node_modules/@visactor/vchart/esm/series/dot/config.js
var DEFAULT_GRID_BACKGROUND = {
  fill: "#bbb",
  fillOpacity: 0.2
};

// node_modules/@visactor/vchart/esm/series/dot/dot.js
var DotSeries = class _DotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.dot;
  }
  getSeriesGroupField() {
    return this._seriesField;
  }
  setSeriesGroupField(field5) {
    isValid_default(field5) && (this._seriesGroupField = field5);
  }
  getTitleField() {
    return this._titleField;
  }
  setTitleField(field5) {
    isValid_default(field5) && (this._titleField = field5);
  }
  getSubTitleField() {
    return this._subTitleField;
  }
  setSubTitleField(field5) {
    isValid_default(field5) && (this._subTitleField = field5);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field5) {
    isValid_default(field5) && (this._dotTypeField = field5);
  }
  getHighLightSeriesGroup() {
    return this._highLightSeriesGroup;
  }
  setHighLightSeriesGroup(field5) {
    isValid_default(field5) && (this._highLightSeriesGroup = field5);
  }
  setGridBackground(gridBackground) {
    isValid_default(gridBackground) && (this._gridBackground = gridBackground);
  }
  initData() {
    var _a;
    super.initData(), this._xDimensionStatisticsDomain = this.getRawData().latestData.map((d2) => d2[this._fieldY[0]]), registerDataSetInstanceTransform(this._option.dataSet, "objFlat", objFlat), registerDataSetInstanceTransform(this._option.dataSet, "copyDataView", copyDataView), registerDataSetInstanceParser(this._option.dataSet, "dataview", dataViewParser), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "objFlat",
      options: "dots",
      level: TransformLevel.dotObjFlat
    }, false);
  }
  setSeriesField(field5) {
    isValid_default(field5) && (this._seriesField = field5, this.getMarksInType(["line", "area"]).forEach((m5) => {
      m5.setFacet(this._seriesField);
    }));
  }
  getStatisticFields() {
    return [{
      key: this._fieldY[0],
      operations: ["values"],
      customize: this._xDimensionStatisticsDomain
    }];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setSeriesGroupField(this._spec.seriesGroupField), this.setTitleField(this._spec.titleField), this.setSubTitleField(this._spec.subTitleField), this.setDotTypeField(this._spec.dotTypeField), this.setHighLightSeriesGroup(this._spec.highLightSeriesGroup), this.setGridBackground(mergeSpec(DEFAULT_GRID_BACKGROUND, (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.background) || {}));
  }
  initMark() {
    this._clipMark = this._createMark(_DotSeries.mark.group), this._containerMark = this._createMark(_DotSeries.mark.group, {
      parent: this._clipMark,
      dataView: this.getRawData()
    }), this._gridBackgroundMark = this._createMark(_DotSeries.mark.gridBackground, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._gridMark = this._createMark(_DotSeries.mark.grid, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._dotMark = this._createMark(_DotSeries.mark.dot, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    }), this._titleMark = this._createMark(_DotSeries.mark.title, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._subTitleMark = this._createMark(_DotSeries.mark.subTitle, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._symbolMark = this._createMark(_DotSeries.mark.symbol, {
      parent: this._containerMark,
      dataView: this.getRawData()
    });
  }
  initMarkStyle() {
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight,
      clip: true
    }, "normal", AttributeLevel.Series), clipMark.setInteractive(false));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding
    }, "normal", AttributeLevel.Series), containerMark.setInteractive(false));
    const gridBackgroundMark = this._gridBackgroundMark;
    gridBackgroundMark && (this.setMarkStyle(gridBackgroundMark, {
      x: this.getRegionRectLeft.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y: this.dataToGridBackgroundPositionY.bind(this),
      y1: this.dataToGridBackgroundPositionY1.bind(this),
      fill: this._gridBackground.fill,
      fillOpacity: this.dataToGridBackgroundOpacity.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(gridBackgroundMark));
    const gridMark = this._gridMark;
    gridMark && (this.setMarkStyle(gridMark, {
      stroke: this.getColorAttribute(),
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y1: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(gridMark));
    const dotMark = this._dotMark;
    dotMark && (this.setMarkStyle(dotMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getDotColorAttribute(),
      fillOpacity: this.dataToOpacity.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(dotMark));
    const titleMark = this._titleMark;
    titleMark && (this.setMarkStyle(titleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(titleMark));
    const subTitleMark = this._subTitleMark;
    subTitleMark && (this.setMarkStyle(subTitleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getSubTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(subTitleMark));
    const symbolMark = this._symbolMark;
    symbolMark && (this.setMarkStyle(symbolMark, {
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(symbolMark));
  }
  dataToGridBackgroundPositionY(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) - getBandwidth(0) / 2;
  }
  dataToGridBackgroundPositionY1(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) + getBandwidth(0) / 2;
  }
  dataToOpacity(datum) {
    var _a, _b, _c, _d;
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1] ? 0 : null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.dot) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.fillOpacity) && void 0 !== _d ? _d : 1;
  }
  dataToGridBackgroundOpacity(datum) {
    return datum[this._seriesGroupField] === this._highLightSeriesGroup ? this._gridBackground.fillOpacity : 0;
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    super.onLayoutEnd(ctx);
    const layoutOffsetX = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.leftAppendPadding) && void 0 !== _b ? _b : 0;
    this.setMarkStyle(this._clipMark, {
      width: this.getLayoutRect().width + layoutOffsetX
    }, "normal", AttributeLevel.Series);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesGroupField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesGroupField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._seriesGroupField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
    };
  }
  getDotColorScale() {
    var _a, _b, _c;
    const colorDomain = this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesGroupField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesGroupField].values : this._seriesField ? null === (_c = this.getViewDataStatistics()) || void 0 === _c ? void 0 : _c.latestData[this._seriesField].values : [], colorRange = this._getDataScheme();
    return new ColorOrdinalScale().domain(colorDomain).range(colorRange);
  }
  getDotColorAttribute() {
    var _a, _b, _c, _d;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this.getDotColorScale(),
      field: null !== (_d = null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesGroupField) && void 0 !== _c ? _c : this._seriesField) && void 0 !== _d ? _d : DEFAULT_DATA_SERIES_FIELD
    };
  }
  initTooltip() {
    this._tooltipHelper = new DotSeriesTooltipHelper(this), this._dotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._dotMark);
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m5) => {
      "group" === m5.type ? this.onMarkTreePositionUpdate(m5.getMarks()) : m5.updateLayoutState();
    });
  }
  getDotData() {
    var _a;
    return null === (_a = this._dotMark) || void 0 === _a ? void 0 : _a.getData();
  }
  _getDataIdKey() {
  }
  getStackValueField() {
    return null;
  }
  getActiveMarks() {
    return [this._dotMark];
  }
};
DotSeries.type = SeriesTypeEnum.dot, DotSeries.mark = dotSeriesMark;
var registerDotSeries = () => {
  registerSymbolMark(), registerRuleMark(), registerRectMark(), registerTextMark(), Factory2.registerSeries(DotSeries.type, DotSeries);
};

// node_modules/@visactor/vchart/esm/series/link/tooltip-helper.js
var LinkSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType) {
    return "mark" === activeType ? {
      visible: true,
      activeType,
      title: {
        key: "link info",
        value: "link info"
      },
      content: [{
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "time",
        value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d %H:%M", datum.from.split("_")[1])
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "type",
        value: (datum) => datum.action_type
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "from",
        value: (datum) => datum.from
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        key: "to",
        value: (datum) => datum.to
      }]
    } : null;
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/link-dot-info.js
var linkDotInfo = (data, op) => {
  const { infoKey, fields: fields2, linkData, dotData } = op, { fromField, toField, xField, yField } = fields2(), dataLinkObj = linkData(), dataDotObj = dotData(), dataLinkDotHash = {};
  return dataDotObj.forEach((datum) => {
    const dataCopy = {};
    for (const key in datum) key !== infoKey && (dataCopy[key] = datum[key]);
    const dataOp = datum[infoKey];
    null == dataOp || dataOp.forEach((d2) => {
      dataLinkDotHash[d2.node_name] = Object.assign({}, dataCopy, d2);
    });
  }), dataLinkObj.forEach((datum) => {
    var _a, _b, _c, _d;
    datum[fromField + "_xField"] = null === (_a = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _a ? void 0 : _a[xField], datum[fromField + "_yField"] = null === (_b = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _b ? void 0 : _b[yField], datum[toField + "_xField"] = null === (_c = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _c ? void 0 : _c[xField], datum[toField + "_yField"] = null === (_d = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _d ? void 0 : _d[yField];
  }), dataLinkObj;
};

// node_modules/@visactor/vchart/esm/series/link/link.js
var LinkSeries = class _LinkSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.link;
  }
  getFromField() {
    return this._fromField;
  }
  setFromField(field5) {
    isValid_default(field5) && (this._fromField = field5);
  }
  getToField() {
    return this._toField;
  }
  setToField(field5) {
    isValid_default(field5) && (this._toField = field5);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field5) {
    isValid_default(field5) && (this._dotTypeField = field5);
  }
  getDotSeriesSpec() {
    return this._dotSeriesSpec;
  }
  setDotSeriesSpec(spec) {
    isValid_default(spec) && (this._dotSeriesSpec = spec);
  }
  _getDotData() {
    const dotSeries = this._option.getChart().getSeriesInIndex([this._spec.dotSeriesIndex])[0];
    return dotSeries ? dotSeries.getRawData().latestData : [];
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._option.dataSet, "linkDotInfo", linkDotInfo), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "linkDotInfo",
      options: {
        infoKey: "dots",
        fields: () => ({
          fromField: this._fromField,
          toField: this._toField,
          xField: this._dotSeriesSpec.xField,
          yField: this._dotSeriesSpec.yField
        }),
        linkData: () => this._rawData.latestData,
        dotData: () => this._getDotData()
      },
      level: TransformLevel.linkDotInfo
    }, false);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFromField(this._spec.fromField), this.setToField(this._spec.toField), this.setDotTypeField(this._spec.dotTypeField), this.setDotSeriesSpec(this._spec.dotSeriesSpec);
  }
  initMark() {
    this._clipMark = this._createMark(_LinkSeries.mark.group), this._containerMark = this._createMark(_LinkSeries.mark.group, {
      parent: this._clipMark
    }), this._linkMark = this._createMark(_LinkSeries.mark.link, {
      skipBeforeLayouted: false,
      parent: this._containerMark
    }), this._arrowMark = this._createMark(_LinkSeries.mark.arrow, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d;
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight,
      clip: true
    }, "normal", AttributeLevel.Series), clipMark.setInteractive(false));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding,
      width: this.getLayoutRect().width
    }, "normal", AttributeLevel.Series), containerMark.setInteractive(false));
    const linkMark = this._linkMark;
    linkMark && (this.setMarkStyle(linkMark, {
      stroke: this.getColorAttribute(),
      strokeOpacity: this.dataToOpacity.bind(this),
      x: this.dataToPositionXFrom.bind(this),
      y: this.dataToPositionYFrom.bind(this),
      x1: this.dataToPositionXTo.bind(this),
      y1: this.dataToPositionYTo.bind(this)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(linkMark));
    const arrowMark = this._arrowMark;
    if (arrowMark) {
      const arrowSize = null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.arrow) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
      this.setMarkStyle(arrowMark, {
        x: this.dataToPositionXTo.bind(this),
        y: (datum) => this.dataToPositionArrowYTo(datum, arrowSize),
        fill: this.getColorAttribute(),
        fillOpacity: this.dataToOpacity.bind(this),
        size: arrowSize,
        symbolType: (datum) => this.isPositionYFromHigher(datum) ? "triangleDown" : "triangleUp"
      }, "normal", AttributeLevel.Series), this._trigger.registerMark(arrowMark);
    }
  }
  afterInitMark() {
    super.afterInitMark(), this._trigger.setStateKeys([this._seriesField, this._fromField]);
  }
  dataToPositionXFrom(datum) {
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYFrom(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_yField"));
  }
  dataToPositionXTo(datum) {
    if (!this._xAxisHelper) return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYTo(datum) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionArrowYTo(datum, arrowSize) {
    if (!this._yAxisHelper) return Number.NaN;
    const { dataToPosition } = this._yAxisHelper, offset = this.isPositionYFromHigher(datum) ? -arrowSize / 2 : arrowSize / 2;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    }) + offset;
  }
  dataToOpacity(datum) {
    return this.isPositionXOuterRange(datum, this._fromField + "_xField") || this.isPositionXOuterRange(datum, this._toField + "_xField") || datum[this._fromField] === datum[this._toField] ? 0 : 1;
  }
  isPositionYFromHigher(datum) {
    return this.dataToPositionYFrom(datum) < this.dataToPositionYTo(datum);
  }
  isPositionXOuterRange(datum, field5) {
    if (!this._xAxisHelper) return false;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, field5), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, field5), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1];
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
    };
  }
  initTooltip() {
    this._tooltipHelper = new LinkSeriesTooltipHelper(this), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), this._arrowMark && this._tooltipHelper.activeTriggerSet.mark.add(this._arrowMark);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m5) => {
      "group" === m5.type ? this.onMarkTreePositionUpdate(m5.getMarks()) : m5.updateLayoutState();
    });
  }
  getDotInfoData() {
    var _a, _b;
    return null === (_b = null !== (_a = this._linkMark) && void 0 !== _a ? _a : this._arrowMark) || void 0 === _b ? void 0 : _b.getData();
  }
  getActiveMarks() {
    return [this._linkMark, this._arrowMark];
  }
};
LinkSeries.type = SeriesTypeEnum.link, LinkSeries.mark = linkSeriesMark;
var registerLinkSeries = () => {
  registerRuleMark(), registerSymbolMark(), Factory2.registerSeries(LinkSeries.type, LinkSeries);
};

// node_modules/@visactor/vchart/esm/series/polar/progress-like/progress-like.js
var ProgressLikeSeries = class _ProgressLikeSeries extends PolarSeries {
  constructor() {
    super(...arguments), this._supportStack = true, this._arcGroupMark = null, this._getAngleValueStart = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this._stack ? STACK_FIELD_START : SEGMENT_FIELD_START], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle);
        let pos;
        if (isValid_default(originValue)) {
          const index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
          void 0 !== targetIndex && (pos = this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value - step / 2]));
        }
        return isNil_default(pos) && (pos = this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2])), pos + offsetAngle;
      }
      return this._getAngleValueStartWithoutMask(datum);
    }, this._getAngleValueEnd = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this._stack ? STACK_FIELD_END : this._angleField[0]], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle), index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
        let pos;
        return pos = void 0 !== targetIndex ? this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value + step / 2]) : this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2]), pos + offsetAngle;
      }
      return this._getAngleValueEndWithoutMask(datum);
    };
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec();
    const chartSpec = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getSpec(), startAngle = null !== (_b = this._spec.startAngle) && void 0 !== _b ? _b : null == chartSpec ? void 0 : chartSpec.startAngle;
    this._startAngle = isValid_default(startAngle) ? degreeToRadian(startAngle) : POLAR_START_RADIAN;
    const endAngle = null !== (_c = this._spec.endAngle) && void 0 !== _c ? _c : null == chartSpec ? void 0 : chartSpec.endAngle;
    this._endAngle = isValid_default(endAngle) ? degreeToRadian(endAngle) : POLAR_END_RADIAN, this.setAngleField(this._spec.valueField || this._spec.angleField), this.setRadiusField(this._spec.categoryField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice();
  }
  getStackGroupFields() {
    return this._radiusField;
  }
  getStackValueField() {
    var _a;
    return null === (_a = this._angleField) || void 0 === _a ? void 0 : _a[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  _convertMarkStyle(style) {
    const newStyle = super._convertMarkStyle(style);
    if (newStyle.fill) {
      const value = style.fill;
      "conical" !== (null == value ? void 0 : value.gradient) || isValid_default(null == value ? void 0 : value.startAngle) || isValid_default(null == value ? void 0 : value.endAngle) || (newStyle.fill = Object.assign(Object.assign({}, value), {
        startAngle: this._startAngle,
        endAngle: this._endAngle
      }));
    }
    return newStyle;
  }
  _getAngleValueStartWithoutMask(datum) {
    if (this._stack) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_START]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value)) return value;
    }
    return this._startAngle;
  }
  _getAngleValueEndWithoutMask(datum) {
    if (this._stack) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_END]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value)) return value;
    }
    return this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]]);
  }
  getDimensionField() {
    return this._specRadiusField;
  }
  getMeasureField() {
    return this._specAngleField;
  }
  initMark() {
    this._initArcGroupMark();
  }
  initMarkStyle() {
    this._initArcGroupMarkStyle();
  }
  _initArcGroupMark() {
    return this._arcGroupMark = this._createMark(_ProgressLikeSeries.mark.group, {
      skipBeforeLayouted: false
    }), this._arcGroupMark;
  }
  _initArcGroupMarkStyle() {
    const groupMark = this._arcGroupMark;
    groupMark.setZIndex(this.layoutZIndex), groupMark.created(), this.setMarkStyle(groupMark, {
      clip: true,
      x: 0,
      y: 0,
      path: () => {
        const axis2 = this._getAngleAxis();
        if (this._isTickMaskVisible(axis2)) {
          const { tickMask } = this._spec, { angle: angle2, offsetAngle, style = {} } = tickMask, subTickData = this._getAngleAxisSubTickData(axis2), { x: x3, y: y3 } = this.angleAxisHelper.center(), radius = this._computeLayoutRadius(), markStyle = style;
          return subTickData.map(({ value }) => {
            const pos = this.angleAxisHelper.dataToPosition([value]) + degreeToRadian(offsetAngle), angleUnit = degreeToRadian(angle2) / 2;
            return createArc(Object.assign(Object.assign({}, markStyle), {
              x: x3,
              y: y3,
              startAngle: pos - angleUnit,
              endAngle: pos + angleUnit,
              innerRadius: radius * this._innerRadius,
              outerRadius: radius * this._outerRadius,
              fill: true
            }));
          });
        }
        const { width, height } = this.getLayoutRect();
        return [createRect({
          width,
          height,
          fill: true
        })];
      }
    }, "normal", AttributeLevel.Series), this._arcGroupMark.setInteractive(false);
  }
  _getAngleAxis() {
    if (!this.angleAxisHelper) return;
    const angleAxisId = this.angleAxisHelper.getAxisId();
    return this._option.getChart().getAllComponents().find((component2) => component2.id === angleAxisId);
  }
  _getAngleAxisTickData(angleAxis) {
    var _a;
    return null === (_a = null == angleAxis ? void 0 : angleAxis.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  _isTickMaskVisible(angleAxis) {
    const tickData = this._getAngleAxisTickData(angleAxis), { tickMask } = this._spec;
    return tickMask && false !== tickMask.visible && (null == tickData ? void 0 : tickData.length) > 1;
  }
  _getAngleAxisSubTickData(angleAxis) {
    var _a;
    const tickData = this._getAngleAxisTickData(angleAxis), subTickData = [], { subTick = {}, tick = {} } = null !== (_a = null == angleAxis ? void 0 : angleAxis.getSpec()) && void 0 !== _a ? _a : {}, { tickCount: subTickCount = 4 } = subTick, { alignWithLabel } = tick;
    if ((null == tickData ? void 0 : tickData.length) >= 2) {
      const tickSegment = tickData[1].value - tickData[0].value;
      for (let i2 = 0; i2 < tickData.length - 1; i2++) {
        const pre = tickData[i2], next = tickData[i2 + 1];
        subTickData.push(pre);
        for (let j2 = 0; j2 < subTickCount; j2++) {
          const percent = (j2 + 1) / (subTickCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment);
          subTickData.push({
            value
          });
        }
      }
      return subTickData.push(tickData[tickData.length - 1]), subTickData;
    }
    return tickData;
  }
};
ProgressLikeSeries.mark = progressLikeSeriesMark;

// node_modules/@visactor/vchart/esm/mark/progress-arc.js
var ProgressArcMark = class extends BaseArcMark {
  constructor() {
    super(...arguments), this._cacheStateStyle = {};
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      innerPadding: 0,
      outerPadding: 0
    });
  }
  _filterStyle(style, state, level, stateStyle = this.stateStyle) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    isValid_default(style.innerRadius) && this.setAttribute("innerRadius", this._styleConvert(style.innerRadius), state, level, this._cacheStateStyle), isValid_default(style.outerRadius) && this.setAttribute("outerRadius", this._styleConvert(style.outerRadius), state, level, this._cacheStateStyle);
    const innerPadding = null !== (_a = style.innerPadding) && void 0 !== _a ? _a : null === (_c = null === (_b = stateStyle[state]) || void 0 === _b ? void 0 : _b.innerPadding) || void 0 === _c ? void 0 : _c.style, outerPadding = null !== (_d = style.outerPadding) && void 0 !== _d ? _d : null === (_f = null === (_e = stateStyle[state]) || void 0 === _e ? void 0 : _e.outerPadding) || void 0 === _f ? void 0 : _f.style, innerRadius = null !== (_k = null !== (_g = style.innerRadius) && void 0 !== _g ? _g : null === (_j = null === (_h = this._cacheStateStyle[state]) || void 0 === _h ? void 0 : _h.innerRadius) || void 0 === _j ? void 0 : _j.style) && void 0 !== _k ? _k : null === (_m = null === (_l = stateStyle[state]) || void 0 === _l ? void 0 : _l.innerRadius) || void 0 === _m ? void 0 : _m.style, outerRadius = null !== (_r = null !== (_o = style.outerRadius) && void 0 !== _o ? _o : null === (_q = null === (_p = this._cacheStateStyle[state]) || void 0 === _p ? void 0 : _p.outerRadius) || void 0 === _q ? void 0 : _q.style) && void 0 !== _r ? _r : null === (_t = null === (_s = stateStyle[state]) || void 0 === _s ? void 0 : _s.outerRadius) || void 0 === _t ? void 0 : _t.style;
    if (0 === innerRadius && 0 === outerRadius) return style;
    const paddingModified = isValid_default(style.innerPadding) && isValid_default(innerRadius) || isValid_default(style.outerPadding) && isValid_default(outerRadius), radiusModified = isValid_default(style.innerRadius) && innerPadding || isValid_default(style.outerRadius) && outerPadding;
    if (paddingModified || radiusModified) {
      const newStyle = Object.assign({}, style);
      return innerPadding && isValid_default(innerRadius) && (isFunction_default(innerRadius) ? newStyle.innerRadius = (item, ctx, opt, source) => innerRadius(item, ctx, opt, source) + (isFunction_default(innerPadding) ? innerPadding(item, ctx, opt, source) : innerPadding) : isFunction_default(innerPadding) ? newStyle.innerRadius = (item, ctx, opt, source) => {
        const padding = innerPadding(item, ctx, opt, source);
        return innerRadius + padding;
      } : newStyle.innerRadius = innerRadius + innerPadding), outerPadding && isValid_default(outerRadius) && (isFunction_default(outerRadius) ? newStyle.outerRadius = (item, ctx, opt, source) => outerRadius(item, ctx, opt, source) - (isFunction_default(outerPadding) ? outerPadding(item, ctx, opt, source) : outerPadding) : isFunction_default(outerPadding) ? newStyle.outerRadius = (item, ctx, opt, source) => {
        const padding = outerPadding(item, ctx, opt, source);
        return outerRadius - padding;
      } : newStyle.outerRadius = outerRadius - outerPadding), newStyle;
    }
    return style;
  }
};
ProgressArcMark.type = "arc", ProgressArcMark.constructorType = "progressArc";
var registerProgressArcMark = () => {
  registerArcGraphic2(), registerVGrammarArcAnimation(), Factory2.registerMark(ProgressArcMark.constructorType, ProgressArcMark);
};

// node_modules/@visactor/vchart/esm/series/polar/progress-like/animation.js
var Appear_Grow5 = (params2) => ({
  type: "growAngleIn",
  options: {
    overall: params2.startAngle
  }
});
var Appear_FadeIn8 = {
  type: "fadeIn"
};
function progressLikePresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn8 : Appear_Grow5(params2);
}
var registerProgressLikeAnimation = () => {
  Factory2.registerAnimation("circularProgress", (params2, preset) => ({
    appear: progressLikePresetAnimation(params2, preset),
    enter: {
      type: "growAngleIn"
    },
    disappear: {
      type: "growAngleOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/progress/circular/circular.js
var CircularProgressSeries = class _CircularProgressSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circularProgress, this._progressMark = null, this._trackMark = null, this._getRadiusValueStart = (datum) => {
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields()));
        if (isValidNumber_default(value)) return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]);
    }, this._getRadiusValueEnd = (datum) => {
      var _a, _b;
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + (null === (_b = (_a = this.radiusAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0));
        if (isValidNumber_default(value)) return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]) + this.radiusAxisHelper.getScale(0).step();
    };
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getGroupFields() {
    return this._radiusField;
  }
  initMark() {
    super.initMark(), this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    super.initMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a;
    return this._progressMark = this._createMark(_CircularProgressSeries.mark.progress, {
      parent: this._arcGroupMark,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a;
    const progressMark = this._progressMark;
    progressMark && (this.setMarkStyle(progressMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart,
      endAngle: this._getAngleValueEnd,
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(progressMark));
  }
  initTooltip() {
    super.initTooltip(), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark);
  }
  _initTrackMark() {
    var _a;
    return this._trackMark = this._createMark(_CircularProgressSeries.mark.track, {
      parent: this._arcGroupMark,
      customShape: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.customShape
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && (this.setMarkStyle(trackMark, {
      visible: (datum) => {
        const range2 = this.angleAxisHelper.getScale(0).range(), min4 = Math.min(range2[0], range2[range2.length - 1]), startValue = this._getAngleValueStartWithoutMask(datum);
        return Math.abs(startValue - min4) <= 1e-14;
      },
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: () => {
        const fieldName = this._stack ? STACK_FIELD_START : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueStart({
          [fieldName]: domain[0]
        });
      },
      endAngle: () => {
        const fieldName = this._stack ? STACK_FIELD_END : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueEnd({
          [fieldName]: domain[domain.length - 1]
        });
      },
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 100
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(trackMark));
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
CircularProgressSeries.type = SeriesTypeEnum.circularProgress, CircularProgressSeries.mark = circularProgressSeriesMark;
var registerCircularProgressSeries = () => {
  registerProgressArcMark(), registerArcMark(), registerProgressLikeAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(CircularProgressSeries.type, CircularProgressSeries);
};

// node_modules/@visactor/vchart/esm/series/progress/linear/animation.js
function LinearProgressGrowOption(params2) {
  return () => "vertical" === params2.direction ? {
    orient: "negative"
  } : {
    orient: "positive"
  };
}
var Appear_Grow6 = (params2) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: LinearProgressGrowOption(params2)
});
var linearProgressDisappear = (params2) => ({
  type: "horizontal" === params2.direction ? "growWidthOut" : "growHeightOut",
  options: LinearProgressGrowOption(params2)
});
var Appear_FadeIn9 = {
  type: "fadeIn"
};
function linearProgressPresetAnimation(params2, preset) {
  return false === preset ? {} : "fadeIn" === preset ? Appear_FadeIn9 : Appear_Grow6(params2);
}
var registerLinearProgressAnimation = () => {
  Factory2.registerAnimation("linearProgress", (params2, preset) => ({
    appear: linearProgressPresetAnimation(params2, preset),
    enter: {
      type: "grow"
    },
    disappear: linearProgressDisappear(params2)
  }));
};

// node_modules/@visactor/vchart/esm/series/progress/linear/tooltip-helper.js
var LinearProgressSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    const result2 = super.getDefaultTooltipPattern(activeType, dimensionInfo);
    return "mark" === activeType ? result2 : "dimension" === activeType ? (result2.visible = false, result2) : null;
  }
};

// node_modules/@visactor/vchart/esm/series/progress/linear/linear.js
var LinearProgressSeries = class _LinearProgressSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.linearProgress, this._progressMark = null, this._trackMark = null, this._progressGroupMark = null;
  }
  initMark() {
    this._initProgressGroupMark(), this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    this._initProgressGroupMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a;
    return this._progressMark = this._createMark(_LinearProgressSeries.mark.progress, {
      isSeriesMark: true,
      parent: this._progressGroupMark,
      customShape: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const progressMark = this._progressMark;
    if (progressMark) {
      if ("vertical" === this._spec.direction) {
        const leftPadding = null !== (_b = null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.leftPadding) && void 0 !== _b ? _b : 0, rightPadding = null !== (_d = null === (_c = this._spec.progress) || void 0 === _c ? void 0 : _c.rightPadding) && void 0 !== _d ? _d : 0;
        this.setMarkStyle(progressMark, {
          x: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._spec.bandWidth / 2 + leftPadding;
          },
          y: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
          },
          height: () => {
            var _a2;
            return null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([0], {
              bandPosition: this._bandPosition
            });
          },
          width: this._spec.bandWidth - leftPadding - rightPadding,
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series);
      } else {
        const topPadding = null !== (_f = null === (_e = this._spec.progress) || void 0 === _e ? void 0 : _e.topPadding) && void 0 !== _f ? _f : 0, bottomPadding = null !== (_h = null === (_g = this._spec.progress) || void 0 === _g ? void 0 : _g.bottomPadding) && void 0 !== _h ? _h : 0;
        this.setMarkStyle(progressMark, {
          x: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._xAxisHelper.dataToPosition([1], {
              bandPosition: this._bandPosition
            });
          },
          y: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._spec.bandWidth / 2 + topPadding;
          },
          height: this._spec.bandWidth - topPadding - bottomPadding,
          width: () => {
            var _a2;
            return null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([1], {
              bandPosition: this._bandPosition
            });
          },
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series);
      }
      this._trigger.registerMark(progressMark);
    }
  }
  _initTrackMark() {
    var _a;
    return this._trackMark = this._createMark(_LinearProgressSeries.mark.track, {
      parent: this._progressGroupMark,
      customShape: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.customShape
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && ("vertical" === this._spec.direction ? this.setMarkStyle(trackMark, {
      x: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
      },
      y: 0,
      width: this._spec.bandWidth,
      height: () => this._scaleY.range()[0],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(trackMark, {
      x: 0,
      y: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
      },
      height: this._spec.bandWidth,
      width: () => this._scaleX.range()[1],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(trackMark));
  }
  _initProgressGroupMark() {
    return this._progressGroupMark = this._createMark(_LinearProgressSeries.mark.group, {
      skipBeforeLayouted: false
    }), this._progressGroupMark;
  }
  _initProgressGroupMarkStyle() {
    const groupMark = this._progressGroupMark;
    groupMark.setZIndex(this.layoutZIndex), groupMark.created(), this.setMarkStyle(groupMark, {
      clip: true,
      x: 0,
      y: 0,
      path: () => {
        var _a;
        const rectPaths = [];
        return null === (_a = this._rawData) || void 0 === _a || _a.rawData.forEach((datum, index) => {
          var _a2, _b, _c, _d;
          if ("vertical" === this._spec.direction) {
            const x3 = valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b ? void 0 : _b.call(_a2, 0)) - this._spec.bandWidth / 2, height = this._scaleY.range()[0];
            rectPaths.push(createRect({
              x: x3,
              y: 0,
              height,
              width: this._spec.bandWidth,
              cornerRadius: this._spec.cornerRadius,
              fill: true
            }));
          } else {
            const y3 = valueInScaleRange(this.dataToPositionY(datum), null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0)) - this._spec.bandWidth / 2, width = this._scaleX.range()[1];
            rectPaths.push(createRect({
              x: 0,
              y: y3,
              height: this._spec.bandWidth,
              width,
              cornerRadius: this._spec.cornerRadius,
              fill: true
            }));
          }
        }), rectPaths;
      }
    }, "normal", AttributeLevel.Series), this._progressGroupMark.setInteractive(false);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("linearProgress")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new LinearProgressSeriesTooltipHelper(this), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark), this._trackMark && this._tooltipHelper.activeTriggerSet.mark.add(this._trackMark);
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
LinearProgressSeries.type = SeriesTypeEnum.linearProgress, LinearProgressSeries.mark = linearProgressSeriesMark;
var registerLinearProgressSeries = () => {
  registerRectMark(), registerLinearProgressAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(LinearProgressSeries.type, LinearProgressSeries);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/config.js
var DEFAULT_ROTATE_ANGLES = [0];
var DEFAULT_DRAW_OUT_OF_BOUND = "hidden";
var DEFAULT_MIN_FONT_SIZE = 20;
var DEFAULT_FONTSIZE_RANGE = [20, 40];
var DEFAULT_FONT_WEIGHT_RANGE = [200, 500];
var DEFAULT_MASK_SHAPE = "circle";
var DEFAULT_ZOOM_TO_FIT = {
  shrink: false,
  enlarge: false,
  fontSizeLimitMin: 0
};
var DEFAULT_RANDOM = true;
var DEFAULT_FONT_PADDING = 1;
var SHAPE_TYPE = ["triangleForward", "triangle", "diamond", "square", "star", "cardioid", "circle", "pentagon"];

// node_modules/@visactor/vchart/esm/constant/word-cloud.js
var WORD_CLOUD_ANGLE = `${PREFIX}_WORD_CLOUD_ANGLE`;
var WORD_CLOUD_FILLING_ANGLE = `${PREFIX}_WORD_CLOUD_FILLING_ANGLE`;
var WORD_CLOUD_WEIGHT = `${PREFIX}_WORD_CLOUD_WEIGHT`;
var WORDCLOUD_COLOR = `${PREFIX}_WORDCLOUD_COLOR`;
var WORDCLOUD_DATA_TOTAL = `${PREFIX}_WORDCLOUD_DATA_TOTAL`;
var WORD_CLOUD_TEXT = `${PREFIX}_WORD_CLOUD_TEXT`;
var WORDCLOUD_SHAPE_DATA_TOTAL = `${PREFIX}_WORDCLOUD_SHAPE_DATA_TOTAL`;

// node_modules/@visactor/vchart/esm/series/word-cloud/base.js
var BaseWordCloudSeries = class _BaseWordCloudSeries extends BaseSeries {
  constructor() {
    super(...arguments), this._fontSizeRange = [DEFAULT_MIN_FONT_SIZE, DEFAULT_MIN_FONT_SIZE], this._isWordCloudShape = false;
  }
  setValueField(field5) {
    isValid_default(field5) && (this._valueField = field5);
  }
  setFontSizeRange(fontSizeRange) {
    isValid_default(fontSizeRange) ? this._fontSizeRange = fontSizeRange : this._fontSizeRange = DEFAULT_FONTSIZE_RANGE;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.setAttrFromSpec(), this._padding = this._option.getChart().padding, this._nameField = this._spec.nameField, this._fontFamilyField = this._spec.fontFamilyField, this._fontWeightField = this._spec.fontWeightField, this._fontStyleField = this._spec.fontStyleField, this._colorHexField = this._spec.colorHexField, this._colorMode = null !== (_a = this._spec.colorMode) && void 0 !== _a ? _a : "ordinal", this._colorList = this._spec.colorList, this.setValueField(this._spec.valueField), this._fontWeightRange = null !== (_b = this._spec.fontWeightRange) && void 0 !== _b ? _b : DEFAULT_FONT_WEIGHT_RANGE, this._rotateAngles = null !== (_c = this._spec.rotateAngles) && void 0 !== _c ? _c : DEFAULT_ROTATE_ANGLES, this.setFontSizeRange(this._spec.fontSizeRange), this._maskShape = null !== (_d = this._spec.maskShape) && void 0 !== _d ? _d : DEFAULT_MASK_SHAPE, this._keepAspect = this._spec.keepAspect, this._random = null !== (_e = this._spec.random) && void 0 !== _e ? _e : DEFAULT_RANDOM, this._fontPadding = null !== (_g = null === (_f = this._spec.word) || void 0 === _f ? void 0 : _f.padding) && void 0 !== _g ? _g : DEFAULT_FONT_PADDING, this._textField = (null === (_h = this._spec.word) || void 0 === _h ? void 0 : _h.formatMethod) ? WORD_CLOUD_TEXT : this._nameField, this._wordCloudConfig = Object.assign({
      drawOutOfBound: DEFAULT_DRAW_OUT_OF_BOUND,
      layoutMode: "default",
      zoomToFit: DEFAULT_ZOOM_TO_FIT
    }, this._spec.wordCloudConfig), this._wordCloudShapeConfig = Object.assign({
      fillingSeriesField: this.getSeriesField(),
      fillingRotateAngles: DEFAULT_ROTATE_ANGLES,
      layoutMode: "default"
    }, this._spec.wordCloudShapeConfig), this._fillingFontPadding = null !== (_k = null === (_j = this._spec.fillingWord) || void 0 === _j ? void 0 : _j.padding) && void 0 !== _k ? _k : DEFAULT_FONT_PADDING, this._isWordCloudShape = !SHAPE_TYPE.includes(this._maskShape), this._defaultFontFamily = this._option.getTheme().fontFamily;
  }
  initMark() {
    this._wordMark = this._createMark(_BaseWordCloudSeries.mark.word, {
      defaultMorphElementKey: this._seriesField,
      groupKey: this._seriesField,
      isSeriesMark: true
    }), this._isWordCloudShape && (this._fillingWordMark = this._createMark(_BaseWordCloudSeries.mark.fillingWord));
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const wordMark = this._wordMark, fillingWordMark = this._fillingWordMark, wordSpec = null !== (_a = this._spec.word) && void 0 !== _a ? _a : {};
    wordMark && (this.setMarkStyle(wordMark, {
      fill: this._colorHexField ? (datum) => datum[this._colorHexField] : this.getWordColorAttribute(this._seriesField, false),
      text: (datum) => datum[this._textField],
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      fontFamily: (datum) => datum.fontFamily,
      fontSize: (datum) => datum.fontSize,
      fontStyle: (datum) => datum.fontStyle,
      fontWeight: (datum) => datum.fontWeight,
      angle: (datum) => datum.angle,
      visible: (datum) => !datum.isFillingWord && datum.visible
    }, "normal", AttributeLevel.Series), this.setMarkStyle(wordMark, {
      fontFamily: null !== (_c = null === (_b = wordSpec.style) || void 0 === _b ? void 0 : _b.fontFamily) && void 0 !== _c ? _c : this._defaultFontFamily
    }, "normal", AttributeLevel.User_Mark)), fillingWordMark && (this.setMarkStyle(fillingWordMark, {
      fill: this._wordCloudShapeConfig.fillingColorHexField ? (datum) => datum[this._wordCloudShapeConfig.fillingColorHexField] : this.getWordColorAttribute(this._wordCloudShapeConfig.fillingSeriesField, true),
      text: (datum) => datum[this._textField],
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      fontFamily: (datum) => datum.fontFamily,
      fontSize: (datum) => datum.fontSize,
      fontStyle: (datum) => datum.fontStyle,
      fontWeight: (datum) => datum.fontWeight,
      angle: (datum) => datum.angle,
      visible: (datum) => datum.isFillingWord && datum.visible
    }, "normal", AttributeLevel.Series), this.setMarkStyle(fillingWordMark, {
      fontFamily: null !== (_e = null === (_d = wordSpec.style) || void 0 === _d ? void 0 : _d.fontFamily) && void 0 !== _e ? _e : this._defaultFontFamily
    }, "normal", AttributeLevel.User_Mark)), this._trigger.registerMark(wordMark), this._trigger.registerMark(fillingWordMark);
  }
  initTooltip() {
    super.initTooltip(), this._wordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._wordMark), this._fillingWordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._fillingWordMark);
  }
  initAnimation() {
    [this._wordMark, this._fillingWordMark].forEach((mark) => {
      var _a, _b;
      if (mark) {
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params2 = {
          animationConfig: () => {
            var _a2, _b2;
            return null === (_b2 = null === (_a2 = mark.getAnimationConfig()) || void 0 === _a2 ? void 0 : _a2.appear) || void 0 === _b2 ? void 0 : _b2[0];
          }
        };
        mark.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("wordCloud")(params2, appearPreset), userAnimationConfig("word", this._spec, this._markAttributeContext)));
      }
    });
  }
  getWordOrdinalColorScale(field5, isFillingWord) {
    var _a, _b, _c, _d, _e;
    const colorList = isFillingWord ? this._wordCloudShapeConfig.fillingColorList : this._colorList, colorDomain = field5 ? null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum) => datum[field5]) : [], colorRange = null !== (_c = null != colorList ? colorList : null === (_b = this._option.globalScale.getScale("color")) || void 0 === _b ? void 0 : _b.range()) && void 0 !== _c ? _c : this._getDataScheme();
    return null === (_e = (_d = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _e ? void 0 : _e.call(_d, colorRange);
  }
  getWordColorAttribute(field5, isFillingWord) {
    var _a, _b;
    if ("ordinal" === this._colorMode) return {
      scale: this.getWordOrdinalColorScale(field5, isFillingWord),
      field: null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD
    };
    let colorList = null !== (_b = isFillingWord ? this._colorList : this._wordCloudShapeConfig.fillingColorList) && void 0 !== _b ? _b : this._option.globalScale.getScale("color").range();
    return 1 === colorList.length && (colorList = [colorList[0], colorList[0]]), (datum) => colorList[0];
  }
  compile() {
    var _a, _b;
    super.compile();
    const { width, height } = this._region.getLayoutRect();
    if (!isValidNumber_default(width) || !isValidNumber_default(height) || !(height > 0 && width > 0)) return;
    const wordCloudTransforms = [], valueField = this._valueField, valueScale = new LinearScale(), fontWeightRange = this._fontWeightRange, rotateAngles = this._rotateAngles, fillingRotateAngles = this._wordCloudShapeConfig.fillingRotateAngles;
    if (valueField) {
      const [minValue, maxValue] = extent2(null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum) => +datum[valueField]));
      valueScale.domain([minValue, maxValue], true).range(fontWeightRange), wordCloudTransforms.push({
        type: "map",
        as: WORD_CLOUD_WEIGHT,
        callback: (datum) => minValue === maxValue ? valueScale.scale(maxValue) : valueScale.scale(datum[valueField])
      });
    }
    wordCloudTransforms.push({
      type: "map",
      as: WORD_CLOUD_ANGLE,
      callback: () => rotateAngles[Math.floor(Math.random() * rotateAngles.length)]
    }), wordCloudTransforms.push({
      type: "map",
      as: WORD_CLOUD_FILLING_ANGLE,
      callback: () => fillingRotateAngles[Math.floor(Math.random() * fillingRotateAngles.length)]
    });
    const wordSpec = null !== (_b = this._spec.word) && void 0 !== _b ? _b : {};
    wordSpec.formatMethod && wordCloudTransforms.push({
      type: "map",
      as: WORD_CLOUD_TEXT,
      callback: wordSpec.formatMethod
    }), this._isWordCloudShape ? wordCloudTransforms.push(Object.assign({
      type: "wordcloudShape"
    }, this._wordCloudShapeTransformOption())) : (wordCloudTransforms.push(Object.assign({
      type: "wordcloud"
    }, this._wordCloudTransformOption())), this._wordMark.getProduct().transform(wordCloudTransforms)), this._data.getProduct().transform(wordCloudTransforms);
  }
  _wordCloudTransformOption() {
    var _a, _b, _c, _d, _e;
    const { width, height } = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    return {
      layoutType: isTrueBrowser(this._option.mode) ? this._wordCloudConfig.layoutMode : "fast",
      size: [width, height],
      shape: this._maskShape,
      dataIndexKey: DEFAULT_DATA_KEY,
      text: {
        field: this._textField
      },
      fontSize: this._valueField ? {
        field: this._valueField
      } : this._fontSizeRange[0],
      fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
      padding: this._fontPadding,
      rotate: {
        field: WORD_CLOUD_ANGLE
      },
      fontFamily: null !== (_d = null !== (_c = this._fontFamilyField) && void 0 !== _c ? _c : wordStyleSpec.fontFamily) && void 0 !== _d ? _d : this._defaultFontFamily,
      fontWeight: this._fontWeightField ? {
        field: this._fontWeightField
      } : this._valueField ? {
        field: WORD_CLOUD_WEIGHT
      } : null,
      fontStyle: null !== (_e = this._fontStyleField) && void 0 !== _e ? _e : wordStyleSpec.fontStyle,
      randomVisible: this._random,
      clip: "clip" === this._wordCloudConfig.drawOutOfBound,
      shrink: this._wordCloudConfig.zoomToFit.shrink,
      enlarge: this._wordCloudConfig.zoomToFit.enlarge,
      minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
      progressiveTime: this._wordCloudConfig.progressiveTime,
      progressiveStep: this._wordCloudConfig.progressiveStep
    };
  }
  _wordCloudShapeTransformOption() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const { width, height } = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {}, wordCloudShapeConfig = null !== (_c = this._wordCloudShapeConfig) && void 0 !== _c ? _c : {}, fillingRotateAngles = this._wordCloudShapeConfig.fillingRotateAngles;
    return {
      dataIndexKey: DEFAULT_DATA_KEY,
      size: [width, height],
      shape: this._maskShape,
      text: {
        field: this._textField
      },
      fontSize: this._valueField ? {
        field: this._valueField
      } : this._fontSizeRange[0],
      fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
      padding: this._fontPadding,
      rotateList: this._rotateAngles,
      fontFamily: null !== (_e = null !== (_d = this._fontFamilyField) && void 0 !== _d ? _d : wordStyleSpec.fontFamily) && void 0 !== _e ? _e : this._defaultFontFamily,
      fontWeight: this._fontWeightField ? {
        field: this._fontWeightField
      } : this._valueField ? {
        field: WORD_CLOUD_WEIGHT
      } : null,
      fontStyle: null !== (_f = this._fontStyleField) && void 0 !== _f ? _f : wordStyleSpec.fontStyle,
      fillingFontFamily: null !== (_h = null !== (_g = wordCloudShapeConfig.fillingFontFamilyField) && void 0 !== _g ? _g : wordStyleSpec.fontFamily) && void 0 !== _h ? _h : this._defaultFontFamily,
      fillingPadding: this._fillingFontPadding,
      fillingFontStyle: null !== (_j = wordCloudShapeConfig.fillingFontStyleField) && void 0 !== _j ? _j : wordStyleSpec.fontStyle,
      fillingFontWeight: null !== (_k = wordCloudShapeConfig.fillingFontWeightField) && void 0 !== _k ? _k : wordStyleSpec.fontWeight,
      fillingRotateList: fillingRotateAngles,
      fillingTimes: wordCloudShapeConfig.fillingTimes,
      fillingXStep: wordCloudShapeConfig.fillingXStep,
      fillingYStep: wordCloudShapeConfig.fillingYStep,
      fillingXRatioStep: wordCloudShapeConfig.fillingXRatioStep,
      fillingYRatioStep: wordCloudShapeConfig.fillingYRatioStep,
      fillingInitialOpacity: wordCloudShapeConfig.fillingInitialOpacity,
      fillingDeltaOpacity: wordCloudShapeConfig.fillingDeltaOpacity,
      fillingInitialFontSize: wordCloudShapeConfig.fillingInitialFontSize,
      fillingDeltaFontSize: wordCloudShapeConfig.fillingDeltaFontSize,
      ratio: wordCloudShapeConfig.ratio,
      fillingRatio: wordCloudShapeConfig.fillingRatio,
      removeWhiteBorder: wordCloudShapeConfig.removeWhiteBorder,
      textLayoutTimes: wordCloudShapeConfig.textLayoutTimes,
      fontSizeShrinkFactor: wordCloudShapeConfig.fontSizeShrinkFactor,
      stepFactor: wordCloudShapeConfig.stepFactor,
      layoutMode: wordCloudShapeConfig.layoutMode,
      importantWordCount: wordCloudShapeConfig.importantWordCount,
      globalShinkLimit: wordCloudShapeConfig.globalShinkLimit,
      fontSizeEnlargeFactor: wordCloudShapeConfig.fontSizeEnlargeFactor,
      fillingDeltaFontSizeFactor: wordCloudShapeConfig.fillingDeltaFontSizeFactor
    };
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  dataToPosition(data) {
    return null;
  }
  dataToPositionX(data) {
    return null;
  }
  dataToPositionY(data) {
    return null;
  }
  dataToPositionZ(data) {
    return null;
  }
  valueToPosition(value1, value2) {
    return null;
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.compile();
  }
  getActiveMarks() {
    return [this._wordMark, this._fillingWordMark];
  }
};
BaseWordCloudSeries.mark = wordCloudSeriesMark;

// node_modules/@visactor/vchart/esm/series/word-cloud/animation.js
var WordCloud3dAnimation = (params2) => ({
  custom: RotateBySphereAnimate,
  customParameters: (datum, element) => params2,
  easing: "linear",
  loop: 1 / 0,
  duration: 6e3
});
function computeWordDelay(duration, totalTime, wordCount) {
  return duration * wordCount < totalTime ? duration + (totalTime - wordCount * duration) / (wordCount - 1) : (totalTime - duration) / (wordCount - 1);
}
var WordCloudScaleInAnimation = (params2) => ({
  channel: {
    fontSize: {
      from: 0
    }
  },
  duration: 200,
  delay: (datum, element, vgrammarParams) => {
    const animationConfig2 = params2.animationConfig(), duration = (null == animationConfig2 ? void 0 : animationConfig2.duration) || 200, totalTime = (null == animationConfig2 ? void 0 : animationConfig2.totalTime) || DEFAULT_ANIMATION_CONFIG.appear.duration, count = vgrammarParams.VGRAMMAR_ANIMATION_PARAMETERS.elementCount;
    return vgrammarParams.VGRAMMAR_ANIMATION_PARAMETERS.elementIndex * computeWordDelay(duration, totalTime, count);
  }
});
function wordcloudPresetAnimation(params2, preset) {
  return false === preset ? {} : "fadeIn" === preset ? {
    type: "fadeIn"
  } : WordCloudScaleInAnimation(params2);
}
var registerWordCloudAnimation = () => {
  Factory2.registerAnimation("wordCloud", (params2, preset) => ({
    appear: wordcloudPresetAnimation(params2, preset),
    enter: {
      type: "fadeIn"
    },
    exit: {
      type: "fadeOut"
    },
    disappear: {
      type: "fadeOut"
    }
  }));
};
var registerWordCloud3dAnimation = () => {
  Factory2.registerAnimation("wordCloud3d", (params2) => ({
    appear: WordCloud3dAnimation(params2)
  }));
};

// node_modules/@visactor/vgrammar-wordcloud/es/shapes.js
var shapes = {
  triangleForward,
  triangleUpright: triangle,
  triangle,
  diamond: diamond2,
  square: square3,
  star: star2,
  cardioid,
  circle: circle3,
  pentagon
};
function diamond2() {
  return function(theta) {
    const thetaPrime = theta % (2 * Math.PI / 4);
    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
  };
}
function star2() {
  return function(theta) {
    const thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);
    return (theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0 ? 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime)) : 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));
  };
}
function square3() {
  return function(theta) {
    return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
  };
}
function triangle() {
  return function(theta) {
    const thetaPrime = (theta + 3 * Math.PI / 2) % (2 * Math.PI / 3);
    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
  };
}
function triangleForward() {
  return function(theta) {
    const thetaPrime = theta % (2 * Math.PI / 3);
    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
  };
}
function cardioid() {
  return function(theta) {
    return 1 - Math.sin(theta);
  };
}
function circle3() {
  return function() {
    return 1;
  };
}
function pentagon() {
  return function(theta) {
    const thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);
    return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));
  };
}
function getMaxRadiusAndCenter(shape, size) {
  const w2 = size[0], h2 = size[1];
  let maxRadius = 1;
  const center2 = [size[0] >> 1, size[1] >> 1];
  switch (shape) {
    case "cardioid":
      center2[1] = ~~(h2 / 2.7 * 0.6), maxRadius = Math.floor(Math.min(w2 / 2.3, h2 / 2.6));
      break;
    case "triangleForward":
      maxRadius = h2 / Math.sqrt(0.75) > w2 ? Math.floor(w2 / 2) : Math.floor(h2 / (2 * Math.sqrt(0.75)));
      break;
    case "triangle":
    case "triangleUpright":
      center2[1] = ~~(h2 / 1.5), maxRadius = Math.floor(Math.min(h2 / 1.5, w2 / 2));
      break;
    case "rect":
      maxRadius = Math.floor(Math.max(h2 / 2, w2 / 2));
      break;
    default:
      maxRadius = Math.floor(Math.min(w2 / 2, h2 / 2));
  }
  return {
    maxRadius,
    center: center2
  };
}
var getShapeFunction = (type) => shapes[type] ? shapes[type]() : shapes.circle();

// node_modules/@visactor/vgrammar-wordcloud/es/util.js
var randomHslColor = (min4, max4) => "hsl(" + (360 * Math.random()).toFixed() + "," + (30 * Math.random() + 70).toFixed() + "%," + (Math.random() * (max4 - min4) + min4).toFixed() + "%)";
function functor(d2) {
  return isFunction_default(d2) ? d2 : function() {
    return d2;
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/base.js
var BaseLayout = class _BaseLayout {
  constructor(options) {
    var _a, _b;
    switch (this.options = merge({}, _BaseLayout.defaultOptions, options), isFunction_default(this.options.shape) ? this.shape = this.options.shape : this.shape = getShapeFunction(this.options.shape), this.getText = null !== (_a = functor(this.options.text)) && void 0 !== _a ? _a : (d2) => d2, this.getTextFontWeight = functor(this.options.fontWeight), this.getTextFontSize = functor(this.options.fontSize), this.getTextFontStyle = functor(this.options.fontStyle), this.getTextFontFamily = functor(this.options.fontFamily), this.outputCallback = null !== (_b = this.options.outputCallback) && void 0 !== _b ? _b : (res) => res, this.options.color) {
      case "random-dark":
        this.getTextColor = () => randomHslColor(10, 50);
        break;
      case "random-light":
        this.getTextColor = () => randomHslColor(50, 90);
        break;
      default:
        this.getTextColor = functor(this.options.color);
    }
    if (isNil_default(this.options.rotate)) if (this.options.useRandomRotate) {
      const rotationRange = Math.abs(this.options.maxRotation - this.options.minRotation), rotationSteps = Math.abs(Math.floor(this.options.rotationSteps)), minRotation = Math.min(this.options.maxRotation, this.options.minRotation);
      this.getTextRotate = () => 0 === this.options.rotateRatio || Math.random() > this.options.rotateRatio ? 0 : 0 === rotationRange ? minRotation : rotationSteps > 0 ? minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1) : minRotation + Math.random() * rotationRange;
    } else this.getTextRotate = () => 0;
    else this.getTextRotate = isFunction_default(this.options.rotate) ? (d2) => {
      var _a2;
      return degreeToRadian(null !== (_a2 = this.options.rotate(d2)) && void 0 !== _a2 ? _a2 : 0);
    } : () => {
      var _a2;
      return degreeToRadian(null !== (_a2 = this.options.rotate) && void 0 !== _a2 ? _a2 : 0);
    };
  }
  exceedTime() {
    var _a;
    return this.options.progressiveStep > 0 ? this.progressiveIndex >= ((null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : 0) + 1) * this.options.progressiveStep : this.options.progressiveTime > 0 && (/* @__PURE__ */ new Date()).getTime() - this.escapeTime > this.options.progressiveTime;
  }
  progressiveRun() {
    var _a;
    if (this.options.progressiveStep > 0 ? this.currentStepIndex = (null !== (_a = this.currentStepIndex) && void 0 !== _a ? _a : 0) + 1 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), this.data && this.progressiveIndex && this.progressiveIndex < this.data.length) {
      this.progressiveResult = [];
      const len = this.data.length;
      let i2 = this.progressiveIndex;
      for (; i2 < len; ) {
        this.layoutWord(i2);
        if (i2++, this.progressiveIndex = i2, this.exceedTime()) break;
      }
      return this.progressiveResult;
    }
    return this.result;
  }
  initProgressive() {
    this.progressiveIndex = -1, this.options.progressiveStep > 0 ? this.currentStepIndex = 0 : this.options.progressiveTime > 0 && (this.escapeTime = Date.now()), this.progressiveResult = [];
  }
  output() {
    return this.result ? this.outputCallback(this.result) : null;
  }
  progressiveOutput() {
    return this.progressiveResult ? this.outputCallback(this.progressiveResult) : null;
  }
  unfinished() {
    return this.data && this.data.length && !isNil_default(this.progressiveIndex) && this.progressiveIndex < this.data.length;
  }
  release() {
    this.data = null, this.result = null, this.progressiveIndex = null, this.progressiveResult = null;
  }
};
BaseLayout.defaultOptions = {
  fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", "Arial Unicode MS", "Droid Fallback Sans", sans-serif',
  fontWeight: "normal",
  color: "random-dark",
  fontStyle: "normal",
  minFontSize: 12,
  drawOutOfBound: false,
  shrink: false,
  minRotation: -Math.PI / 2,
  maxRotation: Math.PI / 2,
  rotationSteps: 0,
  rotateRatio: 0.1,
  random: false,
  shape: "circle",
  progressiveTime: 0,
  progressiveStep: 0,
  backgroundColor: "#fff"
};

// node_modules/@visactor/vgrammar-wordcloud/es/spirals.js
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function archimedeanSpiral(size) {
  const e3 = size[0] / size[1];
  return (t2) => [e3 * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
}
function rectangularSpiral(size) {
  const dx = 4 * size[0] / size[1];
  let x3 = 0, y3 = 0;
  return (t2) => {
    const sign4 = t2 < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign4 * t2) - sign4 & 3) {
      case 0:
        x3 += dx;
        break;
      case 1:
        y3 += 4;
        break;
      case 2:
        x3 -= dx;
        break;
      default:
        y3 -= 4;
    }
    return [x3, y3];
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/cloud-layout.js
var CloudLayout = class _CloudLayout extends BaseLayout {
  constructor(options) {
    var _a;
    super(merge({}, _CloudLayout.defaultOptions, options)), this.cw = 64, this.ch = 2048, this._size = [256, 256], this._isBoardExpandCompleted = false, this._placeStatus = 0, this._tTemp = null, this._dtTemp = null, this._dy = 0, this.cacheMap = /* @__PURE__ */ new Map(), this.options.minFontSize <= _CloudLayout.defaultOptions.minFontSize && (this.options.minFontSize = _CloudLayout.defaultOptions.minFontSize), this.spiral = isString_default(this.options.spiral) ? null !== (_a = spirals[this.options.spiral]) && void 0 !== _a ? _a : spirals.archimedean : this.options.spiral, this.random = this.options.random ? Math.random : () => 1, this.getTextPadding = functor(this.options.padding);
  }
  zoomRatio() {
    return this._originSize[0] / this._size[0];
  }
  dy() {
    return this._dy;
  }
  layoutWord(index) {
    const d2 = this.data[index];
    if ("" === ("" + d2.text).trim()) return true;
    const { maxRadius, center: center2 } = getMaxRadiusAndCenter(this.options.shape, this._size);
    if (d2.x = center2[0], d2.y = center2[1], cloudSprite(this.contextAndRatio, d2, this.data, index, this.cw, this.ch), this._placeStatus = 0, d2.hasText && this.place(this._board, d2, this._bounds, maxRadius)) return this.result.push(d2), this._bounds ? cloudBounds(this._bounds, d2) : this._bounds = [{
      x: d2.x + d2.x0,
      y: d2.y + d2.y0
    }, {
      x: d2.x + d2.x1,
      y: d2.y + d2.y1
    }], d2.x -= this._size[0] >> 1, d2.y -= this._size[1] >> 1, this._tTemp = null, this._dtTemp = null, true;
    if (this.updateBoardExpandStatus(d2.fontSize), d2.hasText && this.shouldShrinkContinue()) {
      if (1 === this._placeStatus) {
        const maxSize0 = d2.fontSize * this._originSize[0] / this.options.minFontSize, distSize0 = Math.max(d2.width, d2.height);
        if (distSize0 <= maxSize0) this.expandBoard(this._board, this._bounds, distSize0 / this._size[0]);
        else {
          if (!this.options.clip) return true;
          this.expandBoard(this._board, this._bounds, maxSize0 / this._size[0]);
        }
      } else this._placeStatus, this.expandBoard(this._board, this._bounds);
      return this.updateBoardExpandStatus(d2.fontSize), false;
    }
    return this._tTemp = null, this._dtTemp = null, true;
  }
  layout(words, config2) {
    this.initProgressive(), this.result = [], this._size = [config2.width, config2.height], this.clearCache(), this._originSize = [...this._size];
    const contextAndRatio = this.getContext(vglobal.createCanvas({
      width: 1,
      height: 1
    }));
    this.contextAndRatio = contextAndRatio, this._board = new Array((this._size[0] >> 5) * this._size[1]).fill(0), this._bounds = null;
    const n2 = words.length;
    let i2 = 0;
    this.result = [];
    const data = words.map((d2) => ({
      text: this.getText(d2),
      fontFamily: this.getTextFontFamily(d2),
      fontStyle: this.getTextFontStyle(d2),
      fontWeight: this.getTextFontWeight(d2),
      angle: this.getTextRotate(d2),
      fontSize: ~~this.getTextFontSize(d2),
      padding: this.getTextPadding(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    })).sort(function(a4, b2) {
      return b2.fontSize - a4.fontSize;
    });
    this.data = data;
    let curWordTryCount = 0;
    for (; i2 < n2; ) {
      if (this.layoutWord(i2) || curWordTryCount >= 2 ? (i2++, curWordTryCount = 0) : curWordTryCount++, this.progressiveIndex = i2, this.exceedTime()) break;
    }
    if (!this.options.clip && this.options.enlarge && this._bounds && this.shrinkBoard(this._bounds), this._bounds && ["cardioid", "triangle", "triangle-upright"].includes(this.options.shape)) {
      const currentCenterY = (this._bounds[0].y + this._bounds[1].y) / 2;
      this._dy = -(currentCenterY - this._size[1] / 2);
    }
    return this.result;
  }
  formatTagItem(words) {
    const size = this._size, zoomRatio = this.zoomRatio(), globalDy = this.dy(), dx = size[0] >> 1, dy = size[1] >> 1, n2 = words.length, result2 = [];
    let w2, t2;
    for (let i2 = 0; i2 < n2; ++i2) w2 = words[i2], t2 = {}, t2.datum = w2.datum, t2.x = (w2.x + dx) * zoomRatio, t2.y = (w2.y + dy + globalDy) * zoomRatio, t2.fontFamily = w2.fontFamily, t2.fontSize = w2.fontSize * zoomRatio, t2.fontStyle = w2.fontStyle, t2.fontWeight = w2.fontWeight, t2.angle = w2.angle, result2.push(t2);
    return result2;
  }
  output() {
    return this.outputCallback ? this.outputCallback(this.formatTagItem(this.result)) : this.formatTagItem(this.result);
  }
  progressiveOutput() {
    return this.outputCallback ? this.outputCallback(this.formatTagItem(this.progressiveResult)) : this.formatTagItem(this.progressiveResult);
  }
  updateBoardExpandStatus(fontSize) {
    this._isBoardExpandCompleted = fontSize * (this._originSize[0] / this._size[0]) < this.options.minFontSize;
  }
  shouldShrinkContinue() {
    return !this.options.clip && this.options.shrink && !this._isBoardExpandCompleted;
  }
  shrinkBoard(bounds) {
    const leftTopPoint = bounds[0], rightBottomPoint = bounds[1];
    if (rightBottomPoint.x >= this._size[0] || rightBottomPoint.y >= this._size[1]) return;
    const minXValue = Math.min(leftTopPoint.x, this._size[0] - rightBottomPoint.x), minYValue = Math.min(leftTopPoint.y, this._size[1] - rightBottomPoint.y), minRatio = 2 * Math.min(minXValue / this._size[0], minYValue / this._size[1]);
    this._size = this._size.map((v2) => v2 * (1 - minRatio));
  }
  expandBoard(board, bounds, factor) {
    const expandedLeftWidth = this._size[0] * (factor || 1.1) - this._size[0] >> 5;
    let diffWidth = 2 * expandedLeftWidth > 2 ? expandedLeftWidth : 2;
    diffWidth % 2 != 0 && diffWidth++;
    let diffHeight = Math.ceil(this._size[1] * (diffWidth << 5) / this._size[0]);
    diffHeight % 2 != 0 && diffHeight++;
    const w2 = this._size[0], h2 = this._size[1], widthArr = new Array(diffWidth).fill(0), heightArr = new Array(diffHeight / 2 * (diffWidth + (w2 >> 5))).fill(0);
    this.insertZerosToArray(board, h2 * (w2 >> 5), heightArr.length + diffWidth / 2);
    for (let i2 = h2 - 1; i2 > 0; i2--) this.insertZerosToArray(board, i2 * (w2 >> 5), widthArr.length);
    this.insertZerosToArray(board, 0, heightArr.length + diffWidth / 2), this._size = [w2 + (diffWidth << 5), h2 + diffHeight], bounds && (bounds[0].x += (diffWidth << 5) / 2, bounds[0].y += diffHeight / 2, bounds[1].x += (diffWidth << 5) / 2, bounds[1].y += diffHeight / 2);
  }
  insertZerosToArray(array2, index, length2) {
    const len = Math.floor(length2 / 6e4), restLen = length2 % 6e4;
    for (let i2 = 0; i2 < len; i2++) array2.splice(index + 6e4 * i2, 0, ...new Array(6e4).fill(0));
    array2.splice(index + 6e4 * len, 0, ...new Array(restLen).fill(0));
  }
  getContext(canvas) {
    canvas.width = 1, canvas.height = 1;
    const imageData = canvas.getContext("2d").getImageData(0, 0, 1, 1), ratio = Math.sqrt(imageData.data.length >> 2);
    canvas.width = (this.cw << 5) / ratio, canvas.height = this.ch / ratio;
    const context = canvas.getContext("2d");
    return context.fillStyle = context.strokeStyle = "red", context.textAlign = "center", {
      context,
      ratio,
      canvas
    };
  }
  place(board, tag, bounds, maxRadius) {
    let isCollide = false;
    if (this.shouldShrinkContinue() && (tag.width > this._size[0] || tag.height > this._size[1])) return this._placeStatus = 1, false;
    const dt = this.random() < 0.5 ? 1 : -1;
    if (!this.shouldShrinkContinue() && this.isSizeLargerThanMax(tag, dt)) return null;
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(this._size[0] * this._size[0] + this._size[1] * this._size[1]), s3 = this.spiral(this._size);
    let dxdy, dx, dy, _tag, t2 = -dt;
    for (this._tTemp = null, this._dtTemp = null; dxdy = s3(t2 += dt); ) {
      dx = dxdy[0], dy = dxdy[1];
      const radius = Math.sqrt(dx ** 2 + dy ** 2);
      let rad = Math.atan(dy / dx);
      dx < 0 ? rad += Math.PI : dy < 0 && (rad = 2 * Math.PI + rad);
      const rx = this.shape(rad);
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      if (radius >= maxRadius) isCollide && null === this._tTemp && (this._tTemp = t2, this._dtTemp = dt);
      else {
        if (tag.x = startX + ~~(radius * rx * Math.cos(-rad)), tag.y = startY + ~~(radius * rx * Math.sin(-rad)), _tag = tag, this.options.clip) if (this.shouldShrinkContinue()) {
          if (isPartOutside(_tag, this._size)) {
            isCollide && null === this._tTemp && (this._tTemp = t2, this._dtTemp = dt);
            continue;
          }
        } else {
          if (isFullOutside(_tag, this._size)) {
            isCollide && null === this._tTemp && (this._tTemp = t2, this._dtTemp = dt);
            continue;
          }
          isPartOutside(_tag, this._size) && (_tag = clipInnerTag(_tag, this._size));
        }
        else if (isPartOutside(_tag, this._size)) {
          isCollide && null === this._tTemp && (this._tTemp = t2, this._dtTemp = dt);
          continue;
        }
        if (isCollide = true, (!bounds || collideRects(_tag, bounds)) && (!bounds || !cloudCollide(_tag, board, this._size))) {
          const sprite = _tag.sprite, w2 = _tag.width >> 5, sw = this._size[0] >> 5, lx = _tag.x - (w2 << 4), sx = 127 & lx, msx = 32 - sx, h2 = _tag.y1 - _tag.y0;
          let last2, x3 = (_tag.y + _tag.y0) * sw + (lx >> 5);
          for (let j2 = 0; j2 < h2; j2++) {
            last2 = 0;
            for (let i2 = 0; i2 <= w2; i2++) board[x3 + i2] |= last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0);
            x3 += sw;
          }
          return tag.sprite = null, _tag.sprite = null, true;
        }
      }
    }
    return null !== this._tTemp && (this._placeStatus = 3), !this.shouldShrinkContinue() && this.setCache(_tag, dt), false;
  }
  clearCache() {
    this.cacheMap.clear();
  }
  setCache(tag, dt) {
    const cacheKey = `${tag.angle}-${dt}`, w2 = tag.x1 - tag.x0, h2 = tag.y1 - tag.y0;
    if (!this.cacheMap.has(cacheKey)) return void this.cacheMap.set(cacheKey, {
      width: w2,
      height: h2
    });
    const { width, height } = this.cacheMap.get(cacheKey);
    (w2 < width && h2 < height || w2 <= width && h2 < height) && this.cacheMap.set(cacheKey, {
      width: w2,
      height: h2
    });
  }
  isSizeLargerThanMax(tag, dt) {
    const cacheKey = `${tag.angle}-${dt}`;
    if (!this.cacheMap.has(cacheKey)) return false;
    const { width, height } = this.cacheMap.get(cacheKey), w2 = tag.x1 - tag.x0, h2 = tag.y1 - tag.y0;
    return w2 >= width && h2 >= height;
  }
};
function cloudSprite(contextAndRatio, d2, data, di, cw, ch) {
  if (d2.sprite) return;
  const c4 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c4.setTransform(ratio, 0, 0, ratio, 0, 0), c4.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x3 = 0, y3 = 0, maxh = 0;
  const n2 = data.length;
  let w2, w32, h2, i2, j2;
  for (--di; ++di < n2; ) {
    if (d2 = data[di], c4.save(), c4.font = d2.fontStyle + " " + d2.fontWeight + " " + ~~((d2.fontSize + 1) / ratio) + "px " + d2.fontFamily, w2 = c4.measureText(d2.text + "m").width * ratio, h2 = d2.fontSize << 1, d2.angle) {
      const sr = Math.sin(d2.angle), cr = Math.cos(d2.angle), wcr = w2 * cr, wsr = w2 * sr, hcr = h2 * cr, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5, h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else w2 = w2 + 31 >> 5 << 5;
    if (h2 > maxh && (maxh = h2), x3 + w2 >= cw << 5 && (x3 = 0, y3 += maxh, maxh = 0), y3 + h2 >= ch) break;
    c4.translate((x3 + (w2 >> 1)) / ratio, (y3 + (h2 >> 1)) / ratio), d2.angle && c4.rotate(d2.angle), c4.fillText(d2.text, 0, 0), d2.padding && (c4.lineWidth = 2 * d2.padding, c4.strokeText(d2.text, 0, 0)), c4.restore(), d2.width = w2, d2.height = h2, d2.xoff = x3, d2.yoff = y3, d2.x1 = w2 >> 1, d2.y1 = h2 >> 1, d2.x0 = -d2.x1, d2.y0 = -d2.y1, d2.hasText = true, x3 += w2;
  }
  const pixels = c4.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  for (; --di >= 0; ) {
    if (!(d2 = data[di]).hasText) continue;
    for (w2 = d2.width, w32 = w2 >> 5, h2 = d2.y1 - d2.y0, i2 = 0; i2 < h2 * w32; i2++) sprite[i2] = 0;
    if (x3 = d2.xoff, null == x3) return;
    y3 = d2.yoff;
    let seen = 0, seenRow = -1;
    for (j2 = 0; j2 < h2; j2++) {
      for (i2 = 0; i2 < w2; i2++) {
        const k3 = w32 * j2 + (i2 >> 5), m5 = pixels[(y3 + j2) * (cw << 5) + (x3 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
        sprite[k3] |= m5, seen |= m5;
      }
      seen ? seenRow = j2 : (d2.y0++, h2--, j2--, y3++);
    }
    d2.y1 = d2.y0 + seenRow, d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
  }
}
function cloudCollide(tag, board, size) {
  const sw = size[0] >> 5, sprite = tag.sprite, w2 = tag.width >> 5, lx = tag.x - (w2 << 4), sx = 127 & lx, msx = 32 - sx, h2 = tag.y1 - tag.y0;
  let last2, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
  for (let j2 = 0; j2 < h2; j2++) {
    last2 = 0;
    for (let i2 = 0; i2 <= w2; i2++) if ((last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0)) & board[x3 + i2]) return true;
    x3 += sw;
  }
  return false;
}
function cloudBounds(bounds, d2) {
  const b0 = bounds[0], b1 = bounds[1];
  d2.x + d2.x0 < b0.x && (b0.x = d2.x + d2.x0), d2.y + d2.y0 < b0.y && (b0.y = d2.y + d2.y0), d2.x + d2.x1 > b1.x && (b1.x = d2.x + d2.x1), d2.y + d2.y1 > b1.y && (b1.y = d2.y + d2.y1);
}
function collideRects(a4, b2) {
  return a4.x + a4.x1 > b2[0].x && a4.x + a4.x0 < b2[1].x && a4.y + a4.y1 > b2[0].y && a4.y + a4.y0 < b2[1].y;
}
CloudLayout.defaultOptions = {
  enlarge: false,
  minFontSize: 2
};
var isFullOutside = (tag, size) => tag.x + tag.x0 > size[0] || tag.y + tag.y0 > size[0] || tag.x + tag.x1 < 0 || tag.y + tag.y1 < 0;
var isPartOutside = (tag, size) => tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1];
function clipInnerTag(tag, size) {
  const sprite = tag.sprite, h2 = tag.y1 - tag.y0, w2 = tag.width >> 5;
  let x3 = 0;
  const _sprite = [], js = Math.max(-(tag.y0 + tag.y), 0), je = Math.min(h2 + (size[1] - (tag.y1 + tag.y)), h2), is = Math.max(-(tag.x0 + tag.x), 0) >> 5, ie = Math.min(w2 + (size[0] - (tag.x1 + tag.x) >> 5) + 1, w2);
  for (let j2 = 0; j2 < h2; j2++) {
    for (let i2 = 0; i2 < w2; i2++) j2 < js || je <= j2 || i2 < is || ie <= i2 || _sprite.push(sprite[x3 + i2]);
    x3 += w2;
  }
  const xl = is << 5, xr = w2 - ie << 5, yb = js, yt = h2 - je;
  return Object.assign(Object.assign({}, tag), {
    width: tag.width - xl - xr,
    height: tag.height - yb - yt,
    x0: tag.x0 + xl,
    x1: tag.x1 - xr,
    y0: tag.y0 + yb,
    y1: tag.y1 - yt,
    x: tag.x + xl / 2 - xr / 2,
    sprite: _sprite
  });
}

// node_modules/@visactor/vgrammar-wordcloud/es/grid-layout.js
var GridLayout = class _GridLayout extends BaseLayout {
  constructor(options) {
    super(merge({}, _GridLayout.defaultOptions, options)), this.fillGridAt = (x3, y3) => {
      x3 >= this.ngx || y3 >= this.ngy || x3 < 0 || y3 < 0 || (this.grid[x3][y3] = false);
    }, this.updateGrid = (gx, gy, gw, gh, info) => {
      const occupied = info.occupied;
      let i2 = occupied.length;
      for (; i2--; ) {
        const px = gx + occupied[i2][0], py = gy + occupied[i2][1];
        px >= this.ngx || py >= this.ngy || px < 0 || py < 0 || this.fillGridAt(px, py);
      }
    }, this.gridSize = Math.max(Math.floor(this.options.gridSize), 4);
  }
  getPointsAtRadius(radius) {
    if (this.pointsAtRadius[radius]) return this.pointsAtRadius[radius];
    const T2 = 8 * radius;
    let t2 = T2;
    const points = [];
    for (0 === radius && points.push([this.center[0], this.center[1], 0]); t2--; ) {
      const rx = this.shape(t2 / T2 * 2 * Math.PI);
      points.push([this.center[0] + radius * rx * Math.cos(-t2 / T2 * 2 * Math.PI), this.center[1] + radius * rx * Math.sin(-t2 / T2 * 2 * Math.PI) * this.options.ellipticity, t2 / T2 * 2 * Math.PI]);
    }
    return this.pointsAtRadius[radius] = points, points;
  }
  getTextInfo(item, shrinkRatio = 1) {
    var _a;
    const sizeShrinkRatio = this.options.clip ? 1 : shrinkRatio, fontSize = Math.max(Math.floor(this.getTextFontSize(item) * sizeShrinkRatio), this.options.minFontSize);
    let word = this.getText(item) + "";
    if (this.options.clip && (word = word.slice(0, Math.ceil(word.length * shrinkRatio))), !word) return null;
    const fontWeight = this.getTextFontWeight(item), fontStyle = this.getTextFontStyle(item), angle2 = this.getTextRotate && null !== (_a = this.getTextRotate(item)) && void 0 !== _a ? _a : 0, fontFamily = this.getTextFontFamily(item), fcanvas = document.createElement("canvas"), fctx = fcanvas.getContext("2d", {
      willReadFrequently: true
    });
    fctx.font = fontStyle + " " + fontWeight + " " + fontSize.toString(10) + "px " + fontFamily;
    const fw = fctx.measureText(word).width, fh = Math.max(fontSize, fctx.measureText("m").width, fctx.measureText("Ｗ").width);
    let boxWidth = fw + 2 * fh, boxHeight = 3 * fh;
    const fgw = Math.ceil(boxWidth / this.gridSize), fgh = Math.ceil(boxHeight / this.gridSize);
    boxWidth = fgw * this.gridSize, boxHeight = fgh * this.gridSize;
    const fillTextOffsetX = -fw / 2, fillTextOffsetY = 0.4 * -fh, cgh = Math.ceil((boxWidth * Math.abs(Math.sin(angle2)) + boxHeight * Math.abs(Math.cos(angle2))) / this.gridSize), cgw = Math.ceil((boxWidth * Math.abs(Math.cos(angle2)) + boxHeight * Math.abs(Math.sin(angle2))) / this.gridSize), width = cgw * this.gridSize, height = cgh * this.gridSize;
    fcanvas.setAttribute("width", "" + width), fcanvas.setAttribute("height", "" + height), fctx.scale(1, 1), fctx.translate(width / 2, height / 2), fctx.rotate(-angle2), fctx.font = fontStyle + " " + fontWeight + " " + fontSize.toString(10) + "px " + fontFamily, fctx.fillStyle = "#000", fctx.textBaseline = "middle", fctx.fillText(word, fillTextOffsetX, fillTextOffsetY);
    const imageData = fctx.getImageData(0, 0, width, height).data;
    if (this.exceedTime()) return null;
    const occupied = [];
    let gy, gx = cgw;
    const bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2], singleGridLoop = (gx2, gy2, out) => {
      let y3 = this.gridSize;
      for (; y3--; ) {
        let x3 = this.gridSize;
        for (; x3--; ) if (imageData[4 * ((gy2 * this.gridSize + y3) * width + (gx2 * this.gridSize + x3)) + 3]) return out.push([gx2, gy2]), gx2 < bounds[3] && (bounds[3] = gx2), gx2 > bounds[1] && (bounds[1] = gx2), gy2 < bounds[0] && (bounds[0] = gy2), void (gy2 > bounds[2] && (bounds[2] = gy2));
      }
    };
    for (; gx--; ) for (gy = cgh; gy--; ) singleGridLoop(gx, gy, occupied);
    return {
      datum: item,
      occupied,
      bounds,
      gw: cgw,
      gh: cgh,
      fillTextOffsetX,
      fillTextOffsetY,
      fillTextWidth: fw,
      fillTextHeight: fh,
      fontSize,
      fontStyle,
      fontWeight,
      fontFamily,
      angle: angle2,
      text: word
    };
  }
  canFitText(gx, gy, gw, gh, occupied) {
    let i2 = occupied.length;
    for (; i2--; ) {
      const px = gx + occupied[i2][0], py = gy + occupied[i2][1];
      if (px >= this.ngx || py >= this.ngy || px < 0 || py < 0) {
        if (!this.options.drawOutOfBound) return false;
      } else if (!this.grid[px][py]) return false;
    }
    return true;
  }
  layoutWord(index, shrinkRatio = 1) {
    const item = this.data[index], info = this.getTextInfo(item, shrinkRatio);
    if (!info) return false;
    if (this.exceedTime()) return false;
    if (!this.options.drawOutOfBound && (!this.options.shrink || info.fontSize <= this.options.minFontSize) && !this.options.clip) {
      const bounds = info.bounds;
      if (bounds[1] - bounds[3] + 1 > this.ngx || bounds[2] - bounds[0] + 1 > this.ngy) return false;
    }
    let r2 = this.maxRadius + 1;
    const tryToPutWordAtPoint = (gxy) => {
      const gx = Math.floor(gxy[0] - info.gw / 2), gy = Math.floor(gxy[1] - info.gh / 2), gw = info.gw, gh = info.gh;
      return !!this.canFitText(gx, gy, gw, gh, info.occupied) && (info.distance = this.maxRadius - r2, info.theta = gxy[2], this.outputText(gx, gy, info), this.updateGrid(gx, gy, gw, gh, info), true);
    };
    for (; r2--; ) {
      let points = this.getPointsAtRadius(this.maxRadius - r2);
      this.options.random && (points = [].concat(points), shuffleArray(points));
      if (points.some(tryToPutWordAtPoint)) return true;
    }
    return (this.options.clip || !!(this.options.shrink && info.fontSize > this.options.minFontSize)) && this.layoutWord(index, 0.75 * shrinkRatio);
  }
  outputText(gx, gy, info) {
    const color = this.getTextColor(info), output = {
      text: info.text,
      datum: info.datum,
      color,
      fontStyle: info.fontStyle,
      fontWeight: info.fontWeight,
      fontFamily: info.fontFamily,
      angle: info.angle,
      width: info.fillTextWidth,
      height: info.fillTextHeight,
      x: (gx + info.gw / 2) * this.gridSize,
      y: (gy + info.gh / 2) * this.gridSize + info.fillTextOffsetY + 0.5 * info.fontSize,
      fontSize: info.fontSize
    };
    this.result.push(output), this.progressiveResult && this.progressiveResult.push(output);
  }
  initGrid(canvas) {
    let i2;
    if (this.grid = [], canvas) {
      let bctx = document.createElement("canvas").getContext("2d");
      bctx.fillStyle = this.options.backgroundColor, bctx.fillRect(0, 0, 1, 1);
      let bgPixel = bctx.getImageData(0, 0, 1, 1).data, imageData = canvas.getContext("2d").getImageData(0, 0, this.ngx * this.gridSize, this.ngy * this.gridSize).data;
      const singleGridLoop = (gx2, gy) => {
        let y3 = this.gridSize;
        for (; y3--; ) {
          let x3 = this.gridSize;
          for (; x3--; ) for (i2 = 4; i2--; ) if (imageData[4 * ((gy * this.gridSize + y3) * this.ngx * this.gridSize + (gx2 * this.gridSize + x3)) + i2] !== bgPixel[i2]) return void (this.grid[gx2][gy] = false);
        }
      };
      let gx = this.ngx;
      for (; gx--; ) {
        this.grid[gx] = [];
        let gy = this.ngy;
        for (; gy--; ) singleGridLoop(gx, gy), false !== this.grid[gx][gy] && (this.grid[gx][gy] = true);
      }
      imageData = bctx = bgPixel = void 0;
    } else {
      let gx = this.ngx;
      for (; gx--; ) {
        this.grid[gx] = [];
        let gy = this.ngy;
        for (; gy--; ) this.grid[gx][gy] = true;
      }
    }
  }
  layout(data, config2) {
    this.initProgressive(), this.data = data, this.pointsAtRadius = [], this.ngx = Math.floor(config2.width / this.gridSize), this.ngy = Math.floor(config2.height / this.gridSize);
    const { center: center2, maxRadius } = getMaxRadiusAndCenter(this.options.shape, [config2.width, config2.height]);
    this.center = config2.origin ? [config2.origin[0] / this.gridSize, config2.origin[1] / this.gridSize] : [center2[0] / this.gridSize, center2[1] / this.gridSize], this.maxRadius = Math.floor(maxRadius / this.gridSize), this.initGrid(config2.canvas), this.result = [];
    let i2 = 0;
    for (; i2 < data.length; ) {
      this.layoutWord(i2);
      if (i2++, this.progressiveIndex = i2, this.exceedTime()) break;
    }
    return this.result;
  }
};
GridLayout.defaultOptions = {
  gridSize: 8,
  ellipticity: 1
};

// node_modules/@visactor/vgrammar-wordcloud/es/fast-layout.js
var FastLayout = class _FastLayout extends BaseLayout {
  constructor(options) {
    super(merge({}, _FastLayout.defaultOptions, options)), this.random = this.options.random ? Math.random : () => 0, this.aspectRatio = 1;
  }
  fit(word) {
    for (let i2 = 0, len = this.result.length; i2 < len; i2++) if (isOverlap(word, this.result[i2])) return false;
    return true;
  }
  getTextInfo(datum) {
    const info = {
      datum,
      fontSize: this.getTextFontSize(datum),
      fontWeight: this.getTextFontWeight(datum),
      fontStyle: this.getTextFontStyle(datum),
      fontFamily: this.getTextFontFamily(datum),
      angle: this.getTextRotate(datum),
      text: this.getText(datum) + "",
      x: this.center[0],
      y: this.center[1]
    }, bounds = getTextBounds(info);
    return info.width = bounds.width(), info.height = bounds.height(), info.top = this.center[1] - info.height + 0.21 * info.height, info.left = this.center[0] - info.width / 2, info;
  }
  layoutWord(index) {
    const info = this.getTextInfo(this.data[index]);
    let angle2 = 2 * Math.PI, radius = 0, left2 = info.left, top = info.top;
    const width = info.width, height = info.height;
    let rx = 1, isFit = this.fit(info);
    for (; !isFit && radius < this.maxRadius; ) radius += 0.5, rx = this.shape(radius / this.maxRadius * 2 * Math.PI), angle2 += 0.5 * (this.options.random ? this.random() > 0.5 ? 1 : -1 : index % 2 == 0 ? 1 : -1), left2 = this.center[0] - width / 2 + radius * rx * Math.cos(angle2) * this.aspectRatio, top = this.center[1] - height / 2 + radius * rx * Math.sin(angle2), info.left = left2, info.top = top, info.x = left2 + width / 2, info.y = top + height / 2, isFit = this.fit(info);
    return !!isFit && (!!(this.options.clip || info.left >= 0 && info.left + info.width <= this.width && info.top >= 0 && info.top + info.height <= this.height) && (this.result.push(info), true));
  }
  layout(data, config2) {
    if (!(null == data ? void 0 : data.length)) return [];
    this.initProgressive(), this.result = [], this.maxRadius = Math.sqrt(config2.width * config2.width + config2.height * config2.height) / 2, this.center = [config2.width / 2, config2.height / 2], this.width = config2.width, this.height = config2.height, this.data = data.sort((a4, b2) => this.getTextFontSize(b2) - this.getTextFontSize(a4));
    let i2 = 0;
    for (; i2 < data.length; ) {
      this.layoutWord(i2);
      if (i2++, this.progressiveIndex = i2, this.exceedTime()) break;
    }
    return this.result;
  }
};
function isOverlap(a4, b2) {
  return !(a4.left + a4.width < b2.left || a4.top + a4.height < b2.top || a4.left > b2.left + b2.width || a4.top > b2.top + b2.height);
}
FastLayout.defaultOptions = {
  enlarge: false
};

// node_modules/@visactor/vgrammar-wordcloud/es/wordcloud.js
var OUTPUT = {
  x: "x",
  y: "y",
  z: "z",
  fontFamily: "fontFamily",
  fontSize: "fontSize",
  fontStyle: "fontStyle",
  fontWeight: "fontWeight",
  angle: "angle"
};
var transform22 = (options, upstreamData) => {
  var _a, _b, _c, _d, _e, _f;
  if (options.size && (options.size[0] <= 0 || options.size[1] <= 0)) {
    return Logger.getInstance().info("Wordcloud size dimensions must be greater than 0"), [];
  }
  const data = upstreamData, canvasSize = (null !== (_a = options.size) && void 0 !== _a ? _a : [500, 500]).slice();
  canvasSize[0] = Math.floor(canvasSize[0]), canvasSize[1] = Math.floor(canvasSize[1]);
  const fontFamily = options.fontFamily ? field3(options.fontFamily) : "sans-serif", fontStyle = options.fontStyle ? field3(options.fontStyle) : "normal", fontWeight = options.fontWeight ? field3(options.fontWeight) : "normal", rotate3 = options.rotate ? field3(options.rotate) : 0, text2 = field3(options.text), spiral = null !== (_b = options.spiral) && void 0 !== _b ? _b : "archimedean", padding = options.padding ? field3(options.padding) : 1, shape = null !== (_c = options.shape) && void 0 !== _c ? _c : "square", shrink = null !== (_d = options.shrink) && void 0 !== _d && _d, enlarge = null !== (_e = options.enlarge) && void 0 !== _e && _e, clip = null !== (_f = options.clip) && void 0 !== _f && _f, minFontSize = options.minFontSize, randomVisible = options.randomVisible, as = options.as || OUTPUT, depth_3d = options.depth_3d, postProjection = options.postProjection;
  let fontSize = options.fontSize ? field3(options.fontSize) : 14;
  const fontSizeRange = options.fontSizeRange;
  if (fontSizeRange && !isNumber_default(fontSize)) {
    const fsize = fontSize, fontSizeSqrtScale = generateSqrtScale(extent3(fsize, data), fontSizeRange);
    fontSize = (datum) => fontSizeSqrtScale(fsize(datum));
  }
  let Layout2 = CloudLayout;
  "fast" === options.layoutType ? Layout2 = FastLayout : "grid" === options.layoutType && (Layout2 = GridLayout);
  const layout2 = new Layout2({
    text: text2,
    padding,
    spiral,
    shape,
    rotate: rotate3,
    fontFamily,
    fontStyle,
    fontWeight,
    fontSize,
    shrink,
    clip,
    enlarge,
    minFontSize,
    random: randomVisible,
    progressiveStep: options.progressiveStep,
    progressiveTime: options.progressiveTime,
    outputCallback: (words) => {
      const res = [];
      let t2, w2;
      for (let i2 = 0, len = words.length; i2 < len; i2++) w2 = words[i2], t2 = w2.datum, t2[as.x] = w2.x, t2[as.y] = w2.y, t2[as.fontFamily] = w2.fontFamily, t2[as.fontSize] = w2.fontSize, t2[as.fontStyle] = w2.fontStyle, t2[as.fontWeight] = w2.fontWeight, t2[as.angle] = w2.angle, "StereographicProjection" === postProjection && stereographicProjection(canvasSize, w2, t2, as, depth_3d), res.push(t2);
      return res;
    }
  });
  return layout2.layout(data, {
    width: canvasSize[0],
    height: canvasSize[1]
  }), options.progressiveStep > 0 || options.progressiveTime > 0 ? {
    progressive: layout2
  } : layout2.output();
};
var field3 = (option) => isString_default(option) || isNumber_default(option) || isFunction_default(option) ? option : (datum) => datum[option.field];
var sqrt5 = (x3) => x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
var generateSqrtScale = (domain, range2) => {
  if (domain[0] === domain[1]) return (datum) => range2[0];
  const s0 = sqrt5(domain[0]), s1 = sqrt5(domain[1]), min4 = Math.min(s0, s1), max4 = Math.max(s0, s1);
  return (datum) => (sqrt5(datum) - min4) / (max4 - min4) * (range2[1] - range2[0]) + range2[0];
};
var extent3 = (field5, data) => {
  let min4 = 1 / 0, max4 = -1 / 0;
  const n2 = data.length;
  let v2;
  for (let i2 = 0; i2 < n2; ++i2) v2 = toNumber(field5(data[i2])), v2 < min4 && (min4 = v2), v2 > max4 && (max4 = v2);
  return 1 === data.length && min4 === max4 && (min4 -= 1e4), [min4, max4];
};
function stereographicProjection(canvasSize, w2, t2, as, depth_3d) {
  const r2 = Math.max(canvasSize[0], canvasSize[1]) / 2, out = _StereographicProjection(canvasSize[0], canvasSize[1], r2, {
    x: r2,
    y: r2,
    z: null != depth_3d ? depth_3d : r2
  }, w2);
  t2[as.x] = out.x, t2[as.y] = out.y, t2[as.z] = out.z;
}
function _StereographicProjection(w2, h2, r2, center2, word) {
  const { x: x3, y: y3 } = word, theta = x3 / w2 * Math.PI * 2;
  let phi = Math.PI - y3 / h2 * Math.PI;
  phi += (phi < Math.PI / 2 ? 1 : -1) * Math.pow(Math.min(phi - Math.PI / 2, 1), 2) / 5;
  return {
    x: r2 * Math.sin(phi) * Math.cos(theta) + center2.x,
    y: r2 * Math.cos(phi) + center2.y,
    z: r2 * Math.sin(phi) * Math.sin(theta) + center2.z
  };
}

// node_modules/@visactor/vgrammar-wordcloud/es/index.js
var registerWordCloudTransforms = () => {
  Factory.registerTransform("wordcloud", {
    transform: transform22,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js
var WORDCLOUD_SHAPE_HOOK_EVENT;
!function(WORDCLOUD_SHAPE_HOOK_EVENT2) {
  WORDCLOUD_SHAPE_HOOK_EVENT2.BEFORE_WORDCLOUD_SHAPE_LAYOUT = "beforeWordcloudShapeLayout", WORDCLOUD_SHAPE_HOOK_EVENT2.AFTER_WORDCLOUD_SHAPE_LAYOUT = "afterWordcloudShapeLayout";
}(WORDCLOUD_SHAPE_HOOK_EVENT || (WORDCLOUD_SHAPE_HOOK_EVENT = {}));
var colorListEqual = (arr0, arr1) => {
  if (1 === arr1.length && "#537EF5" === arr1[0]) return true;
  if (!Array.isArray(arr0) || !Array.isArray(arr1) || arr0.length !== arr1.length) return false;
  for (let i2 = 0; i2 < arr0.length; i2++) if (arr0[i2] !== arr1[i2]) return false;
  return true;
};
var fakeRandom = () => {
  let i2 = -1;
  const arr = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
  return () => (i2 = (i2 + 1) % arr.length, arr[i2]);
};
var isChinese = (text2) => /^[\u4e00-\u9fa5]+$/.test(text2);
var calTextLength = (text2, textLengthLimit) => {
  if (isNil_default(text2)) return 0;
  let length2 = 0;
  for (const char of text2) isChinese(char) ? length2 += 1 : length2 += 0.53;
  return length2;
};
function loadImage(url) {
  return url && (isValidUrl_default(url) || isBase64_default(url) || url.startsWith("<svg")) ? new Promise((resolve, reject) => {
    var _a;
    const imageMark = createImage({
      image: url
    }), imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);
    imgData && "success" === imgData.state && imgData.data ? resolve(imgData.data) : (imageMark.successCallback = () => {
      var _a2;
      if (imageMark) {
        const imgData2 = null === (_a2 = imageMark.resources) || void 0 === _a2 ? void 0 : _a2.get(url);
        imgData2 && "success" === imgData2.state && imgData2.data ? resolve(imgData2.data) : reject(new Error("image load failed" + url));
      } else reject(new Error("image load failed" + url));
    }, imageMark.failCallback = () => {
      Logger.getInstance().error("image 加载失败！", url);
    });
  }) : null;
}
function functor2(d2) {
  return "function" == typeof d2 ? d2 : function() {
    return d2;
  };
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js
var __awaiter16 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function loadAndHandleImage(segmentationInput) {
  return __awaiter16(this, void 0, void 0, function* () {
    const shapeImage = yield loadImage(segmentationInput.shapeUrl);
    return segmentationInput.removeWhiteBorder && shapeImage ? removeBorder(shapeImage, segmentationInput.tempCanvas, segmentationInput.tempCtx) : shapeImage;
  });
}
function segmentation(shapeImage, segmentationInput) {
  const { size, tempCanvas, tempCtx: ctx } = segmentationInput, shapeConfig = scaleAndMiddleShape(shapeImage, size);
  tempCanvas.width = size[0], tempCanvas.height = size[1], ctx.clearRect(0, 0, tempCanvas.width, tempCanvas.height), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height);
  const imageData = ctx.getImageData(0, 0, size[0], size[1]), labels = new Array(size[0] * size[1]).fill(0);
  let curLabel = 1;
  const offset = [[0, 1], [1, 0], [-1, 0], [0, -1]];
  let queue = [];
  for (let i2 = 0; i2 < size[1]; i2++) for (let j2 = 0; j2 < size[0]; j2++) if (0 === labels[i2 * size[0] + j2] && !isEmptyPixel(imageData, i2, j2)) {
    labels[i2 * size[0] + j2] = curLabel, queue.push([i2, j2]);
    for (let k3 = 0; k3 < queue.length; k3++) for (let m5 = 0; m5 < 4; m5++) {
      let row = queue[k3][0] + offset[m5][0], col = queue[k3][1] + offset[m5][1];
      row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 !== labels[row * size[0] + col] || isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, queue.push([row, col]));
    }
    curLabel++, queue = [];
  }
  const boundaries = {}, areas = {}, centers = {}, maxPoints = {}, maxR = {}, ratios = {}, shapeBounds = {
    x1: 1 / 0,
    x2: -1 / 0,
    y1: 1 / 0,
    y2: -1 / 0,
    width: 0,
    height: 0
  };
  for (let i2 = 0; i2 < size[1]; i2++) for (let j2 = 0; j2 < size[0]; j2++) {
    const label = labels[i2 * size[0] + j2];
    0 !== label && (isBoundaryPixel(i2, j2) && (boundaries[label] = boundaries[label] || [], boundaries[label].push([j2, i2]), maxPoints[label] || (maxPoints[label] = [1 / 0, -1 / 0, 1 / 0, -1 / 0]), i2 < maxPoints[label][0] && (maxPoints[label][0] = i2), i2 > maxPoints[label][1] && (maxPoints[label][1] = i2), j2 < maxPoints[label][2] && (maxPoints[label][2] = j2), j2 > maxPoints[label][3] && (maxPoints[label][3] = j2), j2 < shapeBounds.x1 && (shapeBounds.x1 = j2), j2 > shapeBounds.x2 && (shapeBounds.x2 = j2), i2 < shapeBounds.y1 && (shapeBounds.y1 = i2), i2 > shapeBounds.y2 && (shapeBounds.y2 = i2)), areas[label] = areas[label] || 0, areas[label]++);
  }
  const allBoundaries = [];
  for (const label in boundaries) {
    const boundary = boundaries[label], x4 = ~~(boundary.reduce((acc, cur) => acc + cur[0], 0) / boundary.length), y4 = ~~(boundary.reduce((acc, cur) => acc + cur[1], 0) / boundary.length);
    centers[label] = [x4, y4], allBoundaries.push(...boundary);
    const [yMin, yMax, xMin, xMax] = maxPoints[label];
    maxR[label] = ~~Math.max(Math.sqrt((x4 - xMin) ** 2 + (y4 - yMin) ** 2), Math.sqrt((x4 - xMax) ** 2 + (y4 - yMax) ** 2), Math.sqrt((x4 - xMin) ** 2 + (y4 - yMax) ** 2), Math.sqrt((x4 - xMax) ** 2 + (y4 - yMin) ** 2)), ratios[label] = (xMax - xMin) / (yMax - yMin);
  }
  const regions = Object.keys(centers).map((key) => ({
    label: key - 1,
    boundary: boundaries[key],
    area: areas[key],
    center: centers[key],
    maxPoint: maxPoints[key],
    maxR: maxR[key],
    ratio: ratios[key]
  }));
  shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;
  const x3 = ~~(allBoundaries.reduce((acc, cur) => acc + cur[0], 0) / allBoundaries.length), y3 = ~~(allBoundaries.reduce((acc, cur) => acc + cur[1], 0) / allBoundaries.length), shapeMaxR = ~~Math.max(Math.sqrt((x3 - shapeBounds.x1) ** 2 + (y3 - shapeBounds.y1) ** 2), Math.sqrt((x3 - shapeBounds.x2) ** 2 + (y3 - shapeBounds.y2) ** 2), Math.sqrt((x3 - shapeBounds.x1) ** 2 + (y3 - shapeBounds.y2) ** 2), Math.sqrt((x3 - shapeBounds.x2) ** 2 + (y3 - shapeBounds.y1) ** 2)), shapeRatio = shapeBounds.width / shapeBounds.height, shapeArea = Object.keys(areas).reduce((acc, key) => acc + areas[key], 0), segmentation2 = {
    regions,
    labels,
    labelNumber: curLabel - 1
  };
  return Object.assign(segmentationInput, {
    segmentation: segmentation2,
    shapeConfig,
    shapeBounds,
    shapeMaxR,
    shapeRatio,
    shapeCenter: [x3, y3],
    shapeArea
  });
  function isBoundaryPixel(i2, j2) {
    const offset2 = [[0, 1], [1, 0], [-1, 0], [0, -1]];
    if (0 === i2 || 0 === j2 || i2 === size[1] - 1 || j2 === size[0] - 1) return true;
    for (let k3 = 0; k3 < 4; k3++) {
      let row = i2 + offset2[k3][0], col = j2 + offset2[k3][1];
      if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 === labels[row * size[0] + col]) return true;
    }
    return false;
  }
}
function isEmptyPixel(imageData, i2, j2) {
  const width = imageData.width;
  return 0 === imageData.data[i2 * width * 4 + 4 * j2 + 3] || 255 === imageData.data[i2 * width * 4 + 4 * j2 + 0] && 255 === imageData.data[i2 * width * 4 + 4 * j2 + 1] && 255 === imageData.data[i2 * width * 4 + 4 * j2 + 2];
}
function removeBorder(image, canvas, ctx) {
  canvas.width = image.width, canvas.height = image.height, ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);
  const width = canvas.width, imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let top = 0, bottom = imageData.height, left2 = 0, right2 = imageData.width;
  for (; top < bottom && rowBlank(imageData, width, top); ) ++top;
  for (; bottom - 1 > top && rowBlank(imageData, width, bottom - 1); ) --bottom;
  for (; left2 < right2 && columnBlank(imageData, width, left2, top, bottom); ) ++left2;
  for (; right2 - 1 > left2 && columnBlank(imageData, width, right2 - 1, top, bottom); ) --right2;
  const trimmed = ctx.getImageData(left2, top, right2 - left2, bottom - top);
  return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.putImageData(trimmed, 0, 0), canvas;
}
function rowBlank(imageData, width, y3) {
  for (let x3 = 0; x3 < width; ++x3) if (!isEmptyPixel(imageData, y3, x3)) return false;
  return true;
}
function columnBlank(imageData, width, x3, top, bottom) {
  for (let y3 = top; y3 < bottom; ++y3) if (!isEmptyPixel(imageData, y3, x3)) return false;
  return true;
}
function scaleAndMiddleShape(image, size) {
  const width = image.width, height = image.height;
  let scale4 = size[0] / width;
  height * scale4 > size[1] && (scale4 = size[1] / height);
  const newWidth = Math.floor(scale4 * width), newHeight = Math.floor(scale4 * height);
  return {
    x: (size[0] - newWidth) / 2,
    y: (size[1] - newHeight) / 2,
    width: newWidth,
    height: newHeight,
    scale: scale4
  };
}
function allocateWords(words, segmentationOutput) {
  const { segmentation: { regions } } = segmentationOutput;
  let areaMax = -1 / 0, totalArea = 0, areaMaxIndex = 0;
  regions.forEach((region, index) => {
    const area2 = region.area;
    area2 > areaMax && (areaMax = area2, areaMaxIndex = index), totalArea += area2;
  });
  let wordsSum = 0;
  regions.forEach((region) => {
    const area2 = region.area, regionNum = Math.ceil(area2 / totalArea * words.length), regionWeight = area2 / areaMax;
    region.words = [], region.regionNum = regionNum, region.regionWeight = regionWeight, wordsSum += regionNum;
  }), wordsSum < words.length && (regions[areaMaxIndex].wordsNum += words.length - wordsSum);
  let currIndex = areaMaxIndex;
  const regionNums = regions.map((region) => region.regionNum);
  words.forEach((word) => {
    let failCounter = 0, updateCounter = 0;
    word.regionIndex = -1;
    do {
      if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {
        word.regionIndex = currIndex, regions[currIndex].words.push(word), regionNums[currIndex]--, currIndex = (currIndex + 1) % regions.length;
        break;
      }
      currIndex = (currIndex + 1) % regions.length, failCounter++, updateCounter++, updateCounter > regions.length + 1 && (regions.forEach((region) => {
        region.regionWeight += 0.15;
      }), updateCounter = 0);
    } while (-1 === word.regionIndex && failCounter < 3 * regions.length);
    -1 === word.regionIndex && (word.regionIndex = areaMaxIndex, regions[areaMaxIndex].words.push(word), regionNums[areaMaxIndex]--);
  }), regions.forEach((region) => {
    region.words.sort((a4, b2) => b2.weight - a4.weight);
  });
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js
function layout(words, layoutConfig, segmentationOutput) {
  const { size, stepFactor } = layoutConfig, { segmentation: { regions }, tempCtx: ctx, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, board = initBoardWithShape(segmentationOutput);
  for (const region of regions) {
    const { words: regionWords, center: center2, maxR, ratio } = region;
    for (let i2 = 0; i2 < regionWords.length; i2++) {
      measureSprite(canvas, ctx, words, i2);
      const word = regionWords[i2];
      word.x = center2[0], word.y = center2[1], word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  for (let _2 = 0; _2 < layoutConfig.textLayoutTimes; _2++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i2 = 0; i2 < failedWords.length; i2++) {
      const word = failedWords[i2];
      measureSprite(canvas, ctx, failedWords, i2), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function layoutGlobalShrink(words, layoutConfig, segmentationOutput) {
  const { stepFactor, importantWordCount, globalShinkLimit } = layoutConfig, { size, segmentation: { regions }, tempCtx: ctx, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, boardOrigin = initBoardWithShape(segmentationOutput);
  let board = boardOrigin.slice(0);
  const fontFactor = layoutConfig.fontSizeShrinkFactor;
  let id2 = null, idIntialFactor = 1, globalShinkFactor = 1;
  const importantCount = importantWordCount;
  let weightStd = 0;
  if (words.length > importantCount) {
    weightStd = words.sort((word0, word1) => word1.weight - word0.weight)[importantCount].weight;
  }
  for (let k3 = 0; k3 < regions.length; k3++) {
    const region = regions[k3], { words: regionWords, center: center2, maxR, ratio } = region;
    let restartTag = false;
    for (let i2 = 0; i2 < regionWords.length; i2++) {
      measureSprite(canvas, ctx, words, i2);
      const word = regionWords[i2];
      if (word.x = center2[0], word.y = center2[1], !word.skip && word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = true;
      else {
        if (!word.skip && word.weight > weightStd && globalShinkFactor > globalShinkLimit) {
          const wordId = word.datum[Symbol.for("vGrammar_id")];
          wordId !== id2 && (id2 = wordId, idIntialFactor = globalShinkFactor), globalShinkFactor *= fontFactor, words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize * fontFactor;
          }), board = boardOrigin.slice(0), restartTag = true;
          break;
        }
        if (!word.skip && word.datum[Symbol.for("vGrammar_id")] === id2) {
          words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize / globalShinkFactor;
          }), word.skip = true, globalShinkFactor = idIntialFactor, id2 = null, board = boardOrigin.slice(0), restartTag = true;
          break;
        }
      }
    }
    restartTag && (k3 = -1);
  }
  for (let _2 = 0; _2 < layoutConfig.textLayoutTimes; _2++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i2 = 0; i2 < failedWords.length; i2++) {
      const word = failedWords[i2];
      measureSprite(canvas, ctx, failedWords, i2), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function layoutSelfEnlarge(words, layoutConfig, segmentationOutput) {
  const { size, stepFactor, importantWordCount } = layoutConfig, { segmentation: { regions }, tempCtx: ctx, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput, boardOrigin = initBoardWithShape(segmentationOutput);
  let board = boardOrigin.slice(0);
  const fontFactor = layoutConfig.fontSizeEnlargeFactor, importantCount = Math.min(importantWordCount, words.length);
  let weightStd = 0;
  if (words.length > importantCount) {
    weightStd = words.sort((word0, word1) => word1.weight - word0.weight)[importantCount - 1].weight;
  }
  let importantWordSuccessedNum = 0, globalEnlargeFactor = 1, layoutFinish = false;
  for (let k3 = 0; k3 < regions.length; k3++) {
    const region = regions[k3], { words: regionWords, center: center2, maxR, ratio } = region;
    let restartTag = false;
    for (let i2 = 0; i2 < regionWords.length; i2++) {
      measureSprite(canvas, ctx, words, i2);
      const word = regionWords[i2];
      if (word.x = center2[0], word.y = center2[1], word.hasText && word.sprite && place2(board, word, maxR, ratio, size, boardSize, stepFactor)) {
        if (word.hasPlaced = true, word.weight >= weightStd && importantWordSuccessedNum++, importantWordSuccessedNum >= importantCount && !layoutFinish) {
          globalEnlargeFactor *= fontFactor, words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize * fontFactor;
          }), board = boardOrigin.slice(0), restartTag = true, importantWordSuccessedNum = 0;
          break;
        }
      } else {
        if (word.weight >= weightStd && globalEnlargeFactor > 1) {
          words.forEach((word2) => {
            word2.hasText = false, word2.sprite = null, word2.fontSize = word2.fontSize / fontFactor;
          }), globalEnlargeFactor /= fontFactor, layoutFinish = true, board = boardOrigin.slice(0), restartTag = true;
          break;
        }
        if (word.weight >= weightStd) return layoutGlobalShrink(words, layoutConfig, segmentationOutput);
      }
    }
    restartTag && (k3 = -1);
  }
  for (let _2 = 0; _2 < layoutConfig.textLayoutTimes; _2++) {
    const failedWords = words.filter((word) => (word.hasPlaced || (word.hasText = false, word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), !word.hasPlaced));
    if (0 === failedWords.length) break;
    for (let i2 = 0; i2 < failedWords.length; i2++) {
      const word = failedWords[i2];
      measureSprite(canvas, ctx, failedWords, i2), word.x = shapeCenter[0], word.y = shapeCenter[1], word.hasText && place2(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = true);
    }
  }
  layoutConfig.board = board;
}
function place2(board, word, maxR, ratio, size, boardSize, stepFactor) {
  const startX = word.x, startY = word.y, spiral = archimedeanSpiral2(ratio), dt = 1 * stepFactor;
  let dxdy, dx, dy, t2 = -dt;
  for (; dxdy = spiral(t2 += dt); ) {
    const { wordSize, bounds: { dTop, dBottom, dLeft, dRight } } = word;
    if (dx = dxdy[0], dy = dxdy[1], Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) break;
    if (word.x = ~~(startX + dx), word.y = ~~(startY + dy), !(word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || isCollideWithBoard(word, board, boardSize))) return placeWordOnBoard(word, board, boardSize), true;
  }
  return false;
}
function placeWordOnBoard(word, board, boardSize) {
  const { wordSize } = word, sprite = word.sprite, w2 = wordSize[0] >> 5, sw = boardSize[0] >> 5, lx = word.x - (w2 << 4), sx = lx % 32, msx = 32 - sx, h2 = wordSize[1];
  let last2, x3 = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
  if (0 === sx) for (let j2 = 0; j2 < h2; j2++) {
    for (let i2 = 0; i2 < w2; i2++) board[x3 + i2] |= sprite[j2 * w2 + i2];
    x3 += sw;
  }
  else for (let j2 = 0; j2 < h2; j2++) {
    last2 = 0;
    for (let i2 = 0; i2 <= w2; i2++) board[x3 + i2] |= last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0);
    x3 += sw;
  }
}
function isCollideWithBoard(word, board, boardSize) {
  const { sprite, wordSize } = word, sw = boardSize[0] >> 5, w2 = wordSize[0] >> 5, lx = word.x - (w2 << 4), sx = lx % 32, msx = 32 - sx, h2 = wordSize[1];
  let last2, x3 = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
  if (0 === sx) for (let j2 = 0; j2 < h2; j2++) {
    for (let i2 = 0; i2 < w2; i2++) if (board[x3 + i2] & sprite[j2 * w2 + i2]) return true;
    x3 += sw;
  }
  else for (let j2 = 0; j2 < h2; j2++) {
    last2 = 0;
    for (let i2 = 0; i2 <= w2; i2++) if ((last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0)) & board[x3 + i2]) return true;
    x3 += sw;
  }
  return false;
}
function archimedeanSpiral2(ratio) {
  return function(t2) {
    return [ratio * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
  };
}
function measureSprite(canvas, ctx, words, wi) {
  if (words[wi].sprite || 0 === words[wi].fontSize) return;
  const cw = 2048, radians2 = Math.PI / 180, n2 = words.length;
  canvas.width = cw, canvas.height = 2048, ctx.clearRect(0, 0, cw, 2048), ctx.textAlign = "center";
  let wordW, wordH, x3 = 0, y3 = 0, maxHeight = 0, yMax = 0;
  const wiDist = wi;
  for (--wi; ++wi < n2; ) {
    const word = words[wi], fontSize = Math.max(word.fontSize, 2);
    if (ctx.save(), ctx.font = word.fontStyle + " " + word.fontWeight + " " + fontSize + "px " + word.fontFamily, wordW = ctx.measureText(word.text + "m").width + 2 * word.padding, wordH = 2 * fontSize + 2 * word.padding, 0 !== word.rotate) {
      const sr = Math.sin(word.rotate * radians2), cr = Math.cos(word.rotate * radians2), wcr = wordW * cr, wsr = wordW * sr, hcr = wordH * cr, hsr = wordH * sr;
      wordW = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)), wordH = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    }
    if (wordW = wordW + 31 >> 5 << 5, wordH = Math.ceil(wordH), wordH > maxHeight && (maxHeight = wordH), x3 + wordW >= cw && (x3 = 0, y3 += maxHeight, maxHeight = wordH), y3 + wordH >= 2048) {
      if (0 === y3) {
        word.hasText = false;
        continue;
      }
      break;
    }
    y3 + wordH >= yMax && (yMax = y3 + wordH), ctx.translate(x3 + (wordW >> 1), y3 + (wordH >> 1)), 0 !== word.rotate && ctx.rotate(word.rotate * radians2), ctx.fillText(word.text, 0, 0), word.padding && (ctx.lineWidth = 2 * word.padding, ctx.strokeText(word.text, 0, 0)), ctx.restore(), word.LT = [x3, y3], word.wordSize = [wordW, wordH], word.hasText = true, x3 += wordW;
  }
  if (0 === yMax) return;
  const pixels = ctx.getImageData(0, 0, cw, yMax).data;
  let i2, j2;
  for (; --wi >= wiDist; ) {
    const word = words[wi];
    if (!word.hasText) {
      word.bounds = {
        dTop: 1 / 0,
        dBottom: -1 / 0,
        dLeft: 1 / 0,
        dRight: -1 / 0
      };
      break;
    }
    const { LT = [0, 0], wordSize } = word;
    [x3, y3] = LT;
    const w32 = wordSize[0] >> 5, sprite = new Array(w32 * wordSize[1]).fill(0);
    let [dTop, dBottom, dLeft, dRight] = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
    for (j2 = 0; j2 < wordSize[1]; j2++) {
      let seen;
      for (i2 = 0; i2 < wordSize[0]; i2++) if (pixels[4 * ((y3 + j2) * cw + (x3 + i2)) + 3] > 0) {
        const m5 = 1 << 31 - i2 % 32;
        sprite[w32 * j2 + (i2 >> 5)] |= m5, i2 < dLeft && (dLeft = i2), i2 > dRight && (dRight = i2), seen |= m5;
      }
      seen && (j2 < dTop && (dTop = j2), j2 > dBottom && (dBottom = j2));
    }
    word.bounds = {
      dTop: (wordSize[1] >> 1) - dTop,
      dBottom: dBottom - (wordSize[1] >> 1),
      dLeft: (wordSize[0] >> 1) - dLeft,
      dRight: dRight - (wordSize[0] >> 1)
    }, word.sprite = sprite, delete word.LT;
  }
}
function initBoardWithShape(segmentationOutput) {
  const { segmentation: { labels }, boardSize, size } = segmentationOutput, w32 = boardSize[0] >> 5, board = new Array(w32 * size[1]).fill(0);
  for (let i2 = 0; i2 < size[1]; i2++) for (let j2 = 0; j2 < size[0]; j2++) {
    if (0 === labels[i2 * size[0] + j2]) {
      const m5 = 1 << 31 - j2 % 32;
      board[w32 * i2 + (j2 >> 5)] |= m5;
    }
  }
  if (boardSize[0] > size[0]) {
    const m5 = (1 << boardSize[0] - size[0]) - 1;
    for (let y3 = 0; y3 < size[1]; y3++) {
      board[w32 * y3 + w32 - 1] |= m5;
    }
  }
  return board;
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js
function filling(words, layoutConfig, segmentationOutput) {
  const { size, fillingTimes, fillingXStep, fillingYStep, getFillingFontStyle, getFillingFontWeight, getFillingFontFamily, fillingInitialFontSize, fillingDeltaFontSize, fillingInitialOpacity, fillingDeltaOpacity, fillingRotateList, getFillingPadding, random, board, minFillFoontSize } = layoutConfig, { boardSize, shapeBounds, tempCtx: ctx, tempCanvas: canvas, randomGenerator } = segmentationOutput;
  let fontSize = fillingInitialFontSize, opacity = fillingInitialOpacity;
  const placedFillingWords = [];
  for (let i2 = 0; i2 < fillingTimes; i2++) filling1Time(fontSize, opacity), fontSize = Math.max(fontSize > fillingDeltaFontSize ? fontSize - fillingDeltaFontSize : fillingDeltaFontSize, minFillFoontSize), opacity = opacity > fillingDeltaOpacity ? opacity - fillingDeltaOpacity : fillingDeltaOpacity;
  return placedFillingWords;
  function filling1Time(fontSize2, opacity2) {
    const fillingWords = words.map((word) => {
      const { text: text2, color, fillingColor, hasPlaced, datum } = word;
      return {
        x: 0,
        y: 0,
        weight: 0,
        text: text2,
        fontFamily: getFillingFontFamily(datum),
        fontStyle: getFillingFontStyle(datum),
        fontWeight: getFillingFontWeight(datum),
        fontSize: fontSize2,
        rotate: fillingRotateList[~~(randomGenerator() * fillingRotateList.length)],
        padding: getFillingPadding(datum),
        opacity: opacity2,
        visible: true,
        color,
        fillingColor,
        hasPlaced,
        datum
      };
    });
    randomArray(fillingWords);
    let wi = 0;
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = shapeBounds, [startX, startY] = [x14 + ~~(randomGenerator() * fillingXStep * 2), y14 + ~~(randomGenerator() * fillingYStep * 2)];
    for (let y3 = startY; y3 <= y23; y3 += fillingYStep) for (let x3 = startX; x3 <= x23; x3 += fillingXStep) {
      measureSprite(canvas, ctx, fillingWords, wi);
      const word = fillingWords[wi];
      word.x = x3, word.y = y3;
      const { wordSize, bounds, hasPlaced } = word;
      if (!hasPlaced || !bounds) {
        ++wi === fillingWords.length && (wi = 0, random && randomArray(fillingWords));
        continue;
      }
      const { dTop, dBottom, dLeft, dRight } = bounds;
      word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || word.hasText && word.sprite && !isCollideWithBoard(word, board, boardSize) && (placeWordOnBoard(word, board, boardSize), placedFillingWords.push(Object.assign({}, word)), ++wi === fillingWords.length && (wi = 0, random && randomArray(fillingWords)));
    }
  }
  function randomArray(words2) {
    return words2.sort(() => randomGenerator() - 0.5);
  }
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js
function cloud_shape_layout_default(words, layoutConfig, segmentationOutput) {
  allocateWords(words, segmentationOutput), "ensureMapping" === layoutConfig.layoutMode ? layoutGlobalShrink(words, layoutConfig, segmentationOutput) : "ensureMappingEnlarge" === layoutConfig.layoutMode ? layoutSelfEnlarge(words, layoutConfig, segmentationOutput) : layout(words, layoutConfig, segmentationOutput);
  const fillingWords = filling(words, layoutConfig, segmentationOutput), failedWords = [], successedWords = [];
  for (let i2 = 0; i2 < words.length; i2++) words[i2].hasPlaced ? successedWords.push(words[i2]) : failedWords.push(words[i2]);
  return failedWords.forEach((word) => word.visible = false), {
    fillingWords,
    successedWords,
    failedWords
  };
}

// node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js
var __awaiter17 = function(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OUTPUT2 = {
  x: "x",
  y: "y",
  fontFamily: "fontFamily",
  fontSize: "fontSize",
  fontStyle: "fontStyle",
  fontWeight: "fontWeight",
  angle: "angle",
  opacity: "opacity",
  visible: "visible",
  isFillingWord: "isFillingWord",
  color: "color"
};
var transform23 = (options, upstreamData, parameters, view) => __awaiter17(void 0, void 0, void 0, function* () {
  var _a, _b, _c;
  if (!options.size || isNil_default(options.size[0]) || isNil_default(options.size[1]) || options.size[0] <= 0 || options.size[1] <= 0) {
    return Logger.getInstance().info("Wordcloud size dimensions must be greater than 0"), [];
  }
  options.size = [Math.ceil(options.size[0]), Math.ceil(options.size[1])], options.shape || error2("WordcloudShape shape must be specified."), options.text || error2("WordcloudShape text must be specified."), (null == view ? void 0 : view.emit) && view.emit(WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT);
  const data = upstreamData, as = options.as || OUTPUT2;
  if (!data || 0 === data.length) return [];
  const segmentationInput = {
    shapeUrl: options.shape,
    size: options.size,
    ratio: options.ratio || 0.8,
    tempCanvas: void 0,
    tempCtx: void 0,
    removeWhiteBorder: options.removeWhiteBorder || false,
    boardSize: [0, 0],
    random: false,
    randomGenerator: void 0
  }, tempCanvas = vglobal.createCanvas({
    width: options.size[0],
    height: options.size[1]
  }), tempCtx = tempCanvas.getContext("2d");
  tempCtx.textAlign = "center", tempCtx.textBaseline = "middle", segmentationInput.tempCanvas = tempCanvas, segmentationInput.tempCtx = tempCtx;
  const boardW = options.size[0] + 31 >> 5 << 5;
  segmentationInput.boardSize = [boardW, options.size[1]], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = fakeRandom();
  const shapeImage = yield loadAndHandleImage(segmentationInput);
  if (!shapeImage) return [];
  const segmentationOutput = segmentation(shapeImage, segmentationInput), colorMode = options.colorMode || "ordinal", wordsConfig = {
    getText: field4(options.text),
    getFontSize: field4(options.fontSize),
    fontSizeRange: options.fontSizeRange,
    colorMode,
    getColor: options.colorField ? field4(options.colorField) : field4(options.text),
    getFillingColor: field4(options.fillingColorField),
    colorList: options.colorList || ("ordinal" === colorMode ? ["#2E62F1"] : ["#537EF5", "#2E62F1", "#2358D8", "#184FBF", "#0C45A6", "#013B8E"]),
    getColorHex: field4(options.colorHexField),
    getFontFamily: field4(options.fontFamily || "sans-serif"),
    rotateList: options.rotateList || [0],
    getPadding: field4(options.padding || 1),
    getFontStyle: field4(options.fontStyle || "normal"),
    getFontWeight: field4(options.fontWeight || "normal"),
    getFontOpacity: options.fontOpacity ? field4(options.fontOpacity) : () => 1
  };
  initFontSizeScale(data, wordsConfig, segmentationOutput);
  const layoutConfig = {
    size: options.size,
    ratio: options.ratio || 0.8,
    shapeUrl: options.shape,
    random: void 0 === options.random || options.random,
    textLayoutTimes: options.textLayoutTimes || 3,
    removeWhiteBorder: options.removeWhiteBorder || false,
    layoutMode: options.layoutMode || "default",
    fontSizeShrinkFactor: options.fontSizeShrinkFactor || 0.8,
    stepFactor: options.stepFactor || 1,
    importantWordCount: options.importantWordCount || 10,
    globalShinkLimit: options.globalShinkLimit || 0.2,
    fontSizeEnlargeFactor: options.fontSizeEnlargeFactor || 1.5,
    fillingRatio: options.fillingRatio || 0.7,
    fillingTimes: options.fillingTimes || 4,
    fillingXStep: options.fillingXRatioStep ? Math.max(Math.floor(options.size[0] * options.fillingXRatioStep), 1) : options.fillingXStep || 4,
    fillingYStep: options.fillingYRatioStep ? Math.max(Math.floor(options.size[1] * options.fillingYRatioStep), 1) : options.fillingYStep || 4,
    fillingInitialFontSize: options.fillingInitialFontSize,
    fillingDeltaFontSize: options.fillingDeltaFontSize,
    fillingInitialOpacity: options.fillingInitialOpacity || 0.8,
    fillingDeltaOpacity: options.fillingDeltaOpacity || 0.05,
    getFillingFontFamily: field4(options.fillingFontFamily || "sans-serif"),
    getFillingFontStyle: field4(options.fillingFontStyle || "normal"),
    getFillingFontWeight: field4(options.fillingFontWeight || "normal"),
    getFillingPadding: field4(options.fillingPadding || 0.4),
    fillingRotateList: options.fillingRotateList || [0, 90],
    fillingDeltaFontSizeFactor: options.fillingDeltaFontSizeFactor || 0.2,
    fillingColorList: options.fillingColorList || ["#537EF5"],
    sameColorList: false,
    minInitFontSize: options.minInitFontSize || 10,
    minFontSize: options.minFontSize || 4,
    minFillFoontSize: options.minFillFoontSize || 2
  }, sameColorList = colorListEqual(wordsConfig.colorList, layoutConfig.fillingColorList);
  layoutConfig.sameColorList = sameColorList, initColorScale(data, wordsConfig, layoutConfig, options), initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput);
  const { getText, getFontFamily, getFontStyle, getFontWeight, getPadding: getPadding2, getColor, getFillingColor, getColorHex, fontSizeScale, colorScale, fillingColorScale, getFontOpacity, rotateList } = wordsConfig, words = data.map((datum) => {
    var _a2, _b2;
    return {
      x: 0,
      y: 0,
      weight: 0,
      text: getText(datum),
      fontFamily: getFontFamily(datum),
      fontWeight: getFontWeight(datum),
      fontStyle: getFontStyle(datum),
      rotate: rotateList[~~(segmentationInput.randomGenerator() * rotateList.length)],
      fontSize: Math.max(layoutConfig.minInitFontSize, ~~fontSizeScale(datum)),
      opacity: getFontOpacity(datum),
      padding: getPadding2(datum),
      color: getColorHex && getColorHex(datum) || colorScale && colorScale(getColor(datum)) || "black",
      fillingColor: !getFillingColor || (null === (_a2 = options.colorField) || void 0 === _a2 ? void 0 : _a2.field) === (null === (_b2 = options.fillingColorField) || void 0 === _b2 ? void 0 : _b2.field) && sameColorList ? void 0 : getColorHex && getColorHex(datum) || fillingColorScale && fillingColorScale(getFillingColor(datum)) || "black",
      datum,
      visible: true,
      hasPlaced: false
    };
  }), wordsMaxFontSize = maxInArray(words.map((word) => word.fontSize));
  words.forEach((word) => word.weight = word.fontSize / wordsMaxFontSize), words.sort((a4, b2) => b2.weight - a4.weight);
  const { fillingWords, successedWords, failedWords } = cloud_shape_layout_default(words, layoutConfig, segmentationOutput);
  let w2, t2;
  const modKeywords = [];
  for (let i2 = 0; i2 < words.length; ++i2) w2 = words[i2], t2 = w2.datum, t2[as.x] = w2.x, t2[as.y] = w2.y, t2[as.fontFamily] = w2.fontFamily, t2[as.fontSize] = w2.fontSize, t2[as.fontStyle] = w2.fontStyle, t2[as.fontWeight] = w2.fontWeight, t2[as.angle] = degreeToRadian(w2.rotate), t2[as.opacity] = w2.opacity, t2[as.visible] = w2.visible, t2[as.isFillingWord] = false, t2[as.color] = w2.color, modKeywords.push(t2);
  const textKey = null !== (_b = null === (_a = options.text) || void 0 === _a ? void 0 : _a.field) && void 0 !== _b ? _b : "textKey", dataIndexKey = null !== (_c = options.dataIndexKey) && void 0 !== _c ? _c : "defaultDataIndexKey", fillingWordsData = [];
  return fillingWords.forEach((word, index) => {
    var _a2, _b2;
    const t3 = {};
    t3[as.x] = word.x, t3[as.y] = word.y, t3[as.fontFamily] = word.fontFamily, t3[as.fontSize] = word.fontSize, t3[as.fontStyle] = word.fontStyle, t3[as.fontWeight] = word.fontWeight, t3[as.angle] = degreeToRadian(word.rotate), t3[as.opacity] = word.opacity, t3[as.visible] = word.visible, t3[as.isFillingWord] = true, t3[as.color] = getFillingColor ? (null === (_a2 = options.colorField) || void 0 === _a2 ? void 0 : _a2.field) === (null === (_b2 = options.fillingColorField) || void 0 === _b2 ? void 0 : _b2.field) && sameColorList ? word.color : word.fillingColor : layoutConfig.fillingColorList[~~(segmentationInput.randomGenerator() * layoutConfig.fillingColorList.length)], t3[textKey] = word.text, t3[dataIndexKey] = `${word.text}_${index}_fillingWords`, fillingWordsData.push(t3);
  }), (null == view ? void 0 : view.emit) && view.emit(WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT, {
    successedWords,
    failedWords
  }), modKeywords.concat(fillingWordsData);
});
var initColorScale = (data, wordsConfig, layoutConfig, options) => {
  var _a, _b, _c, _d;
  const { colorMode, getColor, getFillingColor } = wordsConfig, { sameColorList } = layoutConfig;
  let colorScale, fillingColorScale, colorList = wordsConfig.colorList, fillingColorList = layoutConfig.fillingColorList;
  if ("ordinal" === colorMode) {
    const uniqueColorField = data.map((word) => getColor(word));
    if (colorScale = (datum) => new OrdinalScale().domain(uniqueColorField).range(colorList).scale(datum), getFillingColor && ((null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) !== (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) || !sameColorList)) {
      const uniquefillingColorField = data.map((datum) => getFillingColor(datum));
      fillingColorScale = (datum) => new OrdinalScale().domain(uniquefillingColorField).range(fillingColorList).scale(datum);
    }
  } else {
    1 === colorList.length && (colorList = [colorList[0], colorList[0]]);
    const valueScale = new LinearScale().domain(extent4(getColor, data)).range(colorList);
    if (colorScale = (i2) => valueScale.scale(i2), getFillingColor && ((null === (_c = options.colorField) || void 0 === _c ? void 0 : _c.field) !== (null === (_d = options.fillingColorField) || void 0 === _d ? void 0 : _d.field) || !sameColorList)) {
      1 === fillingColorList.length && (fillingColorList = [fillingColorList[0], fillingColorList[0]]);
      const fillingValueScale = new LinearScale().domain(extent4(getFillingColor, data)).range(fillingColorList);
      fillingColorScale = (i2) => fillingValueScale.scale(i2);
    }
  }
  Object.assign(wordsConfig, {
    colorScale,
    fillingColorScale
  });
};
var initFontSizeScale = (data, wordsConfig, segmentationOutput) => {
  let { fontSizeRange: range2 } = wordsConfig;
  const { getFontSize, getText } = wordsConfig;
  let fontSizeScale;
  if (getFontSize) {
    if (getFontSize && range2) {
      const sizeScale = new SqrtScale().domain(extent4(getFontSize, data)).range(range2);
      fontSizeScale = (datum) => sizeScale.scale(getFontSize(datum));
    } else if (getFontSize && isFunction_default(getFontSize) && !range2) {
      const a4 = 0.5, [min4, max4] = extent4(getFontSize, data), words = data.map((datum) => ({
        text: getText(datum),
        value: getFontSize(datum),
        weight: max4 === min4 ? 1 : (getFontSize(datum) - min4) / (max4 - min4)
      })), x3 = getInitialFontSize(words, segmentationOutput, true);
      range2 = [~~(a4 * x3), ~~x3];
      const sizeScale = new SqrtScale().domain(extent4(getFontSize, data)).range(range2);
      fontSizeScale = (datum) => sizeScale.scale(getFontSize(datum));
    }
  } else {
    const words = data.map((word) => ({
      text: getText(word)
    })), x3 = getInitialFontSize(words, segmentationOutput, false);
    fontSizeScale = functor2(x3);
  }
  Object.assign(wordsConfig, {
    getFontSize,
    fontSizeRange: range2,
    fontSizeScale
  });
};
var getInitialFontSize = (words, segmentationOutput, weight) => {
  const shapeArea = segmentationOutput.shapeArea, ratio = segmentationOutput.ratio, regions = segmentationOutput.segmentation.regions, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(shapeArea) / 12), wordArea = words.reduce((acc, word) => {
    const textLength = calTextLength(word.text);
    return textLength < shapeSizeLimitTextLength ? acc + textLength * (weight ? (0.5 + 0.5 * word.weight) ** 2 : 1) : acc;
  }, 0);
  if (0 === wordArea) return 12;
  let x3 = 20;
  if (1 === regions.length) x3 = Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));
  else {
    const xArr = [];
    for (let i2 = 0; i2 < regions.length; i2++) {
      const regionArea = regions[i2].area, regionAspect = regions[i2].ratio, regionRatio = regionArea / shapeArea;
      if (regionRatio < 0.1) continue;
      const regionWordArea = regionRatio * (wordArea * (regionAspect < 1 ? 2.7 - regionAspect : 1.7)), x4 = Math.sqrt(ratio * (regionArea / regionWordArea));
      xArr.push(x4);
    }
    x3 = xArr.length ? Math.min(...xArr) : Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));
  }
  return x3;
};
function initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput) {
  const { getText } = wordsConfig;
  let { fillingInitialFontSize, fillingDeltaFontSize } = layoutConfig;
  const { fillingRatio } = layoutConfig, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(segmentationOutput.shapeArea) / 4);
  if (!fillingInitialFontSize || !fillingDeltaFontSize) {
    const a4 = fillingRatio / 100, averageLength = data.reduce((acc, word) => {
      const length2 = calTextLength(getText(word));
      return length2 > shapeSizeLimitTextLength ? acc : acc + length2;
    }, 0) / data.length;
    let fontSize;
    if (0 === averageLength) fontSize = 8;
    else {
      const area2 = 0.2 * segmentationOutput.shapeArea;
      fontSize = Math.sqrt(a4 * (area2 / averageLength));
    }
    fillingInitialFontSize = ~~fontSize, fillingDeltaFontSize = fontSize * layoutConfig.fillingDeltaFontSizeFactor, Object.assign(layoutConfig, {
      fillingInitialFontSize,
      fillingDeltaFontSize
    });
  }
}
var extent4 = (field5, data) => {
  let min4 = 1 / 0, max4 = -1 / 0;
  const n2 = data.length;
  let v2;
  for (let i2 = 0; i2 < n2; ++i2) v2 = toNumber(field5(data[i2])), v2 < min4 && (min4 = v2), v2 > max4 && (max4 = v2);
  return 1 === data.length && min4 === max4 && (min4 -= 1e4), [min4, max4];
};
var field4 = (option) => option ? "string" == typeof option || "number" == typeof option ? () => option : isFunction_default(option) ? option : (datum) => datum[option.field] : null;

// node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js
var registerWordCloudShapeTransforms = () => {
  Factory.registerTransform("wordcloudShape", {
    transform: transform23,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/word-cloud.js
var WordCloudSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud;
  }
};
WordCloudSeries.type = SeriesTypeEnum.wordCloud;
var registerWordCloudSeries = () => {
  registerWordCloudTransforms(), registerTextMark(), registerWordCloudAnimation(), Factory2.registerSeries(WordCloudSeries.type, WordCloudSeries);
};
var registerWordCloudShapeSeries = () => {
  registerWordCloudShapeTransforms(), registerWordCloudTransforms(), registerTextMark(), registerWordCloudAnimation(), Factory2.registerSeries(WordCloudSeries.type, WordCloudSeries);
};

// node_modules/@visactor/vchart/esm/series/word-cloud/word-cloud-3d.js
var WordCloud3dSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud3d;
  }
  _wordCloudTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  _wordCloudShapeTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudShapeTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  initMark() {
    this._wordMark = this._createMark(BaseWordCloudSeries.mark.word, {
      groupKey: this._seriesField,
      support3d: true,
      isSeriesMark: true
    }), this._isWordCloudShape && (this._fillingWordMark = this._createMark(BaseWordCloudSeries.mark.fillingWord, {
      groupKey: this._seriesField,
      support3d: true,
      isSeriesMark: true
    }));
  }
  initMarkStyle() {
    super.initMarkStyle();
    const wordMark = this._wordMark, fillingWordMark = this._fillingWordMark;
    wordMark && this.setMarkStyle(wordMark, {
      z: (datum) => {
        var _a;
        return null !== (_a = datum.z) && void 0 !== _a ? _a : 0;
      }
    }, "normal", AttributeLevel.Series), fillingWordMark && this.setMarkStyle(fillingWordMark, {
      z: (datum) => {
        var _a;
        return null !== (_a = datum.z) && void 0 !== _a ? _a : 0;
      }
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b, _c;
    const padding = null !== (_a = this._padding) && void 0 !== _a ? _a : {};
    this._wordMark && this._wordMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("wordCloud3d")) || void 0 === _b ? void 0 : _b(() => {
      var _a2;
      const srView = this.getCompiler().getVGrammarView(), width = srView.width() - padding.left || 0 - padding.right || 0, height = srView.height() - padding.top || 0 - padding.bottom || 0, r2 = Math.max(width, height) / 2;
      return {
        center: {
          x: r2,
          y: r2,
          z: null !== (_a2 = this._spec.depth_3d) && void 0 !== _a2 ? _a2 : r2
        },
        r: r2
      };
    }), userAnimationConfig("word", this._spec, this._markAttributeContext))), this._fillingWordMark && this._fillingWordMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("wordCloud3d")) || void 0 === _c ? void 0 : _c(() => {
      var _a2;
      const srView = this.getCompiler().getVGrammarView(), width = srView.width() - padding.left || 0 - padding.right || 0, height = srView.height() - padding.top || 0 - padding.bottom || 0, r2 = Math.max(width, height) / 2;
      return {
        center: {
          x: r2,
          y: r2,
          z: null !== (_a2 = this._spec.depth_3d) && void 0 !== _a2 ? _a2 : r2
        },
        r: r2
      };
    }), userAnimationConfig("fillingWord", this._spec, this._markAttributeContext)));
  }
};
WordCloud3dSeries.type = SeriesTypeEnum.wordCloud3d;
var registerWordCloud3dSeries = () => {
  registerWordCloudTransforms(), registerTextMark(), registerWordCloud3dAnimation(), Factory2.registerSeries(WordCloud3dSeries.type, WordCloud3dSeries);
};
var registerWordCloudShape3dSeries = () => {
  registerWordCloudShapeTransforms(), registerWordCloudTransforms(), registerTextMark(), registerWordCloud3dAnimation(), Factory2.registerSeries(WordCloud3dSeries.type, WordCloud3dSeries);
};

// node_modules/@visactor/vchart/esm/data/transforms/funnel.js
var funnel2 = (originData, op) => {
  var _a, _b;
  const data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length) return data;
  const { valueField, asTransformRatio, asReachRatio, asHeightRatio, asValueRatio, asNextValueRatio, asLastValueRatio, asLastValue, asCurrentValue, asNextValue, heightVisual = false, isCone = true, range: range2 } = op, max4 = data.reduce((m5, d2) => Math.max(m5, Number.parseFloat(d2[valueField]) || -1 / 0), -1 / 0), min4 = data.reduce((m5, d2) => Math.min(m5, Number.parseFloat(d2[valueField]) || 1 / 0), 1 / 0), rangeArr = [null !== (_a = null == range2 ? void 0 : range2.min) && void 0 !== _a ? _a : min4, null !== (_b = null == range2 ? void 0 : range2.max) && void 0 !== _b ? _b : max4];
  return data.forEach((d2, i2) => {
    var _a2, _b2;
    const currentValue = Number.parseFloat(d2[valueField]), lastValue = Number.parseFloat(null === (_a2 = data[i2 - 1]) || void 0 === _a2 ? void 0 : _a2[valueField]), nextValue = Number.parseFloat(null === (_b2 = data[i2 + 1]) || void 0 === _b2 ? void 0 : _b2[valueField]), transformRatio = isValidNumber_default(nextValue * currentValue) && 0 !== currentValue ? nextValue / currentValue : 0, reachRatio = isValidNumber_default(currentValue * lastValue) && 0 !== lastValue ? currentValue / lastValue : 0;
    asLastValue && (d2[asLastValue] = lastValue), asNextValue && (d2[asNextValue] = nextValue), asTransformRatio && (d2[asTransformRatio] = transformRatio), asReachRatio && (d2[asReachRatio] = 0 === i2 ? 1 : reachRatio), asHeightRatio && (d2[asHeightRatio] = true === heightVisual ? transformRatio : 1 / data.length), asValueRatio && (d2[asValueRatio] = currentValue / rangeArr[1]), asNextValueRatio && (d2[asNextValueRatio] = i2 === data.length - 1 ? isCone ? 0 : d2[asValueRatio] : nextValue / rangeArr[1]), asLastValueRatio && (d2[asLastValueRatio] = 0 === i2 ? 1 : lastValue / rangeArr[1]), asCurrentValue && (d2[asCurrentValue] = currentValue);
  }), data;
};
var funnelTransform = (originData, op) => {
  var _a, _b;
  const data = null === (_b = null === (_a = originData[0]) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.map((datum) => Object.assign({}, datum));
  return data && 0 !== data.length ? (data.shift(), data.forEach((d2) => {
    d2[op.asIsTransformLevel] = true;
  }), data) : data;
};

// node_modules/@visactor/vchart/esm/constant/funnel.js
var FUNNEL_TRANSFORM_RATIO = `${PREFIX}_FUNNEL_TRANSFORM_RATIO`;
var FUNNEL_REACH_RATIO = `${PREFIX}_FUNNEL_REACH_RATIO`;
var FUNNEL_HEIGHT_RATIO = `${PREFIX}_FUNNEL_HEIGHT_RATIO`;
var FUNNEL_VALUE_RATIO = `${PREFIX}_FUNNEL_VALUE_RATIO`;
var FUNNEL_LAST_VALUE_RATIO = `${PREFIX}_FUNNEL_LAST_VALUE_RATIO`;
var FUNNEL_NEXT_VALUE_RATIO = `${PREFIX}_FUNNEL_NEXT_VALUE_RATIO`;
var FUNNEL_LAST_VALUE = `${PREFIX}_FUNNEL_LAST_VALUE`;
var FUNNEL_CURRENT_VALUE = `${PREFIX}_FUNNEL_CURRENT_VALUE`;
var FUNNEL_NEXT_VALUE = `${PREFIX}_FUNNEL_NEXT_VALUE`;
var FUNNEL_TRANSFORM_LEVEL = `${PREFIX}_FUNNEL_TRANSFORM_LEVEL`;
var FUNNEL_LABEL_LINE_LENGTH = 20;
var FUNNEL_LABEL_SPACE_WIDTH = 5;
var FUNNEL_MAX_SIZE = "80%";
var FUNNEL_MIN_SIZE = 0;

// node_modules/@visactor/vchart/esm/series/funnel/tooltip-helper.js
var FunnelSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.titleValueCallback = (datum, params2) => {
      var _a, _b, _c;
      const series2 = this.series;
      return "transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name) ? "转化率" : null !== (_b = this._getDimensionData(datum)) && void 0 !== _b ? _b : null === (_c = datum.properties) || void 0 === _c ? void 0 : _c[`${series2.getCategoryField()}`];
    }, this.contentValueCallback = (datum, params2) => {
      var _a;
      if ("transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name)) {
        return `${(100 * (null == datum ? void 0 : datum[FUNNEL_REACH_RATIO])).toFixed(1)}%`;
      }
      return this._getMeasureData(datum);
    }, this.contentKeyCallback = (datum, params2) => {
      var _a;
      if ("transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name)) return "转化率";
      const { dimensionFields, seriesFields } = this._seriesCacheInfo, subDimensionField = dimensionFields[dimensionFields.length - 1];
      return isValid_default(seriesFields[0]) ? null == datum ? void 0 : datum[seriesFields[0]] : null == datum ? void 0 : datum[subDimensionField];
    };
  }
};

// node_modules/@visactor/vchart/esm/mark/polygon/base-polygon.js
var BasePolygonMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      points: []
    });
  }
};

// node_modules/@visactor/vchart/esm/mark/polygon/polygon.js
var PolygonMark = class _PolygonMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _PolygonMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
};
PolygonMark.type = "polygon";
var registerPolygonMark = () => {
  Factory2.registerMark(PolygonMark.type, PolygonMark), registerPolygonGraphic2(), registerVGrammarPolygonAnimation();
};

// node_modules/@visactor/vchart/esm/series/funnel/funnel-transformer.js
var FunnelSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel"), spec.isTransform && this._addMarkLabelSpec(spec, "transform", "transformLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/funnel/funnel.js
var FunnelSeries = class _FunnelSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel, this._funnelMarkName = "funnel", this._funnelMarkType = "polygon", this._transformMarkName = "transform", this._transformMarkType = "polygon", this.transformerConstructor = FunnelSeriesSpecTransformer, this._funnelMark = null, this._funnelTransformMark = null, this._labelMark = null, this._transformLabelMark = null, this._funnelOuterLabelMark = {};
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this._funnelOrient = null !== (_a = this._spec.funnelOrient) && void 0 !== _a ? _a : "top", this._shape = null !== (_b = this._spec.shape) && void 0 !== _b ? _b : "trapezoid", this._isHorizontal() ? this._funnelAlign = ["top", "bottom"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center" : this._funnelAlign = ["left", "right"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center", this._spec.categoryField && this.setSeriesField(this._spec.categoryField);
  }
  initData() {
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "funnel", funnel2), registerDataSetInstanceTransform(this._dataSet, "funnelTransform", funnelTransform);
    const viewDataTransform = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataTransform`
    });
    viewDataTransform.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataTransform = new SeriesData(this._option, viewDataTransform);
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._categoryField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  _statisticViewData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    super._statisticViewData(), this._data.getDataView().transform({
      type: "funnel",
      options: {
        valueField: this.getValueField(),
        isCone: this._spec.isCone,
        asCurrentValue: FUNNEL_CURRENT_VALUE,
        asTransformRatio: FUNNEL_TRANSFORM_RATIO,
        asReachRatio: FUNNEL_REACH_RATIO,
        asHeightRatio: FUNNEL_HEIGHT_RATIO,
        asValueRatio: FUNNEL_VALUE_RATIO,
        asNextValueRatio: FUNNEL_NEXT_VALUE_RATIO,
        asLastValueRatio: FUNNEL_LAST_VALUE_RATIO,
        asLastValue: FUNNEL_LAST_VALUE,
        asNextValue: FUNNEL_NEXT_VALUE,
        range: {
          min: null !== (_b = null === (_a = this._spec.range) || void 0 === _a ? void 0 : _a.min) && void 0 !== _b ? _b : null === (_d = null === (_c = this.getViewDataStatistics().latestData) || void 0 === _c ? void 0 : _c[this.getValueField()]) || void 0 === _d ? void 0 : _d.min,
          max: null !== (_f = null === (_e = this._spec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null === (_h = null === (_g = this.getViewDataStatistics().latestData) || void 0 === _g ? void 0 : _g[this.getValueField()]) || void 0 === _h ? void 0 : _h.max
        }
      }
    }), null === (_j = this._viewDataTransform.getDataView()) || void 0 === _j || _j.transform({
      type: "funnelTransform",
      options: {
        asIsTransformLevel: FUNNEL_TRANSFORM_LEVEL
      }
    });
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.funnel), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel,
      morph: shouldMarkDoMorph(this._spec, this._funnelMarkName),
      defaultMorphElementKey: this._seriesField,
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_b = this._spec.funnel) || void 0 === _b ? void 0 : _b.customShape
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.transform), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_c = this._theme) || void 0 === _c ? void 0 : _c.transform,
      skipBeforeLayouted: false,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId(),
      customShape: null === (_d = this._spec.transform) || void 0 === _d ? void 0 : _d.customShape
    })), null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.outerLabel) || void 0 === _f ? void 0 : _f.visible) {
      const { line: line2 } = null !== (_g = this._spec.outerLabel) && void 0 !== _g ? _g : {}, { line: lineTheme } = null !== (_j = null === (_h = this._theme) || void 0 === _h ? void 0 : _h.outerLabel) && void 0 !== _j ? _j : {};
      this._funnelOuterLabelMark.label = this._createMark(_FunnelSeries.mark.outerLabel, {
        themeSpec: null === (_k = this._theme) || void 0 === _k ? void 0 : _k.outerLabel,
        markSpec: this._spec.outerLabel,
        skipBeforeLayouted: true
      }), this._funnelOuterLabelMark.line = this._createMark(_FunnelSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label]
      });
    }
  }
  initTooltip() {
    this._tooltipHelper = new FunnelSeriesTooltipHelper(this), this._funnelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelMark), this._funnelTransformMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelTransformMark);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getGroupFields() {
    return null;
  }
  initMarkStyle() {
    const funnelMark = this._funnelMark;
    funnelMark && (this.setMarkStyle(funnelMark, {
      points: (datum) => this.getPoints(datum),
      visible: (datum) => isValid_default(datum[this._valueField]),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(funnelMark));
    const funnelTransformMark = this._funnelTransformMark;
    funnelTransformMark && (this.setMarkStyle(funnelTransformMark, {
      points: (datum) => this.getPoints(datum)
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(funnelTransformMark));
    const outerLabelMark = this._funnelOuterLabelMark.label;
    outerLabelMark && this.setMarkStyle(outerLabelMark, {
      text: (datum) => {
        const text2 = `${datum[this.getCategoryField()]}`;
        return isFunction_default(this._spec.outerLabel.formatMethod) ? this._spec.outerLabel.formatMethod(text2, datum) : text2;
      },
      x: (datum) => this._computeOuterLabelPosition(datum).x,
      y: (datum) => this._computeOuterLabelPosition(datum).y,
      textAlign: (datum) => this._computeOuterLabelPosition(datum).align,
      textBaseline: (datum) => this._computeOuterLabelPosition(datum).textBaseline,
      limit: (datum) => this._computeOuterLabelLimit(datum)
    }, "normal", AttributeLevel.Series);
    const outerLabelLineMark = this._funnelOuterLabelMark.line;
    outerLabelLineMark && outerLabelMark && this.setMarkStyle(outerLabelLineMark, {
      x: (datum) => this._computeOuterLabelLinePosition(datum).x1,
      y: (datum) => this._computeOuterLabelLinePosition(datum).y1,
      x1: (datum) => this._computeOuterLabelLinePosition(datum).x2,
      y1: (datum) => this._computeOuterLabelLinePosition(datum).y2
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    if (!labelMark) return;
    const target = labelMark.getTarget(), component2 = labelMark.getComponent();
    target === this._funnelMark ? (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${datum[this.getCategoryField()]} ${datum[this.getValueField()]}`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.label),
      stroke: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(component2), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend())) : this._funnelTransformMark && target === this._funnelTransformMark && (this._transformLabelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${(100 * field2(FUNNEL_REACH_RATIO).bind(this)(datum)).toFixed(1)}%`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.transformLabel)
    }, "normal", AttributeLevel.Series));
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("cartesianGroupClip")) || void 0 === _d ? void 0 : _d({
      direction: () => this._isHorizontal() ? "x" : "y",
      width: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { x1: x14, x2: x23 } = rootMark.getBounds();
          return Math.max(x14, x23);
        }
        return this.getLayoutRect().width;
      },
      height: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { y1: y14, y2: y23 } = rootMark.getBounds();
          return Math.max(y14, y23);
        }
        return this.getLayoutRect().height;
      },
      orient: () => this._isReverse() ? "negative" : "positive"
    }, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext))), [null === (_e = this._funnelOuterLabelMark) || void 0 === _e ? void 0 : _e.label].forEach((m5) => {
      m5 && m5.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("fadeInOut")(), userAnimationConfig(m5.name, this._spec, this._markAttributeContext)));
    }), [this._funnelMark, this._funnelTransformMark].forEach((m5) => {
      m5 && m5.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("funnel")({}, appearPreset), userAnimationConfig(m5.name, this._spec, this._markAttributeContext)));
    }), (null === (_f = this._funnelOuterLabelMark) || void 0 === _f ? void 0 : _f.line) && this._funnelOuterLabelMark.line.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _g ? void 0 : _g(), userAnimationConfig("outerLabelLine", this._spec, this._markAttributeContext)));
  }
  initGroups() {
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return null;
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataTransform.getDataView()) || void 0 === _a || _a.target.addListener("change", (d2) => {
      this._viewDataTransform.updateData();
    });
  }
  getPoints(datum) {
    const isTransformLevel = this.isTransformLevel(datum), heightHalf = this._getMainAxisLength(isTransformLevel) / 2;
    let upperLeft, lowerLeft;
    isTransformLevel ? (upperLeft = "rect" === this._shape ? this._getSecondaryAxisLength(datum[FUNNEL_LAST_VALUE_RATIO]) / 2 : this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2) : (upperLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = "rect" === this._shape ? upperLeft : this._getSecondaryAxisLength(datum[FUNNEL_NEXT_VALUE_RATIO]) / 2);
    const { x: x3, y: y3 } = this._getPositionByData(datum), points = this._getPolygonPoints([x3, y3], upperLeft, lowerLeft, upperLeft, lowerLeft, heightHalf);
    return "center" !== this._funnelAlign && this._adjustPoints(points), points;
  }
  isTransformLevel(datum) {
    return !!(null == datum ? void 0 : datum[FUNNEL_TRANSFORM_LEVEL]);
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this);
  }
  valueToPosition(category) {
    var _a, _b, _c;
    const innerDatum = null === (_c = null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.find) || void 0 === _c ? void 0 : _c.call(_b, (d2) => d2[this._categoryField] === category);
    return isValid_default(innerDatum) ? this._getPolygonCenter(this.getPoints(innerDatum)) : null;
  }
  dataToPosition(datum) {
    return this.valueToPosition(datum[this._categoryField]);
  }
  dataToPositionX(datum) {
    return this.dataToPosition(datum).x;
  }
  dataToPositionY(datum) {
    return this.dataToPosition(datum).y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  _getMainAxisLength(isTransform = false) {
    var _a;
    const funnelCount = this.getViewData().latestData.length, viewHeight = this._isHorizontal() ? this.getLayoutRect().width : this.getLayoutRect().height, hasTransform = !!this._spec.isTransform, gap = hasTransform ? 0 : null !== (_a = this._spec.gap) && void 0 !== _a ? _a : 0, transformCount = hasTransform ? Math.max(0, funnelCount - 1) : 0, funnelHeight = (viewHeight - gap * Math.max(0, funnelCount - 1)) / (funnelCount + 0.5 * transformCount);
    return isTransform ? hasTransform ? 0.5 * funnelHeight : 0 : funnelHeight;
  }
  _getSecondaryAxisLength(ratio) {
    const validRatio = Number.isNaN(ratio) || !Number.isFinite(ratio) ? 0 : ratio, maxSize = this._computeMaxSize(), minSize = this._computeMinSize();
    return minSize + (maxSize - minSize) * validRatio;
  }
  _getPositionByData(datum) {
    var _a;
    const index = null === (_a = this.getViewData().latestData) || void 0 === _a ? void 0 : _a.findIndex((d2) => d2[this._categoryField] === datum[this._categoryField] && d2[DEFAULT_DATA_KEY] === datum[DEFAULT_DATA_KEY]);
    if (!isValid_default(index) || index < 0) return {};
    const isTransform = this.isTransformLevel(datum), isHorizontal4 = this._isHorizontal(), viewWidth = isHorizontal4 ? this.getLayoutRect().height : this.getLayoutRect().width, viewHeight = isHorizontal4 ? this.getLayoutRect().width : this.getLayoutRect().height, centerX = viewWidth / 2;
    let centerY = 0;
    const funnelHeight = this._getMainAxisLength(), transformHeight = this._getMainAxisLength(true);
    return centerY += index * (funnelHeight + transformHeight), centerY += isTransform ? -transformHeight / 2 : funnelHeight / 2, !this._spec.isTransform && this._spec.gap && (centerY += this._spec.gap * index), this._isReverse() && (centerY = viewHeight - centerY), this._isHorizontal() ? {
      x: centerY,
      y: centerX
    } : {
      x: centerX,
      y: centerY
    };
  }
  _getPolygonPoints(center2, upperLeft, lowerLeft, upperRight, lowerRight, heightHalf) {
    const x3 = center2[0], y3 = center2[1];
    switch (this._funnelOrient) {
      case "left":
        return [{
          x: x3 - heightHalf,
          y: y3 + upperLeft
        }, {
          x: x3 - heightHalf,
          y: y3 - upperRight
        }, {
          x: x3 + heightHalf,
          y: y3 - lowerRight
        }, {
          x: x3 + heightHalf,
          y: y3 + lowerLeft
        }];
      case "right":
        return [{
          x: x3 + heightHalf,
          y: y3 - upperRight
        }, {
          x: x3 + heightHalf,
          y: y3 + upperRight
        }, {
          x: x3 - heightHalf,
          y: y3 + lowerLeft
        }, {
          x: x3 - heightHalf,
          y: y3 - lowerLeft
        }];
      case "bottom":
        return [{
          x: x3 + upperLeft,
          y: y3 + heightHalf
        }, {
          x: x3 - upperRight,
          y: y3 + heightHalf
        }, {
          x: x3 - lowerRight,
          y: y3 - heightHalf
        }, {
          x: x3 + lowerLeft,
          y: y3 - heightHalf
        }];
      default:
        return [{
          x: x3 - upperLeft,
          y: y3 - heightHalf
        }, {
          x: x3 + upperRight,
          y: y3 - heightHalf
        }, {
          x: x3 + lowerRight,
          y: y3 + heightHalf
        }, {
          x: x3 - lowerLeft,
          y: y3 + heightHalf
        }];
    }
  }
  _getPolygonCenter(points) {
    if (this._isHorizontal()) {
      const p0_x2 = (points[0].x + points[3].x) / 2, p0_y2 = (points[0].y + points[3].y) / 2;
      return {
        x: (p0_x2 + (points[1].x + points[2].x) / 2) / 2,
        y: (p0_y2 + (points[1].y + points[2].y) / 2) / 2
      };
    }
    const p0_x = (points[0].x + points[3].x) / 2, p0_y = (points[0].y + points[3].y) / 2;
    return {
      x: (p0_x + (points[1].x + points[2].x) / 2) / 2,
      y: (p0_y + (points[1].y + points[2].y) / 2) / 2
    };
  }
  _adjustPoints(points) {
    let upperOffset, lowerOffset, dirKey;
    return this._isHorizontal() ? (dirKey = "y", "left" === this._funnelOrient ? (upperOffset = "bottom" === this._funnelAlign ? -points[1].y : points[1].y, lowerOffset = "bottom" === this._funnelAlign ? -points[2].y : points[2].y) : (upperOffset = "bottom" === this._funnelAlign ? -points[0].y : points[0].y, lowerOffset = "bottom" === this._funnelAlign ? -points[3].y : points[3].y)) : (dirKey = "x", "top" === this._funnelOrient ? (upperOffset = "left" === this._funnelAlign ? points[0].x : -points[0].x, lowerOffset = "left" === this._funnelAlign ? points[3].x : -points[3].x) : (upperOffset = "left" === this._funnelAlign ? points[1].x : -points[1].x, lowerOffset = "left" === this._funnelAlign ? points[2].x : -points[2].x)), points[0][dirKey] -= upperOffset, points[1][dirKey] -= upperOffset, points[2][dirKey] -= lowerOffset, points[3][dirKey] -= lowerOffset, points;
  }
  _computeLabelPosition(datum) {
    const points = this.getPoints(datum);
    return this._getPolygonCenter(points);
  }
  _computeLabelLimit(datum, labelSpec) {
    const limit = null == labelSpec ? void 0 : labelSpec.limit;
    if (isNumber_default(limit)) return limit;
    const points = this.getPoints(datum);
    return "shapeSize" === limit ? this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2 : this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : void 0;
  }
  _computeOuterLabelPosition(datum) {
    var _a, _b;
    let x3, y3, position = null === (_a = this._spec.outerLabel) || void 0 === _a ? void 0 : _a.position, textAlign = "center", textBaseline = "middle";
    if (position = this._isHorizontal() ? ["top", "bottom"].includes(position) ? position : "bottom" === this._funnelAlign ? "top" : "bottom" : ["left", "right"].includes(position) ? position : "left" === this._funnelAlign ? "right" : "left", false !== (null === (_b = this._spec.outerLabel) || void 0 === _b ? void 0 : _b.alignLabel)) ({ x: x3, y: y3 } = this._getPositionByData(datum)), "left" === position ? (x3 = 0, textAlign = "left") : "right" === position ? (x3 = this.getLayoutRect().width, textAlign = "right") : "top" === position ? (y3 = 0, textBaseline = "top") : "bottom" === position && (y3 = this.getLayoutRect().height, textBaseline = "bottom");
    else {
      const { x2: x23, y2: y23 } = this._computeOuterLabelLinePosition(datum);
      x3 = x23, y3 = y23, "left" === position ? (x3 -= FUNNEL_LABEL_SPACE_WIDTH, textAlign = "right") : "right" === position ? (x3 += FUNNEL_LABEL_SPACE_WIDTH, textAlign = "left") : "top" === position ? (y3 -= FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "bottom") : "bottom" === position && (y3 += FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "top");
    }
    return {
      x: x3,
      y: y3,
      align: textAlign,
      textBaseline
    };
  }
  _computeOuterLabelLimit(datum) {
    var _a, _b, _c, _d, _e;
    if (this._isHorizontal()) return this._getMainAxisLength(this.isTransformLevel(datum));
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, categoryField = this.getCategoryField(), funnelLabelBounds = null === (_c = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct().getGroupGraphicItem().find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _c ? void 0 : _c.AABBBounds, funnelLabelWidth = funnelLabelBounds ? funnelLabelBounds.x2 - funnelLabelBounds.x1 : 0;
    return this.getLayoutRect().width / 2 - Math.max(shapeMiddleWidth / 2, funnelLabelWidth / 2) - FUNNEL_LABEL_LINE_LENGTH - 2 * (null !== (_e = null === (_d = this._spec.outerLabel) || void 0 === _d ? void 0 : _d.spaceWidth) && void 0 !== _e ? _e : FUNNEL_LABEL_SPACE_WIDTH);
  }
  _computeOuterLabelLinePosition(datum) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const categoryField = this.getCategoryField(), outerLabelMarkBounds = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.getProduct()) || void 0 === _c ? void 0 : _c.elements) || void 0 === _d ? void 0 : _d.find((el) => {
      var _a2;
      return (null === (_a2 = el.data[0]) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    })) || void 0 === _e ? void 0 : _e.getBounds(), labelMarkBounds = null === (_h = null === (_g = null === (_f = this._labelMark) || void 0 === _f ? void 0 : _f.getComponent()) || void 0 === _g ? void 0 : _g.getProduct().getGroupGraphicItem().find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _h ? void 0 : _h.AABBBounds, outerLabelSpec = null !== (_j = this._spec.outerLabel) && void 0 !== _j ? _j : {};
    let x14, x23, y14, y23;
    if (this._isHorizontal()) {
      const spaceWidth2 = null !== (_k = outerLabelSpec.spaceWidth) && void 0 !== _k ? _k : FUNNEL_LABEL_SPACE_WIDTH, points2 = this.getPoints(datum), shapeMiddleHeight = (Math.abs(points2[0].y - points2[1].y) + Math.abs(points2[2].y - points2[3].y)) / 2;
      return "top" === this._spec.outerLabel.position || "bottom" === this._funnelAlign ? (y14 = this._getPolygonCenter(points2).y - shapeMiddleHeight / 2 - spaceWidth2, y23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y2) + spaceWidth2 : y14 - spaceWidth2, x14 = this._getPolygonCenter(points2).x, y14 - y23 < FUNNEL_LABEL_LINE_LENGTH && (y23 = y14 - FUNNEL_LABEL_LINE_LENGTH), x23 = x14) : (y14 = this._getPolygonCenter(points2).y + shapeMiddleHeight / 2 + spaceWidth2, y23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y1) - spaceWidth2 : y14 + spaceWidth2, x14 = this._getPolygonCenter(points2).x, y23 - y14 < FUNNEL_LABEL_LINE_LENGTH && (y23 = y14 + FUNNEL_LABEL_LINE_LENGTH), x23 = x14), {
        x1: x14,
        x2: x23,
        y1: y14,
        y2: y23
      };
    }
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, labelWidth = (null == labelMarkBounds ? void 0 : labelMarkBounds.x2) - (null == labelMarkBounds ? void 0 : labelMarkBounds.x1) || 0, spaceWidth = null !== (_l = outerLabelSpec.spaceWidth) && void 0 !== _l ? _l : FUNNEL_LABEL_SPACE_WIDTH;
    return "right" === this._spec.outerLabel.position || "left" === this._funnelAlign ? (x14 = this._getPolygonCenter(points).x + Math.max(labelWidth / 2, shapeMiddleWidth / 2) + spaceWidth, x23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x1) - spaceWidth : x14 + spaceWidth, y14 = this._getPolygonCenter(points).y, x23 - x14 < FUNNEL_LABEL_LINE_LENGTH && (x23 = x14 + FUNNEL_LABEL_LINE_LENGTH), y23 = y14) : (x14 = this._getPolygonCenter(points).x - Math.max(labelWidth / 2, shapeMiddleWidth / 2) - spaceWidth, x23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x2) + spaceWidth : x14 - spaceWidth, y14 = this._getPolygonCenter(points).y, x14 - x23 < FUNNEL_LABEL_LINE_LENGTH && (x23 = x14 - FUNNEL_LABEL_LINE_LENGTH), y23 = y14), {
      x1: x14,
      x2: x23,
      y1: y14,
      y2: y23
    };
  }
  _computeMaxSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, maxSize = null !== (_a = this._spec.maxSize) && void 0 !== _a ? _a : FUNNEL_MAX_SIZE;
    return calcLayoutNumber(maxSize, size);
  }
  _computeMinSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, minSize = null !== (_a = this._spec.minSize) && void 0 !== _a ? _a : FUNNEL_MIN_SIZE;
    return calcLayoutNumber(minSize, size);
  }
  _isHorizontal() {
    return "left" === this._funnelOrient || "right" === this._funnelOrient;
  }
  _isReverse() {
    return "bottom" === this._funnelOrient || "right" === this._funnelOrient;
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._funnelMark];
  }
};
FunnelSeries.type = SeriesTypeEnum.funnel, FunnelSeries.mark = funnelSeriesMark, FunnelSeries.transformerConstructor = FunnelSeriesSpecTransformer;
var registerFunnelSeries = () => {
  registerPolygonMark(), registerTextMark(), registerRuleMark(), Factory2.registerSeries(FunnelSeries.type, FunnelSeries), Factory2.registerAnimation("funnel", (params2, preset) => Object.assign({
    appear: "clipIn" === preset ? void 0 : {
      type: "fadeIn"
    }
  }, FadeInOutAnimation)), registerCartesianGroupClipAnimation(), registerFadeInOutAnimation();
};

// node_modules/@visactor/vchart/esm/mark/polygon/pyramid-3d.js
var Pyramid3dMark = class _Pyramid3dMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _Pyramid3dMark.type;
  }
};
Pyramid3dMark.type = "pyramid3d";
var registerPyramid3dMark = () => {
  Factory2.registerMark(Pyramid3dMark.type, Pyramid3dMark), registerPyramid3dGraphic2(), registerVGrammarPolygonAnimation();
};

// node_modules/@visactor/vchart/esm/series/funnel/3d/funnel-3d-transformer.js
var Funnel3dSeriesSpecTransformer = class extends FunnelSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel3d"), spec.isTransform && this._addMarkLabelSpec(spec, "transform3d", "transformLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/funnel/3d/funnel-3d.js
var Funnel3dSeries = class _Funnel3dSeries extends FunnelSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel3d, this._funnelMarkName = "funnel3d", this._funnelMarkType = "pyramid3d", this._transformMarkName = "transform3d", this._transformMarkType = "pyramid3d", this.transformerConstructor = Funnel3dSeriesSpecTransformer;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.funnel3d), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel3d,
      key: this._seriesField,
      isSeriesMark: true,
      support3d: true
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.transform3d), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_b = this._theme) || void 0 === _b ? void 0 : _b.transform3d,
      key: this._seriesField,
      skipBeforeLayouted: false,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId()
    })), null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.outerLabel) || void 0 === _d ? void 0 : _d.visible) {
      const { line: line2 } = null !== (_e = this._spec.outerLabel) && void 0 !== _e ? _e : {}, { line: lineTheme } = null !== (_g = null === (_f = this._theme) || void 0 === _f ? void 0 : _f.outerLabel) && void 0 !== _g ? _g : {};
      this._funnelOuterLabelMark.label = this._createMark(_Funnel3dSeries.mark.outerLabel, {
        themeSpec: null === (_h = this._theme) || void 0 === _h ? void 0 : _h.outerLabel,
        key: this._seriesField,
        markSpec: this._spec.outerLabel
      }), this._funnelOuterLabelMark.line = this._createMark(_Funnel3dSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        key: this._seriesField,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label]
      });
    }
  }
  initMarkStyle() {
    super.initMarkStyle();
    const funnelMark = this._funnelMark;
    funnelMark && this.setMarkStyle(funnelMark, {
      z: (_2) => {
        if (this._isHorizontal()) return 0;
        const points = this.getPoints(_2), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    super.initLabelMarkStyle(labelMark), this.setMarkStyle(labelMark, {
      z: (_2) => {
        if (this._isHorizontal()) return 0;
        const points = this.getPoints(_2), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series), this._labelMark = labelMark, (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(labelMark.getComponent()), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend());
  }
};
Funnel3dSeries.type = SeriesTypeEnum.funnel3d, Funnel3dSeries.mark = funnel3dSeriesMark, Funnel3dSeries.transformerConstructor = Funnel3dSeriesSpecTransformer;
var registerFunnel3dSeries = () => {
  registerPyramid3dMark(), registerTextMark(), registerRuleMark(), Factory2.registerSeries(Funnel3dSeries.type, Funnel3dSeries);
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/utils.js
var computeRatio = (angle2, range2) => {
  const ratio = (angle2 - range2[0]) / (range2[1] - range2[0] || 1);
  return Math.max(0, Math.min(1, ratio));
};
var getInnerMostElements = (element) => {
  const updateElements = element.mark.elements.filter((e3) => e3.diffState === DiffState.update), minDepth = minInArray(updateElements.map((e3) => {
    var _a;
    return null === (_a = null == e3 ? void 0 : e3.data) || void 0 === _a ? void 0 : _a[0].depth;
  }));
  return updateElements.filter((e3) => {
    var _a;
    return (null === (_a = null == e3 ? void 0 : e3.data) || void 0 === _a ? void 0 : _a[0].depth) === minDepth;
  });
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/enter.js
var computeInnerAngleRange = (elements, startAngle, endAngle) => {
  if (isEmpty_default(elements)) return [startAngle, endAngle];
  return [minInArray(elements.map((m5) => 1 * m5.getGraphicAttribute("startAngle", false))), maxInArray(elements.map((m5) => 1 * m5.getGraphicAttribute("endAngle", false)))];
};
var sunburstEnter = (params2) => ({
  channel: {
    startAngle: {
      from: (d2, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
        return computeRatio(d2.startAngle, angleRange) * (endAngle - startAngle) + startAngle;
      },
      to: (d2) => d2.startAngle
    },
    endAngle: {
      from: (d2, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
        return computeRatio(d2.endAngle, angleRange) * (endAngle - startAngle) + startAngle;
      },
      to: (d2) => d2.endAngle
    },
    outerRadius: {
      from: (d2) => d2.innerRadius,
      to: (d2) => d2.outerRadius
    },
    innerRadius: {
      from: (d2) => d2.innerRadius,
      to: (d2) => d2.innerRadius
    }
  }
});

// node_modules/@visactor/vchart/esm/series/sunburst/animation/exit.js
var computeInnerAngleRange2 = (elements) => [minInArray(elements.map((m5) => 1 * m5.getGraphicAttribute("startAngle", false))), maxInArray(elements.map((m5) => 1 * m5.getGraphicAttribute("endAngle", false)))];
var sunburstExit = (params2) => ({
  channel: {
    startAngle: {
      from: (_d, element) => element.getGraphicAttribute("startAngle", false),
      to: (_d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), range2 = computeInnerAngleRange2(innerElements);
        return computeRatio(element.getGraphicAttribute("startAngle", false), range2) * (endAngle - startAngle) + startAngle;
      }
    },
    endAngle: {
      from: (_d, element) => element.getGraphicAttribute("endAngle", false),
      to: (_d, element) => {
        const { startAngle, endAngle } = params2.animationInfo(), innerElements = getInnerMostElements(element), range2 = computeInnerAngleRange2(innerElements);
        return computeRatio(element.getGraphicAttribute("endAngle", false), range2) * (endAngle - startAngle) + startAngle;
      }
    },
    outerRadius: {
      from: (_d, element) => element.getGraphicAttribute("outerRadius", false),
      to: () => params2.animationInfo().innerRadius
    },
    innerRadius: {
      from: (_d, element) => element.getGraphicAttribute("innerRadius", false),
      to: () => params2.animationInfo().innerRadius
    }
  }
});

// node_modules/@visactor/vchart/esm/series/sunburst/animation/preset.js
var sunburstPresetAnimation = (_params, preset) => {
  switch (preset) {
    case "fadeIn":
      return {
        type: "fadeIn"
      };
    case "growAngle":
      return {
        type: "growAngleIn"
      };
    default:
      return {
        type: "growRadiusIn"
      };
  }
};

// node_modules/@visactor/vchart/esm/series/sunburst/animation/index.js
var registerSunburstAnimation = () => {
  Factory2.registerAnimation("sunburst", (params2, preset) => ({
    appear: sunburstPresetAnimation(params2, preset),
    enter: sunburstEnter(params2),
    exit: sunburstExit(params2),
    disappear: sunburstExit(params2)
  }));
};

// node_modules/@visactor/vgrammar-hierarchy/es/format.js
var flattenNodes = (nodes, output = [], options) => {
  const hasMaxDepth = (null == options ? void 0 : options.maxDepth) >= 0;
  return nodes.forEach((node) => {
    (!hasMaxDepth || node.depth <= options.maxDepth) && (output.push((null == options ? void 0 : options.callback) ? options.callback(node) : node), node.children && (hasMaxDepth && node.depth === options.maxDepth ? (node.children = null, node.isLeaf = true) : flattenNodes(node.children, output, options)));
  }), output;
};

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/binary.js
function binary_default(parent, x05, y05, x14, y14) {
  const nodes = parent.children, n2 = nodes.length;
  let sum5 = 0;
  const sums = new Array(n2 + 1);
  sums[0] = 0;
  for (let i2 = 0; i2 < n2; ++i2) sum5 += nodes[i2].value, sums[i2 + 1] = sum5;
  const partition = (i2, j2, value, x06, y06, x15, y15) => {
    if (i2 >= j2 - 1) {
      const node = nodes[i2];
      return node.x0 = x06, node.y0 = y06, node.x1 = x15, void (node.y1 = y15);
    }
    const valueOffset = sums[i2], valueTarget = value / 2 + valueOffset;
    let k3 = i2 + 1, hi = j2 - 1;
    for (; k3 < hi; ) {
      const mid = k3 + hi >>> 1;
      sums[mid] < valueTarget ? k3 = mid + 1 : hi = mid;
    }
    valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3 && --k3;
    const valueLeft = sums[k3] - valueOffset, valueRight = value - valueLeft;
    if (x15 - x06 > y15 - y06) {
      const xk = value ? (x06 * valueRight + x15 * valueLeft) / value : x15;
      partition(i2, k3, valueLeft, x06, y06, xk, y15), partition(k3, j2, valueRight, xk, y06, x15, y15);
    } else {
      const yk = value ? (y06 * valueRight + y15 * valueLeft) / value : y15;
      partition(i2, k3, valueLeft, x06, y06, x15, yk), partition(k3, j2, valueRight, x06, yk, x15, y15);
    }
  };
  partition(0, n2, parent.value, x05, y05, x14, y14);
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/dice.js
function dice_default(parent, x05, y05, x14, y14, keyMap2 = {
  x0: "x0",
  x1: "x1",
  y0: "y0",
  y1: "y1"
}) {
  const nodes = parent.children;
  let node, i2 = -1;
  const n2 = nodes.length, k3 = parent.value && (x14 - x05) / parent.value;
  for (; ++i2 < n2; ) node = nodes[i2], node[keyMap2.y0] = y05, node[keyMap2.y1] = y14, node[keyMap2.x0] = x05, node[keyMap2.x1] = x05 += node.value * k3;
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/slice.js
function slice_default(parent, x05, y05, x14, y14) {
  const nodes = parent.children;
  let node, i2 = -1;
  const n2 = nodes.length, k3 = parent.value && (y14 - y05) / parent.value;
  for (; ++i2 < n2; ) node = nodes[i2], node.x0 = x05, node.x1 = x14, node.y0 = y05, y05 += node.value * k3, node.y1 = y05;
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/sliceDice.js
function sliceDice_default(parent, x05, y05, x14, y14) {
  (parent.depth % 2 == 1 ? slice_default : dice_default)(parent, x05, y05, x14, y14);
}

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/squarify.js
function squarifyRatio(ratio, parent, x05, y05, x14, y14) {
  const rows = [], nodes = parent.children;
  let row, nodeValue, i0 = 0, i1 = 0;
  const n2 = nodes.length;
  let dx, dy, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta, value = parent.value;
  for (; i0 < n2; ) {
    dx = x14 - x05, dy = y14 - y05;
    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n2);
    for (minValue = sumValue, maxValue = sumValue, alpha = Math.max(dy / dx, dx / dy) / (value * ratio), beta = sumValue * sumValue * alpha, minRatio = Math.max(maxValue / beta, beta / minValue); i1 < n2; ++i1) {
      if (nodeValue = nodes[i1].value, sumValue += nodeValue, nodeValue < minValue && (minValue = nodeValue), nodeValue > maxValue && (maxValue = nodeValue), beta = sumValue * sumValue * alpha, newRatio = Math.max(maxValue / beta, beta / minValue), newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    row = Object.assign({}, parent, {
      value: sumValue,
      children: nodes.slice(i0, i1)
    }), rows.push(row), dx < dy ? dice_default(row, x05, y05, x14, value ? y05 += dy * sumValue / value : y14) : slice_default(row, x05, y05, value ? x05 += dx * sumValue / value : x14, y14), value -= sumValue, i0 = i1;
  }
  return rows;
}
var generateSquarify = (ratio) => (parent, x05, y05, x14, y14) => {
  squarifyRatio(ratio, parent, x05, y05, x14, y14);
};

// node_modules/@visactor/vgrammar-hierarchy/es/utils.js
var calculateNodeValue = (subTree, output, depth = 0, flattenIndex = -1, parent, getNodeKey) => {
  let sum5 = 0, prevFlattenIndex = null != flattenIndex ? flattenIndex : -1, maxDepth2 = depth;
  return subTree.forEach((datum, index) => {
    var _a, _b;
    const node = {
      flattenIndex: ++prevFlattenIndex,
      key: getNodeKey ? getNodeKey(datum) : `${null !== (_a = null == parent ? void 0 : parent.key) && void 0 !== _a ? _a : ""}-${index}`,
      maxDepth: -1,
      depth,
      index,
      value: datum.value,
      isLeaf: true,
      datum: parent ? parent.datum.concat(datum) : [datum],
      parentKey: null == parent ? void 0 : parent.key
    };
    if (null === (_b = datum.children) || void 0 === _b ? void 0 : _b.length) {
      node.children = [], node.isLeaf = false;
      const res = calculateNodeValue(datum.children, node.children, depth + 1, prevFlattenIndex, node, getNodeKey);
      node.value = isNil_default(datum.value) ? res.sum : Math.max(res.sum, node.value), prevFlattenIndex = res.flattenIndex, maxDepth2 = Math.max(res.maxDepth, maxDepth2);
    } else node.isLeaf = true, node.value = isNil_default(datum.value) ? 0 : datum.value;
    sum5 += Math.abs(node.value), output.push(node);
  }), {
    sum: sum5,
    maxDepth: maxDepth2,
    flattenIndex: prevFlattenIndex
  };
};
var eachBefore = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    ctxRes = callback(node, index, parent, ctxRes), (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachBefore(node.children, callback, node, ctxRes));
  }), ctx;
};
var eachAfter = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachAfter(node.children, callback, node, ctxRes)), ctxRes = callback(node, index, parent, ctxRes);
  }), ctxRes;
};

// node_modules/@visactor/vgrammar-hierarchy/es/treemap/layout.js
var algorithms = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  sliceDice: sliceDice_default
};
var TreemapLayout = class _TreemapLayout {
  constructor(options) {
    var _a;
    this._filterByArea = (node, ratio) => {
      var _a2;
      const minArea = this._getMinAreaByDepth(node.depth);
      if (minArea > 0 && node.value * ratio < minArea) return false;
      if (null === (_a2 = node.children) || void 0 === _a2 ? void 0 : _a2.length) {
        const newChildren = node.children.filter((child) => this._filterByArea(child, ratio));
        newChildren.length ? newChildren.length !== node.children.length && (node.children = newChildren) : (node.isLeaf = true, node.children = null);
      }
      return true;
    }, this._getMinAreaByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.minVisibleArea) ? this.options.minVisibleArea[depth] : this.options.minVisibleArea) && void 0 !== _a2 ? _a2 : 0;
    }, this._getGapWidthByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.gapWidth) ? this.options.gapWidth[depth] : this.options.gapWidth) && void 0 !== _a2 ? _a2 : 0;
    }, this._getPaddingByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.padding) ? this.options.padding[depth] : this.options.padding) && void 0 !== _a2 ? _a2 : 0;
    }, this._getLabelPaddingByDepth = (depth) => {
      var _a2;
      return depth < 0 ? 0 : null !== (_a2 = isArray_default(this.options.labelPadding) ? this.options.labelPadding[depth] : this.options.labelPadding) && void 0 !== _a2 ? _a2 : 0;
    }, this._layoutNode = (parent) => {
      const gapWidth = this._getGapWidthByDepth(parent.depth);
      let x05 = parent.x0, y05 = parent.y0, x14 = parent.x1, y14 = parent.y1;
      if (parent.maxDepth = this._maxDepth, gapWidth > 0 && (x05 += gapWidth / 2, x14 -= gapWidth / 2, y05 += gapWidth / 2, y14 -= gapWidth / 2, x05 > x14 && (x05 = (x05 + x14) / 2, x14 = x05), y05 > y14 && (y05 = (y05 + y14) / 2, y14 = y05), parent.x0 = x05, parent.x1 = x14, parent.y0 = y05, parent.y1 = y14), parent.children) {
        const labelPadding = this._getLabelPaddingByDepth(parent.depth), padding = this._getPaddingByDepth(parent.depth);
        padding > 0 && padding < Math.min(x14 - x05, y14 - y05) / 2 && (y05 += padding, y14 -= padding, x05 += padding, x14 -= padding), labelPadding > 0 && ("top" === this.options.labelPosition && y05 + labelPadding < y14 ? (parent.labelRect = {
          x0: x05,
          y0: y05,
          x1: x14,
          y1: y05 + labelPadding
        }, y05 += labelPadding) : "bottom" === this.options.labelPosition && y14 - labelPadding > y05 ? (parent.labelRect = {
          x0: x05,
          y0: y14 - labelPadding,
          x1: x14,
          y1: y14
        }, y14 -= labelPadding) : "left" === this.options.labelPosition && x05 + labelPadding < x14 ? (parent.labelRect = {
          x0: x05,
          y0: y05,
          x1: x05 + labelPadding,
          y1: y14
        }, x05 += labelPadding) : "right" === this.options.labelPosition && x14 - labelPadding > x05 && (parent.labelRect = {
          x0: x14 - labelPadding,
          y0: y05,
          x1: x14,
          y1: y14
        }, x14 -= labelPadding));
        const childGapWidth = this._getGapWidthByDepth(parent.depth + 1);
        childGapWidth > 0 && (x05 -= childGapWidth / 2, x14 += childGapWidth / 2, y05 -= childGapWidth / 2, y14 += childGapWidth / 2), this._splitNode(parent, x05, y05, x14, y14);
      }
    }, this.options = Object.assign({}, _TreemapLayout.defaultOpionts, options);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._splitNode = "squarify" === this.options.splitType ? generateSquarify(this.options.aspectRatio) : null !== (_a = algorithms[this.options.splitType]) && void 0 !== _a ? _a : algorithms.binary, this._maxDepth = -1;
  }
  layout(data, config2) {
    var _a;
    if (!data || !data.length) return [];
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    }, nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    if (this._maxDepth = res.maxDepth, res.sum <= 0) return [];
    const root = {
      flattenIndex: -1,
      maxDepth: -1,
      key: "-1",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      x0: viewBox.x0,
      x1: viewBox.x1,
      y0: viewBox.y0,
      y1: viewBox.y1,
      children: nodes
    }, areaRatio = viewBox.width * viewBox.height / res.sum;
    return this._filterByArea(root, areaRatio), this._layout(root), null !== (_a = root.children) && void 0 !== _a ? _a : [];
  }
  _filterChildren(node) {
    const maxDepth2 = this.options.maxDepth;
    if (isNumber_default(maxDepth2) && maxDepth2 >= 0 && node.depth >= maxDepth2) return false;
    const minChildrenVisibleArea = this.options.minChildrenVisibleArea;
    if (isNumber_default(minChildrenVisibleArea) && Math.abs((node.x1 - node.x0) * (node.y1 - node.y0)) < minChildrenVisibleArea) return false;
    const minChildrenVisibleSize = this.options.minChildrenVisibleSize;
    return !isNumber_default(minChildrenVisibleSize) || !(Math.abs(node.x1 - node.x0) < minChildrenVisibleSize || Math.abs(node.y1 - node.y0) < minChildrenVisibleSize);
  }
  _layout(parent) {
    var _a;
    this._filterChildren(parent) || (parent.children = null, parent.isLeaf = true), this._layoutNode(parent), (null === (_a = parent.children) || void 0 === _a ? void 0 : _a.length) && parent.children.forEach((child) => {
      var _a2;
      (null === (_a2 = null == child ? void 0 : child.children) || void 0 === _a2 ? void 0 : _a2.length) ? this._layout(child) : this._layoutNode(child);
    });
  }
};
TreemapLayout.defaultOpionts = {
  aspectRatio: (1 + Math.sqrt(5)) / 2,
  gapWidth: 0,
  labelPadding: 0,
  labelPosition: "top",
  splitType: "binary",
  minVisibleArea: 10
};

// node_modules/@visactor/vgrammar-hierarchy/es/sunburst/layout.js
var keyMap = {
  x0: "startAngle",
  x1: "endAngle",
  y0: "innerRadius",
  y1: "outerRadius"
};
var SunburstLayout = class _SunburstLayout {
  constructor(options) {
    this._layoutNode = (parent) => {
      if (parent.maxDepth = this._maxDepth, parent.children) {
        const ir = this._parsedInnerRadius[parent.depth + 1], or = this._parsedOutterRadius[parent.depth + 1];
        dice_default(parent, parent.startAngle, Math.min(ir, or), parent.endAngle, Math.max(ir, or), keyMap);
        const labelOption = isArray_default(this.options.label) ? this.options.label[parent.depth + 1] : this.options.label;
        parent.children.forEach((child) => {
          if (child.x = this._parsedCenter[0], child.y = this._parsedCenter[1], labelOption) return this._layoutLabel(child, isBoolean_default(labelOption) ? {
            align: "center",
            rotate: "radial"
          } : labelOption);
        });
      }
    }, this.options = options ? Object.assign({}, _SunburstLayout.defaultOpionts, options) : Object.assign({}, _SunburstLayout.defaultOpionts);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._maxDepth = -1;
  }
  _parseRadius(viewBox, maxDepth2) {
    const cx = viewBox.x0 + toPercent(this.options.center[0], viewBox.width), cy = viewBox.y0 + toPercent(this.options.center[1], viewBox.height), maxRadius = Math.min(viewBox.width / 2, viewBox.height / 2), innerRadius = this.options.innerRadius, outerRadius = this.options.outerRadius, isInnerArray = isArray_default(innerRadius), parsedInnerRadius = isInnerArray ? innerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(innerRadius, maxRadius), isOuterArray = isArray_default(outerRadius), gapRadius = this.options.gapRadius, parsedOuterRadius = isOuterArray ? outerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(outerRadius, maxRadius), rangeArr = range(0, maxDepth2 + 1);
    if (isInnerArray) this._parsedInnerRadius = rangeArr.map((entry, index) => {
      const ir = parsedInnerRadius[index];
      return isNil_default(ir) ? maxRadius : ir;
    }), this._parsedOutterRadius = rangeArr.map((entry, index) => {
      var _a;
      return isOuterArray ? parsedOuterRadius[index] : index < maxDepth2 ? this._parsedInnerRadius[index + 1] - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius) : parsedOuterRadius;
    });
    else if (isOuterArray) this._parsedOutterRadius = rangeArr.map((entry, index) => isNil_default(parsedOuterRadius[index]) ? maxRadius : parsedOuterRadius[index]), this._parsedInnerRadius = rangeArr.map((entry, index) => {
      var _a;
      return 0 === index ? parsedInnerRadius : this._parsedOutterRadius[index - 1] - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
    });
    else {
      const ir = toPercent(innerRadius, maxRadius), step = (parsedOuterRadius - ir) / (maxDepth2 + 1);
      this._parsedInnerRadius = rangeArr.map((entry, index) => ir + index * step), this._parsedOutterRadius = rangeArr.map((entry, index) => {
        var _a;
        return this._parsedInnerRadius[index] + step - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
      });
    }
    this._parsedCenter = [cx, cy], this._maxRadius = maxRadius;
  }
  layout(data, config2) {
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length) return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    return this._parseRadius(viewBox, res.maxDepth), this._maxDepth = res.maxDepth, this._layout(nodes, {
      flattenIndex: -1,
      maxDepth: -1,
      key: "-1",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      startAngle: this.options.startAngle,
      endAngle: this.options.endAngle
    }), nodes;
  }
  _layout(nodes, parent) {
    this._layoutNode(parent), nodes.forEach((node) => {
      var _a;
      (null === (_a = null == node ? void 0 : node.children) || void 0 === _a ? void 0 : _a.length) ? this._layout(node.children, node) : this._layoutNode(node);
    });
  }
  _layoutLabel(child, labelOption) {
    var _a;
    const angle2 = (child.startAngle + child.endAngle) / 2, r2 = ("start" === labelOption.align ? child.innerRadius : "end" === labelOption.align ? child.outerRadius : (child.innerRadius + child.outerRadius) / 2) + (null !== (_a = labelOption.offset) && void 0 !== _a ? _a : 0), pos = polarToCartesian({
      x: this._parsedCenter[0],
      y: this._parsedCenter[1]
    }, r2, angle2);
    if (child.label = {
      x: pos.x,
      y: pos.y,
      textBaseline: "middle"
    }, "tangential" === labelOption.rotate) child.label.angle = angle2 - Math.PI / 2, child.label.textAlign = "center", child.label.maxLineWidth = Math.abs(child.endAngle - child.startAngle) * r2;
    else {
      const uniformAngle = angle2 % (2 * Math.PI), formatAngle = uniformAngle < 0 ? uniformAngle + 2 * Math.PI : uniformAngle;
      formatAngle > Math.PI / 2 && formatAngle < 1.5 * Math.PI ? (child.label.angle = formatAngle + Math.PI, child.label.textAlign = "start" === labelOption.align ? "end" : "end" === labelOption.align ? "start" : "center") : (child.label.angle = formatAngle, child.label.textAlign = labelOption.align), child.label.maxLineWidth = child.isLeaf ? void 0 : Math.abs(child.outerRadius - child.innerRadius);
    }
  }
};
SunburstLayout.defaultOpionts = {
  startAngle: Math.PI / 2,
  endAngle: -3 * Math.PI / 2,
  center: ["50%", "50%"],
  gapRadius: 0,
  innerRadius: 0,
  outerRadius: "70%"
};

// node_modules/@visactor/vgrammar-hierarchy/es/lcg.js
var a3 = 1664525;
var c3 = 1013904223;
var m4 = 4294967296;
function randomLCG(initS = 1) {
  let s3 = initS;
  return () => (s3 = (a3 * s3 + c3) % m4) / m4;
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/enclose.js
function packEncloseRandom(circles, random) {
  let i2 = 0;
  const sCircles = shuffleArray(Array.from(circles), random), n2 = sCircles.length;
  let p2, e3, B2 = [];
  for (; i2 < n2; ) p2 = sCircles[i2], e3 && enclosesWeak(e3, p2) ? ++i2 : (B2 = extendBasis(B2, p2), e3 = encloseBasis(B2), i2 = 0);
  return e3;
}
function extendBasis(B2, p2) {
  let i2, j2;
  if (enclosesWeakAll(p2, B2)) return [p2];
  for (i2 = 0; i2 < B2.length; ++i2) if (enclosesNot(p2, B2[i2]) && enclosesWeakAll(encloseBasis2(B2[i2], p2), B2)) return [B2[i2], p2];
  for (i2 = 0; i2 < B2.length - 1; ++i2) for (j2 = i2 + 1; j2 < B2.length; ++j2) if (enclosesNot(encloseBasis2(B2[i2], B2[j2]), p2) && enclosesNot(encloseBasis2(B2[i2], p2), B2[j2]) && enclosesNot(encloseBasis2(B2[j2], p2), B2[i2]) && enclosesWeakAll(encloseBasis3(B2[i2], B2[j2], p2), B2)) return [B2[i2], B2[j2], p2];
  Logger.getInstance().error("error when packEncloseRandom");
}
function enclosesNot(a4, b2) {
  const dr = a4.radius - b2.radius, dx = b2.x - a4.x, dy = b2.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b2) {
  const dr = a4.radius - b2.radius + 1e-9 * Math.max(a4.radius, b2.radius, 1), dx = b2.x - a4.x, dy = b2.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B2) {
  for (let i2 = 0; i2 < B2.length; ++i2) if (!enclosesWeak(a4, B2[i2])) return false;
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    radius: a4.radius
  };
}
function encloseBasis2(a4, b2) {
  const x14 = a4.x, y14 = a4.y, r1 = a4.radius, x23 = b2.x, y23 = b2.y, r2 = b2.radius, x212 = x23 - x14, y212 = y23 - y14, r21 = r2 - r1, l2 = Math.sqrt(x212 * x212 + y212 * y212);
  return {
    x: (x14 + x23 + x212 / l2 * r21) / 2,
    y: (y14 + y23 + y212 / l2 * r21) / 2,
    radius: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b2, c4) {
  const x14 = a4.x, y14 = a4.y, r1 = a4.radius, x23 = b2.x, y23 = b2.y, r2 = b2.radius, x3 = c4.x, y3 = c4.y, r3 = c4.radius, a22 = x14 - x23, a32 = x14 - x3, b22 = y14 - y23, b3 = y14 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x14 * x14 + y14 * y14 - r1 * r1, d2 = d1 - x23 * x23 - y23 * y23 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (2 * ab) - x14, xb = (b3 * c22 - b22 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (2 * ab) - y14, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r4 = -(Math.abs(A5) > 1e-6 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C2)) / (2 * A5) : C2 / B2);
  return {
    x: x14 + xa + xb * r4,
    y: y14 + ya + yb * r4,
    radius: r4
  };
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/siblings.js
function place3(b2, a4, c4) {
  const dx = b2.x - a4.x;
  let x3, a22;
  const dy = b2.y - a4.y;
  let y3, b22;
  const d2 = dx * dx + dy * dy;
  d2 ? (a22 = a4.radius + c4.radius, a22 *= a22, b22 = b2.radius + c4.radius, b22 *= b22, a22 > b22 ? (x3 = (d2 + b22 - a22) / (2 * d2), y3 = Math.sqrt(Math.max(0, b22 / d2 - x3 * x3)), c4.x = b2.x - x3 * dx - y3 * dy, c4.y = b2.y - x3 * dy + y3 * dx) : (x3 = (d2 + a22 - b22) / (2 * d2), y3 = Math.sqrt(Math.max(0, a22 / d2 - x3 * x3)), c4.x = a4.x + x3 * dx - y3 * dy, c4.y = a4.y + x3 * dy + y3 * dx)) : (c4.x = a4.x + c4.radius, c4.y = a4.y);
}
function intersects(a4, b2) {
  const dr = a4.radius + b2.radius - 1e-6, dx = b2.x - a4.x, dy = b2.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score2(node) {
  const a4 = node._, b2 = node.next._, ab = a4.radius + b2.radius, dx = (a4.x * b2.radius + b2.x * a4.radius) / ab, dy = (a4.y * b2.radius + b2.y * a4.radius) / ab;
  return dx * dx + dy * dy;
}
function getCicleNode(circle4) {
  return {
    _: circle4,
    next: null,
    prev: null
  };
}
function packSiblingsRandom(circles, random) {
  const n2 = (circles = array(circles)).length;
  if (!n2) return 0;
  let a4 = circles[0];
  if (a4.x = 0, a4.y = 0, 1 === n2) return a4.radius;
  const b2 = circles[1];
  if (a4.x = -b2.radius, b2.x = a4.radius, b2.y = 0, 2 === n2) return a4.radius + b2.radius;
  let c4 = circles[2];
  place3(b2, a4, c4);
  let j2, k3, sj, sk, aa, ca, isContinue, aNode = getCicleNode(a4), bNode = getCicleNode(b2), cNode = getCicleNode(c4);
  aNode.next = bNode, cNode.prev = bNode, bNode.next = cNode, aNode.prev = cNode, cNode.next = aNode, bNode.prev = aNode;
  for (let i2 = 3; i2 < n2; ++i2) {
    isContinue = false, c4 = circles[i2], place3(aNode._, bNode._, c4), cNode = getCicleNode(c4), j2 = bNode.next, k3 = aNode.prev, sj = bNode._.radius, sk = aNode._.radius;
    do {
      if (sj <= sk) {
        if (intersects(j2._, cNode._)) {
          bNode = j2, aNode.next = bNode, bNode.prev = aNode, --i2, isContinue = true;
          break;
        }
        sj += j2._.radius, j2 = j2.next;
      } else {
        if (intersects(k3._, cNode._)) {
          aNode = k3, aNode.next = bNode, bNode.prev = aNode, --i2, isContinue = true;
          break;
        }
        sk += k3._.radius, k3 = k3.prev;
      }
    } while (j2 !== k3.next);
    if (!isContinue) {
      for (cNode.prev = aNode, cNode.next = bNode, aNode.next = bNode.prev = bNode = cNode, aa = score2(aNode), cNode = cNode.next; cNode !== bNode; ) ca = score2(cNode), ca < aa && (aNode = cNode, aa = ca), cNode = cNode.next;
      bNode = aNode.next;
    }
  }
  const aCircles = [bNode._];
  for (cNode = bNode.next; cNode !== bNode; ) aCircles.push(cNode._), cNode = cNode.next;
  c4 = packEncloseRandom(aCircles, random);
  for (let i2 = 0; i2 < n2; ++i2) a4 = circles[i2], a4.x -= c4.x, a4.y -= c4.y;
  return c4.radius;
}

// node_modules/@visactor/vgrammar-hierarchy/es/circle-packing/layout.js
function radiusLeaf(radius) {
  return function(node) {
    node.children || (node.radius = Math.max(0, +radius(node) || 0));
  };
}
function packChildrenRandom(padding, k3, random) {
  return function(node) {
    const children = null == node ? void 0 : node.children;
    if (children) {
      let i2;
      const n2 = children.length, r2 = padding(node) * k3 || 0;
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].radius += r2;
      const e3 = packSiblingsRandom(children, random);
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].radius -= r2;
      node.radius = e3 + r2;
    }
  };
}
function translateChild(k3, maxDepth2) {
  return function(node, index, parent) {
    node.radius *= k3, node.maxDepth = maxDepth2, parent && (node.x = parent.x + k3 * node.x, node.y = parent.y + k3 * node.y);
  };
}
var CirclePackingLayout = class _CirclePackingLayout {
  constructor(options) {
    this.options = options;
    const keyOption = null == options ? void 0 : options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._getPadding = isNumber_default(null == options ? void 0 : options.padding) ? (node) => options.padding : isArray_default(null == options ? void 0 : options.padding) ? (node) => {
      var _a;
      return null !== (_a = options.padding[node.depth + 1]) && void 0 !== _a ? _a : 0;
    } : () => 0, this._maxDepth = -1;
  }
  layout(data, config2) {
    var _a;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length) return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    this._maxDepth = res.maxDepth;
    const random = randomLCG(), root = {
      flattenIndex: -1,
      maxDepth: -1,
      key: "root",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      x: viewBox.x0 + viewBox.width / 2,
      y: viewBox.y0 + viewBox.height / 2
    }, { nodeSort, setRadius, padding, includeRoot } = null !== (_a = this.options) && void 0 !== _a ? _a : {};
    if (false !== nodeSort) {
      const sort = isFunction_default(nodeSort) ? this.options.nodeKey : _CirclePackingLayout.defaultOpionts.nodeSort;
      eachBefore([root], (node) => {
        node.children && node.children.length && node.children.sort(sort);
      });
    }
    if (setRadius) eachBefore([root], radiusLeaf(setRadius)), eachAfter([root], packChildrenRandom(this._getPadding, 0.5, random)), eachBefore([root], translateChild(1, this._maxDepth));
    else {
      const size = Math.min(viewBox.width, viewBox.height);
      eachBefore([root], radiusLeaf(_CirclePackingLayout.defaultOpionts.setRadius)), eachAfter([root], packChildrenRandom(zero2, 1, random)), padding && eachAfter([root], packChildrenRandom(this._getPadding, root.radius / size, random)), eachBefore([root], translateChild(size / (2 * root.radius), this._maxDepth));
    }
    return includeRoot ? [root] : nodes;
  }
};
CirclePackingLayout.defaultOpionts = {
  setRadius: (node) => Math.sqrt(node.value),
  padding: 0,
  nodeSort: (a4, b2) => b2.value - a4.value
};

// node_modules/@visactor/vgrammar-hierarchy/es/tree/cluster.js
function defaultSeparation(a4, b2) {
  return a4.parentKey === b2.parentKey ? 1 : 2;
}
function meanX(children) {
  return children.reduce((x3, c4) => x3 + c4.x, 0) / children.length;
}
function maxY(children) {
  return 1 + children.reduce((y3, c4) => Math.max(y3, c4.y), 0);
}
function leafLeft(node) {
  let children = node.children;
  for (; children; ) children = (node = children[0]).children;
  return node;
}
function leafRight(node) {
  let children = node.children;
  for (; children; ) children = (node = children[children.length - 1]).children;
  return node;
}
function clusterTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation) {
  let previousNode, x3 = 0;
  if (eachAfter([root], (node) => {
    const children = node.children;
    children ? (node.x = meanX(children), node.y = maxY(children)) : (node.x = previousNode ? x3 += separation(node, previousNode) : 0, node.y = 0, previousNode = node);
  }), isNumber_default(minNodeGap) && isNumber_default(linkWidth)) eachAfter([root], (node) => {
    node.x = viewBox.x0 + (node.x - root.x) * minNodeGap, node.y = viewBox.y0 + (root.y - node.y) * linkWidth;
  });
  else {
    const left2 = leafLeft(root), right2 = leafRight(root), x05 = left2.x - separation(left2, right2) / 2, x14 = right2.x + separation(right2, left2) / 2, kx2 = isNumber_default(minNodeGap) ? minNodeGap : viewBox.width / (x14 - x05);
    eachAfter([root], (node) => {
      node.x = viewBox.x0 + (node.x - x05) * kx2, node.y = viewBox.y0 + (1 - (root.y ? node.y / root.y : 1)) * viewBox.height;
    });
  }
  return root;
}

// node_modules/@visactor/vgrammar-hierarchy/es/tree/tree.js
function defaultSeparation2(a4, b2) {
  return a4.parentKey === b2.parentKey ? 1 : 2;
}
function nextLeft(v2) {
  const children = v2.children;
  return children ? children[0] : v2.t;
}
function nextRight(v2) {
  const children = v2.children;
  return children ? children[children.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  const change = shift / (wp.i - wm.i);
  wp.c -= change, wp.s += shift, wm.c += change, wp.z += shift, wp.m += shift;
}
function executeShifts(v2) {
  let shift = 0, change = 0;
  const children = v2.children;
  let w2, i2 = children.length;
  for (; --i2 >= 0; ) w2 = children[i2], w2.z += shift, w2.m += shift, shift += w2.s + (change += w2.c);
}
function nextAncestor(vim, v2, ancestor) {
  var _a;
  const vimAncestor = null !== (_a = vim.a) && void 0 !== _a ? _a : vim;
  return vimAncestor.parent === v2.parent ? vimAncestor : ancestor;
}
function createTreeNode(node, i2) {
  return {
    _: node,
    i: i2,
    parent: null,
    A: null,
    a: null,
    z: 0,
    m: 0,
    c: 0,
    s: 0,
    t: null
  };
}
function treeRoot(root) {
  const tree = createTreeNode(root, 0), nodes = [tree];
  let child, children, i2, n2, node = nodes.pop();
  for (; node; ) {
    if (children = node._.children, children) for (n2 = children.length, node.children = new Array(n2), i2 = n2 - 1; i2 >= 0; --i2) child = createTreeNode(children[i2], i2), node.children[i2] = child, nodes.push(child), child.parent = node;
    node = nodes.pop();
  }
  return tree.parent = createTreeNode(null, 0), tree.parent.children = [tree], tree;
}
function tidyTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation2) {
  const apportion = (v2, w2, ancestor) => {
    if (w2) {
      let shift, vip = v2, vop = v2, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m;
      for (vim = nextRight(vim), vip = nextLeft(vip); vim && vip; ) vom = nextLeft(vom), vop = nextRight(vop), vop.a = v2, shift = vim.z + sim - vip.z - sip + separation(vim._, vip._), shift > 0 && (moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift), sip += shift, sop += shift), sim += vim.m, sip += vip.m, som += vom.m, sop += vop.m, vim = nextRight(vim), vip = nextLeft(vip);
      vim && !nextRight(vop) && (vop.t = vim, vop.m += sim - sop), vip && !nextLeft(vom) && (vom.t = vip, vom.m += sip - som, ancestor = v2);
    }
    return ancestor;
  }, t2 = treeRoot(root);
  let getY;
  if (eachAfter([t2], (v2) => {
    const children = v2.children, siblings = v2.parent.children, w2 = v2.i ? siblings[v2.i - 1] : null;
    if (children) {
      executeShifts(v2);
      const midpoint = (children[0].z + children[children.length - 1].z) / 2;
      w2 ? (v2.z = w2.z + separation(v2._, w2._), v2.m = v2.z - midpoint) : v2.z = midpoint;
    } else w2 && (v2.z = w2.z + separation(v2._, w2._));
    v2.parent.A = apportion(v2, w2, v2.parent.A || siblings[0]);
  }), t2.parent.m = -t2.z, eachBefore([t2], (v2) => {
    v2._.x = v2.z + v2.parent.m, v2.m += v2.parent.m;
  }), isNumber_default(linkWidth)) getY = (node) => node.depth * linkWidth;
  else if (isArray_default(linkWidth) && linkWidth.length) {
    const sumed = linkWidth.reduce((res, entry, index) => (res[index] = 0 === index ? entry : res[index - 1] + entry, res), []);
    getY = (node) => {
      var _a;
      return null !== (_a = sumed[node.depth]) && void 0 !== _a ? _a : sumed[sumed.length - 1];
    };
  }
  if (isNumber_default(minNodeGap) && getY) {
    eachBefore([root], (node) => {
      node.x = viewBox.x0 + viewBox.width / 2 + node.x * minNodeGap, node.y = viewBox.y0 + getY(node);
    });
  } else {
    let left2 = root, right2 = root, bottom = root;
    eachBefore([root], (node) => {
      node.x < left2.x && (left2 = node), node.x > right2.x && (right2 = node), node.depth > bottom.depth && (bottom = node);
    });
    const s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx2 = isNumber_default(minNodeGap) ? minNodeGap : viewBox.width / (right2.x + s3 + tx), ky2 = viewBox.height / (bottom.depth || 1);
    eachBefore([root], (node) => {
      node.x = viewBox.x0 + (node.x + tx) * kx2, node.y = viewBox.y0 + (getY ? getY(node) : node.depth * ky2);
    });
  }
  return root;
}

// node_modules/@visactor/vgrammar-hierarchy/es/tree/layout.js
var TreeLayout = class _TreeLayout {
  constructor(options) {
    this.options = Object.assign({}, _TreeLayout.defaultOpionts, options);
    const keyOption = null == options ? void 0 : options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._maxDepth = -1;
  }
  layout(data, config2) {
    const formattedData = array(data);
    if (!formattedData.length) return [];
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    }, nodes = [], res = calculateNodeValue(formattedData, nodes, 0, -1, null, this._getNodeKey);
    this._maxDepth = res.maxDepth;
    const isVertical3 = ["vertical", "TB", "BT"].includes(this.options.direction), vb = "radial" === this.options.layoutType ? {
      x0: 0,
      y0: 0,
      x1: 2 * Math.PI,
      y1: Math.min(viewBox.width, viewBox.height) / 2,
      width: 2 * Math.PI,
      height: Math.min(viewBox.width, viewBox.height) / 2
    } : isVertical3 ? viewBox : {
      x0: viewBox.y0,
      y0: viewBox.x0,
      x1: viewBox.y1,
      y1: viewBox.x1,
      width: viewBox.height,
      height: viewBox.width
    };
    if ("leaf" === this.options.alignType ? clusterTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth) : tidyTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth), "radial" === this.options.layoutType) {
      const center2 = {
        x: (viewBox.x0 + viewBox.x1) / 2,
        y: (viewBox.y0 + viewBox.y1) / 2
      };
      eachBefore(nodes, (node) => {
        const angle2 = node.x, radius = node.y, res2 = polarToCartesian(center2, radius, angle2);
        node.x = res2.x, node.y = res2.y, node.maxDepth = this._maxDepth;
      });
    } else ["BT", "RL"].includes(this.options.direction) ? eachBefore(nodes, (node) => {
      node.y = vb.y0 + vb.y1 - node.y, node.maxDepth = this._maxDepth;
    }) : eachBefore(nodes, (node) => {
      node.maxDepth = this._maxDepth;
    }), isVertical3 || eachBefore(nodes, (node) => {
      [node.x, node.y] = [node.y, node.x];
    });
    return nodes;
  }
};
TreeLayout.defaultOpionts = {
  direction: "horizontal",
  alignType: "depth",
  layoutType: "orthogonal"
};

// node_modules/@visactor/vchart/esm/data/transforms/flatten.js
var flatten2 = (data, op = {}) => {
  if (!data) return [];
  const result2 = [];
  return flattenNodes(data, result2, op), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/sunburst.js
var sunburstLayout = (data, op) => {
  if (!data) return data;
  const options = op(), { width, height } = options;
  return new SunburstLayout(options).layout(data, {
    width,
    height
  });
};

// node_modules/@visactor/vchart/esm/constant/sunburst.js
var SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD = 10;

// node_modules/@visactor/vchart/esm/series/sunburst/tooltip-helper.js
var SunburstTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.contentKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/drill.js
var DrillEnum;
!function(DrillEnum2) {
  DrillEnum2.DrillDown = "drillDown", DrillEnum2.DrillUp = "drillUp";
}(DrillEnum || (DrillEnum = {}));
var drillFilter = (data, op) => {
  const info = op.info(), keyField = op.keyField(), dataKey = null == info ? void 0 : info.key;
  if (isNil_default(dataKey)) return data;
  if (info.type === DrillEnum.DrillDown) {
    const targetNode = findHierarchyNode(data, dataKey, keyField, "children");
    return array(targetNode);
  }
  if (info.type === DrillEnum.DrillUp) {
    const targetNode = findHierarchyNodeParent(data, dataKey, keyField, "children");
    if (targetNode) return array(targetNode);
  }
  return data;
};

// node_modules/@visactor/vchart/esm/interaction/drill/drillable.js
var Drillable = class {
  _getDrillTriggerEvent(type) {
    var _a;
    const { mode: mode2 } = this._drillParams;
    return null === (_a = getDefaultTriggerEventByMode(mode2)) || void 0 === _a ? void 0 : _a[type];
  }
  _hideTooltip() {
    const tooltip3 = this.getChart().getAllComponents().find((c4) => c4.type === ComponentTypeEnum.tooltip);
    tooltip3 && tooltip3.hideTooltip();
  }
  initDrillable(params2) {
    this._drillParams = params2;
  }
  initDrillableData(dataSet) {
    const { getRawData } = this._drillParams;
    registerDataSetInstanceTransform(dataSet, "drillFilter", drillFilter), getRawData().transform({
      type: "drillFilter",
      options: {
        info: () => this._drillInfo,
        keyField: () => this._drillParams.drillField()
      }
    });
  }
  bindDrillEvent() {
    const { event, getRawData, drillField } = this._drillParams, keyField = drillField();
    this._getDrillTriggerEvent("start") && event.on(this._getDrillTriggerEvent("start"), (e3) => {
      var _a, _b, _c;
      if (isNil_default(e3.datum) || isNil_default(null === (_a = e3.datum) || void 0 === _a ? void 0 : _a[keyField])) return void this.drillUp();
      this._hideTooltip();
      const dataKey = e3.datum[keyField], selectPath = null !== (_c = null === (_b = this._drillInfo) || void 0 === _b ? void 0 : _b.path) && void 0 !== _c ? _c : [], clickedPath = findHierarchyPath(getRawData().rawData, dataKey, keyField, "children");
      selectPath[selectPath.length - 1] === clickedPath[clickedPath.length - 1] ? this.drillUp() : this.drillDown(clickedPath);
    });
  }
  drillDown(drillPath = []) {
    const { getRawData, event } = this._drillParams;
    if (!isArray_default(drillPath) || isEmpty_default(drillPath)) return drillPath;
    const dataKey = drillPath[drillPath.length - 1];
    return this._drillInfo = {
      key: dataKey,
      path: drillPath,
      type: DrillEnum.DrillDown
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path: drillPath,
        type: DrillEnum.DrillDown
      },
      model: this
    }), drillPath;
  }
  drillUp() {
    var _a, _b;
    const { getRawData, event } = this._drillParams, path = null !== (_b = null === (_a = this._drillInfo) || void 0 === _a ? void 0 : _a.path) && void 0 !== _b ? _b : [];
    if (!isArray_default(path) || isEmpty_default(path)) return path;
    const dataKey = path.pop();
    return this._drillInfo = {
      key: dataKey,
      path,
      type: DrillEnum.DrillUp
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path,
        type: DrillEnum.DrillUp
      },
      model: this
    }), path;
  }
};

// node_modules/@visactor/vchart/esm/series/sunburst/sunburst.js
var SunburstSeries = class _SunburstSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sunburst;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), this._centerX = this._spec.centerX, this._centerY = this._spec.centerY, this._offsetX = this._spec.offsetX, this._offsetY = this._spec.offsetY, this.__innerRadius = this._spec.innerRadius, this.__outerRadius = this._spec.outerRadius, this._gap = this._spec.gap, this._labelLayout = this._spec.labelLayout, this._sunburst = this._spec.sunburst, this._label = this._spec.label, this._labelAutoVisible = this._spec.labelAutoVisible;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    rawData && (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "sunburstLayout", sunburstLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten2), rawData.transform({
      type: "sunburstLayout",
      options: () => {
        const { innerRadius, outerRadius, gap, label } = this._computeLevel();
        return {
          nodeKey: this._categoryField,
          width: this.getLayoutRect().width,
          height: this.getLayoutRect().height,
          center: [isValid_default(this._centerX) ? this._centerX : this.getLayoutRect().width / 2, isValid_default(this._centerY) ? this._centerY : this.getLayoutRect().height / 2],
          startAngle: this._startAngle,
          endAngle: this._endAngle,
          innerRadius,
          outerRadius,
          gapRadius: gap,
          label
        };
      }
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initArcMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initArcMarkStyle(), this._initLabelMarkStyle();
  }
  _initArcMark() {
    var _a;
    if (false === this._sunburst.visible) return;
    const sunburstMark = this._createMark(_SunburstSeries.mark.sunburst, {
      isSeriesMark: true,
      customShape: null === (_a = this._spec.sunburst) || void 0 === _a ? void 0 : _a.customShape
    });
    this._sunburstMark = sunburstMark, this._trigger.registerMark(this._sunburstMark);
  }
  _initArcMarkStyle() {
    isNil_default(this._sunburstMark) || this.setMarkStyle(this._sunburstMark, {
      x: (d2) => d2.x + (isValid_default(this._offsetX) ? this._offsetX : 0),
      y: (d2) => d2.y + (isValid_default(this._offsetY) ? this._offsetY : 0),
      outerRadius: (d2) => d2.outerRadius,
      innerRadius: (d2) => d2.innerRadius,
      startAngle: (d2) => d2.startAngle,
      endAngle: (d2) => d2.endAngle,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    if (true !== this._label.visible) return;
    const labelMark = this._createMark(_SunburstSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark, this._trigger.registerMark(labelMark);
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      visible: (d2) => {
        var _a;
        const labelAutoVisible = this._labelAutoVisible;
        return isObject_default(labelAutoVisible) && true === labelAutoVisible.enable ? (d2.endAngle - d2.startAngle) * (d2.outerRadius - d2.innerRadius) > (null !== (_a = null == labelAutoVisible ? void 0 : labelAutoVisible.circumference) && void 0 !== _a ? _a : SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD) : this._spec.label.visible;
      },
      x: (d2) => {
        var _a;
        return (null === (_a = d2.label) || void 0 === _a ? void 0 : _a.x) + (isValid_default(this._offsetX) ? this._offsetX : 0);
      },
      y: (d2) => {
        var _a;
        return (null === (_a = d2.label) || void 0 === _a ? void 0 : _a.y) + (isValid_default(this._offsetY) ? this._offsetY : 0);
      },
      textBaseline: (d2) => {
        var _a;
        return null === (_a = d2.label) || void 0 === _a ? void 0 : _a.textBaseline;
      },
      textAlign: (d2) => {
        var _a;
        return null === (_a = d2.label) || void 0 === _a ? void 0 : _a.textAlign;
      },
      angle: (d2) => {
        var _a, _b;
        return null !== (_b = null === (_a = d2.label) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
      },
      fontSize: 10,
      text: (d2) => d2.name
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initTooltip() {
    this._tooltipHelper = new SunburstTooltipHelper(this), this._sunburstMark && this._tooltipHelper.activeTriggerSet.mark.add(this._sunburstMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a, _b;
    const animationParams = {
      animationInfo: () => ({
        innerRadius: this._computeRadius(array(this.__innerRadius))[0],
        outerRadius: this._computeRadius(array(this.__outerRadius))[0],
        startAngle: array(this._startAngle)[0],
        endAngle: array(this._endAngle)[0]
      })
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("sunburst")) || void 0 === _a2 ? void 0 : _a2(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _computeRadius(radius) {
    if (isArray_default(radius)) return radius.map((r2) => {
      const { width: width2, height: height2 } = this.getRegion().getLayoutRect();
      return Math.min(width2 / 2, height2 / 2) * r2;
    });
    const { width, height } = this.getRegion().getLayoutRect();
    return Math.min(width / 2, height / 2) * radius;
  }
  _computeLevel() {
    return {
      innerRadius: this._computeRadius(this.__innerRadius),
      outerRadius: this._computeRadius(this.__outerRadius),
      gap: this._gap,
      label: this._labelLayout
    };
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._sunburstMark];
  }
};
SunburstSeries.type = SeriesTypeEnum.sunburst, SunburstSeries.mark = sunburstSeriesMark, mixin(SunburstSeries, Drillable);
var registerSunBurstSeries = () => {
  Factory2.registerSeries(SunburstSeries.type, SunburstSeries), registerArcMark(), registerTextMark(), registerFadeInOutAnimation(), registerSunburstAnimation();
};

// node_modules/@visactor/vchart/esm/data/transforms/circle-packing.js
var circlePackingLayout = (data, op) => {
  if (!data) return data;
  const options = op(), { width, height } = options;
  if (0 === width || 0 === height) return data;
  return new CirclePackingLayout(options).layout(data, {
    width,
    height
  });
};

// node_modules/@visactor/vchart/esm/series/circle-packing/tooltip-helper.js
var CirclePackingTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.contentKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// node_modules/@visactor/vchart/esm/series/circle-packing/animation.js
var circlePackingPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "growRadiusIn"
};
var registerCirclePackingAnimation = () => {
  Factory2.registerAnimation("circlePacking", (parmas, preset) => ({
    appear: circlePackingPresetAnimation(preset),
    enter: {
      type: "growRadiusIn"
    },
    exit: {
      type: "growRadiusOut"
    },
    disappear: {
      type: "growRadiusOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/circle-packing/circle-packing.js
var CirclePackingSeries = class _CirclePackingSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circlePacking;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._circlePacking = this._spec.circlePacking, this._label = this._spec.label, this._layoutPadding = this._spec.layoutPadding;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    isNil_default(rawData) || (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "circlePackingLayout", circlePackingLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten2), rawData.transform({
      type: "circlePackingLayout",
      options: () => ({
        nodeKey: this._categoryField,
        padding: this._layoutPadding,
        includeRoot: false,
        width: this.getLayoutRect().width || 1,
        height: this.getLayoutRect().height || 1
      })
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initCirclePackingMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
  }
  _initCirclePackingMark() {
    var _a, _b;
    if (false === (null === (_a = this._circlePacking) || void 0 === _a ? void 0 : _a.visible)) return;
    const circlePacking2 = this._createMark(_CirclePackingSeries.mark.circlePacking, {
      isSeriesMark: true,
      customShape: null === (_b = this._spec.circlePacking) || void 0 === _b ? void 0 : _b.customShape
    });
    this._circlePackingMark = circlePacking2, this._trigger.registerMark(circlePacking2);
  }
  _initCirclePackingMarkStyle() {
    isNil_default(this._circlePackingMark) || this.setMarkStyle(this._circlePackingMark, {
      x: (d2) => d2.x,
      y: (d2) => d2.y,
      outerRadius: (d2) => d2.radius,
      innerRadius: 0,
      startAngle: 0,
      endAngle: 2 * Math.PI,
      fill: this.getColorAttribute(),
      zIndex: (d2) => d2.depth
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    var _a;
    if (false === (null === (_a = this._label) || void 0 === _a ? void 0 : _a.visible)) return;
    const labelMark = this._createMark(_CirclePackingSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark, this._trigger.registerMark(labelMark);
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      x: (d2) => d2.x,
      y: (d2) => d2.y,
      text: (d2) => d2.key,
      cursor: "pointer"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  initTooltip() {
    this._tooltipHelper = new CirclePackingTooltipHelper(this), this._tooltipHelper.updateTooltipSpec(), this._circlePackingMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circlePackingMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("circlePacking")) || void 0 === _a2 ? void 0 : _a2(void 0, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._circlePackingMark];
  }
};
CirclePackingSeries.type = SeriesTypeEnum.circlePacking, CirclePackingSeries.mark = circlePackingSeriesMark, mixin(CirclePackingSeries, Drillable);
var registerCirclePackingSeries = () => {
  Factory2.registerSeries(CirclePackingSeries.type, CirclePackingSeries), registerArcMark(), registerTextMark(), registerScaleInOutAnimation(), registerCirclePackingAnimation();
};

// node_modules/@visactor/vgrammar-sankey/es/hierarchy.js
var calculateNodeValue2 = (subTree) => {
  let sum5 = 0;
  return subTree.forEach((node, index) => {
    var _a;
    isNil_default(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = calculateNodeValue2(node.children) : node.value = 0), sum5 += Math.abs(node.value);
  }), sum5;
};

// node_modules/@visactor/vgrammar-sankey/es/layout.js
function left(node) {
  return node.depth;
}
function right(node, maxDepth2) {
  return maxDepth2 - 1 - node.endDepth;
}
function justify(node, maxDepth2) {
  return node.sourceLinks.length ? node.depth : maxDepth2 - 1;
}
function center(node, maxDepth2, nodeMap) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minInArray(node.sourceLinks.map((link3) => nodeMap[link3.target].depth)) - 1 : 0;
}
var ascendingNodeBreadth = (a4, b2) => a4.y0 - b2.y0;
var calcDivideValue = (node, isTarget) => {
  if (isNil_default(node.value)) return null;
  const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce((res2, sLink) => (isNil_default(sLink.value) ? res2.count += 1 : res2.sum += sLink.value, res2), {
    sum: 0,
    count: 0
  });
  return res.count > 0 ? (node.value - res.sum) / res.count : null;
};
var alignFunctions = {
  left,
  right,
  justify,
  center,
  start: left,
  end: right
};
var SankeyLayout = class _SankeyLayout {
  constructor(options) {
    this._ascendingSourceBreadth = (a4, b2) => ascendingNodeBreadth(this._nodeMap[a4.source], this._nodeMap[b2.source]) || a4.index - b2.index, this._ascendingTargetBreadth = (a4, b2) => ascendingNodeBreadth(this._nodeMap[a4.target], this._nodeMap[b2.target]) || a4.index - b2.index, this.options = Object.assign({}, _SankeyLayout.defaultOptions, options);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._logger = Logger.getInstance(), this._alignFunc = isFunction_default(this.options.setNodeLayer) ? (node) => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];
  }
  layout(data, config2) {
    if (!data) return null;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    isVertical(this.options.direction) ? this._viewBox = {
      x0: viewBox.y0,
      x1: viewBox.y1,
      y0: viewBox.x0,
      y1: viewBox.x1,
      width: viewBox.height,
      height: viewBox.width
    } : this._viewBox = viewBox;
    const result2 = this.computeNodeLinks(data), nodes = result2.nodes, links = result2.links;
    if (this._nodeMap = result2.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), ["right", "end", "justify"].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), this._maxDepth <= 1) return null;
    const columns = this.computeNodeBreadths(nodes);
    return this.computeLinkBreadths(nodes), isVertical(this.options.direction) && (nodes.forEach((node) => {
      const y05 = node.y0, y14 = node.y1;
      node.y0 = node.x0, node.y1 = node.x1, node.x0 = y05, node.x1 = y14;
    }), links.forEach((link3) => {
      link3.vertical = true;
      const x05 = link3.x0, x14 = link3.x1;
      link3.x0 = link3.y0, link3.x1 = link3.y1, link3.y0 = x05, link3.y1 = x14;
    })), links.forEach((link3) => {
      const sourceNode = this._nodeMap[link3.source], targetNode = this._nodeMap[link3.target];
      link3.sourceRect = {
        x0: sourceNode.x0,
        x1: sourceNode.x1,
        y0: sourceNode.y0,
        y1: sourceNode.y1
      }, link3.targetRect = {
        x0: targetNode.x0,
        x1: targetNode.x1,
        y1: targetNode.y1,
        y0: targetNode.y0
      };
    }), {
      nodes,
      links,
      columns
    };
  }
  computeHierarchicNodeLinks(originalNodes) {
    const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
    calculateNodeValue2(originalNodes);
    const doSubTree = (subTree, depth, parents) => {
      subTree.forEach((node, index) => {
        var _a, _b;
        const nodeKey = this._getNodeKey ? this._getNodeKey(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`;
        if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0;
        else {
          const nodeElement = {
            depth,
            datum: node,
            index,
            key: nodeKey,
            value: null !== (_a = node.value) && void 0 !== _a ? _a : 0,
            sourceLinks: [],
            targetLinks: []
          };
          nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
        }
        parents && originalLinks.push({
          source: parents[parents.length - 1].key,
          target: nodeKey,
          value: null !== (_b = node.value) && void 0 !== _b ? _b : 0,
          parents
        }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([nodeMap[nodeKey]]) : [nodeMap[nodeKey]]);
      });
    };
    return doSubTree(originalNodes, 0, null), originalLinks.forEach((link3, index) => {
      const key = `${link3.source}-${link3.target}`;
      if (linkMap[key]) return linkMap[key].value += link3.value, void linkMap[key].datum.push(link3);
      const linkElement = {
        index,
        key: `${link3.source}-${link3.target}`,
        source: link3.source,
        target: link3.target,
        datum: [link3],
        value: link3.value,
        parents: link3.parents.map((parent) => parent.key)
      };
      links.push(linkElement), nodeMap[link3.source].sourceLinks.push(linkElement), nodeMap[link3.target].targetLinks.push(linkElement), linkMap[key] = linkElement;
    }), {
      nodes,
      links,
      nodeMap
    };
  }
  computeSourceTargetNodeLinks(data) {
    const nodes = [], links = [], nodeMap = {};
    data.nodes && data.nodes.forEach((node, index) => {
      const nodeElement = {
        depth: -1,
        datum: node,
        index,
        key: this._getNodeKey ? this._getNodeKey(node) : index,
        value: node.value,
        sourceLinks: [],
        targetLinks: []
      };
      nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);
    });
    const invalidLinks = [];
    return data.links.forEach((link3, index) => {
      if (isNil_default(link3.source) || isNil_default(link3.target)) return;
      if (data.nodes && (!nodeMap[link3.source] || !nodeMap[link3.target])) return;
      data.nodes || nodeMap[link3.source] || (nodeMap[link3.source] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link3.source,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link3.source])), data.nodes || nodeMap[link3.target] || (nodeMap[link3.target] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link3.target,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link3.target]));
      const linkElement = {
        index,
        source: link3.source,
        target: link3.target,
        datum: link3,
        value: link3.value
      };
      this.options.divideNodeValueToLink && isNil_default(link3.value) && invalidLinks.push(linkElement), links.push(linkElement), nodeMap[link3.source].sourceLinks.push(linkElement), nodeMap[link3.target].targetLinks.push(linkElement);
    }), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link3) => {
      const values = [calcDivideValue(nodeMap[link3.source]), calcDivideValue(nodeMap[link3.target], true)].filter((entry) => !isNil_default(entry));
      values.length && (link3.value = minInArray(values));
    }), {
      nodeMap,
      nodes,
      links
    };
  }
  computeNodeLinks(data) {
    let res;
    "links" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = true, res = this.computeHierarchicNodeLinks(data.nodes));
    let nodes = res.nodes;
    const links = res.links;
    if (this.options.linkSortBy) for (let i2 = 0, len = nodes.length; i2 < len; i2++) nodes[i2].sourceLinks.sort(this.options.linkSortBy), nodes[i2].targetLinks.sort(this.options.linkSortBy);
    return this.options.dropIsolatedNode && (nodes = nodes.filter((node) => node.targetLinks.length || node.sourceLinks.length)), {
      nodes,
      links,
      nodeMap: res.nodeMap
    };
  }
  computeNodeValues(nodes) {
    for (let i2 = 0, len = nodes.length; i2 < len; i2++) {
      const node = nodes[i2];
      node.value = Math.max(isNil_default(node.value) ? 0 : node.value, node.sourceLinks.reduce((sum5, link3) => {
        var _a;
        return sum5 + (null !== (_a = link3.value) && void 0 !== _a ? _a : 0);
      }, 0), node.targetLinks.reduce((sum5, link3) => {
        var _a;
        return sum5 + (null !== (_a = link3.value) && void 0 !== _a ? _a : 0);
      }, 0));
    }
  }
  computeNodeDepths(nodes) {
    const n2 = nodes.length;
    let next, nextMap, current = nodes, depth = 0;
    for (; current.length && depth < n2; ) {
      next = [], nextMap = {};
      for (let i2 = 0, curLen = current.length; i2 < curLen; i2++) {
        const node = current[i2];
        node.depth = depth;
        for (let j2 = 0, linkLen = node.sourceLinks.length; j2 < linkLen; j2++) {
          const link3 = node.sourceLinks[j2];
          nextMap[link3.target] || (next.push(this._nodeMap[link3.target]), nextMap[link3.target] = true);
        }
      }
      current = next, depth += 1;
    }
    depth > n2 && this._logger.warn("Error: there is a circular link"), this._maxDepth = depth;
  }
  computeNodeEndDepths(nodes) {
    const n2 = nodes.length;
    let next, nextMap, current = nodes, depth = 0;
    for (; current.length && depth < n2; ) {
      next = [], nextMap = {};
      for (let i2 = 0, curLen = current.length; i2 < curLen; i2++) {
        const node = current[i2];
        node.endDepth = depth;
        for (let j2 = 0, linkLen = node.targetLinks.length; j2 < linkLen; j2++) {
          const link3 = node.targetLinks[j2];
          nextMap[link3.source] || (next.push(this._nodeMap[link3.source]), nextMap[link3.source] = true);
        }
      }
      current = next, depth += 1;
    }
    depth > n2 && this._logger.warn("Error: there is a circular link");
  }
  computeNodeLayers(nodes) {
    const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;
    let nodeWidth = null, linkWidth = null, isEvenWidth = false;
    if (isString_default(nodeWidthOption)) {
      const ratio = clamp_default(parseFloat(nodeWidthOption.replace("%", "")) / 100, 0, 1);
      let stepWidth = width / (this._maxDepth - 1 + ratio);
      minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, linkWidth = stepWidth * (1 - ratio), isEvenWidth = true;
    } else if (isNumber_default(nodeWidthOption)) {
      if (nodeWidth = nodeWidthOption, isNumber_default(linkWidthOption)) linkWidth = linkWidthOption;
      else if (isNil_default(linkWidthOption)) {
        let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
        minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;
      }
      isEvenWidth = true;
    } else isFunction_default(nodeWidthOption) && isNumber_default(linkWidthOption) && (linkWidth = linkWidthOption);
    const columns = [];
    for (let i2 = 0, len = nodes.length; i2 < len; i2++) {
      const node = nodes[i2];
      node.layer = this._isHierarchic ? node.depth : clamp_default(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
      const layer = node.layer;
      layer === this._maxDepth - 1 && (node.isLastLayer = true), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [node];
    }
    if (this.options.nodeSortBy) for (let j2 = 0, colLen = columns.length; j2 < colLen; j2++) columns[j2].sort(this.options.nodeSortBy);
    if (!isEvenWidth && isFunction_default(nodeWidthOption)) {
      let curLayerX = this._viewBox.x0;
      for (let i2 = 0; i2 < this._maxDepth; i2++) {
        const column = columns[i2];
        let maxNodeWidth = 0, maxLinkWidth = 0;
        for (let j2 = 0, colLen = column.length; j2 < colLen; j2++) {
          const node = column[j2], curNodeWidth = nodeWidthOption(node);
          node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
          const sourceLinks = node.sourceLinks;
          for (let k3 = 0, linkLen = sourceLinks.length; k3 < linkLen; k3++) {
            const link3 = sourceLinks[k3], curLinkWidth = isFunction_default(linkWidthOption) ? linkWidthOption(link3) : linkWidth;
            maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
          }
        }
        curLayerX += maxNodeWidth;
      }
    }
    return columns;
  }
  initializeNodeBreadths(columns) {
    const minLinkHeight = this.options.minLinkHeight;
    let minNodeHeight = this.options.minNodeHeight;
    (isNil_default(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight);
    let ky2 = 0, getGapY = null;
    if (isFunction_default(this.options.nodeGap)) getGapY = this.options.nodeGap, ky2 = columns.reduce((val, column) => {
      const sumValue = column.reduce((sum5, node) => sum5 + node.value, 0), sumGapY = column.reduce((sum5, node) => sum5 + this.options.nodeGap(node), 0);
      return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
    }, 1 / 0);
    else {
      const maxRowCount = columns.reduce((cnt, column) => Math.max(cnt, column.length), 0), gapY = Math.min(minNodeHeight > 0 ? Math.max(this.options.nodeGap, minNodeHeight) : this.options.nodeGap, this._viewBox.height / maxRowCount);
      getGapY = () => gapY, this._gapY = gapY, ky2 = columns.reduce((val, column) => {
        const sumValue = column.reduce((sum5, node) => sum5 + node.value, 0);
        return Math.min(val, (this._viewBox.height - (column.length - 1) * gapY) / sumValue);
      }, 1 / 0);
    }
    const isStartGap = "start" === this.options.gapPosition, isMiddleGap = !isStartGap && "end" !== this.options.gapPosition;
    for (let i2 = 0, columnCount = columns.length; i2 < columnCount; i2++) {
      const nodes = columns[i2];
      let y3 = this._viewBox.y0, gapY = 0;
      for (let j2 = 0, len = nodes.length; j2 < len; j2++) {
        const node = nodes[j2];
        gapY = getGapY(node), isStartGap && (y3 += gapY), node.y0 = y3, node.y1 = y3 + (minNodeHeight > 0 && 0 !== node.value ? Math.max(node.value * ky2, minNodeHeight) : node.value * ky2), y3 = isStartGap ? node.y1 : node.y1 + gapY;
        for (let k3 = 0, linkLen = node.sourceLinks.length; k3 < linkLen; k3++) {
          const link3 = node.sourceLinks[k3];
          link3.thickness = minLinkHeight > 0 && 0 !== link3.value ? Math.max(link3.value * ky2, minLinkHeight) : link3.value * ky2;
        }
      }
      let deltaY = this._viewBox.y1 - y3 + (isMiddleGap ? gapY : 0);
      if (deltaY > 0) if ("start" === this.options.crossNodeAlign) ;
      else if ("end" === this.options.crossNodeAlign) for (let j2 = 0, len = nodes.length; j2 < len; ++j2) {
        const node = nodes[j2];
        node.y0 += deltaY, node.y1 += deltaY;
      }
      else {
        deltaY /= nodes.length + 1;
        for (let j2 = 0, len = nodes.length; j2 < len; ++j2) {
          const node = nodes[j2];
          node.y0 += deltaY * (j2 + 1), node.y1 += deltaY * (j2 + 1);
        }
      }
      else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY > 0)) {
        gapY += deltaY;
        for (let j2 = 1, len = nodes.length; j2 < len; ++j2) {
          const node = nodes[j2];
          node.y0 += deltaY * j2, node.y1 += deltaY * j2;
        }
      }
      this.reorderLinks(nodes);
    }
  }
  computeNodeBreadths(nodes) {
    const columns = this.computeNodeLayers(nodes);
    this.initializeNodeBreadths(columns);
    const iterations2 = this.options.iterations;
    if (!this._isHierarchic && !isFunction_default(this.options.setNodeLayer) && !isFunction_default(this.options.nodeGap)) for (let i2 = 0; i2 < iterations2; ++i2) {
      const alpha = Math.pow(0.99, i2), beta = Math.max(1 - alpha, (i2 + 1) / iterations2);
      this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);
    }
    return columns;
  }
  relaxLeftToRight(columns, alpha, beta) {
    for (let i2 = 1, n2 = columns.length; i2 < n2; ++i2) {
      const column = columns[i2];
      for (let j2 = 0, colLen = column.length; j2 < colLen; j2++) {
        const target = column[j2];
        let y3 = 0, w2 = 0;
        for (let k3 = 0, linkLen = target.targetLinks.length; k3 < linkLen; k3++) {
          const link3 = target.targetLinks[k3], v2 = link3.value * (target.layer - this._nodeMap[link3.source].layer);
          y3 += this.targetTop(this._nodeMap[link3.source], target) * v2, w2 += v2;
        }
        if (!(w2 > 0)) continue;
        const dy = (y3 / w2 - target.y0) * alpha;
        target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);
      }
      isNil_default(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  relaxRightToLeft(columns, alpha, beta) {
    for (let i2 = columns.length - 2; i2 >= 0; --i2) {
      const column = columns[i2];
      for (let j2 = 0, colLen = column.length; j2 < colLen; j2++) {
        const source = column[j2];
        let y3 = 0, w2 = 0;
        for (let k3 = 0, linkLen = source.sourceLinks.length; k3 < linkLen; k3++) {
          const link3 = source.sourceLinks[k3], v2 = link3.value * (this._nodeMap[link3.target].layer - source.layer);
          y3 += this.sourceTop(source, this._nodeMap[link3.target]) * v2, w2 += v2;
        }
        if (!(w2 > 0)) continue;
        const dy = (y3 / w2 - source.y0) * alpha;
        source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);
      }
      void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  resolveCollisions(nodes, alpha) {
    const i2 = nodes.length >> 1, subject = nodes[i2];
    this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i2 - 1, alpha), this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i2 + 1, alpha), this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
  }
  resolveCollisionsTopToBottom(nodes, y3, i2, alpha) {
    for (; i2 < nodes.length; ++i2) {
      const node = nodes[i2], dy = (y3 - node.y0) * alpha;
      dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y3 = node.y1 + this._gapY;
    }
  }
  resolveCollisionsBottomToTop(nodes, y3, i2, alpha) {
    for (; i2 >= 0; --i2) {
      const node = nodes[i2], dy = (node.y1 - y3) * alpha;
      dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y3 = node.y0 - this._gapY;
    }
  }
  targetTop(source, target) {
    let i2, len, link3, y3 = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;
    for (i2 = 0, len = source.sourceLinks.length; i2 < len && (link3 = source.sourceLinks[i2], link3.target !== target.key); i2++) y3 += link3.thickness + this._gapY;
    for (i2 = 0, len = target.targetLinks.length; i2 < len && (link3 = target.targetLinks[i2], link3.source !== source.key); i2++) y3 -= link3.thickness;
    return y3;
  }
  sourceTop(source, target) {
    let i2, len, link3, y3 = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;
    for (i2 = 0, len = target.targetLinks.length; i2 < len && (link3 = target.targetLinks[i2], link3.source !== source.key); i2++) y3 += link3.thickness + this._gapY;
    for (i2 = 0, len = source.sourceLinks.length; i2 < len && (link3 = source.sourceLinks[i2], link3.target !== target.key); i2++) y3 -= link3.thickness;
    return y3;
  }
  computeLinkBreadths(nodes) {
    for (let i2 = 0, len = nodes.length; i2 < len; i2++) {
      const node = nodes[i2];
      let y05 = node.y0, y14 = y05;
      for (let j2 = 0, linkLen = node.sourceLinks.length; j2 < linkLen; j2++) {
        const link3 = node.sourceLinks[j2];
        link3.y0 = y05 + link3.thickness / 2, link3.x0 = node.x1, y05 += link3.thickness;
      }
      for (let j2 = 0, linkLen = node.targetLinks.length; j2 < linkLen; j2++) {
        const link3 = node.targetLinks[j2];
        link3.y1 = y14 + link3.thickness / 2, link3.x1 = node.x0, y14 += link3.thickness;
      }
    }
  }
  reorderNodeLinks(node) {
    if (isNil_default(this.options.linkSortBy)) {
      const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;
      for (let j2 = 0, linkLen = targetLinks.length; j2 < linkLen; j2++) {
        const link3 = targetLinks[j2];
        this._nodeMap[link3.source].sourceLinks.sort(this._ascendingTargetBreadth);
      }
      for (let j2 = 0, linkLen = sourceLinks.length; j2 < linkLen; j2++) {
        const link3 = sourceLinks[j2];
        this._nodeMap[link3.target].targetLinks.sort(this._ascendingSourceBreadth);
      }
    }
  }
  reorderLinks(nodes) {
    if (isNil_default(this.options.linkSortBy)) for (let i2 = 0, len = nodes.length; i2 < len; i2++) {
      const node = nodes[i2];
      node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);
    }
  }
};
SankeyLayout.defaultOptions = {
  iterations: 6,
  nodeAlign: "justify",
  direction: "horizontal",
  nodeWidth: 24,
  nodeGap: 8,
  crossNodeAlign: "middle",
  dropIsolatedNode: true
};

// node_modules/@visactor/vgrammar-sankey/es/transform.js
var transform28 = (options, upstreamData) => {
  const res = new SankeyLayout(options).layout(Array.isArray(upstreamData) ? upstreamData[0] : upstreamData, "width" in options ? {
    width: options.width,
    height: options.height
  } : {
    x0: options.x0,
    x1: options.x1,
    y0: options.y0,
    y1: options.y1
  });
  return res ? [res] : [];
};

// node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js
var SankeyHighlight = class _SankeyHighlight extends BaseInteraction {
  constructor(view, options) {
    var _a, _b;
    super(view, options), this.type = _SankeyHighlight.type, this.highlightAdjacentElement = (element, isNode) => {
      var _a2, _b2;
      const datum = element.getDatum(), allLinkElements = null !== (_b2 = null === (_a2 = this._linkMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = isNode ? [datum.key] : [datum.source, datum.target], getIsHighlight = isNode ? (linkDatum) => linkDatum.target === datum.key || linkDatum.source === datum.key : (linkDatum) => linkDatum.source === datum.source && linkDatum.target === datum.target;
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum();
        getIsHighlight(linkDatum) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {
          ratio: 1
        }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState));
      }), highlightNodes;
    }, this.highlightRelatedBySourceTarget = (element, isNode) => {
      var _a2, _b2, _c, _d, _e, _f;
      if (!isNode) return this.highlightAdjacentElement(element, isNode);
      const datum = element.getDatum(), allNodeElements = null !== (_b2 = null === (_a2 = this._nodeMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = [], allLinkElements = null !== (_d = null === (_c = this._linkMark) || void 0 === _c ? void 0 : _c.elements) && void 0 !== _d ? _d : [], highlightLinks = [], allNodes = allNodeElements.reduce((res, nodeEl) => {
        const nodeDatum = nodeEl.getDatum();
        return res[null == nodeDatum ? void 0 : nodeDatum.key] = {
          datum: nodeDatum,
          el: nodeEl
        }, res;
      }, {}), downNodes = [datum], upNodes = [datum];
      for (; downNodes.length; ) {
        const first = downNodes.pop();
        (null === (_e = null == first ? void 0 : first.sourceLinks) || void 0 === _e ? void 0 : _e.length) && first.sourceLinks.forEach((link3) => {
          highlightLinks.push(link3), allNodes[link3.target] && downNodes.push(allNodes[link3.target].datum);
        });
      }
      for (; upNodes.length; ) {
        const first = upNodes.pop();
        (null === (_f = null == first ? void 0 : first.targetLinks) || void 0 === _f ? void 0 : _f.length) && first.targetLinks.forEach((link3) => {
          highlightLinks.push(link3), allNodes[link3.source] && upNodes.push(allNodes[link3.source].datum);
        });
      }
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum();
        highlightLinks.some((link3) => link3.source === linkDatum.source && link3.target === linkDatum.target) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {
          ratio: 1
        }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState));
      }), highlightNodes;
    }, this.highlightRelatedElement = (element, isNode) => {
      var _a2, _b2, _c, _d, _e;
      const allLinkElements = null !== (_b2 = null === (_a2 = this._linkMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [];
      if (!!!(null === (_e = null === (_d = null === (_c = allLinkElements[0]) || void 0 === _c ? void 0 : _c.getDatum) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.parents)) return this.highlightRelatedBySourceTarget(element, isNode);
      const datum = element.getDatum(), highlightNodes = isNode ? [datum.key] : [datum.source, datum.target], upstreamLinks = this.parseUpstreamLinks(element, isNode);
      return allLinkElements.forEach((linkEl) => {
        const linkDatum = linkEl.getDatum(), originalDatum = array(linkDatum.datum);
        if (!isNode && linkDatum.source === datum.source && linkDatum.target === datum.target) return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
          ratio: 1
        });
        const selectedDatum = isNode ? originalDatum.filter((entry) => {
          var _a3;
          return (null !== (_a3 = entry.parents) && void 0 !== _a3 ? _a3 : []).some((par) => par.key === datum.key);
        }) : originalDatum.filter((entry) => {
          var _a3;
          return (null !== (_a3 = entry.parents) && void 0 !== _a3 ? _a3 : []).some((par) => par.key === datum.target);
        });
        if (selectedDatum && selectedDatum.length) {
          highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
          const ratio = selectedDatum.reduce((sum5, d2) => sum5 + d2.value, 0) / linkDatum.value;
          return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
            ratio
          });
        }
        const upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
        if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
          ratio: upSelectedLink.value / linkDatum.value
        });
        linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState);
      }), highlightNodes;
    }, this.highlightElement = (element, isNode) => {
      var _a2, _b2;
      const allNodeElements = null !== (_b2 = null === (_a2 = this._nodeMark) || void 0 === _a2 ? void 0 : _a2.elements) && void 0 !== _b2 ? _b2 : [], highlightNodes = "related" === this.options.effect ? this.highlightRelatedElement(element, isNode) : this.highlightAdjacentElement(element, isNode);
      allNodeElements.forEach((el) => {
        highlightNodes.includes(el.getDatum().key) ? (el.removeState(this.options.blurState), el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), el.addState(this.options.blurState));
      });
    }, this.handleStart = (e3) => {
      e3.element && (e3.element.mark === this._nodeMark ? (this._activeElement = e3.element, this.highlightElement(e3.element, true)) : e3.element.mark === this._linkMark && (this._activeElement = e3.element, this.highlightElement(e3.element, false)));
    }, this.handleReset = (e3) => {
      e3.element && e3.element === this._activeElement && this.clearPrevElements();
    }, this.options = Object.assign({}, _SankeyHighlight.defaultOptions, options), this._nodeMark = null === (_a = view.getMarksBySelector(this.options.nodeSelector)) || void 0 === _a ? void 0 : _a[0], this._linkMark = null === (_b = view.getMarksBySelector(this.options.linkSelector)) || void 0 === _b ? void 0 : _b[0];
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.resetTrigger,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    [this._linkMark, this._nodeMark].forEach((mark) => {
      mark && mark.elements.forEach((el) => {
        el.hasState(this.options.highlightState) && el.removeState(this.options.highlightState), el.hasState(this.options.blurState) && el.removeState(this.options.blurState);
      });
    });
  }
  parseUpstreamLinks(element, isNode) {
    const datum = element.getDatum();
    return (isNode ? datum.targetLinks : array(datum)).reduce((res, link3) => (array(link3.datum).forEach((dividedLink) => {
      var _a;
      const parents = null !== (_a = dividedLink.parents) && void 0 !== _a ? _a : [{
        key: dividedLink.source
      }], len = isNode ? parents.length : parents.length - 1;
      for (let i2 = 0; i2 < len; i2++) {
        const source = parents[i2].key, target = parents[i2 + 1] ? parents[i2 + 1].key : datum.key, value = dividedLink.value, existingItem = res.find((item) => item.source === source && item.target === target);
        existingItem ? existingItem.value += value : res.push({
          source,
          target,
          value
        });
      }
    }), res), []);
  }
};
SankeyHighlight.type = "sankey-highlight", SankeyHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  resetTrigger: "pointerout",
  effect: "related"
};

// node_modules/@visactor/vgrammar-sankey/es/index.js
var registerSankeyTransforms = () => {
  Factory.registerTransform("sankey", {
    transform: transform28,
    markPhase: "beforeJoin"
  }, true);
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey.js
var collectHierarchyField = (set2, data, field5) => {
  data.forEach((obj) => {
    isNil_default(obj[field5]) || set2.add(obj[field5]), obj.children && obj.children.length > 0 && collectHierarchyField(set2, obj.children, field5);
  });
};
var convertValuesToNumbers = (data) => {
  data.forEach((obj) => {
    obj.value = isString_default(obj.value) ? +obj.value : obj.value, obj.children && obj.children.length > 0 && convertValuesToNumbers(obj.children);
  });
};
var sankeyFormat = (data) => {
  var _a;
  if (!data || !isArray_default(data)) return [];
  if (data.length > 1) {
    const updateData = {
      links: [],
      nodes: []
    };
    return data.forEach((datum) => {
      "links" !== datum.id && "nodes" !== datum.id || (updateData[datum.id] = datum.values);
    }), [updateData];
  }
  return (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data;
};
var sankeyLayout = (data, op) => {
  var _a, _b;
  if (!data || !(null == op ? void 0 : op.view) || !data.length) return [];
  const view = op.view();
  if (view.x1 - view.x0 == 0 || view.y1 - view.y0 == 0 || view.x1 - view.x0 == -1 / 0 || view.x1 - view.x0 == 1 / 0 || view.y1 - view.y0 == -1 / 0 || view.y1 - view.y0 == 1 / 0) return [];
  const originalData = data[0];
  if (("source" !== op.sourceField || "target" !== op.targetField || "value" !== op.valueField) && originalData.links) {
    const updatedData = [];
    originalData.links.forEach((datum) => {
      const updatedDatum = {};
      for (const key in datum) key === op.sourceField ? updatedDatum.source = datum[op.sourceField] : key === op.targetField ? updatedDatum.target = datum[op.targetField] : key === op.valueField ? updatedDatum.value = datum[op.valueField] : updatedDatum[key] = datum[key];
      updatedData.push(updatedDatum);
    }), originalData.links = updatedData;
  }
  if (originalData.links) {
    const updatedData = [];
    originalData.links.forEach((datum) => {
      const updatedDatum = {};
      for (const key in datum) "value" === key ? updatedDatum.value = isString_default(datum.value) ? +datum.value : datum.value : updatedDatum[key] = datum[key];
      updatedData.push(updatedDatum);
    }), originalData.links = updatedData;
  } else (null === (_b = null === (_a = originalData.nodes) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.children) && convertValuesToNumbers(originalData.nodes);
  const layout2 = new SankeyLayout(op), result2 = [];
  return result2.push(layout2.layout(originalData, view)), result2;
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey-nodes.js
var sankeyNodes = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].nodes) && void 0 !== _b ? _b : [];
};

// node_modules/@visactor/vchart/esm/data/transforms/sankey-links.js
var sankeyLinks = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].links) && void 0 !== _b ? _b : [];
};

// node_modules/@visactor/vchart/esm/series/sankey/tooltip-helper.js
var SankeySeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    if ("mark" === activeType) return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: (datum) => {
          if (datum.source) {
            if (isNumber_default(datum.source)) {
              const seriesKeys = this.series.getSeriesKeys();
              return seriesKeys[datum.source] + " => " + seriesKeys[datum.target];
            }
            return datum.source + " => " + datum.target;
          }
          return datum.datum[this.series.getSpec().categoryField];
        },
        hasShape: false
      },
      content: [{
        key: this.contentKeyCallback,
        value: (datum) => datum.value,
        hasShape: true,
        shapeType: this.contentShapeTypeCallback,
        shapeColor: this.contentShapeColorCallback,
        shapeStroke: this.contentShapeColorCallback,
        shapeHollow: false
      }]
    };
    if ("dimension" === activeType && dimensionInfo) {
      const title3 = {
        key: void 0,
        value: this._getDimensionData,
        hasShape: false
      }, content = [];
      return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
        content.push({
          seriesId: series2.id,
          key: this.contentKeyCallback,
          value: this.contentValueCallback,
          hasShape: true,
          shapeType: this.contentShapeTypeCallback,
          shapeColor: this.contentShapeColorCallback,
          shapeStroke: this.contentShapeColorCallback,
          shapeHollow: false
        });
      })), {
        visible: true,
        activeType,
        title: title3,
        content
      };
    }
    return null;
  }
};

// node_modules/@visactor/vchart/esm/series/sankey/animation.js
var sankeyGrowIn = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: {
    overall: isOverall ? params2.growFrom() : isOverall,
    orient: "positive"
  }
});
var sankeyNodePresetAnimation = (params2, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : sankeyGrowIn(params2);
var sankeyLinkPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "linkPathGrowIn"
};
var registerSankeyAnimation = () => {
  Factory2.registerAnimation("sankeyNode", (params2, preset) => Object.assign({
    appear: sankeyNodePresetAnimation(params2, preset)
  }, FadeInOutAnimation)), Factory2.registerAnimation("sankeyLinkPath", (params2, preset) => ({
    appear: sankeyLinkPresetAnimation(preset),
    enter: {
      type: "linkPathGrowIn"
    },
    exit: {
      type: "linkPathGrowOut"
    },
    disappear: {
      type: "linkPathGrowOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/mark/link-path.js
var LinkPathMark = class _LinkPathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _LinkPathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      x0: 0,
      y0: 0,
      x1: 100,
      y1: 100,
      thickness: 1,
      round: true
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId(), direction2 = this.getStyle("direction");
    this._product = view.glyph("linkPath", null != group ? group : view.rootMark).id(id2).configureGlyph({
      direction: direction2
    }), this._compiledProductId = id2;
  }
};
LinkPathMark.type = "linkPath";
var registerLinkPathMark = () => {
  registerLinkPathGlyph(), Factory2.registerMark(LinkPathMark.type, LinkPathMark);
};

// node_modules/@visactor/vchart/esm/series/sankey/sankey.js
var SankeySeries = class _SankeySeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sankey, this._nodeLayoutZIndex = LayoutZIndex.Node, this._labelLayoutZIndex = LayoutZIndex.Label, this._viewBox = new Bounds(), this._handleAdjacencyClick = (params2) => {
      const element = params2.item;
      element && element.mark.id().includes("node") ? this._handleNodeAdjacencyClick(element) : element && element.mark.id().includes("link") ? this._handleLinkAdjacencyClick(element) : this._handleClearEmpty();
    }, this._handleRelatedClick = (params2) => {
      const element = params2.item;
      element && element.mark.id().includes("node") ? this._handleNodeRelatedClick(element) : element && element.mark.id().includes("link") ? this._handleLinkRelatedClick(element) : this._handleClearEmpty();
    }, this._handleClearEmpty = () => {
      const nodeVGrammarMark = this._nodeMark.getProduct();
      if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
      const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
      if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
      const allLinkElements = linkVGrammarMark.elements, labelVGrammarMark = this._labelMark.getProduct();
      if (!labelVGrammarMark || !labelVGrammarMark.elements || !labelVGrammarMark.elements.length) return;
      const allLabelElements = labelVGrammarMark.elements;
      allNodeElements.forEach((el) => {
        el.clearStates();
      }), allLinkElements.forEach((el) => {
        el.clearStates();
      }), allLabelElements.forEach((el) => {
        el.clearStates();
      });
    }, this._handleNodeAdjacencyClick = (element) => {
      const nodeDatum = element.getDatum(), highlightNodes = [nodeDatum.key];
      if (this._linkMark) {
        const vGrammarMark = this._linkMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((linkEl, i2) => {
          linkEl.clearStates();
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
          if (array(linkDatum[father]).includes(nodeDatum.key)) {
            let ratio;
            if (highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), "parents" === father) {
              const originalDatum = linkDatum.datum;
              ratio = (originalDatum ? originalDatum.filter((entry) => entry.parents.some((par) => par.key === nodeDatum.key)).reduce((sum5, d2) => sum5 + d2.value, 0) : 0) / linkDatum.value;
            }
            linkEl.addState("selected", {
              ratio
            });
          } else linkDatum.target === nodeDatum.key ? highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source) : linkEl.useStates(["blur"]);
        });
      }
      if (this._nodeMark) {
        const vGrammarMark = this._nodeMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((el) => {
          el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
        });
      }
      if (this._labelMark) {
        const vGrammarMark = this._labelMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((el) => {
          el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
        });
      }
    }, this._handleLinkAdjacencyClick = (element) => {
      const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target];
      if (this._linkMark) {
        const vGrammarMark = this._linkMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((linkEl) => {
          linkEl.clearStates(), linkEl === element ? linkEl.addState("selected", {
            ratio: 1
          }) : linkEl.useStates(["blur"]);
        });
      }
      if (this._nodeMark) {
        const vGrammarMark = this._nodeMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((el) => {
          el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
        });
      }
      if (this._labelMark) {
        const vGrammarMark = this._labelMark.getProduct();
        if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
        vGrammarMark.elements.forEach((el) => {
          el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
        });
      }
    }, this._handleNodeRelatedClick = (element) => {
      var _a;
      const nodeDatum = element.getDatum(), nodeVGrammarMark = this._nodeMark.getProduct();
      if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
      const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
      if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
      const allLinkElements = linkVGrammarMark.elements;
      if ("source" === ((null === (_a = allLinkElements[0].getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
        const highlightNodes = [nodeDatum.key], highlightLinks = [];
        if (allLinkElements.forEach((linkEl, i2) => {
          var _a2, _b, _c, _d;
          linkEl.clearStates();
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
          if (array(linkDatum[father]).includes(nodeDatum.key)) {
            if (highlightLinks.includes(null !== (_a2 = linkDatum.key) && void 0 !== _a2 ? _a2 : linkDatum.index) || highlightLinks.push(null !== (_b = linkDatum.key) && void 0 !== _b ? _b : linkDatum.index), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), !highlightNodes.includes(linkDatum.target)) {
              highlightNodes.push(linkDatum.target);
              let targetNodeSourceLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.target).data[0].sourceLinks;
              for (; (null == targetNodeSourceLinks ? void 0 : targetNodeSourceLinks.length) > 0; ) {
                const newTargetNodeSourceLinks = [];
                return targetNodeSourceLinks.forEach((targetNodeSourceLinkDatum) => {
                  var _a3, _b2;
                  if (!highlightLinks.includes(null !== (_a3 = targetNodeSourceLinkDatum.key) && void 0 !== _a3 ? _a3 : targetNodeSourceLinkDatum.index) && (highlightLinks.push(null !== (_b2 = targetNodeSourceLinkDatum.key) && void 0 !== _b2 ? _b2 : targetNodeSourceLinkDatum.index), !highlightNodes.includes(targetNodeSourceLinkDatum.target))) {
                    highlightNodes.push(targetNodeSourceLinkDatum.target);
                    const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === targetNodeSourceLinkDatum.target);
                    newTargetNodeSourceLinks.push(sourceNodeTemp.data[0].targetLinks);
                  }
                }), void (targetNodeSourceLinks = newTargetNodeSourceLinks);
              }
            }
          } else if (linkDatum.target === nodeDatum.key && (highlightLinks.includes(null !== (_c = linkDatum.key) && void 0 !== _c ? _c : linkDatum.index) || highlightLinks.push(null !== (_d = linkDatum.key) && void 0 !== _d ? _d : linkDatum.index), !highlightNodes.includes(linkDatum.source))) {
            highlightNodes.push(linkDatum.source);
            let sourceNodeTargetLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.source).data[0].targetLinks;
            for (; (null == sourceNodeTargetLinks ? void 0 : sourceNodeTargetLinks.length) > 0; ) {
              const newSourceNodeTargetLinks = [];
              return sourceNodeTargetLinks.forEach((sourceNodeTargetLinkDatum) => {
                var _a3, _b2;
                if (!highlightLinks.includes(null !== (_a3 = sourceNodeTargetLinkDatum.key) && void 0 !== _a3 ? _a3 : sourceNodeTargetLinkDatum.index) && (highlightLinks.push(null !== (_b2 = sourceNodeTargetLinkDatum.key) && void 0 !== _b2 ? _b2 : sourceNodeTargetLinkDatum.index), !highlightNodes.includes(sourceNodeTargetLinkDatum.source))) {
                  highlightNodes.push(sourceNodeTargetLinkDatum.source);
                  const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === sourceNodeTargetLinkDatum.source);
                  newSourceNodeTargetLinks.push(sourceNodeTemp.data[0].targetLinks);
                }
              }), void (sourceNodeTargetLinks = newSourceNodeTargetLinks);
            }
          }
        }), this._linkMark) {
          const vGrammarMark = this._linkMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((linkEl, i2) => {
            var _a2;
            linkEl.clearStates(), highlightLinks.includes(null !== (_a2 = linkEl.getDatum().key) && void 0 !== _a2 ? _a2 : linkEl.getDatum().index) ? linkEl.useStates(["selected"]) : linkEl.useStates(["blur"]);
          });
        }
        if (this._nodeMark) {
          const vGrammarMark = this._nodeMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
          });
        }
        if (this._labelMark) {
          const vGrammarMark = this._labelMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
          });
        }
      } else {
        const highlightNodes = [nodeDatum.key], upstreamLinks = nodeDatum.targetLinks.reduce((res, link3) => (array(link3.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i2 = 0; i2 < len; i2++) {
            const source = parents[i2].key, target = parents[i2 + 1] ? parents[i2 + 1].key : nodeDatum.key, value = dividedLink.value, existingItem = res.find((item) => item.source === source && item.target === target);
            existingItem ? existingItem.value += value : res.push({
              source,
              target,
              value
            });
          }
        }), res), []);
        if (allLinkElements.forEach((linkEl, i2) => {
          linkEl.clearStates();
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source", originalDatum = linkDatum.datum, selectedDatum = originalDatum ? originalDatum.filter((entry) => entry[father].some((par) => par.key === nodeDatum.key)) : null, upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const ratio = selectedDatum.reduce((sum5, d2) => sum5 + d2.value, 0) / linkDatum.value;
            return linkEl.useStates(["selected"]), void linkEl.addState("selected", {
              ratio
            });
          }
          if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.useStates(["selected"]), void linkEl.addState("selected", {
            ratio: upSelectedLink.value / linkDatum.value
          });
          linkEl.useStates(["blur"]);
        }), this._nodeMark) {
          const vGrammarMark = this._nodeMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
          });
        }
        if (this._labelMark) {
          const vGrammarMark = this._labelMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
          });
        }
      }
    }, this._handleLinkRelatedClick = (element) => {
      var _a;
      const nodeVGrammarMark = this._nodeMark.getProduct();
      if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
      const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
      if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
      const allLinkElements = linkVGrammarMark.elements;
      if ("source" === ((null === (_a = element.getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
        if (this._linkMark) {
          const vGrammarMark = this._linkMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((linkEl) => {
            linkEl.clearStates();
          });
        }
        if (this._nodeMark) {
          const vGrammarMark = this._nodeMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates();
          });
        }
        if (this._labelMark) {
          const vGrammarMark = this._labelMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates();
          });
        }
      } else {
        const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target], upstreamLinks = [];
        if (array(curLinkDatum.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i2 = 0; i2 < len - 1; i2++) {
            const source = parents[i2].key, target = parents[i2 + 1].key, value = dividedLink.value, existingItem = upstreamLinks.find((item) => item.source === source && item.target === target);
            upstreamLinks.push({
              source: parents[i2].key,
              target: parents[i2 + 1].key,
              value: dividedLink.value
            }), existingItem ? existingItem.value += value : upstreamLinks.push({
              source,
              target,
              value
            });
          }
        }), allLinkElements.forEach((linkEl) => {
          linkEl.clearStates();
          const linkDatum = linkEl.getDatum(), originalDatum = linkDatum.datum;
          if (linkDatum.source === curLinkDatum.source && linkDatum.target === curLinkDatum.target) return linkEl.useStates(["selected"]), void linkEl.addState("selected", {
            ratio: 1
          });
          const selectedDatum = originalDatum ? originalDatum.filter((entry) => {
            const parentKeysList = entry.parents.map((item) => item.key);
            return parentKeysList.includes(curLinkDatum.source) && parentKeysList.includes(curLinkDatum.target);
          }) : null;
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const val = selectedDatum.filter((entry) => entry.parents.some((par, index) => {
              var _a2;
              return par.key === curLinkDatum.source && (null === (_a2 = entry.parents[index + 1]) || void 0 === _a2 ? void 0 : _a2.key) === curLinkDatum.target;
            })).reduce((sum5, d2) => sum5 + d2.value, 0), ratio = val / linkDatum.value;
            return linkEl.useStates(["selected"]), void linkEl.addState("selected", {
              ratio
            });
          }
          const upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.useStates(["selected"]), void linkEl.addState("selected", {
            ratio: upSelectedLink.value / linkDatum.value
          });
          linkEl.useStates(["blur"]);
        }), allNodeElements.forEach((el) => {
          el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
        }), this._labelMark) {
          const vGrammarMark = this._labelMark.getProduct();
          if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
          vGrammarMark.elements.forEach((el) => {
            el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates(["blur"]);
          });
        }
      }
    };
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : this._spec.categoryField), this._labelLimit = null !== (_c = null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.limit) && void 0 !== _c ? _c : 100;
  }
  initData() {
    var _a, _b, _c, _d;
    super.initData();
    const viewData = this.getViewData(), rawData = this.getRawData();
    if (rawData && viewData) {
      registerDataSetInstanceTransform(this._dataSet, "sankeyLayout", sankeyLayout), registerDataSetInstanceTransform(this._dataSet, "sankeyFormat", sankeyFormat), rawData.transform({
        type: "sankeyFormat"
      }, false), viewData.transform({
        type: "sankeyLayout",
        options: {
          view: () => ({
            x0: this._viewBox.x1,
            x1: this._viewBox.x2,
            y0: this._viewBox.y1,
            y1: this._viewBox.y2
          }),
          sourceField: this._spec.sourceField,
          targetField: this._spec.targetField,
          valueField: this._spec.valueField,
          direction: this._spec.direction,
          nodeAlign: null !== (_a = this._spec.nodeAlign) && void 0 !== _a ? _a : "justify",
          nodeGap: null !== (_b = this._spec.nodeGap) && void 0 !== _b ? _b : 8,
          nodeWidth: null !== (_c = this._spec.nodeWidth) && void 0 !== _c ? _c : 10,
          linkWidth: this._spec.linkWidth,
          minStepWidth: this._spec.minStepWidth,
          minNodeHeight: null !== (_d = this._spec.minNodeHeight) && void 0 !== _d ? _d : 4,
          minLinkHeight: this._spec.minLinkHeight,
          iterations: this._spec.iterations,
          nodeKey: this._spec.nodeKey,
          linkSortBy: this._spec.linkSortBy,
          nodeSortBy: this._spec.nodeSortBy,
          setNodeLayer: this._spec.setNodeLayer
        },
        level: TransformLevel.sankeyLayout
      });
      const { dataSet } = this._option;
      registerDataSetInstanceTransform(dataSet, "sankeyNodes", sankeyNodes), registerDataSetInstanceTransform(dataSet, "flatten", flatten2);
      const nodesDataView = new DataView(dataSet, {
        name: `sankey-node-${this.id}-data`
      });
      nodesDataView.parse([this.getViewData()], {
        type: "dataview"
      }), nodesDataView.transform({
        type: "sankeyNodes"
      }), nodesDataView.transform({
        type: "flatten",
        options: {
          callback: (node) => {
            if (node.datum) {
              const nodeData = node.datum[node.depth];
              return Object.assign(Object.assign({}, node), nodeData);
            }
            return node;
          }
        }
      }, false), nodesDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._nodesSeriesData = new SeriesData(this._option, nodesDataView), registerDataSetInstanceTransform(dataSet, "sankeyLinks", sankeyLinks);
      const linksDataView = new DataView(dataSet, {
        name: `sankey-link-${this.id}-data`
      });
      linksDataView.parse([this.getViewData()], {
        type: "dataview"
      }), linksDataView.transform({
        type: "sankeyLinks"
      }), linksDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._linksSeriesData = new SeriesData(this._option, linksDataView);
    }
  }
  initMark() {
    var _a, _b, _c;
    const nodeMark = this._createMark(_SankeySeries.mark.node, {
      isSeriesMark: true,
      key: DEFAULT_DATA_INDEX,
      dataView: this._nodesSeriesData.getDataView(),
      dataProductId: this._nodesSeriesData.getProductId(),
      customShape: null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.customShape
    });
    nodeMark && (nodeMark.setZIndex(this._nodeLayoutZIndex), this._nodeMark = nodeMark);
    const linkMark = this._createMark(_SankeySeries.mark.link, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._linksSeriesData.getDataView(),
      dataProductId: this._linksSeriesData.getProductId(),
      customShape: null === (_b = this._spec.link) || void 0 === _b ? void 0 : _b.customShape
    });
    if (linkMark && (this._linkMark = linkMark), null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.visible) {
      const labelMark = this._createMark(_SankeySeries.mark.label, {
        key: DEFAULT_DATA_INDEX,
        dataView: this._nodesSeriesData.getDataView(),
        dataProductId: this._nodesSeriesData.getProductId()
      });
      labelMark && (this._labelMark = labelMark);
    }
  }
  initMarkStyle() {
    this._initNodeMarkStyle(), this._initLinkMarkStyle(), this._initLabelMarkStyle();
  }
  _initNodeMarkStyle() {
    const nodeMark = this._nodeMark;
    nodeMark && (this.setMarkStyle(nodeMark, {
      x: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y: (datum) => datum.y0,
      y1: (datum) => datum.y1,
      fill: (datum) => {
        var _a, _b, _c, _d;
        return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
      }
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Mark), this._trigger.registerMark(nodeMark));
  }
  _initLinkMarkStyle() {
    var _a;
    const linkMark = this._linkMark;
    linkMark && (this.setMarkStyle(linkMark, {
      x0: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y0: (datum) => datum.y0,
      y1: (datum) => datum.y1,
      thickness: (datum) => datum.thickness,
      fill: (datum) => {
        var _a2, _b, _c, _d, _e, _f;
        const fill = null === (_b = null === (_a2 = this._spec.link) || void 0 === _a2 ? void 0 : _a2.style) || void 0 === _b ? void 0 : _b.fill;
        if (fill) return fill;
        const sourceName = this._spec.nodeKey || (null === (_e = null === (_d = null === (_c = this._rawData.latestData[0]) || void 0 === _c ? void 0 : _c.nodes) || void 0 === _d ? void 0 : _d[0]) || void 0 === _e ? void 0 : _e.children) ? datum.source : this.getNodeList()[datum.source];
        return null === (_f = this._colorScale) || void 0 === _f ? void 0 : _f.scale(sourceName);
      },
      direction: null !== (_a = this._spec.direction) && void 0 !== _a ? _a : "horizontal"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(linkMark));
  }
  _initLabelMarkStyle() {
    this._labelMark && ("vertical" === this._spec.direction ? "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "center",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => datum.y1 >= this._viewBox.y2 ? datum.y0 : datum.y1,
      fill: (datum) => {
        var _a, _b, _c, _d;
        return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
      },
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "center",
      textBaseline: (datum) => datum.y1 >= this._viewBox.y2 ? "bottom" : "top"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "center",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "left" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: (datum) => {
        var _a, _b, _c, _d;
        return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
      },
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "right" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: (datum) => {
        var _a, _b, _c, _d;
        return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
      },
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1 >= this._viewBox.x2 ? datum.x0 : datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: (datum) => {
        var _a, _b, _c, _d;
        return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
      },
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: (datum) => datum.x1 >= this._viewBox.x2 ? "right" : "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._labelMark.setZIndex(this._labelLayoutZIndex), this._trigger.registerMark(this._labelMark));
  }
  _createText(datum) {
    var _a;
    if (isNil_default(datum) || isNil_default(datum.datum)) return "";
    let text2 = datum.datum[this._spec.categoryField] || "";
    return (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.formatMethod) && (text2 = this._spec.label.formatMethod(text2, datum.datum)), text2;
  }
  initAnimation() {
    var _a, _b, _c, _d, _e;
    const animationParams = {
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._nodeMark && this._nodeMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("sankeyNode")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("node", this._spec, this._markAttributeContext))), this._linkMark && this._linkMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("sankeyLinkPath")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("link", this._spec, this._markAttributeContext))), this._labelMark && this._labelMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext)));
  }
  initEvent() {
    var _a, _b, _c;
    super.initEvent(), null === (_a = this._nodesSeriesData.getDataView()) || void 0 === _a || _a.target.addListener("change", this.nodesSeriesDataUpdate.bind(this)), null === (_b = this._linksSeriesData.getDataView()) || void 0 === _b || _b.target.addListener("change", this.linksSeriesDataUpdate.bind(this));
    const emphasisSpec = null !== (_c = this._spec.emphasis) && void 0 !== _c ? _c : {};
    true !== this._option.disableTriggerEvent && (emphasisSpec.enable && "adjacency" === emphasisSpec.effect && ("hover" === emphasisSpec.trigger ? this.event.on("pointerover", {
      level: Event_Bubble_Level.chart
    }, this._handleAdjacencyClick) : this.event.on("pointerdown", {
      level: Event_Bubble_Level.chart
    }, this._handleAdjacencyClick)), emphasisSpec.enable && "related" === emphasisSpec.effect && ("hover" === emphasisSpec.trigger ? this.event.on("pointerover", {
      level: Event_Bubble_Level.chart
    }, this._handleRelatedClick) : this.event.on("pointerdown", {
      level: Event_Bubble_Level.chart
    }, this._handleRelatedClick)));
  }
  nodesSeriesDataUpdate() {
    this._nodesSeriesData.updateData(), this._setNodeOrdinalColorScale();
  }
  linksSeriesDataUpdate() {
    this._linksSeriesData.updateData();
  }
  initTooltip() {
    this._tooltipHelper = new SankeySeriesTooltipHelper(this), this._nodeMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodeMark), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  _setNodeOrdinalColorScale() {
    var _a, _b, _c, _d, _e;
    const colorScale = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalScale) || void 0 === _b ? void 0 : _b.getScale("color");
    if (null == colorScale ? void 0 : colorScale._specified) return void (this._colorScale = colorScale);
    let colorDomain, colorRange;
    colorScale && (colorDomain = colorScale.domain(), colorRange = colorScale.range()), colorRange || (colorRange = this._getDataScheme()), colorDomain && !isNil_default(colorDomain[0]) || (colorDomain = this.getNodeList(), colorDomain.length > 10 && (colorRange = null === (_c = this._getDataScheme()[1]) || void 0 === _c ? void 0 : _c.scheme));
    const ordinalScale = new ColorOrdinalScale();
    null === (_e = (_d = ordinalScale.domain(colorDomain)).range) || void 0 === _e || _e.call(_d, colorRange), this._colorScale = ordinalScale;
  }
  getNodeList() {
    var _a, _b, _c;
    return (null === (_a = this._rawData.latestData[0]) || void 0 === _a ? void 0 : _a.nodes) ? (null === (_b = this._rawData.latestData[0].nodes[0]) || void 0 === _b ? void 0 : _b.children) ? Array.from(this.extractNamesFromTree(this._rawData.latestData[0].nodes, this._spec.categoryField)) : this._rawData.latestData[0].nodes.map((datum, index) => datum[this._spec.categoryField]) : null === (_c = this._rawData.latestData[0]) || void 0 === _c ? void 0 : _c.values.map((datum, index) => datum[this._spec.categoryField]);
  }
  _getNodeNameFromData(datum) {
    return (null == datum ? void 0 : datum.datum) ? null == datum ? void 0 : datum.datum[this._spec.categoryField] : datum[this._spec.categoryField];
  }
  extractNamesFromTree(tree, categoryName) {
    const uniqueNames = /* @__PURE__ */ new Set();
    return tree.forEach((node) => {
      if (uniqueNames.add(node[categoryName]), node.children) {
        this.extractNamesFromTree(node.children, categoryName).forEach((name) => uniqueNames.add(name));
      }
    }), uniqueNames;
  }
  getDimensionField() {
    return [this._spec.categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getRawDataStatisticsByField(field5, isNumeric2) {
    var _a;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field5]) {
      this._viewDataStatistics && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field5]) ? this._rawStatisticsCache[field5] = this._viewDataStatistics.latestData[field5] : this._rawData && (this._rawStatisticsCache[field5] = {
        values: this._collectByField(field5)
      });
    }
    return this._rawStatisticsCache[field5];
  }
  _collectByField(field5) {
    var _a, _b, _c;
    const keyArray = [], rawData = null === (_b = null === (_a = this.getRawData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[0];
    if (!rawData) return [];
    if (rawData.links) (null === (_c = rawData.nodes) || void 0 === _c ? void 0 : _c.length) && rawData.nodes.forEach((node) => {
      node[this._seriesField] && keyArray.push(node[this._seriesField]);
    });
    else if (rawData.nodes) {
      const set2 = /* @__PURE__ */ new Set();
      return collectHierarchyField(set2, rawData.nodes, this._seriesField), Array.from(set2);
    }
    return keyArray;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this.getViewData().reRunAllTransform(), this._nodesSeriesData.updateData(), this._linksSeriesData.updateData();
  }
  getDefaultShapeType() {
    return "square";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._nodeMark, this._linkMark];
  }
};
SankeySeries.type = SeriesTypeEnum.sankey, SankeySeries.mark = sankeySeriesMark;
var registerSankeySeries = () => {
  registerSankeyTransforms(), registerRectMark(), registerLinkPathMark(), registerTextMark(), registerSankeyAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(SankeySeries.type, SankeySeries);
};

// node_modules/@visactor/vchart/esm/data/transforms/treemap.js
var treemap2 = (data, op) => {
  if (!data || !(null == op ? void 0 : op.range)) return data;
  const range2 = op.range();
  if (range2.x1 - range2.x0 == 0 || range2.y1 - range2.y0 == 0) return data;
  return new TreemapLayout(op).layout(data, range2);
};

// node_modules/@visactor/vchart/esm/data/transforms/hierarchy-dimension-statistics.js
var hierarchyDimensionStatistics = (data, op) => {
  let result2 = {}, fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length)) return result2;
  if (!data[0].latestData) return result2;
  const hierarchyData = data[0].latestData, flatData = flatten2(hierarchyData);
  return result2 = dimensionStatistics([{
    latestData: flatData
  }], op), result2;
};

// node_modules/@visactor/vchart/esm/series/treemap/tooltip-helper.js
var TreemapTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.contentKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
  get defaultShapeType() {
    return "square";
  }
};

// node_modules/@visactor/vchart/esm/series/treemap/animation.js
var treemapPresetAnimation = (preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "growCenterIn"
};
var registerTreemapAnimation = () => {
  Factory2.registerAnimation("treemap", (params2, preset) => ({
    appear: treemapPresetAnimation(preset),
    enter: {
      type: "growCenterIn"
    },
    exit: {
      type: "growCenterOut"
    },
    disappear: {
      type: "growCenterOut"
    }
  }));
};

// node_modules/@visactor/vchart/esm/series/treemap/treemap-transform.js
var TreemapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nonLeaf", "nonLeafLabel", "initNonLeafLabelMarkStyle"), this._addMarkLabelSpec(spec, "leaf");
  }
};

// node_modules/@visactor/vchart/esm/series/treemap/treemap.js
var TreemapSeries = class _TreemapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.treemap, this.transformerConstructor = TreemapSeriesSpecTransformer, this._viewBox = new Bounds(), this._enableAnimationHook = this.enableMarkAnimation.bind(this);
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.roam && (this.initZoomable(this.event, this._option.mode), this._matrix = new Matrix()), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2, _b;
        return null !== (_b = null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : this._categoryField) && void 0 !== _b ? _b : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), isValidNumber_default(this._spec.maxDepth) && (this._maxDepth = this._spec.maxDepth - 1);
  }
  initData() {
    var _a, _b, _c, _d;
    super.initData(), this.getViewData() && (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "treemap", treemap2), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten2), this.addViewDataFilter({
      type: "treemap",
      options: {
        range: () => ({
          x0: this._viewBox.x1,
          x1: this._viewBox.x2,
          y0: this._viewBox.y1,
          y1: this._viewBox.y2
        }),
        maxDepth: this._maxDepth,
        gapWidth: this._spec.gapWidth,
        padding: this._spec.nodePadding,
        splitType: this._spec.splitType,
        aspectRatio: this._spec.aspectRatio,
        labelPadding: (null === (_a = this._spec.nonLeafLabel) || void 0 === _a ? void 0 : _a.visible) ? null === (_b = this._spec.nonLeafLabel) || void 0 === _b ? void 0 : _b.padding : 0,
        labelPosition: null === (_c = this._spec.nonLeafLabel) || void 0 === _c ? void 0 : _c.position,
        minVisibleArea: null !== (_d = this._spec.minVisibleArea) && void 0 !== _d ? _d : 10,
        minChildrenVisibleArea: this._spec.minChildrenVisibleArea,
        minChildrenVisibleSize: this._spec.minChildrenVisibleSize
      },
      level: TransformLevel.treemapFilter
    }), this.addViewDataFilter({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      },
      level: TransformLevel.treemapFlatten
    }));
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  getRawDataStatisticsByField(field5, isNumeric2) {
    var _a;
    if (!this._rawDataStatistics) {
      const rawDataName = `${this.type}_${this.id}_rawDataStatic`;
      this._rawDataStatistics = this._createHierarchyDataStatistics(rawDataName, [this._rawData]), this._rawData.target.removeListener("change", this._rawDataStatistics.reRunAllTransform), this._rawDataStatistics.reRunAllTransform();
    }
    return null === (_a = this._rawDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field5];
  }
  _createHierarchyDataStatistics(dataName, rawData) {
    registerDataSetInstanceTransform(this._dataSet, "hierarchyDimensionStatistics", hierarchyDimensionStatistics), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten2);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse(rawData, {
      type: "dataview"
    }), data.transform({
      type: "hierarchyDimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && this._seriesField !== this._categoryField && fields2.push({
            key: this._seriesField,
            operations: ["values"]
          }), fields2;
        }
      }
    }, false), data;
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  initMark() {
    var _a, _b;
    const nonLeafMark = this._createMark(_TreemapSeries.mark.nonLeaf, {
      isSeriesMark: true,
      customShape: null === (_a = this._spec.nonLeaf) || void 0 === _a ? void 0 : _a.customShape
    });
    nonLeafMark && (nonLeafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "nonLeaf")
    }]), this._trigger.registerMark(nonLeafMark), this._nonLeafMark = nonLeafMark);
    const leafMark = this._createMark(_TreemapSeries.mark.leaf, {
      isSeriesMark: true,
      customShape: null === (_b = this._spec.leaf) || void 0 === _b ? void 0 : _b.customShape
    });
    leafMark && (leafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "leaf")
    }]), this._leafMark = leafMark, this._trigger.registerMark(leafMark));
  }
  initMarkStyle() {
    this._initLeafMarkStyle(), this._initNonLeafMarkStyle();
  }
  _initLeafMarkStyle() {
    this._leafMark && this.setMarkStyle(this._leafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initNonLeafMarkStyle() {
    this._nonLeafMark && this.setMarkStyle(this._nonLeafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initNonLeafLabelMarkStyle(labelMark) {
    labelMark && (this._nonLeafLabelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelRect ? (datum.labelRect.x0 + datum.labelRect.x1) / 2 : (datum.x0 + datum.x1) / 2,
      y: (datum) => datum.labelRect ? (datum.labelRect.y0 + datum.labelRect.y1) / 2 : (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initAnimation() {
    this.getMarksInType("rect").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("treemap")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.roam && (this.initDragEventOfSeries(this), this.event.on("panmove", (e3) => {
      this.handlePan(e3);
    }), this.initZoomEventOfSeries(this), this.event.on("zoom", (e3) => {
      this.handleZoom(e3);
    })), this._spec.drill && this.bindDrillEvent();
  }
  _getDataIdKey() {
    return "key";
  }
  initTooltip() {
    this._tooltipHelper = new TreemapTooltipHelper(this), this._leafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._leafMark), this._nonLeafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nonLeafMark);
  }
  _shouldFilterElement(datum, nodeType) {
    const isLeaf = datum.isLeaf;
    return "leaf" === nodeType ? !isLeaf : isLeaf;
  }
  handlePan(event) {
    const { delta } = event;
    if (0 === delta[0] && 0 === delta[1]) return;
    this._matrix.reset(), this._matrix.translate(delta[0], delta[1]);
    const { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = this._matrix;
    this._matrix.multiply(a4, b2, c4, d2, e3, f2), this._viewBox.transformWithMatrix(this._matrix), this.reFilterViewData();
  }
  handleZoom(event) {
    const { scale: scale4, scaleCenter } = event;
    if (1 === scale4) return;
    this._matrix.reset();
    const { x: x3, y: y3 } = scaleCenter;
    this._matrix.translate(x3, y3), this._matrix.scale(scale4, scale4), this._matrix.translate(-x3, -y3);
    const { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = this._matrix;
    this._matrix.multiply(a4, b2, c4, d2, e3, f2), this.disableMarkAnimation(), this.event.on(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook), this._viewBox.transformWithMatrix(this._matrix), this.reFilterViewData();
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height), this._rawData.reRunAllTransform();
  }
  enableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.enable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m5) => {
      m5 && m5.getComponent() && m5.getComponent().getProduct().getGroupGraphicItem().enableAnimation();
    }), this.event.off(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook);
  }
  disableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.disable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m5) => {
      m5 && m5.getComponent() && m5.getComponent().getProduct().getGroupGraphicItem().disableAnimation();
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._nonLeafMark, this._leafMark];
  }
};
TreemapSeries.type = SeriesTypeEnum.treemap, TreemapSeries.mark = treemapSeriesMark, TreemapSeries.transformerConstructor = TreemapSeriesSpecTransformer, mixin(TreemapSeries, Drillable), mixin(TreemapSeries, Zoomable);
var registerTreemapSeries = () => {
  registerRectMark(), registerTextMark(), registerTreemapAnimation(), registerFadeInOutAnimation(), Factory2.registerSeries(TreemapSeries.type, TreemapSeries);
};

// node_modules/@visactor/vchart/esm/series/gauge/animation.js
var Appear_Grow7 = (params2) => ({
  channel: {
    angle: {
      from: params2.startAngle + Math.PI / 2
    }
  }
});
var Appear_FadeIn10 = {
  type: "fadeIn"
};
function gaugePointerPresetAnimation(params2, preset) {
  return "fadeIn" === preset ? Appear_FadeIn10 : Appear_Grow7(params2);
}
var registerGaugePointerAnimation = () => {
  Factory2.registerAnimation("gaugePointer", (params2, preset) => {
    const animation = gaugePointerPresetAnimation(params2, preset);
    return {
      appear: animation,
      enter: animation,
      disappear: {
        type: "fadeOut"
      }
    };
  });
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge-pointer.js
var GaugePointerSeries = class _GaugePointerSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gaugePointer, this._pinMark = null, this._pointerMark = null, this._pinBackgroundMark = null, this._stack = false;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setRadiusField(this._spec.radiusField), this._pointerType = "rect" === (null === (_a = this._spec.pointer) || void 0 === _a ? void 0 : _a.type) ? "rect" : "path";
  }
  initMark() {
    this._pinBackgroundMark = this._createMark(_GaugePointerSeries.mark.pinBackground), this._pointerMark = this._createMark(Object.assign(Object.assign({}, _GaugePointerSeries.mark.pointer), {
      type: this._pointerType
    }), {
      isSeriesMark: true
    }), this._pinMark = this._createMark(_GaugePointerSeries.mark.pin);
  }
  initMarkStyle() {
    this.initPinBackgroundMarkStyle(), this.initPointerMarkStyle(), this.initPinMarkStyle();
  }
  initGroups() {
  }
  initPointerMarkStyle() {
    const pointerMark = this._pointerMark, pointerSpec = this._spec.pointer;
    pointerMark && (this.setMarkStyle(pointerMark, {
      x: (datum) => {
        var _a, _b;
        const { x: x3 } = this._getPointerAnchor(datum, pointerSpec);
        return x3 - this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0);
      },
      y: (datum) => {
        var _a, _b;
        const { y: y3 } = this._getPointerAnchor(datum, pointerSpec);
        return y3 - this._getPointerHeight(datum) * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[1]) && void 0 !== _b ? _b : 0);
      },
      anchor: (datum) => {
        const { x: x3, y: y3 } = this._getPointerAnchor(datum, pointerSpec);
        return [x3, y3];
      },
      fill: this.getColorAttribute(),
      zIndex: 200
    }), "path" === this._pointerType ? this.setMarkStyle(pointerMark, {
      scaleX: this._getPointerWidth.bind(this),
      scaleY: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) + Math.PI / 2
    }) : this.setMarkStyle(pointerMark, {
      width: this._getPointerWidth.bind(this),
      height: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) - Math.PI / 2
    }), this._trigger.registerMark(pointerMark));
  }
  initTooltip() {
    super.initTooltip(), this._pointerMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pointerMark);
  }
  _getPointerAnchor(datum, markSpec) {
    var _a;
    return null === (_a = markSpec.isOnCenter) || void 0 === _a || _a ? this.angleAxisHelper.center() : this.radiusAxisHelper.coordToPoint({
      radius: this._innerRadius * this._computeLayoutRadius(),
      angle: this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]])
    });
  }
  _getPointerWidth() {
    return this._spec.pointer.width * this._computeLayoutRadius();
  }
  _getPointerHeight(datum) {
    var _a, _b;
    const pointerSpec = this._spec.pointer, radiusField = this._radiusField[0];
    return isValid_default(this.radiusAxisHelper) && isValid_default(radiusField) ? this.radiusAxisHelper.dataToPosition([datum[radiusField]]) - (null !== (_a = null == pointerSpec ? void 0 : pointerSpec.innerPadding) && void 0 !== _a ? _a : 0) - (null !== (_b = null == pointerSpec ? void 0 : pointerSpec.outerPadding) && void 0 !== _b ? _b : 10) : pointerSpec.height * this._computeLayoutRadius();
  }
  _getPointerAngle(datum) {
    return this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]]);
  }
  _getRotatedPointerCenterOffset(datum) {
    var _a, _b, _c, _d;
    const pointerSpec = this._spec.pointer, x3 = this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0), y3 = -this._getPointerHeight(datum) * (null !== (_d = null === (_c = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _c ? void 0 : _c[1]) && void 0 !== _d ? _d : 0), angle2 = this._getPointerAngle(datum) - Math.PI / 2, cos3 = Math.cos(angle2), sin3 = Math.sin(angle2);
    return {
      x: x3 * cos3 + y3 * sin3,
      y: -(y3 * cos3 - x3 * sin3)
    };
  }
  initPinBackgroundMarkStyle() {
    const pinBackgroundMark = this._pinBackgroundMark, pinBackgroundSpec = this._spec.pinBackground;
    pinBackgroundMark && this.setMarkStyle(pinBackgroundMark, {
      x: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).y,
      scaleX: () => pinBackgroundSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinBackgroundSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 100
    });
  }
  initPinMarkStyle() {
    const pinMark = this._pinMark, pinSpec = this._spec.pin;
    pinMark && this.setMarkStyle(pinMark, {
      x: (datum) => this._getPointerAnchor(datum, pinSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinSpec).y,
      scaleX: () => pinSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 300
    });
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._pointerMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("gaugePointer")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("pointer", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugePointerSeries.type = SeriesTypeEnum.gaugePointer, GaugePointerSeries.mark = gaugePointerSeriesMark;
var registerGaugePointerSeries = () => {
  registerPathMark(), registerRectMark(), registerGaugePointerAnimation(), Factory2.registerSeries(GaugePointerSeries.type, GaugePointerSeries);
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge-transformer.js
var GaugeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "segment");
  }
};

// node_modules/@visactor/vchart/esm/series/gauge/gauge.js
var GaugeSeries = class _GaugeSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gauge, this.transformerConstructor = GaugeSeriesSpecTransformer, this._segmentMark = null, this._trackMark = null, this._stack = false, this._padAngle = 0;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._padAngle = degreeToRadian(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
  }
  initData() {
    var _a;
    super.initData();
    registerDataSetInstanceTransform(this._option.dataSet, "spiltSegment", (data, op) => {
      const dataCollect = data.slice();
      return dataCollect.sort((a4, b2) => a4[this._angleField[0]] - b2[this._angleField[0]]), dataCollect.forEach((datum, i2) => {
        datum[SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[SEGMENT_FIELD_START] = i2 > 0 ? dataCollect[i2 - 1][SEGMENT_FIELD_END] : void 0;
      }), dataCollect;
    }), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "spiltSegment"
    }, false);
  }
  initMark() {
    super.initMark(), this._trackMark = this._createMark(_GaugeSeries.mark.track, {
      parent: this._arcGroupMark,
      dataView: false
    }), this._segmentMark = this._createMark(_GaugeSeries.mark.segment, {
      parent: this._arcGroupMark,
      isSeriesMark: true
    });
  }
  initMarkStyle() {
    super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
  }
  initSegmentMarkStyle() {
    var _a;
    const segmentMark = this._segmentMark;
    segmentMark && (this.setMarkStyle(segmentMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart.bind(this),
      endAngle: this._getAngleValueEnd.bind(this),
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    }), this._trigger.registerMark(segmentMark));
  }
  initTooltip() {
    super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
  }
  initTrackMarkStyle() {
    var _a;
    const trackMark = this._trackMark;
    trackMark && (this.setMarkStyle(trackMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._startAngle,
      endAngle: this._endAngle,
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      zIndex: 100
    }), this._trigger.registerMark(trackMark));
  }
  _getAngleValueStartWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
    return Math.min(startAngle + this._padAngle / 2, (startAngle + endAngle) / 2);
  }
  _getAngleValueEndWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
    return Math.max(endAngle - this._padAngle / 2, (startAngle + endAngle) / 2);
  }
  _getAngleValueStartWithoutPadAngle(datum) {
    return isValid_default(datum[SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_START]]) : this._startAngle;
  }
  _getAngleValueEndWithoutPadAngle(datum) {
    return this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_END]]);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._segmentMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("segment", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugeSeries.type = SeriesTypeEnum.gauge, GaugeSeries.mark = gaugeSeriesMark, GaugeSeries.transformerConstructor = GaugeSeriesSpecTransformer;
var registerGaugeSeries = () => {
  registerProgressArcMark(), registerProgressLikeAnimation(), Factory2.registerSeries(GaugeSeries.type, GaugeSeries);
};

// node_modules/@visactor/vchart/esm/mark/cell.js
var CellMark = class _CellMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _CellMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      padding: 0
    });
  }
};
CellMark.type = "cell";
var registerCellMark2 = () => {
  Factory2.registerMark(CellMark.type, CellMark), registerCellGraphic(), registerCellMark();
};

// node_modules/@visactor/vchart/esm/series/heatmap/animation.js
function heatmapPresetAnimation(preset) {
  return false === preset ? {} : {
    type: "fadeIn"
  };
}
var registerHeatmapAnimation = () => {
  Factory2.registerAnimation("heatmap", (params2, preset) => Object.assign(Object.assign({}, FadeInOutAnimation), {
    appear: heatmapPresetAnimation(preset)
  }));
};

// node_modules/@visactor/vchart/esm/series/heatmap/tooltip-helper.js
var HeatmapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    const pattern = super.getDefaultTooltipPattern(activeType, dimensionInfo);
    return isValid_default(pattern) && "dimension" === activeType && (pattern.visible = false), pattern;
  }
};

// node_modules/@visactor/vchart/esm/series/heatmap/heatmap-transformer.js
var HeatmapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "cell");
  }
};

// node_modules/@visactor/vchart/esm/series/heatmap/heatmap.js
var HeatmapSeries = class _HeatmapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.heatmap, this.transformerConstructor = HeatmapSeriesSpecTransformer;
  }
  getFieldValue() {
    return this._fieldValue;
  }
  setFieldValue(f2) {
    this._fieldValue = array(f2);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFieldValue(this._spec.valueField);
  }
  initMark() {
    var _a, _b;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._cellMark = this._createMark(_HeatmapSeries.mark.cell, {
      morph: shouldMarkDoMorph(this._spec, _HeatmapSeries.mark.cell.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      isSeriesMark: true,
      progressive,
      customShape: null === (_a = this._spec.cell) || void 0 === _a ? void 0 : _a.customShape
    }), this._backgroundMark = this._createMark(_HeatmapSeries.mark.cellBackground, {
      progressive,
      customShape: null === (_b = this._spec.cellBackground) || void 0 === _b ? void 0 : _b.customShape
    });
  }
  initMarkStyle() {
    this.initCellMarkStyle(), this.initCellBackgroundMarkStyle();
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getMeasureField()[0]]
    });
  }
  initCellMarkStyle() {
    this.setMarkStyle(this._cellMark, {
      x: (datum) => this.dataToPositionX(datum),
      y: (datum) => this.dataToPositionY(datum),
      size: () => [this.getCellSize(this._xAxisHelper), this.getCellSize(this._yAxisHelper)],
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), this._trigger.registerMark(this._cellMark);
  }
  initCellBackgroundMarkStyle() {
    var _a, _b, _c;
    const padding = normalizePadding(null !== (_c = null === (_b = null === (_a = this._spec.cellBackground) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : 0);
    this.setMarkStyle(this._backgroundMark, {
      x: (datum) => {
        const width = this.getCellSize(this._xAxisHelper);
        return this.dataToPositionX(datum) - width / 2 + padding[3];
      },
      y: (datum) => {
        const height = this.getCellSize(this._yAxisHelper);
        return this.dataToPositionY(datum) - height / 2 + padding[0];
      },
      width: () => this.getCellSize(this._xAxisHelper) - padding[1] - padding[3],
      height: () => this.getCellSize(this._yAxisHelper) - padding[0] - padding[2]
    }, "normal", AttributeLevel.Series);
  }
  getColorAttribute() {
    var _a;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: this.getFieldValue[0]
    };
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._cellMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("heatmap")) || void 0 === _c ? void 0 : _c(appearPreset), userAnimationConfig("cell", this._spec, this._markAttributeContext), animationParams));
  }
  getCellSize(axisHelper) {
    var _a, _b;
    return null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, 0)) && void 0 !== _b ? _b : 6;
  }
  initTooltip() {
    this._tooltipHelper = new HeatmapSeriesTooltipHelper(this), this._cellMark && this._tooltipHelper.activeTriggerSet.mark.add(this._cellMark);
  }
  getDefaultShapeType() {
    return "square";
  }
  getDimensionField() {
    return [].concat(this.fieldX, this.fieldY);
  }
  getMeasureField() {
    return this.getFieldValue();
  }
  getActiveMarks() {
    return [this._cellMark];
  }
};
HeatmapSeries.type = SeriesTypeEnum.heatmap, HeatmapSeries.mark = heatmapSeriesMark, HeatmapSeries.transformerConstructor = HeatmapSeriesSpecTransformer;
var registerHeatmapSeries = () => {
  registerTextMark(), registerCellMark2(), registerHeatmapAnimation(), Factory2.registerSeries(HeatmapSeries.type, HeatmapSeries);
};

// node_modules/@visactor/vchart/esm/data/transforms/correlation.js
var correlation2 = (data, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  if (!data || !(null == options ? void 0 : options.view) || !isArray_default(data)) return data;
  const viewBox = options.view();
  if (viewBox.x1 - viewBox.x0 == 0 || viewBox.y1 - viewBox.y0 == 0 || viewBox.x1 - viewBox.x0 == -1 / 0 || viewBox.x1 - viewBox.x0 == 1 / 0 || viewBox.y1 - viewBox.y0 == -1 / 0 || viewBox.y1 - viewBox.y0 == 1 / 0) return data;
  const startAngle = degreeToRadian(null !== (_a = options.startAngle) && void 0 !== _a ? _a : -90), endAngle = degreeToRadian(null !== (_b = options.endAngle) && void 0 !== _b ? _b : 270), maxRadius = Math.max((viewBox.x1 - viewBox.x0) / 2, (viewBox.y1 - viewBox.y0) / 2), innerRadius = toPercent(null !== (_c = options.innerRadius) && void 0 !== _c ? _c : 0, maxRadius), outerRadius = toPercent(options.outerRadius, maxRadius), center2 = [isNumber_default(null === (_d = options.center) || void 0 === _d ? void 0 : _d[0]) ? options.center[0] : viewBox.x0 + toPercent(null !== (_f = null === (_e = options.center) || void 0 === _e ? void 0 : _e[0]) && void 0 !== _f ? _f : "50%", viewBox.x1 - viewBox.x0), isNumber_default(null === (_g = options.center) || void 0 === _g ? void 0 : _g[1]) ? options.center[1] : viewBox.y0 + toPercent(null !== (_j = null === (_h = options.center) || void 0 === _h ? void 0 : _h[1]) && void 0 !== _j ? _j : "50%", viewBox.y1 - viewBox.y0)], fieldAccessor = field(options.field), values = data.map(fieldAccessor), [min4, max4] = extent2(values), radiusScale = min4 === max4 ? (val) => (innerRadius + outerRadius) / 2 : (val) => innerRadius + (outerRadius - innerRadius) * (val - min4) / (max4 - min4), sizeAccessor = isNil_default(options.radiusField) ? fieldAccessor : field(options.radiusField), defaultSize = null !== (_l = null === (_k = null == options ? void 0 : options.radiusRange) || void 0 === _k ? void 0 : _k[1]) && void 0 !== _l ? _l : 5;
  let sizeScale = (datum) => defaultSize;
  if (sizeAccessor) {
    const [minSize, maxSize] = sizeAccessor !== fieldAccessor ? extent2(data.map(sizeAccessor)) : [min4, max4], minR = null !== (_o = null === (_m = options.radiusRange) || void 0 === _m ? void 0 : _m[0]) && void 0 !== _o ? _o : 5, maxR = null !== (_q = null === (_p = options.radiusRange) || void 0 === _p ? void 0 : _p[1]) && void 0 !== _q ? _q : 5;
    minSize !== maxSize && (sizeScale = (datum) => minR + (maxR - minR) * (sizeAccessor(datum) - minSize) / (maxSize - minSize));
  }
  const minAngle = Math.min(startAngle, endAngle), maxAngle = Math.max(startAngle, endAngle), angles2 = getPartialAngles(minAngle, maxAngle, data.length), res = [], searchAngle = (maxAngle - minAngle) / 60;
  return data.forEach((datum, index) => {
    const radius = radiusScale(values[index]), size = sizeScale(datum);
    let x3, y3, angle2 = angles2[index];
    for (let i2 = 0; i2 < 60 && (x3 = center2[0] + radius * Math.cos(angle2), y3 = center2[1] + radius * Math.sin(angle2), hasOverlap3({
      x: x3,
      y: y3,
      size
    }, res) || x3 - size < viewBox.x0 || x3 + size > viewBox.x1 || y3 - size < viewBox.y0 || y3 + size > viewBox.y1); i2++) i2 < 59 && (angle2 += searchAngle, angle2 > maxAngle ? angle2 = minAngle : angle2 < minAngle && (angle2 = maxAngle));
    res.push(Object.assign({
      [CORRELATION_X]: x3,
      [CORRELATION_Y]: y3,
      [CORRELATION_SIZE]: size
    }, datum));
  }), res;
};
var getPartialAngles = (minAngle, maxAngle, count) => {
  let offsetAngle = 0, stepCount = Math.max(Math.ceil(2 * (maxAngle - minAngle) / Math.PI), 2), stepAngle = (maxAngle - minAngle) / stepCount, stepIndex = 0, stepSign = 1, i2 = 0, j2 = 0;
  const res = [];
  let startAngle = minAngle;
  for (; i2 < count; ) j2 < stepCount && (res.push(startAngle + (j2 % 2 ? Math.floor(j2 / 2) + Math.floor(stepCount / 2) : j2 / 2) * stepAngle * stepSign), j2++), i2++, j2 === stepCount && (j2 = 0, stepIndex += 1, stepSign *= -1, 0 === offsetAngle ? offsetAngle = stepAngle / 2 : offsetAngle /= 2, startAngle = -1 === stepSign ? maxAngle - offsetAngle : minAngle + offsetAngle, stepIndex >= 2 && (stepAngle /= 2, stepCount *= 2));
  return res;
};
var hasOverlap3 = (item, arr) => !(!arr || !arr.length) && arr.some((entry) => Math.pow(item.x - entry.x, 2) + Math.pow(item.y - entry.y, 2) < Math.pow(item.size + entry.size, 2));

// node_modules/@visactor/vchart/esm/data/transforms/correlation-center.js
var correlationCenter = (data, options) => {
  if (!data || !isArray_default(data)) return [];
  const { keyword, categoryField } = options, nodeInfo = data[0].latestData[0];
  return {
    [categoryField]: keyword,
    [DEFAULT_DATA_INDEX]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_INDEX],
    [DEFAULT_DATA_SERIES_FIELD]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_SERIES_FIELD]
  };
};

// node_modules/@visactor/vchart/esm/mark/ripple.js
var RippleMark = class _RippleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RippleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      ripple: 0
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.glyph("ripplePoint", null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
};
RippleMark.type = "ripple";
var registerRippleMark = () => {
  Factory2.registerMark(RippleMark.type, RippleMark), registerRippleGlyph();
};

// node_modules/@visactor/vchart/esm/series/correlation/animation.js
var correlationPresetAnimation = (_params, preset) => "fadeIn" === preset ? {
  type: "fadeIn"
} : {
  type: "scaleIn"
};
var registerCorrelationAnimation = () => {
  Factory2.registerAnimation("correlation", (params2, preset) => Object.assign({
    appear: correlationPresetAnimation(0, preset)
  }, ScaleInOutAnimation));
};

// node_modules/@visactor/vchart/esm/series/correlation/correlation-transformer.js
var CorrelationSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nodePoint"), this._addMarkLabelSpec(spec, "centerPoint", "centerLabel");
  }
};

// node_modules/@visactor/vchart/esm/series/correlation/correlation.js
var CorrelationSeries = class _CorrelationSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.correlation, this.transformerConstructor = CorrelationSeriesSpecTransformer, this._viewBox = new Bounds();
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f2) {
    return this._categoryField = f2, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f2) {
    return this._valueField = f2, this._valueField;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field5) {
    isValid_default(field5) && (this._seriesField = field5);
  }
  getSizeField() {
    return this._sizeField;
  }
  setSizeField(field5) {
    isValid_default(field5) && (this._sizeField = field5);
  }
  getSizeRange() {
    return this._sizeRange;
  }
  setSizeRange(range2) {
    isValid_default(range2) && (this._sizeRange = range2);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(this._spec.seriesField), this.setSizeField(this._spec.sizeField), this.setSizeRange(this._spec.sizeRange);
  }
  initData() {
    var _a, _b, _c;
    if (super.initData(), !this._data) return;
    registerDataSetInstanceTransform(this._dataSet, "correlation", correlation2);
    const centerDataSet = new DataSet();
    registerDataSetInstanceParser(centerDataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(centerDataSet, "correlationCenter", correlationCenter);
    const centerDataView = new DataView(centerDataSet, {
      name: `${this.type}_${this.id}_center`
    });
    centerDataView.parse([this.getViewData()], {
      type: "dataview"
    }), centerDataView.transform({
      type: "correlationCenter",
      options: {
        keyword: null !== (_c = null === (_b = null === (_a = this._spec.centerLabel) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "",
        categoryField: this._spec.categoryField
      }
    }), this._centerSeriesData = new SeriesData(this._option, centerDataView);
  }
  _statisticViewData() {
    super._statisticViewData(), this._data.getDataView().transform({
      type: "correlation",
      options: {
        view: () => ({
          x0: this._viewBox.x1,
          x1: this._viewBox.x2,
          y0: this._viewBox.y1,
          y1: this._viewBox.y2
        }),
        field: this._spec.valueField,
        radiusRange: this._spec.sizeRange,
        radiusField: this._spec.sizeField,
        center: [this._spec.centerX, this._spec.centerY],
        innerRadius: this._spec.innerRadius,
        outerRadius: this._spec.outerRadius,
        startAngle: this._spec.startAngle,
        endAngle: this._spec.endAngle
      }
    });
  }
  initMark() {
    var _a, _b;
    const nodePointMark = this._createMark(_CorrelationSeries.mark.nodePoint, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      key: DEFAULT_DATA_INDEX,
      customShape: null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.customShape
    });
    nodePointMark && (nodePointMark.setZIndex(LayoutZIndex.Node), this._nodePointMark = nodePointMark);
    const ripplePointMark = this._createMark(_CorrelationSeries.mark.ripplePoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId()
    });
    ripplePointMark && (this._ripplePointMark = ripplePointMark);
    const centerPointMark = this._createMark(_CorrelationSeries.mark.centerPoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId(),
      customShape: null === (_b = this._spec.centerPoint) || void 0 === _b ? void 0 : _b.customShape
    });
    centerPointMark && (centerPointMark.setZIndex(LayoutZIndex.Node), this._centerPointMark = centerPointMark);
  }
  initMarkStyle() {
    this._initNodePointMarkStyle(), this._initRipplePointMarkStyle(), this._initCenterPointMarkStyle();
  }
  _initNodePointMarkStyle() {
    var _a, _b, _c, _d;
    const nodePointMark = this._nodePointMark;
    if (!nodePointMark) return;
    const nodePointStyle = null !== (_b = null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(nodePointMark, {
      x: (datum) => datum[CORRELATION_X],
      y: (datum) => datum[CORRELATION_Y],
      size: (datum) => datum[CORRELATION_SIZE],
      fill: null !== (_c = nodePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_d = nodePointStyle.fillOpacity) && void 0 !== _d ? _d : 1,
      lineWidth: 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(nodePointMark);
  }
  _initRipplePointMarkStyle() {
    var _a, _b, _c, _d, _e;
    const ripplePointMark = this._ripplePointMark;
    if (!ripplePointMark) return;
    const ripplePointStyle = null !== (_b = null === (_a = this._spec.ripplePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(ripplePointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = ripplePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      opacity: null !== (_d = ripplePointStyle.fillOpacity) && void 0 !== _d ? _d : 0.2,
      ripple: null !== (_e = ripplePointStyle.ripple) && void 0 !== _e ? _e : 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initCenterPointMarkStyle() {
    var _a, _b, _c, _d, _e, _f;
    const centerPointMark = this._centerPointMark;
    centerPointMark && (this.setMarkStyle(centerPointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => 0.2 * Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = null === (_b = null === (_a = this._spec.centerPoint) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_f = null === (_e = null === (_d = this._spec.centerPoint) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.fillOpacity) && void 0 !== _f ? _f : 1
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(centerPointMark));
  }
  initTooltip() {
    super.initTooltip(), this._nodePointMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodePointMark);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this._categoryField],
      z: this.dataToPositionZ.bind(this)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this._nodePointMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("correlation")) || void 0 === _b ? void 0 : _b({}, appearPreset), userAnimationConfig("nodePoint", this._spec, this._markAttributeContext)));
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  getActiveMarks() {
    return [this._nodePointMark, this._centerPointMark];
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this._rawData.reRunAllTransform(), this.getViewData().reRunAllTransform();
  }
};
CorrelationSeries.type = SeriesTypeEnum.correlation, CorrelationSeries.mark = correlationSeriesMark, CorrelationSeries.transformerConstructor = CorrelationSeriesSpecTransformer;
var registerCorrelationSeries = () => {
  registerSymbolMark(), registerRippleMark(), Factory2.registerSeries(CorrelationSeries.type, CorrelationSeries), registerCorrelationAnimation();
};

// node_modules/@visactor/vchart/esm/chart/map/map-transformer.js
var MapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return type === SeriesTypeEnum.map;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      type: spec.type,
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      map: spec.map,
      nameProperty: spec.nameProperty,
      centroidProperty: spec.centroidProperty,
      nameMap: spec.nameMap,
      area: spec.area,
      defaultFillColor: spec.defaultFillColor
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.region.forEach((r2) => {
      r2.coordinate = "geo";
    });
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/map/map.js
var MapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = MapChartSpecTransformer, this.type = "map", this.seriesType = SeriesTypeEnum.map;
  }
};
MapChart.type = "map", MapChart.seriesType = SeriesTypeEnum.map, MapChart.view = "singleDefault", MapChart.transformerConstructor = MapChartSpecTransformer;
var registerMapChart = () => {
  registerMapSeries(), Factory2.registerChart(MapChart.type, MapChart);
};

// node_modules/@visactor/vchart/esm/chart/polar/polar-transformer.js
var PolarChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  getIndicatorSpec(spec) {
    var _a, _b, _c;
    const indicatorSpec = array(spec.indicator), limitRatio = null !== (_a = spec.innerRadius) && void 0 !== _a ? _a : null === (_c = null === (_b = spec.series) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.innerRadius;
    return isValid_default(limitRatio) && indicatorSpec.forEach((indicator2) => {
      isNil_default(indicator2.limitRatio) && (indicator2.limitRatio = limitRatio);
    }), indicatorSpec;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      radius: spec.radius,
      outerRadius: spec.outerRadius,
      innerRadius: spec.innerRadius,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      sortDataByAxis: spec.sortDataByAxis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), isArray_default(spec.dataZoom) && spec.dataZoom.length > 0 && spec.dataZoom.forEach((zoom) => {
      "axis" === zoom.filterMode && (zoom.filterMode = "filter");
    });
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec], isValid_default(spec.indicator) && (spec.indicator = this.getIndicatorSpec(spec));
  }
};

// node_modules/@visactor/vchart/esm/chart/polar/progress-like/progress-like-transformer.js
var ProgressLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      seriesField: spec.seriesField,
      categoryField: spec.categoryField || spec.radiusField,
      valueField: spec.valueField || spec.angleField,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      radius: spec.radius,
      innerRadius: spec.innerRadius,
      centerX: spec.centerX,
      centerY: spec.centerY
    });
  }
  _transformProgressAxisSpec(spec, angleAxisDefaultSpec, radiusAxisDefaultSpec, angleAxisAppendSpec, radiusAxisAppendSpec) {
    var _a, _b;
    spec.axes || (spec.axes = []);
    let radiusAxis = (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).find((axis2) => "radius" === axis2.orient), angleAxis = (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).find((axis2) => "angle" === axis2.orient);
    angleAxis || (angleAxis = angleAxisDefaultSpec, spec.axes.push(angleAxis)), radiusAxis || (radiusAxis = radiusAxisDefaultSpec, spec.axes.push(radiusAxis)), isNil_default(angleAxis.type) && (angleAxis.type = "linear"), isNil_default(radiusAxis.type) && (radiusAxis.type = "band");
    const domain = getLinearAxisSpecDomain(angleAxis, {
      min: 0,
      max: 1
    });
    isNil_default(angleAxis.min) && (angleAxis.min = domain.min), isNil_default(angleAxis.max) && (angleAxis.max = domain.max), angleAxisAppendSpec && Object.assign(angleAxis, mergeSpec({}, angleAxisAppendSpec, angleAxis)), radiusAxisAppendSpec && Object.assign(radiusAxis, mergeSpec({}, radiusAxisAppendSpec, radiusAxis));
  }
};

// node_modules/@visactor/vchart/esm/chart/polar/rose-like/rose-like-transformer.js
var RoseLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return true;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField || spec.angleField,
      valueField: spec.valueField || spec.radiusField
    });
  }
  transformSpec(spec) {
    var _a;
    if (super.transformSpec(spec), this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        radius: false,
        angle: false
      };
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "radius" === orient && (haxAxes.radius = true), "angle" === orient && (haxAxes.angle = true);
      }), haxAxes.angle || spec.axes.push({
        orient: "angle"
      }), haxAxes.radius || spec.axes.push({
        orient: "radius"
      });
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/pie/base/pie-transformer.js
var BasePieChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField || spec.seriesField,
      valueField: spec.valueField || spec.angleField,
      center: spec.center,
      centerOffset: spec.centerOffset,
      cornerRadius: spec.cornerRadius,
      padAngle: spec.padAngle,
      minAngle: spec.minAngle
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/pie/base/base.js
var BasePieChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer;
  }
};
BasePieChart.transformerConstructor = BasePieChartSpecTransformer;

// node_modules/@visactor/vchart/esm/chart/pie/pie.js
var PieChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer, this.type = "pie", this.seriesType = SeriesTypeEnum.pie;
  }
};
PieChart.type = "pie", PieChart.seriesType = SeriesTypeEnum.pie, PieChart.view = "singleDefault", PieChart.transformerConstructor = BasePieChartSpecTransformer;
var registerPieChart = () => {
  registerPieSeries(), Factory2.registerChart(PieChart.type, PieChart);
};

// node_modules/@visactor/vchart/esm/chart/pie/3d/pie-3d.js
var Pie3dChartSpecTransformer = class extends BasePieChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.series.forEach((s3) => {
      "pie3d" === s3.type && (s3.angle3d = spec.angle3d);
    });
  }
};
var Pie3dChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Pie3dChartSpecTransformer, this.type = "pie3d", this.seriesType = SeriesTypeEnum.pie3d;
  }
};
Pie3dChart.type = "pie3d", Pie3dChart.seriesType = SeriesTypeEnum.pie3d, Pie3dChart.view = "singleDefault", Pie3dChart.transformerConstructor = Pie3dChartSpecTransformer;
var registerPie3dChart = () => {
  registerPie3dSeries(), Factory2.registerChart(Pie3dChart.type, Pie3dChart);
};

// node_modules/@visactor/vchart/esm/chart/rose/rose-transformer.js
var RoseChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b, _c;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      radius: null !== (_a = spec.radius) && void 0 !== _a ? _a : POLAR_DEFAULT_RADIUS,
      outerRadius: null !== (_b = spec.outerRadius) && void 0 !== _b ? _b : POLAR_DEFAULT_RADIUS,
      innerRadius: null !== (_c = spec.innerRadius) && void 0 !== _c ? _c : 0,
      seriesField: spec.seriesField,
      stack: spec.stack,
      percent: spec.percent
    });
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      ["domainLine", "grid", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), "angle" === axis2.orient && isNil_default(axis2.bandPosition) && (axis2.bandPosition = 0.5);
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "rect"
        }
      }
    }, crosshairCfg));
  }
};

// node_modules/@visactor/vchart/esm/chart/rose/rose.js
var RoseChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RoseChartSpecTransformer, this.type = "rose", this.seriesType = SeriesTypeEnum.rose, this._canStack = true;
  }
};
RoseChart.type = "rose", RoseChart.seriesType = SeriesTypeEnum.rose, RoseChart.view = "singleDefault", RoseChart.transformerConstructor = RoseChartSpecTransformer;
var registerRoseChart = () => {
  registerRoseSeries(), Factory2.registerChart(RoseChart.type, RoseChart);
};

// node_modules/@visactor/vchart/esm/chart/radar/radar-transformer.js
var RadarChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      seriesField: spec.seriesField,
      line: spec.line,
      point: spec.point,
      stack: spec.stack,
      percent: spec.percent,
      area: mergeSpec({
        visible: false
      }, spec.area),
      seriesMark: null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "area",
      activePoint: spec.activePoint,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap
    });
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      "radius" === axis2.orient && (["domainLine", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), axis2.grid || (axis2.grid = {
        visible: true,
        smooth: true
      }));
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "line"
        }
      }
    }, crosshairCfg));
  }
};

// node_modules/@visactor/vchart/esm/chart/radar/radar.js
var RadarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RadarChartSpecTransformer, this.type = "radar", this.seriesType = SeriesTypeEnum.radar, this._canStack = true;
  }
};
RadarChart.type = "radar", RadarChart.seriesType = SeriesTypeEnum.radar, RadarChart.view = "singleDefault", RadarChart.transformerConstructor = RadarChartSpecTransformer;
var registerRadarChart = () => {
  registerRadarSeries(), Factory2.registerChart(RadarChart.type, RadarChart);
};

// node_modules/@visactor/vchart/esm/chart/common/common-transformer.js
var CommonChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const defaultSpec = super._getDefaultSeriesSpec(spec);
    return delete defaultSpec.data, defaultSpec;
  }
  transformSpec(spec) {
    if (super.transformSpec(spec), spec.series && spec.series.length) {
      const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
      spec.series.forEach((s3) => {
        this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
          k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
        });
      });
    }
    spec.axes && spec.axes.length && spec.axes.forEach((axis2) => {
      get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/common/common.js
var CommonChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CommonChartSpecTransformer, this.type = "common", this._canStack = true;
  }
};
CommonChart.type = "common", CommonChart.view = "singleDefault", CommonChart.transformerConstructor = CommonChartSpecTransformer;
var registerCommonChart = () => {
  Factory2.registerChart(CommonChart.type, CommonChart);
};

// node_modules/@visactor/vchart/esm/constant/scroll-bar.js
var SCROLL_BAR_DEFAULT_SIZE = 12;

// node_modules/@visactor/vchart/esm/chart/sequence/sequence-transformer.js
var SequenceChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getSeriesDataLength(spec, seriesSpec) {
    var _a, _b;
    if (seriesSpec.data) {
      const _d = array(seriesSpec.data)[0];
      return _d instanceof DataView ? null === (_a = _d.latestData) || void 0 === _a ? void 0 : _a.length : null === (_b = _d.values) || void 0 === _b ? void 0 : _b.length;
    }
    const dataTemp = array(spec.data).find((_d, index) => seriesSpec.dataId ? _d instanceof DataView ? _d.name === seriesSpec.dataId : _d.id === seriesSpec.dataId : seriesSpec.dataIndex === index);
    return dataTemp ? dataTemp instanceof DataView ? dataTemp.latestData.length : dataTemp.values.length : 0;
  }
  addAttrToComponentSpec(componentSpec, attr, value) {
    return Array.isArray(componentSpec) ? componentSpec[0][attr] = value : componentSpec[attr] = value, componentSpec;
  }
  transformSpec(spec) {
    var _a, _b, _c, _e, _f, _g, _h, _j, _k, _l, _m;
    super.transformSpec(spec);
    let rowNum = 0;
    const elements = [], region = [], axes = [], scrollBar2 = [], rowHeight = [], seriesRegionNum = spec.series.filter((d2) => d2.type !== SeriesTypeEnum.link).length, defaultSeriesRowHeight = (500 - 20 * (seriesRegionNum - 1)) / seriesRegionNum, leftAppendPadding = (null === (_a = null == spec ? void 0 : spec.appendPadding) || void 0 === _a ? void 0 : _a.left) || 0, rightAppendPadding = (null === (_b = null == spec ? void 0 : spec.appendPadding) || void 0 === _b ? void 0 : _b.right) || 0;
    if (null == spec ? void 0 : spec.legends) {
      elements.push({
        modelId: `legendRow${rowNum}`,
        col: 1,
        row: rowNum
      }), this.addAttrToComponentSpec(spec.legends, "id", `legendRow${rowNum}`);
      const legendSpec = array(spec.legends);
      let legendHeight = null !== (_c = legendSpec[0].height) && void 0 !== _c ? _c : 40;
      if (legendSpec[0].padding) {
        const legendPadding = normalizeLayoutPaddingSpec(legendSpec[0].padding);
        legendHeight += Number(null !== (_e = null == legendPadding ? void 0 : legendPadding.bottom) && void 0 !== _e ? _e : 0), legendHeight += Number(null !== (_f = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _f ? _f : 0), legendSpec[0].offsetY = Number(null !== (_h = null === (_g = legendSpec[0]) || void 0 === _g ? void 0 : _g.offsetY) && void 0 !== _h ? _h : 0) + Number(null !== (_j = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _j ? _j : 0);
      }
      rowHeight.push({
        index: rowNum,
        size: legendHeight
      }), rowNum++;
    }
    (null == spec ? void 0 : spec.dataZoom) && (elements.push({
      modelId: `dataZoomRow${rowNum}`,
      col: 1,
      row: rowNum
    }), this.addAttrToComponentSpec(spec.dataZoom, "id", `dataZoomRow${rowNum}`), rowNum++, rowHeight.push({
      index: rowNum,
      size: 10
    }), rowNum++), region.push({
      id: `regionAxesRow${rowNum}`
    }), elements.push({
      modelId: `axesRow${rowNum}`,
      col: 1,
      row: rowNum
    }), spec.axes[0].id = `axesRow${rowNum}`, spec.axes[0].regionIndex = Array.from(Array(spec.series.length), (_2, index) => index + 1), rowNum++, null === (_k = null == spec ? void 0 : spec.series) || void 0 === _k || _k.forEach((seriesSpec) => {
      var _a2, _b2;
      if ([SeriesTypeEnum.bar, SeriesTypeEnum.line, SeriesTypeEnum.area, SeriesTypeEnum.dot].includes(seriesSpec.type)) {
        if (elements.push({
          modelId: `${seriesSpec.type}Row${rowNum}`,
          col: 1,
          row: rowNum
        }), elements.push({
          modelId: `axesLeftRow${rowNum}`,
          col: 0,
          row: rowNum
        }), region.push({
          id: `${seriesSpec.type}Row${rowNum}`,
          clip: false
        }), rowHeight.push({
          index: rowNum,
          size: (null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight
        }), axes.push({
          orient: "left",
          id: `axesLeftRow${rowNum}`,
          type: seriesSpec.type === SeriesTypeEnum.dot ? "band" : "linear",
          visible: seriesSpec.type !== SeriesTypeEnum.dot,
          title: {
            visible: true,
            autoRotate: false,
            style: {
              text: null == seriesSpec ? void 0 : seriesSpec.barTitle,
              dx: -20,
              textBaseline: "middle",
              textAlign: "end"
            }
          },
          grid: {
            visible: "boolean" != typeof (null === (_a2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a2 ? void 0 : _a2.visible) || (null === (_b2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _b2 ? void 0 : _b2.visible),
            style: (datum, index) => {
              var _a3, _b3, _c2, _e2, _f2;
              let lineWidth = 0;
              if (0 === index) {
                const style = null === (_a3 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a3 ? void 0 : _a3.style;
                lineWidth = null !== (_c2 = null !== (_b3 = null == style ? void 0 : style.lineWidth) && void 0 !== _b3 ? _b3 : null == style ? void 0 : style.strokeWidth) && void 0 !== _c2 ? _c2 : 1;
              }
              return {
                lineWidth,
                stroke: (null === (_f2 = null === (_e2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _e2 ? void 0 : _e2.style) || void 0 === _f2 ? void 0 : _f2.stroke) || "#dfdfdf",
                lineDash: [0, 0]
              };
            }
          },
          domainLine: {
            visible: false
          },
          tick: {
            visible: false
          },
          label: {
            visible: false
          },
          regionIndex: region.length - 1
        }), seriesSpec.type === SeriesTypeEnum.dot) {
          elements.push({
            modelId: `scrollBarRightRow${rowNum}`,
            col: 2,
            row: rowNum
          });
          const dataLength = this._getSeriesDataLength(spec, seriesSpec);
          let ratio = 0;
          dataLength && (ratio = ((null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight) / (30 * dataLength)), scrollBar2.push(Object.assign({
            orient: "right",
            visible: seriesSpec.type === SeriesTypeEnum.dot && ratio < 1,
            id: `scrollBarRightRow${rowNum}`,
            start: 0,
            end: Math.min(ratio, 1),
            filterMode: "axis",
            regionIndex: region.length - 1,
            axisId: `axesLeftRow${rowNum}`
          }, array(null == spec ? void 0 : spec.scrollBar)[0]));
        }
        seriesSpec.regionIndex = region.length - 1, rowNum++, rowHeight.push({
          index: rowNum,
          size: (null == seriesSpec ? void 0 : seriesSpec.padding) || 20
        }), rowNum++, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.type === SeriesTypeEnum.dot && (seriesSpec.title.style.dx = -leftAppendPadding, seriesSpec.subTitle.style.dx = -leftAppendPadding);
      }
    }), null === (_l = null == spec ? void 0 : spec.series) || void 0 === _l || _l.forEach((seriesSpec) => {
      if (seriesSpec.type === SeriesTypeEnum.link) {
        const dotRowNum = seriesSpec.dotSeriesIndex + 1;
        elements.push({
          modelId: `${seriesSpec.type}Row${dotRowNum}`,
          col: 1,
          row: dotRowNum - 1
        }), seriesSpec.regionIndex = spec.series[seriesSpec.dotSeriesIndex].regionIndex, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.height = spec.series[seriesSpec.dotSeriesIndex].height, seriesSpec.clipHeight = spec.series[seriesSpec.dotSeriesIndex].clipHeight;
      }
    }), (null == spec ? void 0 : spec.legends) && this.addAttrToComponentSpec(spec.legends, "regionIndex", [region.length - 1]);
    const layout2 = {
      type: "grid",
      col: 4,
      row: rowNum,
      colWidth: [{
        index: 0,
        size: leftAppendPadding
      }, {
        index: 2,
        size: SCROLL_BAR_DEFAULT_SIZE
      }, {
        index: 3,
        size: rightAppendPadding
      }],
      rowHeight,
      elements
    };
    spec.layout = layout2, spec.region = region, null === (_m = spec.axes) || void 0 === _m || _m.push(...axes), spec.scrollBar = scrollBar2;
  }
};

// node_modules/@visactor/vchart/esm/chart/sequence/sequence.js
var __rest13 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var SequenceChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SequenceChartSpecTransformer, this.type = "sequence";
  }
  _createSeries(constructor, specInfo) {
    if (!constructor) return;
    const { spec } = specInfo, others = __rest13(specInfo, ["spec"]);
    let region;
    if (spec.type === SeriesTypeEnum.link && (spec.dotSeriesSpec = this._spec.series[spec.dotSeriesIndex]), spec.regionId && (region = this.getRegionsInUserId(spec.regionId)), region || (region = this.getRegionsInIndex(spec.regionIndex ? [spec.regionIndex] : void 0)[0]), !region) return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      region,
      specKey: "series",
      globalScale: this._globalScale
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
};
SequenceChart.type = "sequence", SequenceChart.view = "singleDefault", SequenceChart.transformerConstructor = SequenceChartSpecTransformer;
var registerSequenceChart = () => {
  registerDotSeries(), registerLinkSeries(), Factory2.registerChart(SequenceChart.type, SequenceChart);
};

// node_modules/@visactor/vchart/esm/chart/histogram/base/histogram-base-transformer.js
var BaseHistogramChartSpecTransformer = class extends CartesianChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes.forEach((axis2) => axis2.type = "linear");
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      x2Field: null == spec ? void 0 : spec.x2Field,
      y2Field: null == spec ? void 0 : spec.y2Field,
      barMinHeight: null == spec ? void 0 : spec.barMinHeight
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/histogram/base/base.js
var BaseHistogramChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseHistogramChartSpecTransformer, this._canStack = true;
  }
};
BaseHistogramChart.transformerConstructor = BaseHistogramChartSpecTransformer;

// node_modules/@visactor/vchart/esm/chart/histogram/histogram-transformer.js
var HistogramChartSpecTransformer = class extends BaseHistogramChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/histogram/histogram.js
var HistogramChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram", this.seriesType = SeriesTypeEnum.bar;
  }
};
HistogramChart.type = "histogram", HistogramChart.seriesType = SeriesTypeEnum.bar, HistogramChart.view = "singleDefault", HistogramChart.transformerConstructor = HistogramChartSpecTransformer;
var registerHistogramChart = () => {
  registerBarSeries(), Factory2.registerChart(HistogramChart.type, HistogramChart);
};

// node_modules/@visactor/vchart/esm/chart/histogram/3d/histogram-3d.js
var Histogram3dChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Histogram3dChart.type = "histogram3d", Histogram3dChart.seriesType = SeriesTypeEnum.bar3d, Histogram3dChart.view = "singleDefault", Histogram3dChart.transformerConstructor = HistogramChartSpecTransformer;
var registerHistogram3dChart = () => {
  registerBar3dSeries(), Factory2.registerChart(Histogram3dChart.type, Histogram3dChart);
};

// node_modules/@visactor/vchart/esm/chart/progress/circular/circular-progress-transformer.js
var CircularProgressChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      cornerRadius: null !== (_a = spec.cornerRadius) && void 0 !== _a ? _a : 0,
      roundCap: null !== (_b = spec.roundCap) && void 0 !== _b && _b,
      progress: spec.progress,
      track: spec.track,
      tickMask: spec.tickMask
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: false
    }, {
      orient: "radius",
      visible: false
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/progress/circular/circular.js
var CircularProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CircularProgressChartSpecTransformer, this.type = "circularProgress", this.seriesType = SeriesTypeEnum.circularProgress, this._canStack = true;
  }
};
CircularProgressChart.type = "circularProgress", CircularProgressChart.seriesType = SeriesTypeEnum.circularProgress, CircularProgressChart.view = "singleDefault", CircularProgressChart.transformerConstructor = CircularProgressChartSpecTransformer;
var registerCircularProgressChart = () => {
  registerCircularProgressSeries(), Factory2.registerChart(CircularProgressChart.type, CircularProgressChart);
};

// node_modules/@visactor/vchart/esm/chart/gauge/gauge-transformer.js
var GaugeChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      radiusField: spec.radiusField,
      pin: spec.pin,
      pinBackground: spec.pinBackground,
      pointer: spec.pointer
    });
  }
  _getDefaultCircularProgressSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      type: SeriesTypeEnum.circularProgress
    });
  }
  transformSpec(spec) {
    var _a, _b, _c, _d, _e;
    super.transformSpec(spec);
    let backgroundSeries = null === (_a = spec.series) || void 0 === _a ? void 0 : _a.find((series2) => series2.type === SeriesTypeEnum.gauge || series2.type === SeriesTypeEnum.circularProgress);
    isNil_default(backgroundSeries) && (backgroundSeries = null !== (_b = spec.gauge) && void 0 !== _b ? _b : this._getDefaultCircularProgressSeriesSpec(spec), "circularProgress" === backgroundSeries.type && (isNil_default(backgroundSeries.radiusField) && isNil_default(backgroundSeries.categoryField) && (backgroundSeries.radiusField = null !== (_d = null !== (_c = spec.radiusField) && void 0 !== _c ? _c : spec.categoryField) && void 0 !== _d ? _d : spec.seriesField), isNil_default(backgroundSeries.valueField) && isNil_default(backgroundSeries.angleField) && (backgroundSeries.valueField = null !== (_e = spec.valueField) && void 0 !== _e ? _e : spec.angleField)), 1 === spec.series.length ? spec.series.push(backgroundSeries) : spec.series.forEach((s3) => {
      s3.type === backgroundSeries.type && Object.keys(backgroundSeries).forEach((k3) => {
        k3 in s3 || (s3[k3] = backgroundSeries[k3]);
      });
    })), backgroundSeries.type === SeriesTypeEnum.circularProgress ? this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: true,
      domainLine: {
        visible: false
      },
      grid: {
        visible: false
      }
    }, {
      orient: "radius",
      visible: false
    }, {
      zIndex: LayoutZIndex.Region + 50
    }) : this._transformGaugeAxisSpec(spec);
  }
  _transformGaugeAxisSpec(spec) {
    var _a;
    spec.axes || (spec.axes = []);
    const axesPtr = {
      radius: null,
      angle: null
    };
    (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      const { orient } = axis2;
      "radius" === orient && (axesPtr.radius = axis2), "angle" === orient && (axesPtr.angle = axis2);
    }), axesPtr.angle || (axesPtr.angle = {
      orient: "angle",
      visible: true
    }, spec.axes.push(axesPtr.angle)), axesPtr.radius || (axesPtr.radius = {
      orient: "radius",
      visible: false
    }, spec.axes.push(axesPtr.radius)), isNil_default(axesPtr.angle.type) && (axesPtr.angle.type = "linear"), isNil_default(axesPtr.radius.type) && (axesPtr.radius.type = "linear"), isNil_default(axesPtr.angle.zIndex) && (axesPtr.angle.zIndex = LayoutZIndex.Region + 50);
  }
};

// node_modules/@visactor/vchart/esm/chart/gauge/gauge.js
var GaugeChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = GaugeChartSpecTransformer, this.type = "gauge", this.seriesType = SeriesTypeEnum.gaugePointer;
  }
};
GaugeChart.type = "gauge", GaugeChart.seriesType = SeriesTypeEnum.gaugePointer, GaugeChart.view = "singleDefault", GaugeChart.transformerConstructor = GaugeChartSpecTransformer;
var registerGaugeChart = () => {
  registerGaugePointerSeries(), registerGaugeSeries(), Factory2.registerChart(GaugeChart.type, GaugeChart);
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/base/word-cloud-base-transformer.js
var BaseWordCloudChartSpecTransformer = class extends BaseChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/base/base.js
var BaseWordCloudChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseWordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
BaseWordCloudChart.transformerConstructor = BaseWordCloudChartSpecTransformer;

// node_modules/@visactor/vchart/esm/chart/word-cloud/word-cloud-transformer.js
var WordCloudChartSpecTransformer = class extends BaseWordCloudChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      fontFamilyField: spec.fontFamilyField,
      fontWeightField: spec.fontWeightField,
      fontStyleField: spec.fontStyleField,
      colorHexField: spec.colorHexField,
      colorMode: spec.colorMode,
      colorList: spec.colorList,
      rotateAngles: spec.rotateAngles,
      fontWeightRange: spec.fontWeightRange,
      fontSizeRange: spec.fontSizeRange,
      maskShape: spec.maskShape,
      keepAspect: spec.keepAspect,
      random: spec.random,
      wordCloudConfig: spec.wordCloudConfig,
      wordCloudShapeConfig: spec.wordCloudShapeConfig,
      word: spec.word,
      fillingWord: spec.fillingWord
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/word-cloud.js
var WordCloudChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
WordCloudChart.type = "wordCloud", WordCloudChart.seriesType = SeriesTypeEnum.wordCloud, WordCloudChart.view = "singleDefault", WordCloudChart.transformerConstructor = WordCloudChartSpecTransformer;
var registerWordCloudChart = () => {
  registerWordCloudSeries(), Factory2.registerChart(WordCloudChart.type, WordCloudChart);
};
var registerWordCloudShapeChart = () => {
  registerWordCloudShapeSeries(), registerWordCloudSeries(), Factory2.registerChart(WordCloudChart.type, WordCloudChart);
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/3d/word-cloud-3d-transformer.js
var WordCloud3dChartSpecTransformer = class extends BaseWordCloudChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      fontFamilyField: spec.fontFamilyField,
      fontWeightField: spec.fontWeightField,
      fontStyleField: spec.fontStyleField,
      colorHexField: spec.colorHexField,
      colorMode: spec.colorMode,
      colorList: spec.colorList,
      rotateAngles: spec.rotateAngles,
      fontWeightRange: spec.fontWeightRange,
      fontSizeRange: spec.fontSizeRange,
      depth_3d: spec.depth_3d,
      maskShape: spec.maskShape,
      keepAspect: spec.keepAspect,
      random: spec.random,
      wordCloudConfig: spec.wordCloudConfig,
      wordCloudShapeConfig: spec.wordCloudShapeConfig,
      word: spec.word,
      fillingWord: spec.fillingWord
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/word-cloud/3d/word-cloud-3d.js
var WordCloud3dChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WordCloud3dChartSpecTransformer, this.type = "wordCloud3d", this.seriesType = SeriesTypeEnum.wordCloud3d;
  }
};
WordCloud3dChart.type = "wordCloud3d", WordCloud3dChart.seriesType = SeriesTypeEnum.wordCloud3d, WordCloud3dChart.view = "singleDefault", WordCloud3dChart.transformerConstructor = WordCloud3dChartSpecTransformer;
var registerWordCloud3dChart = () => {
  registerWordCloud3dSeries(), Factory2.registerChart(WordCloud3dChart.type, WordCloud3dChart);
};
var registerWordCloudShape3dChart = () => {
  registerWordCloudShape3dSeries(), registerWordCloud3dSeries(), Factory2.registerChart(WordCloud3dChart.type, WordCloud3dChart);
};

// node_modules/@visactor/vchart/esm/chart/funnel/funnel-transformer.js
var FunnelChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      funnelAlign: spec.funnelAlign,
      funnelOrient: spec.funnelOrient,
      shape: spec.shape,
      funnel: spec.funnel,
      transform: spec.transform,
      outerLabel: spec.outerLabel,
      transformLabel: spec.transformLabel,
      isTransform: spec.isTransform,
      maxSize: spec.maxSize,
      minSize: spec.minSize,
      gap: spec.gap,
      isCone: spec.isCone,
      range: spec.range
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/funnel/funnel.js
var FunnelChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel", this.seriesType = SeriesTypeEnum.funnel;
  }
};
FunnelChart.type = "funnel", FunnelChart.seriesType = SeriesTypeEnum.funnel, FunnelChart.view = "singleDefault", FunnelChart.transformerConstructor = FunnelChartSpecTransformer;
var registerFunnelChart = () => {
  registerFunnelSeries(), Factory2.registerChart(FunnelChart.type, FunnelChart);
};

// node_modules/@visactor/vchart/esm/chart/funnel/3d/funnel-3d.js
var Funnel3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel3d", this.seriesType = SeriesTypeEnum.funnel3d;
  }
};
Funnel3dChart.type = "funnel3d", Funnel3dChart.seriesType = SeriesTypeEnum.funnel3d, Funnel3dChart.view = "singleDefault", Funnel3dChart.transformerConstructor = FunnelChartSpecTransformer;
var registerFunnel3dChart = () => {
  registerFunnel3dSeries(), Factory2.registerChart(Funnel3dChart.type, Funnel3dChart);
};

// node_modules/@visactor/vchart/esm/chart/progress/linear/linear-progress-transformer.js
var LinearProgressChartSpecTransformer = class extends CartesianChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      direction: null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal",
      cornerRadius: null !== (_b = spec.cornerRadius) && void 0 !== _b ? _b : 0,
      bandWidth: spec.bandWidth,
      progress: spec.progress,
      track: spec.track
    });
  }
  transformSpec(spec) {
    var _a, _b;
    if (super.transformSpec(spec), spec.axes || (spec.axes = []), "vertical" === spec.direction) {
      let leftAxis = null, bottomAxis = null;
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "band"), isNil_default(leftAxis.type) && (leftAxis.type = "linear");
      const domain = getLinearAxisSpecDomain(leftAxis, {
        min: 0,
        max: 1
      });
      isNil_default(leftAxis.min) && (leftAxis.min = domain.min), isNil_default(leftAxis.max) && (leftAxis.max = domain.max);
    } else {
      let leftAxis = null, bottomAxis = null;
      (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        type: "band",
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "linear"), isNil_default(leftAxis.type) && (leftAxis.type = "band");
      const domain = getLinearAxisSpecDomain(bottomAxis, {
        min: 0,
        max: 1
      });
      isNil_default(bottomAxis.min) && (bottomAxis.min = domain.min), isNil_default(bottomAxis.max) && (bottomAxis.max = domain.max);
    }
  }
};

// node_modules/@visactor/vchart/esm/chart/progress/linear/linear.js
var LinearProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LinearProgressChartSpecTransformer, this.type = "linearProgress", this.seriesType = SeriesTypeEnum.linearProgress, this._canStack = true;
  }
};
LinearProgressChart.type = "linearProgress", LinearProgressChart.seriesType = SeriesTypeEnum.linearProgress, LinearProgressChart.view = "singleDefault", LinearProgressChart.transformerConstructor = LinearProgressChartSpecTransformer;
var registerLinearProgressChart = () => {
  registerLinearProgressSeries(), Factory2.registerChart(LinearProgressChart.type, LinearProgressChart);
};

// node_modules/@visactor/vchart/esm/chart/range-column/range-column-transformer.js
var RangeColumnChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barGapInGroup: spec.barGapInGroup,
      barBackground: spec.barBackground,
      barMinHeight: spec.barMinHeight
    });
    return series2.bar = spec.bar, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/range-column/range-column.js
var RangeColumnChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumnChartSpecTransformer, this.type = "rangeColumn", this.seriesType = SeriesTypeEnum.rangeColumn;
  }
};
RangeColumnChart.type = "rangeColumn", RangeColumnChart.seriesType = SeriesTypeEnum.rangeColumn, RangeColumnChart.view = "singleDefault", RangeColumnChart.transformerConstructor = RangeColumnChartSpecTransformer;
var registerRangeColumnChart = () => {
  registerRangeColumnSeries(), Factory2.registerChart(RangeColumnChart.type, RangeColumnChart);
};

// node_modules/@visactor/vchart/esm/chart/range-column/3d/range-column-3d-transformer.js
var RangeColumn3dChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barGapInGroup: spec.barGapInGroup
    });
    return series2.bar3d = spec.bar3d, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
};

// node_modules/@visactor/vchart/esm/chart/range-column/3d/range-column-3d.js
var RangeColumn3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumn3dChartSpecTransformer, this.type = "rangeColumn3d", this.seriesType = SeriesTypeEnum.rangeColumn3d;
  }
};
RangeColumn3dChart.type = "rangeColumn3d", RangeColumn3dChart.seriesType = SeriesTypeEnum.rangeColumn3d, RangeColumn3dChart.view = "singleDefault", RangeColumn3dChart.transformerConstructor = RangeColumn3dChartSpecTransformer;
var registerRangeColumn3dChart = () => {
  registerRangeColumn3dSeries(), Factory2.registerChart(RangeColumn3dChart.type, RangeColumn3dChart);
};

// node_modules/@visactor/vchart/esm/chart/sunburst/sunburst-transformer.js
var SunburstChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const startAngle = isValid_default(spec.startAngle) ? spec.startAngle : POLAR_START_ANGLE, endAngle = isValid_default(spec.endAngle) ? spec.endAngle : startAngle + radianToDegree(2 * Math.PI), series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      centerX: spec.centerX,
      centerY: spec.centerY,
      offsetX: spec.offsetX,
      offsetY: spec.offsetY,
      startAngle,
      endAngle,
      innerRadius: spec.innerRadius,
      outerRadius: spec.outerRadius,
      gap: spec.gap,
      labelLayout: spec.labelLayout,
      label: spec.label,
      labelAutoVisible: spec.labelAutoVisible,
      drill: spec.drill,
      drillField: spec.drillField
    }), seriesType = SeriesTypeEnum.sunburst;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/sunburst/sunburst.js
var SunburstChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SunburstChartSpecTransformer, this.type = "sunburst", this.seriesType = SeriesTypeEnum.sunburst;
  }
};
SunburstChart.type = "sunburst", SunburstChart.seriesType = SeriesTypeEnum.sunburst, SunburstChart.view = "singleDefault", SunburstChart.transformerConstructor = SunburstChartSpecTransformer;
var registerSunburstChart = () => {
  registerSunBurstSeries(), Factory2.registerChart(SunburstChart.type, SunburstChart);
};

// node_modules/@visactor/vchart/esm/chart/circle-packing/circle-packing-transformer.js
var CirclePackingChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      layoutPadding: spec.layoutPadding,
      label: spec.label,
      circlePacking: spec.circlePacking,
      drill: spec.drill,
      drillField: spec.drillField
    }), seriesType = SeriesTypeEnum.circlePacking;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/circle-packing/circle-packing.js
var CirclePackingChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CirclePackingChartSpecTransformer, this.type = "circlePacking", this.seriesType = SeriesTypeEnum.circlePacking;
  }
};
CirclePackingChart.type = "circlePacking", CirclePackingChart.seriesType = SeriesTypeEnum.circlePacking, CirclePackingChart.view = "singleDefault", CirclePackingChart.transformerConstructor = CirclePackingChartSpecTransformer;
var registerCirclePackingChart = () => {
  registerCirclePackingSeries(), Factory2.registerChart(CirclePackingChart.type, CirclePackingChart);
};

// node_modules/@visactor/vchart/esm/chart/treemap/treemap-transformer.js
var TreemapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      aspectRatio: spec.aspectRatio,
      splitType: spec.splitType,
      maxDepth: spec.maxDepth,
      gapWidth: spec.gapWidth,
      nodePadding: spec.nodePadding,
      minVisibleArea: spec.minVisibleArea,
      minChildrenVisibleArea: spec.minChildrenVisibleArea,
      minChildrenVisibleSize: spec.minChildrenVisibleSize,
      roam: spec.roam,
      drill: spec.drill,
      drillField: spec.drillField,
      leaf: spec.leaf,
      nonLeaf: spec.nonLeaf,
      nonLeafLabel: spec.nonLeafLabel
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/treemap/treemap.js
var TreemapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = TreemapChartSpecTransformer, this.type = "treemap", this.seriesType = SeriesTypeEnum.treemap;
  }
};
TreemapChart.type = "treemap", TreemapChart.seriesType = SeriesTypeEnum.treemap, TreemapChart.view = "singleDefault", TreemapChart.transformerConstructor = TreemapChartSpecTransformer;
var registerTreemapChart = () => {
  registerTreemapSeries(), Factory2.registerChart(TreemapChart.type, TreemapChart);
};

// node_modules/@visactor/vchart/esm/chart/waterfall/waterfall-transformer.js
var WaterfallChartSpecTransformer = class extends BarChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.legends && array(spec.legends).forEach((l2) => {
      l2.select = false, l2.hover = false, l2.filter = false;
    }), setDefaultCrosshairForCartesianChart(spec);
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      bar: spec.bar,
      stackLabel: spec.stackLabel,
      leaderLine: spec.leaderLine,
      total: spec.total
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/waterfall/waterfall.js
var WaterfallChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WaterfallChartSpecTransformer, this.type = "waterfall", this.seriesType = SeriesTypeEnum.waterfall;
  }
};
WaterfallChart.type = "waterfall", WaterfallChart.seriesType = SeriesTypeEnum.waterfall, WaterfallChart.view = "singleDefault", WaterfallChart.transformerConstructor = WaterfallChartSpecTransformer;
var registerWaterfallChart = () => {
  registerWaterfallSeries(), Factory2.registerChart(WaterfallChart.type, WaterfallChart);
};

// node_modules/@visactor/vchart/esm/chart/box-plot/box-plot-transformer.js
var BoxPlotChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    const dataFields = [spec.maxField, spec.medianField, spec.q1Field, spec.q3Field, spec.minField, spec.outliersField], seriesSpec = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      boxPlot: spec.boxPlot,
      direction: null !== (_a = spec.direction) && void 0 !== _a ? _a : "vertical",
      minField: spec.minField,
      maxField: spec.maxField,
      q1Field: spec.q1Field,
      medianField: spec.medianField,
      q3Field: spec.q3Field,
      outliersField: spec.outliersField,
      outliersStyle: spec.outliersStyle
    });
    return seriesSpec["vertical" === seriesSpec.direction ? "yField" : "xField"] = dataFields, seriesSpec;
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes || (spec.axes = [{
      orient: "bottom"
    }, {
      orient: "left"
    }]), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/box-plot/box-plot.js
var BoxPlotChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BoxPlotChartSpecTransformer, this.type = "boxPlot", this.seriesType = SeriesTypeEnum.boxPlot;
  }
};
BoxPlotChart.type = "boxPlot", BoxPlotChart.seriesType = SeriesTypeEnum.boxPlot, BoxPlotChart.view = "singleDefault", BoxPlotChart.transformerConstructor = BoxPlotChartSpecTransformer;
var registerBoxplotChart = () => {
  registerBoxplotSeries(), Factory2.registerChart(BoxPlotChart.type, BoxPlotChart);
};

// node_modules/@visactor/vchart/esm/chart/sankey/sankey-transformer.js
var SankeyChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      sourceField: spec.sourceField,
      targetField: spec.targetField,
      direction: spec.direction,
      nodeAlign: spec.nodeAlign,
      nodeGap: spec.nodeGap,
      nodeWidth: spec.nodeWidth,
      linkWidth: spec.linkWidth,
      minStepWidth: spec.minStepWidth,
      minNodeHeight: spec.minNodeHeight,
      minLinkHeight: spec.minLinkHeight,
      iterations: spec.iterations,
      nodeKey: spec.nodeKey,
      linkSortBy: spec.linkSortBy,
      nodeSortBy: spec.nodeSortBy,
      setNodeLayer: spec.setNodeLayer,
      node: spec.node,
      link: spec.link,
      label: spec.label,
      emphasis: spec.emphasis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/sankey/sankey.js
var SankeyChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SankeyChartSpecTransformer, this.type = "sankey", this.seriesType = SeriesTypeEnum.sankey;
  }
};
SankeyChart.type = "sankey", SankeyChart.seriesType = SeriesTypeEnum.sankey, SankeyChart.view = "singleDefault", SankeyChart.transformerConstructor = SankeyChartSpecTransformer;
var registerSankeyChart = () => {
  registerSankeySeries(), Factory2.registerChart(SankeyChart.type, SankeyChart);
};

// node_modules/@visactor/vchart/esm/chart/range-area/range-area-transformer.js
var RangeAreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign({}, super._getDefaultSeriesSpec(spec));
    return series2.area = spec.area, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2.stack = false, series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// node_modules/@visactor/vchart/esm/chart/range-area/range-area.js
var RangeAreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeAreaChartSpecTransformer, this.type = "rangeArea", this.seriesType = SeriesTypeEnum.rangeArea;
  }
};
RangeAreaChart.type = "rangeArea", RangeAreaChart.seriesType = SeriesTypeEnum.rangeArea, RangeAreaChart.view = "singleDefault", RangeAreaChart.transformerConstructor = RangeAreaChartSpecTransformer;
var registerRangeAreaChart = () => {
  registerRangeAreaSeries(), Factory2.registerChart(RangeAreaChart.type, RangeAreaChart);
};

// node_modules/@visactor/vchart/esm/chart/heatmap/heatmap-transformer.js
var HeatmapChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      valueField: spec.valueField,
      cell: spec.cell
    });
  }
};

// node_modules/@visactor/vchart/esm/chart/heatmap/heatmap.js
var HeatmapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HeatmapChartSpecTransformer, this.type = "heatmap", this.seriesType = SeriesTypeEnum.heatmap;
  }
};
HeatmapChart.type = "heatmap", HeatmapChart.seriesType = SeriesTypeEnum.heatmap, HeatmapChart.view = "singleDefault", HeatmapChart.transformerConstructor = HeatmapChartSpecTransformer;
var registerHeatmapChart = () => {
  registerHeatmapSeries(), Factory2.registerChart(HeatmapChart.type, HeatmapChart);
};

// node_modules/@visactor/vchart/esm/chart/correlation/correlation-transformer.js
var CorrelationChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      sizeField: spec.sizeField,
      sizeRange: spec.sizeRange,
      centerX: spec.centerX,
      centerY: spec.centerY,
      innerRadius: spec.innerRadius,
      outerRadius: spec.outerRadius,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      ripplePoint: spec.ripplePoint,
      centerPoint: spec.centerPoint,
      centerLabel: spec.centerLabel,
      nodePoint: spec.nodePoint,
      label: spec.label
    }), seriesType = SeriesTypeEnum.correlation;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s3) => {
      this._isValidSeries(s3.type) && Object.keys(defaultSeriesSpec).forEach((k3) => {
        k3 in s3 || (s3[k3] = defaultSeriesSpec[k3]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// node_modules/@visactor/vchart/esm/chart/correlation/correlation.js
var CorrelationChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CorrelationChartSpecTransformer, this.type = "correlation", this.seriesType = SeriesTypeEnum.correlation;
  }
};
CorrelationChart.type = "correlation", CorrelationChart.seriesType = SeriesTypeEnum.correlation, CorrelationChart.view = "singleDefault", CorrelationChart.transformerConstructor = CorrelationChartSpecTransformer;
var registerCorrelationChart = () => {
  registerCorrelationSeries(), Factory2.registerChart(CorrelationChart.type, CorrelationChart);
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync-plugin/zero-align-transform.js
function isValidAlignDomain(domain) {
  return 2 === domain.length && isValidNumber_default(domain[0]) && isValidNumber_default(domain[1]) && domain[1] >= domain[0];
}
function getScaleInfo(axis2, domain) {
  const total = domain[1] - domain[0], includeZero = domain[1] * domain[0] < 0;
  let negative = domain[0] <= 0 ? 0 - domain[0] : 0, positive = domain[1] > 0 ? domain[1] - 0 : 0;
  0 === total ? domain[0] < 0 ? (negative = 1, positive = 0) : domain[0] > 0 && (negative = 0, positive = 1) : (negative /= total, positive /= total);
  const domainSpec = axis2.getDomainSpec();
  return {
    total,
    negative,
    positive,
    includeZero,
    domain,
    extendable_min: !isValidNumber_default(domainSpec.min),
    extendable_max: !isValidNumber_default(domainSpec.max)
  };
}
function inDifferentCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, domain: domain2 } = info2;
  if (positive2 > 0) {
    if (!s2Extendable_min) return false;
    let comp = negative1 / positive1;
    s1Extendable_max && (comp = negative1 / Math.max(positive1, positive2), domain1[1] = -domain1[0] / comp), domain2[0] = -domain2[1] * comp;
  } else if (negative2 > 0) {
    if (!s2Extendable_max) return false;
    let comp = positive1 / negative1;
    s1Extendable_min && (comp = positive1 / Math.max(negative1, negative1), domain1[0] = -domain1[1] / comp), domain2[1] = -domain2[0] * comp;
  }
  return true;
}
function inOnlyZeroDomain(info1, info2) {
  const { extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, domain: domain2 } = info2;
  return (0 !== positive2 || 0 !== negative2) && (!(positive2 > 0 && !s1Extendable_max) && (!(negative2 > 0 && !s1Extendable_min) && (domain1[0] = domain2[0], domain1[1] = domain2[1], true)));
}
function inAllCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, domain: domain2 } = info2;
  if (s1Extendable_max && s2Extendable_min) {
    const comp = Math.max(negative1, negative2) / Math.max(positive1, positive2);
    domain1[1] = -domain1[0] / comp, domain2[0] = -domain2[1] * comp;
  } else if (s2Extendable_min) {
    const comp = negative1 / positive1;
    domain2[0] = -domain2[1] * comp;
  } else {
    if (!s1Extendable_max) return false;
    {
      const comp = negative2 / positive2;
      domain1[1] = -domain1[0] / comp;
    }
  }
  return true;
}
function inNoCrossDifferentSide(info1, info2) {
  const { extendable_min: s1Extendable_min, domain: domain1 } = info1, { extendable_max: s2Extendable_max, domain: domain2 } = info2;
  return !(!s1Extendable_min || !s2Extendable_max) && (domain1[0] = -domain1[1], domain2[1] = -domain2[0], true);
}
var zeroAlign = (targetAxis, currentAxis) => {
  const s1 = targetAxis.getScale(), s22 = currentAxis.getScale();
  if (!s1 || !s22) return;
  if (!isContinuous(s1.type) || !isContinuous(s22.type)) return;
  const domain1 = s1.domain().slice(), domain2 = s22.domain().slice();
  if (!isValidAlignDomain(domain1) || !isValidAlignDomain(domain2)) return;
  const info1 = getScaleInfo(targetAxis, domain1), info2 = getScaleInfo(currentAxis, domain2), { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, includeZero: includeZero1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, includeZero: includeZero2 } = info2;
  if (0 === positive1 && 0 === negative1) {
    if (!inOnlyZeroDomain(info1, info2)) return;
  } else if (0 === positive2 && 0 === negative2) {
    if (!inOnlyZeroDomain(info2, info1)) return;
  } else if (includeZero1 || includeZero2) if (includeZero1 && !includeZero2) {
    if (!inDifferentCrossZero(info1, info2)) return;
  } else if (includeZero2 && !includeZero1) {
    if (!inDifferentCrossZero(info2, info1)) return;
  } else {
    if (negative1 === negative2) return;
    if (negative1 > negative2) {
      if (!inAllCrossZero(info1, info2)) return;
    } else if (!inAllCrossZero(info2, info1)) return;
  }
  else {
    if (0 === negative1 && 0 === positive2) {
      if (!inNoCrossDifferentSide(info1, info2)) return;
    } else if (0 === negative2 && 0 === positive1 && !inNoCrossDifferentSide(info2, info1)) return;
    if (0 === negative1 && 0 === negative2) if (0 === domain1[0] && domain2[0] > 0) {
      if (!s2Extendable_min) return;
      domain2[0] = 0;
    } else {
      if (!(0 === domain2[0] && domain1[0] > 0)) return;
      if (!s1Extendable_min) return;
      domain1[0] = 0;
    }
    if (0 === positive1 && 0 === positive2) if (0 === domain1[1] && domain2[1] > 0) {
      if (!s2Extendable_max) return;
      domain2[1] = 0;
    } else {
      if (!(0 === domain2[1] && domain1[1] > 0)) return;
      if (!s1Extendable_max) return;
      domain1[1] = 0;
    }
  }
  s1.domain(domain1), s22.domain(domain2);
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync-plugin/tick-align-transform.js
var tickAlign = (data, op) => {
  var _a, _b, _c, _d, _e;
  if (!data) return data;
  const targetAxis = null === (_a = null == op ? void 0 : op.targetAxis) || void 0 === _a ? void 0 : _a.call(op);
  if (!targetAxis) return data;
  const currentAxis = null === (_b = null == op ? void 0 : op.currentAxis) || void 0 === _b ? void 0 : _b.call(op);
  if (!currentAxis) return data;
  const currentData = null === (_c = currentAxis.getTickData()) || void 0 === _c ? void 0 : _c.getDataView();
  if (!currentData) return data;
  if (!currentData.transformsArr.find((t2) => "ticks" === t2.type)) return data;
  const currentScale = currentAxis.getScale();
  if (!currentScale) return data;
  const targetData = null === (_e = null === (_d = targetAxis.getTickData()) || void 0 === _d ? void 0 : _d.getDataView()) || void 0 === _e ? void 0 : _e.latestData;
  if (!(null == targetData ? void 0 : targetData.length)) return data;
  const targetScale = targetAxis.getScale();
  if (!targetScale) return data;
  const targetDomain = targetScale.domain(), targetRange = targetDomain[1] - targetDomain[0];
  if (0 === targetRange) return data;
  const currentDomain = currentScale.domain(), currentRange = currentDomain[1] - currentDomain[0];
  if (0 === targetRange) return data;
  const newTicks = targetData.map((d2) => {
    const percent = (d2.value - targetDomain[0]) / targetRange;
    return currentRange * percent + currentDomain[0];
  });
  return convertDomainToTickData(newTicks);
};

// node_modules/@visactor/vchart/esm/plugin/components/axis-sync-plugin/axis-sync.js
var AxisSyncPlugin = class _AxisSyncPlugin extends BasePlugin {
  constructor() {
    super(_AxisSyncPlugin.type), this.type = "AxisSyncPlugin";
  }
  _checkEnableSync(axis2) {
    if (!isContinuous(axis2.getScale().type)) return false;
    const sync = axis2.getSpec().sync;
    return !!(null == sync ? void 0 : sync.axisId) && sync;
  }
  _getTargetAxis(axis2, sync) {
    const targetAxis = axis2.getOption().getChart().getComponentByUserId(sync.axisId);
    return (null == targetAxis ? void 0 : targetAxis.type.startsWith("cartesianAxis")) ? targetAxis : null;
  }
  onInit(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync) return;
    if (!sync.zeroAlign) return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    targetAxis && axis2.event.on(ChartEvent.scaleDomainUpdate, {
      filter: ({ model }) => model.id === axis2.id || model.id === targetAxis.id
    }, () => {
      zeroAlign(targetAxis, axis2);
    });
  }
  onDidCompile(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync) return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    if (targetAxis && sync.tickAlign) {
      registerDataSetInstanceTransform(axis2.getOption().dataSet, "tickAlign", tickAlign);
      const opt = {
        targetAxis: () => targetAxis,
        currentAxis: () => axis2
      };
      axis2.addTransformToTickData({
        type: "tickAlign",
        options: opt,
        level: Number.MAX_SAFE_INTEGER
      }, false);
    }
  }
};
AxisSyncPlugin.pluginType = "component", AxisSyncPlugin.type = "AxisSyncPlugin";

// node_modules/@visactor/vchart/esm/plugin/components/index.js
var components_default = {
  AxisSyncPlugin
};

// node_modules/@visactor/vchart/esm/mark/component.js
var ComponentMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = "component", this._componentType = option.componentType, this._mode = option.mode;
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.mark(GrammarMarkType.component, null != group ? group : view.rootMark, {
      componentType: this._componentType,
      mode: this._mode
    }).id(id2), this._compiledProductId = id2;
  }
};
ComponentMark.type = "component";
var registerComponentMark = () => {
  Factory2.registerMark(ComponentMark.type, ComponentMark);
};

// node_modules/@visactor/vchart/esm/data/parser/scale.js
var scaleParser = (scale4) => scale4;

// node_modules/@visactor/vchart/esm/component/axis/base-axis.js
var AxisComponent = class extends BaseComponent {
  getOrient() {
    return this._orient;
  }
  getScale() {
    return this._scale;
  }
  getScales() {
    return this._scales;
  }
  getTickData() {
    return this._tickData;
  }
  get visible() {
    return this._visible;
  }
  getInverse() {
    return this._inverse;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "axes", this._scales = [], this._visible = true, this._tick = void 0, this._visible = null === (_a = spec.visible) || void 0 === _a || _a;
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  getVRenderComponents() {
    var _a, _b;
    return array(null === (_b = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem());
  }
  created() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    if (super.created(), this.setSeriesAndRegionsFromSpec(), this.initEvent(), this.initScales(), this.updateSeriesScale(), this.getVisible() && this._initData(), this._visible) {
      const axisMark = this._createMark({
        type: "component",
        name: `axis-${this.getOrient()}`
      }, {
        componentType: "angle" === this.getOrient() ? "circleAxis" : "axis",
        mode: this._spec.mode,
        noSeparateStyle: true,
        skipTheme: true
      });
      if (this._axisMark = axisMark, axisMark.setZIndex(this.layoutZIndex), isValid_default(this._spec.id) && axisMark.setUserId(this._spec.id), this._marks.addMark(axisMark), null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) {
        const gridMark = this._createMark({
          type: "component",
          name: `axis-${this.getOrient()}-grid`
        }, {
          componentType: "angle" === this.getOrient() ? GridEnum.circleAxisGrid : GridEnum.lineAxisGrid,
          mode: this._spec.mode,
          noSeparateStyle: true,
          skipTheme: true
        });
        gridMark.setZIndex(null !== (_f = null !== (_d = null === (_c = null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.zIndex) && void 0 !== _d ? _d : null === (_e = this._spec.grid) || void 0 === _e ? void 0 : _e.zIndex) && void 0 !== _f ? _f : LayoutZIndex.Axis_Grid), this._marks.addMark(gridMark), this._gridMark = gridMark;
      }
      if (isBoolean_default(this._spec.interactive) && this._marks.forEach((m5) => m5.setInteractive(this._spec.interactive)), false !== this._option.animation && false !== get_default(this._option.getChart().getSpec(), "animation") && true === this._spec.animation) {
        const axisAnimateConfig = animationConfig(null === (_g = Factory2.getAnimationInKey("axis")) || void 0 === _g ? void 0 : _g(), {
          appear: null !== (_j = null !== (_h = this._spec.animationAppear) && void 0 !== _h ? _h : get_default(this._option.getChart().getSpec(), "animationAppear.axis")) && void 0 !== _j ? _j : get_default(this._option.getChart().getSpec(), "animationAppear"),
          disappear: null !== (_l = null !== (_k = this._spec.animationDisappear) && void 0 !== _k ? _k : get_default(this._option.getChart().getSpec(), "animationDisappear.axis")) && void 0 !== _l ? _l : get_default(this._option.getChart().getSpec(), "animationDisappear"),
          enter: null !== (_o = null !== (_m = this._spec.animationEnter) && void 0 !== _m ? _m : get_default(this._option.getChart().getSpec(), "animationEnter.axis")) && void 0 !== _o ? _o : get_default(this._option.getChart().getSpec(), "animationEnter"),
          exit: null !== (_q = null !== (_p = this._spec.animationExit) && void 0 !== _p ? _p : get_default(this._option.getChart().getSpec(), "animationExit.axis")) && void 0 !== _q ? _q : get_default(this._option.getChart().getSpec(), "animationExit"),
          update: null !== (_s = null !== (_r = this._spec.animationUpdate) && void 0 !== _r ? _r : get_default(this._option.getChart().getSpec(), "animationUpdate.axis")) && void 0 !== _s ? _s : get_default(this._option.getChart().getSpec(), "animationUpdate")
        });
        axisAnimateConfig.enter && (axisAnimateConfig.update[0].customParameters = {
          enter: axisAnimateConfig.enter[0]
        }), this._marks.forEach((m5) => m5.setAnimationConfig(axisAnimateConfig));
      }
    }
  }
  isSeriesDataEnable() {
    let enable = true;
    return eachSeries(this._regions, (s3) => {
      var _a;
      isArray_default(null === (_a = s3.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) && (enable = false);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), enable;
  }
  setSeriesAndRegionsFromSpec() {
    const { seriesId, seriesIndex, regionId, regionIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex), this.layout.layoutBindRegionID = this._regions.map((x3) => x3.id);
  }
  getBindSeriesFilter() {
    return {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    };
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this));
    const viewStatistics = getSeries(this._regions, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }).map((s3) => s3.getViewDataStatistics()).filter((v2) => !!v2);
    viewStatistics.length > 1 ? this._option.dataSet.multipleDataViewAddListener(viewStatistics, "change", () => {
      this.updateScaleDomain();
    }) : 1 === viewStatistics.length && viewStatistics[0].target.addListener("change", () => {
      this.updateScaleDomain();
    }), eachSeries(this._regions, (s3) => {
      s3.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s3.id
      }, () => {
        this._clearRawDomain();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  updateScaleDomain() {
  }
  _clearRawDomain() {
  }
  computeData(updateType) {
    !this._tickData || "force" !== updateType && isEqual(this._scale.range(), [0, 1]) || (this._tickData.getDataView().reRunAllTransform(), this._tickData.updateData());
  }
  initScales() {
    this._scales = [this._scale];
    const groups2 = [];
    if (eachSeries(this._regions, (s3) => {
      const g3 = s3.getGroups();
      g3 && groups2.push(g3);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), 0 !== groups2.length) {
      const depth = maxInArray(groups2.map((g3) => g3.fields.length));
      for (let i2 = 1; i2 < depth; i2++) {
        const scale4 = this._scale.clone();
        this._scales.push(scale4);
      }
    }
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, (null == prevSpec ? void 0 : prevSpec.type) !== (null == spec ? void 0 : spec.type) ? (result2.reMake = true, result2) : result2;
  }
  getLabelFormatMethod() {
    return this._spec.label.formatMethod ? (value, datum, index) => this._spec.label.formatMethod(datum.rawValue, datum) : null;
  }
  getLabelItems(length2) {
    return isArray_default(this._tickData.getLatestData()) ? [this._tickData.getLatestData().map((obj) => ({
      id: obj.value,
      label: obj.value,
      value: 0 === length2 ? 0 : this.dataToPosition([obj.value]) / length2,
      rawValue: obj.value
    })).filter((entry) => entry.value >= 0 && entry.value <= 1)] : [];
  }
  _delegateAxisContainerEvent(component2) {
    component2.addEventListener("*", (event, type) => this._delegateEvent(component2, event, type));
  }
  _getAxisAttributes() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const spec = this._spec;
    let titleTextStyle, titleAngle = spec.title.angle;
    "left" !== spec.orient && "right" !== spec.orient || (null === (_a = spec.title) || void 0 === _a ? void 0 : _a.autoRotate) && isNil_default(spec.title.angle) && (titleAngle = "left" === spec.orient ? -90 : 90, titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient]);
    const labelSpec = pickWithout(spec.label, ["style", "formatMethod", "state"]), backgroundSpec = null !== (_b = spec.background) && void 0 !== _b ? _b : {}, titleBackgroundSpec = null !== (_c = spec.title.background) && void 0 !== _c ? _c : {};
    return {
      orient: this.getOrient(),
      select: true !== this._option.disableTriggerEvent && spec.select,
      hover: true !== this._option.disableTriggerEvent && spec.hover,
      line: transformAxisLineStyle(spec.domainLine),
      label: Object.assign({
        style: isFunction_default(spec.label.style) ? (datum, index, data, layer) => {
          var _a2;
          const style = spec.label.style(datum.rawValue, index, datum, data, layer);
          return transformToGraphic(mergeSpec({}, null === (_a2 = this._theme.label) || void 0 === _a2 ? void 0 : _a2.style, style));
        } : transformToGraphic(spec.label.style),
        formatMethod: spec.label.formatMethod ? (value, datum, index) => spec.label.formatMethod(datum.rawValue, datum) : null,
        state: transformAxisLabelStateStyle(spec.label.state)
      }, labelSpec),
      tick: false === spec.tick.visible ? {
        visible: false
      } : {
        visible: spec.tick.visible,
        length: spec.tick.tickSize,
        inside: spec.tick.inside,
        alignWithLabel: spec.tick.alignWithLabel,
        style: isFunction_default(spec.tick.style) ? (value, index, datum, data) => {
          var _a2;
          const style = spec.tick.style(value, index, datum, data);
          return transformToGraphic(mergeSpec({}, null === (_a2 = this._theme.tick) || void 0 === _a2 ? void 0 : _a2.style, style));
        } : transformToGraphic(spec.tick.style),
        state: transformStateStyle(spec.tick.state),
        dataFilter: spec.tick.dataFilter
      },
      subTick: false === spec.subTick.visible ? {
        visible: false
      } : {
        visible: spec.subTick.visible,
        length: spec.subTick.tickSize,
        inside: spec.subTick.inside,
        count: spec.subTick.tickCount,
        style: isFunction_default(spec.subTick.style) ? (value, index, datum, data) => {
          var _a2;
          const style = spec.subTick.style(value, index, datum, data);
          return transformToGraphic(mergeSpec({}, null === (_a2 = this._theme.subTick) || void 0 === _a2 ? void 0 : _a2.style, style));
        } : transformToGraphic(spec.subTick.style),
        state: transformStateStyle(spec.subTick.state)
      },
      title: false === spec.title.visible ? {
        visible: false
      } : Object.assign({
        visible: spec.title.visible,
        position: spec.title.position,
        space: spec.title.space,
        autoRotate: false,
        angle: titleAngle ? degreeToRadian(titleAngle) : null,
        textStyle: mergeSpec({}, titleTextStyle, transformToGraphic(spec.title.style)),
        padding: spec.title.padding,
        shape: false === (null === (_d = spec.title.shape) || void 0 === _d ? void 0 : _d.visible) ? {
          visible: false
        } : {
          visible: null === (_e = spec.title.shape) || void 0 === _e ? void 0 : _e.visible,
          space: null === (_f = spec.title.shape) || void 0 === _f ? void 0 : _f.space,
          style: transformToGraphic(null === (_g = spec.title.shape) || void 0 === _g ? void 0 : _g.style)
        },
        background: false === titleBackgroundSpec.visible ? {
          visible: false
        } : {
          visible: titleBackgroundSpec.visible,
          style: transformToGraphic(titleBackgroundSpec.style)
        },
        state: {
          text: transformStateStyle(spec.title.state),
          shape: transformStateStyle(null === (_h = spec.title.shape) || void 0 === _h ? void 0 : _h.state),
          background: transformStateStyle(null === (_j = spec.title.background) || void 0 === _j ? void 0 : _j.state)
        },
        pickable: false !== (null === (_k = spec.title.style) || void 0 === _k ? void 0 : _k.pickable),
        childrenPickable: false !== (null === (_l = spec.title.style) || void 0 === _l ? void 0 : _l.pickable)
      }, spec.title),
      panel: false === backgroundSpec.visible ? {
        visible: false
      } : {
        visible: backgroundSpec.visible,
        style: transformToGraphic(backgroundSpec.style),
        state: transformStateStyle(backgroundSpec.state)
      }
    };
  }
  _getGridAttributes() {
    const spec = this._spec;
    return {
      alternateColor: spec.grid.alternateColor,
      alignWithLabel: spec.grid.alignWithLabel,
      style: isFunction_default(spec.grid.style) ? () => (datum, index) => {
        var _a, _b;
        const style = spec.grid.style(null === (_a = datum.datum) || void 0 === _a ? void 0 : _a.rawValue, index, datum.datum);
        return transformToGraphic(mergeSpec({}, null === (_b = this._theme.grid) || void 0 === _b ? void 0 : _b.style, style));
      } : transformToGraphic(spec.grid.style),
      subGrid: false === spec.subGrid.visible ? {
        visible: false
      } : {
        type: "line",
        visible: spec.subGrid.visible,
        alternateColor: spec.subGrid.alternateColor,
        style: transformToGraphic(spec.subGrid.style)
      }
    };
  }
  _initTickDataSet(options) {
    registerDataSetInstanceParser(this._option.dataSet, "scale", scaleParser), registerDataSetInstanceTransform(this._option.dataSet, "ticks", ticks3);
    return new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_ticks`
    }).parse(this._scale, {
      type: "scale"
    }).transform({
      type: "ticks",
      options
    }, false);
  }
  _tickTransformOption(coordinateType) {
    const tick = this._tick || {}, label = this._spec.label || {}, { tickCount, forceTickCount, tickStep: tickStep2, tickMode } = tick, { style: labelStyle, formatMethod: labelFormatter, minGap: labelGap } = label;
    return {
      sampling: false !== this._spec.sampling,
      tickCount,
      forceTickCount,
      tickStep: tickStep2,
      tickMode,
      axisOrientType: this._orient,
      coordinateType,
      labelStyle,
      labelFormatter,
      labelGap
    };
  }
  addTransformToTickData(options, execute) {
    var _a, _b;
    null === (_b = null === (_a = this._tickData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.transform(options, execute);
  }
  dataToPosition(values) {
    return this._scale.scale(values);
  }
};
AxisComponent.specKey = "axes";
var registerAxis2 = () => {
  registerAxis(), registerGrid(), registerComponentMark(), Factory2.registerAnimation("axis", () => ({
    appear: {
      custom: GroupFadeIn
    },
    update: {
      custom: GroupTransition
    },
    exit: {
      custom: GroupFadeOut
    }
  }));
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/axis.js
var __rest14 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var CartesianAxisPlugin = [components_default.AxisSyncPlugin];
var CartesianAxis = class extends AxisComponent {
  getOrient() {
    return this._orient;
  }
  set autoIndentOnce(v2) {
    this._autoIndentOnce = v2;
  }
  getScales() {
    return this._scales;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianAxis, this.name = ComponentTypeEnum.cartesianAxis, this._defaultBandPosition = 0.5, this._defaultBandInnerPadding = 0.1, this._defaultBandOuterPadding = 0.3, this.layoutType = "region-relative", this.layoutZIndex = LayoutZIndex.Axis, this.layoutLevel = LayoutLevel.Axis, this._orient = "left", this._autoIndentOnce = false, this._hasAutoIndent = false, this._scales = [], this._tick = void 0, this._layoutCache = {
      width: 0,
      height: 0,
      _lastComputeOutBounds: {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      }
    }, this._innerOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s3) => {
          const orient = this.getOrient();
          isXAxis(orient) ? s3.setXAxisHelper(this.axisHelper()) : isYAxis(orient) ? s3.setYAxisHelper(this.axisHelper()) : isZAxis(orient) && s3.setZAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      let { x: x3, y: y3 } = pos;
      return isValidNumber_default(x3) && (x3 += Number("left" === this._orient) * this.getLayoutRect().width), isValidNumber_default(y3) && (y3 += Number("top" === this._orient) * this.getLayoutRect().height), {
        x: x3,
        y: y3
      };
    }, this._transformLayoutRect = (result2) => {
      if (!this._visible) return result2;
      const bounds = this._latestBounds.clone().translate(-this.getLayoutStartPoint().x, -this.getLayoutStartPoint().y);
      switch (this._layout.layoutOrient) {
        case "left":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x1 < 0 ? -bounds.x1 : 0);
          break;
        case "right":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x2 > 0 ? bounds.x2 : 0);
          break;
        case "top":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y1 < 0 ? -bounds.y1 : 0);
          break;
        case "bottom":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y2 > 0 ? bounds.y2 : 0);
      }
      return result2.width = Math.ceil(result2.width), result2.height = Math.ceil(result2.height), this._layout.setRectInSpec(this._layoutCacheProcessing(result2));
    }, this._fixAxisOnZero = () => {
      const { onZero, visible } = this._spec.domainLine;
      if (this.visible && onZero && false !== visible) {
        const { onZeroAxisId, onZeroAxisIndex } = this._spec.domainLine, axesComponents = this._option.getComponentsByKey("axes"), isX = isXAxis(this.getOrient()), isValidAxis = (item) => {
          var _a;
          return (isX ? !isXAxis(item.getOrient()) : isXAxis(item.getOrient())) && isContinuous(item.getScale().type) && item.getTickData() ? null === (_a = item.getTickData().getLatestData()) || void 0 === _a ? void 0 : _a.find((d2) => 0 === d2.value) : item.getScale().ticks().includes(0);
        }, relativeAxes = axesComponents.filter((item) => isValidAxis(item));
        if (relativeAxes.length) {
          let bindAxis;
          if (isValid_default(onZeroAxisId)) bindAxis = relativeAxes.find((axis2) => axis2.id === onZeroAxisId);
          else if (isValid_default(onZeroAxisIndex)) {
            const indexAxis = axesComponents[onZeroAxisIndex];
            isValidAxis(indexAxis) && (bindAxis = indexAxis);
          } else bindAxis = relativeAxes[0];
          if (bindAxis) {
            const axisMark = this._axisMark.getProduct(), position = bindAxis.valueToPosition(0);
            isX ? axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dy: "bottom" === this._orient ? -(bindAxis.getScale().range()[0] - position) : position
              })
            }) : axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dx: "left" === this._orient ? position : -(bindAxis.getScale().range()[1] - position)
              })
            });
          }
        }
      }
    }, this._orient = getOrient(spec, ["z"]), isZAxis(this._orient) && (this.layoutType = "absolute"), this._dataSet = options.dataSet;
  }
  static getSpecInfo(chartSpec) {
    const axesSpec = chartSpec[this.specKey];
    if (!axesSpec) return null;
    const isHorizontal4 = "horizontal" === chartSpec.direction;
    if (!isArray_default(axesSpec)) {
      if (!isValidCartesianAxis(axesSpec)) return null;
      const { axisType, componentName } = getCartesianAxisInfo(axesSpec, isHorizontal4);
      return axesSpec.type = axisType, [{
        spec: axesSpec,
        specPath: [this.specKey],
        type: componentName
      }];
    }
    let valid = true;
    if (axesSpec.filter((s3) => "z" === s3.orient)[0]) {
      const xAxis = axesSpec.filter((s3) => "bottom" === s3.orient)[0], yAxis = axesSpec.filter((s3) => isYAxis(s3.orient))[0];
      valid = 3 === axesSpec.length && xAxis && yAxis;
    }
    let axesSpecList = axesSpec.map((spec, index) => ({
      spec,
      index
    }));
    valid || (axesSpecList = axesSpecList.filter(({ spec }) => "z" !== spec.orient));
    const specInfos = [];
    return axesSpecList.forEach(({ spec, index }) => {
      if (!isValidCartesianAxis(spec)) return;
      const { axisType, componentName } = getCartesianAxisInfo(spec, isHorizontal4);
      spec.type = axisType, specInfos.push({
        spec,
        specIndex: index,
        specPath: [this.specKey, index],
        type: componentName
      });
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest14(specInfo, ["spec"]), C2 = Factory2.getComponentInKey(others.type);
    return C2 ? new C2(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  initLayout() {
    super.initLayout(), this._layout.autoIndent = false !== this._spec.autoIndent, this._layout.layoutOrient = this._orient;
  }
  setLayout3dBox(box3d) {
    this.layout3dBox = box3d;
  }
  updateScaleRange() {
    let isScaleChange = false;
    const { width, height } = this.getLayoutRect(), { left: left2, right: right2, top, bottom } = this._innerOffset;
    let newRange = [];
    isXAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2]) : isZAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2], this._scale.range(newRange)) : isValidNumber_default(height) && (newRange = this._inverse ? [top, height - bottom] : [height - bottom, top]);
    const [start, end] = this._scale.range();
    return newRange[0] === start && newRange[1] === end || (isScaleChange = true, this._scale.range(newRange)), isScaleChange;
  }
  init(option) {
    var _a;
    super.init(option), null === (_a = this.pluginService) || void 0 === _a || _a.load(CartesianAxisPlugin.map((P2) => new P2())), this.callPlugin((plugin) => {
      this.pluginService && plugin.onInit && plugin.onInit(this.pluginService, this);
    });
  }
  setAttrFromSpec() {
    var _a;
    if (super.setAttrFromSpec(), this.visible) {
      isXAxis(this.getOrient()) ? isUndefined_default(this._spec.maxHeight) && (this._spec.maxHeight = "30%") : isUndefined_default(this._spec.maxWidth) && (this._spec.maxWidth = "30%");
      const axisStyle = this._getAxisAttributes();
      axisStyle.label.formatMethod = this.getLabelFormatMethod(), axisStyle.verticalFactor = "top" === this.getOrient() || "right" === this.getOrient() ? -1 : 1, this._axisStyle = axisStyle;
    }
    this._tick = this._spec.tick;
    const chartSpec = null === (_a = this._option.getChart()) || void 0 === _a ? void 0 : _a.getSpec();
    this._inverse = transformInverse(this._spec, "horizontal" === (null == chartSpec ? void 0 : chartSpec.direction));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    if (super.onLayoutStart(layoutRect, viewRect, ctx), !isZAxis(this.getOrient()) && this._spec.innerOffset) {
      const spec = this._spec;
      isYAxis(this.getOrient()) ? ["top", "bottom"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.height, viewRect);
      }) : ["left", "right"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.width, viewRect);
      });
    }
  }
  getSeriesStatisticsField(s3) {
    let f2;
    return f2 = isXAxis(this.getOrient()) ? s3.fieldX : isZAxis(this.getOrient()) ? s3.fieldZ : s3.fieldY, isContinuous(this._scale.type) ? f2 : [f2[0]];
  }
  _tickTransformOption(coordinateType) {
    var _a, _b;
    return Object.assign(Object.assign({}, super._tickTransformOption(coordinateType)), {
      noDecimals: this._tick.noDecimals,
      labelLastVisible: null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.lastVisible,
      labelFlush: null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.flush
    });
  }
  _initData() {
    const tickData = this._initTickDataSet(this._tickTransformOption("cartesian"));
    tickData.target.addListener("change", this._forceLayout.bind(this)), this._tickData = new CompilableData(this._option, tickData);
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      getScale: (depth = 0) => this._scales[depth],
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => true === this._inverse
    };
  }
  afterCompile() {
    var _a;
    const product2 = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
    product2 && product2.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
      if (false === this._isLayout && (isXAxis(this.getOrient()) ? this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutHorizontal && plugin.onDidLayoutHorizontal(this.pluginService, this);
      }) : this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutVertical && plugin.onDidLayoutVertical(this.pluginService, this);
      }), this._delegateAxisContainerEvent(product2.getGroupGraphicItem()), this._unitText)) {
        const bounds = product2.graphicItem.AABBBounds, pos = isXAxis(this._orient) ? {
          x: bounds.x2,
          y: this.getLayoutStartPoint().y
        } : {
          x: this.getLayoutStartPoint().x,
          y: bounds.y1
        };
        this._unitText.setAttributes(pos);
      }
    }), this.callPlugin((plugin) => {
      this.pluginService && plugin.onDidCompile && plugin.onDidCompile(this.pluginService, this);
    });
  }
  onLayoutEnd(ctx) {
    this.updateScaleRange() ? this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "range"
    }) : this.updateSeriesScale(), super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  collectScale() {
    const scales = [];
    return eachSeries(this._regions, (s3) => {
      scales.push("left" === this.getOrient() || "right" === this.getOrient() ? s3.scaleY : s3.scaleX);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), scales;
  }
  collectData(depth, rawData) {
    const data = [];
    return eachSeries(this._regions, (s3) => {
      var _a, _b, _c;
      let field5;
      if (field5 = depth > 0 ? null === (_b = null === (_a = s3.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : isXAxis(this.getOrient()) ? s3.fieldX2 ? [...s3.fieldX, s3.fieldX2] : s3.fieldX : isZAxis(this.getOrient()) ? s3.fieldZ : s3.fieldY, field5 = isArray_default(field5) ? isContinuous(this._scale.type) ? field5 : [field5[0]] : [field5], depth || (this._dataFieldText = s3.getFieldAlias(field5[0])), field5) {
        const viewData = s3.getViewData();
        if (rawData) field5.forEach((f2) => {
          data.push(s3.getRawDataStatisticsByField(f2, false));
        });
        else if (viewData && viewData.latestData && viewData.latestData.length) {
          const seriesData = null === (_c = s3.getViewDataStatistics) || void 0 === _c ? void 0 : _c.call(s3);
          field5.forEach((f2) => {
            var _a2;
            (null === (_a2 = null == seriesData ? void 0 : seriesData.latestData) || void 0 === _a2 ? void 0 : _a2[f2]) && data.push(seriesData.latestData[f2]);
          });
        }
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), data;
  }
  updateSeriesScale() {
    const orient = this.getOrient();
    eachSeries(this._regions, (s3) => {
      isXAxis(orient) ? (s3.setScaleX(this._scale), s3.setXAxisHelper(this.axisHelper())) : isYAxis(orient) ? (s3.setScaleY(this._scale), s3.setYAxisHelper(this.axisHelper())) : isZAxis(orient) && (s3.setScaleZ(this._scale), s3.setZAxisHelper(this.axisHelper()));
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getBoundsInRect(rect) {
    let result2 = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    if (!this._visible) return result2;
    this._verticalLimitSize = isXAxis(this.getOrient()) ? rect.height : rect.width, this.setLayoutRect(rect);
    !this.updateScaleRange() && isArray_default(this._tickData.getLatestData()) || this.computeData("range");
    const context = {
      skipLayout: false
    }, isX = isXAxis(this.getOrient());
    this.pluginService && (isX ? this.callPlugin((plugin) => {
      plugin.onWillLayoutHorizontal && plugin.onWillLayoutHorizontal(this.pluginService, context, this);
    }) : this.callPlugin((plugin) => {
      plugin.onWillLayoutVertical && plugin.onWillLayoutVertical(this.pluginService, context, this);
    }));
    const product2 = this._axisMark.getProduct();
    let hasBounds2 = false;
    if (!context.skipLayout) {
      const attrs = this._getUpdateAttribute(true), axisComponent = product2.getGroupGraphicItem(), spec = mergeSpec(Object.assign({}, this.getLayoutStartPoint()), this._axisStyle, attrs, {
        line: {
          visible: false
        }
      }), updateBounds = axisComponent.getBoundsWithoutRender(spec);
      hasBounds2 = true, this._latestBounds = updateBounds, isFinite(updateBounds.width()) && (result2 = this._appendAxisUnit(updateBounds, isX));
    }
    return hasBounds2 || (this._latestBounds = product2.getBounds()), result2;
  }
  updateLayoutAttribute() {
    if (!this.visible) return;
    const startPoint = this.getLayoutStartPoint(), _a = this._getUpdateAttribute(false), { grid: updateGridAttrs } = _a, updateAxisAttrs = __rest14(_a, ["grid"]), axisProduct = this._axisMark.getProduct(), axisAttrs = mergeSpec({
      x: startPoint.x,
      y: startPoint.y
    }, this._axisStyle, updateAxisAttrs);
    if (axisProduct.encode(axisAttrs), this._gridMark) {
      this._gridMark.getProduct().encode(mergeSpec({
        x: startPoint.x,
        y: startPoint.y
      }, this._getGridAttributes(), updateGridAttrs));
    }
    super.updateLayoutAttribute();
  }
  _getTitleLimit(isX) {
    var _a, _b, _c, _d, _e;
    if (this._spec.title.visible && isNil_default(null === (_a = this._spec.title.style) || void 0 === _a ? void 0 : _a.maxLineWidth)) {
      const angle2 = null !== (_e = null !== (_c = null === (_b = this._axisStyle.title) || void 0 === _b ? void 0 : _b.angle) && void 0 !== _c ? _c : null === (_d = this._spec.title.style) || void 0 === _d ? void 0 : _d.angle) && void 0 !== _e ? _e : 0;
      if (isX) {
        const width = this.getLayoutRect().width, cosValue = Math.abs(Math.cos(angle2));
        return cosValue < 1e-6 ? 1 / 0 : width / cosValue;
      }
      const height = this.getLayoutRect().height, sinValue = Math.abs(Math.sin(angle2));
      return sinValue < 1e-6 ? 1 / 0 : height / sinValue;
    }
    return null;
  }
  _getUpdateAttribute(ignoreGrid) {
    var _a;
    let regionHeight = 0, regionWidth = 0;
    if (!ignoreGrid) {
      const regions = this.getRegions();
      let { x: minX, y: minY } = regions[0].getLayoutStartPoint(), maxX = minX + regions[0].getLayoutRect().width, maxY2 = minY + regions[0].getLayoutRect().height;
      for (let index = 1; index < regions.length; index++) {
        const region = regions[index], { x: x3, y: y3 } = region.getLayoutStartPoint(), { width: width2, height: height2 } = region.getLayoutRect();
        minX = Math.min(minX, x3), maxX = Math.max(maxX, width2 + x3), minY = Math.min(minY, y3), maxY2 = Math.max(maxY2, height2 + y3);
      }
      regionHeight = Math.abs(maxY2 - minY), regionWidth = Math.abs(maxX - minX);
    }
    const { width, height } = this.getLayoutRect(), isX = isXAxis(this._orient), isY = isYAxis(this._orient), isZ = isZAxis(this._orient);
    let end = {
      x: 0,
      y: 0
    }, gridLength = 0, axisLength = 0;
    const depth = this.layout3dBox ? this.layout3dBox.length : 0;
    if (isX ? (end = {
      x: width,
      y: 0
    }, gridLength = regionHeight, axisLength = width) : isY && (end = {
      x: 0,
      y: height
    }, gridLength = regionWidth, axisLength = height), isZ) {
      const directionStr = null !== (_a = this.directionStr) && void 0 !== _a ? _a : "r2l", depthZ = this.layout3dBox ? this.layout3dBox.width : 0;
      let anchor3d = [0, 0], alpha = -Math.PI / 2, z2 = 0;
      "l2r" === directionStr && (z2 = this.layout3dBox.length, anchor3d = [0, 0, 0], alpha = Math.PI / 2);
      const items2 = this.getLabelItems(width), axisAttrs = {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: depth,
          y: 0
        },
        z: z2,
        alpha,
        anchor3d,
        title: {
          text: this._spec.title.text || this._dataFieldText,
          maxWidth: this._getTitleLimit(isX)
        },
        items: items2
      };
      return ignoreGrid || (axisAttrs.grid = {
        type: "line",
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: depth,
          y: 0
        },
        items: items2[0],
        verticalFactor: this._axisStyle.verticalFactor,
        depth: depthZ,
        length: regionHeight,
        z: z2,
        alpha,
        anchor3d
      }), axisAttrs;
    }
    let verticalMinSize = isX ? this.layout.minHeight : this.layout.minWidth;
    (isX && this._layout.layoutRectLevelMap.height === USER_LAYOUT_RECT_LEVEL || isY && this._layout.layoutRectLevelMap.width === USER_LAYOUT_RECT_LEVEL) && (verticalMinSize = this._verticalLimitSize);
    const items = this.getLabelItems(axisLength), attrs = {
      start: {
        x: 0,
        y: 0
      },
      end,
      title: {
        text: this._spec.title.text || this._dataFieldText,
        maxWidth: this._getTitleLimit(isX)
      },
      items,
      verticalLimitSize: this._verticalLimitSize,
      verticalMinSize
    };
    return ignoreGrid || (attrs.grid = {
      type: "line",
      start: {
        x: 0,
        y: 0
      },
      end,
      items: items[0],
      verticalFactor: this._axisStyle.verticalFactor,
      depth,
      length: gridLength
    }), attrs;
  }
  initEvent() {
    super.initEvent(), this.visible && (this.event.on(ChartEvent.layoutEnd, this._fixAxisOnZero), this.event.on(ChartEvent.layoutRectUpdate, () => {
      this._clearLayoutCache();
    }));
  }
  _layoutCacheProcessing(rect) {
    return ["width", "height"].forEach((key) => {
      rect[key] < this._layoutCache[key] ? rect[key] = this._layoutCache[key] : this._layoutCache[key] = rect[key];
    }), this._autoIndentOnce && this._hasAutoIndent ? ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key];
    }) : (this._hasAutoIndent = true, ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] < this._layoutCache._lastComputeOutBounds[key] ? this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key] : this._layoutCache._lastComputeOutBounds[key] = this.layout.getLastComputeOutBounds()[key];
    })), rect;
  }
  _clearLayoutCache() {
    this._hasAutoIndent = false, this._layoutCache.width = 0, this._layoutCache.height = 0, this._layoutCache._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
  onDataUpdate() {
    this._clearLayoutCache();
  }
  _appendAxisUnit(bounds, isX) {
    var _a;
    if (this._spec.unit && this._spec.unit.visible) {
      const { text: text2, style } = this._spec.unit;
      let pos, unitTextStyle;
      isX ? (pos = {
        x: bounds.x2,
        y: this.getLayoutStartPoint().y
      }, unitTextStyle = {
        textAlign: "left",
        textBaseline: "middle"
      }) : (pos = {
        x: this.getLayoutStartPoint().x,
        y: bounds.y1
      }, unitTextStyle = {
        textAlign: "left" === this._orient ? "left" : "right",
        textBaseline: "bottom"
      }), unitTextStyle = Object.assign(Object.assign(Object.assign({}, unitTextStyle), style), {
        x: pos.x,
        y: pos.y,
        text: text2
      }), this._unitText ? this._unitText.setAttributes(unitTextStyle) : (this._unitText = createText(unitTextStyle), this._unitText.name = "axis-unit", null === (_a = this.getContainer()) || void 0 === _a || _a.add(this._unitText));
      const textBounds = this._unitText.AABBBounds;
      isX ? (bounds.x2 += textBounds.x2 > bounds.x2 ? textBounds.x2 - bounds.x2 : 0, bounds.y2 += textBounds.y2 > bounds.y2 ? textBounds.y2 - bounds.y2 : 0) : (bounds.x1 += textBounds.x1 < bounds.x1 ? textBounds.x1 - bounds.x1 : 0, bounds.y1 += textBounds.y1 < bounds.y1 ? textBounds.y1 - bounds.y1 : 0);
    }
    return bounds;
  }
  _getNeedClearVRenderComponents() {
    return this._unitText ? [this._unitText] : [];
  }
};
CartesianAxis.type = ComponentTypeEnum.cartesianAxis, CartesianAxis.specKey = "axes";

// node_modules/@visactor/vchart/esm/component/axis/mixin/linear-axis-mixin.js
var e103 = Math.sqrt(50);
var e53 = Math.sqrt(10);
var e23 = Math.sqrt(2);
var LinearAxisMixin = class {
  constructor() {
    this._extend = {};
  }
  setExtraAttrFromSpec() {
    isValid_default(this._spec.nice) && (this._nice = this._spec.nice), isValid_default(this._spec.zero) && (this._zero = this._spec.zero), this._expand = this._spec.expand, this._domain = getLinearAxisSpecDomain(this._spec);
  }
  transformScaleDomain() {
    this.setScaleNice();
  }
  setLinearScaleNice() {
    var _a;
    let tickCount = 5;
    const tick = this._spec.tick || {};
    if (isValidNumber_default(tick.forceTickCount)) tickCount = tick.forceTickCount;
    else if (isFunction_default(tick.tickCount)) {
      const range2 = this._scale.range();
      let rangeSize = Math.abs(range2[range2.length - 1] - range2[0]);
      if (1 === rangeSize && this._option) {
        rangeSize = isXAxis(this._orient) ? this._option.getChartViewRect().width : this._option.getChartViewRect().height;
      }
      tickCount = tick.tickCount({
        rangeSize,
        labelStyle: this._spec.label && this._spec.label.style
      });
    } else tickCount = isValidNumber_default(tick.tickCount) ? tick.tickCount : 5;
    "accurateFirst" === this._spec.niceType && (tickCount = Math.max(5, tickCount));
    const { min: min4, max: max4 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    isNil_default(min4) && isNil_default(max4) ? this._nice && this._scale.nice(tickCount) : isValid_default(min4) && isNil_default(max4) ? this._nice && this._scale.niceMax(tickCount) : isNil_default(min4) && isValid_default(max4) && this._nice && this._scale.niceMin(tickCount);
  }
  setLogScaleNice() {
    var _a;
    const { min: min4, max: max4 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    isNil_default(min4) && isNil_default(max4) ? this._nice && this._scale.nice() : isValid_default(min4) && isNil_default(max4) ? this._nice && this._scale.niceMax() : isNil_default(min4) && isValid_default(max4) && this._nice && this._scale.niceMin();
  }
  setScaleNice() {
    "log" === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
  }
  dataToPosition(values, cfg) {
    return this.valueToPosition(values[0]);
  }
  valueToPosition(value) {
    return "log" !== this._spec.type || isNil_default(value) || 0 !== value && 0 !== value[0] ? this._scale.scale(value) : this._scale.range()[0];
  }
  computeLinearDomain(data) {
    const domain = [];
    return data.length ? data.forEach((d2) => {
      const { min: min4, max: max4 } = d2;
      domain[0] = void 0 === domain[0] ? min4 : Math.min(domain[0], min4), domain[1] = void 0 === domain[1] ? max4 : Math.max(domain[1], max4);
    }) : (domain[0] = 0, domain[1] = 0), this.expandDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), domain;
  }
  expandDomain(domain) {
    if (!this._expand) return;
    let domainMin = domain[0], domainMax = domain[domain.length - 1];
    domainMin === domainMax && (0 === domainMax ? domainMax = 1 : domainMax > 0 ? domainMin = 0 : domainMax < 0 && (domainMax = 0)), isValid_default(this._expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this._expand.min), isValid_default(this._expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this._expand.max);
  }
  niceDomain(domain) {
    const { min: userMin, max: userMax } = getLinearAxisSpecDomain(this._spec);
    if (isValid_default(userMin) || isValid_default(userMax) || "linear" !== this._spec.type) return domain;
    if (Math.abs(minInArray(domain) - maxInArray(domain)) <= 1e-12) {
      let num = domain[0];
      const flag = num >= 0 ? 1 : -1;
      if (num = Math.abs(num), num < 1) domain[0] = 0, domain[1] = 1;
      else {
        let step = num / 5;
        const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
        step = (err >= e103 ? 10 : err >= e53 ? 5 : err >= e23 ? 2 : 1) * Math.pow(10, power), domain[0] = 0, domain[1] = 10 * step;
      }
      flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
    }
    return domain;
  }
  includeZero(domain) {
    this._zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
  }
  setExtendDomain(key, value) {
    if (void 0 === value) return void delete this._extend[key];
    this._extend[key] = value;
    const domain = this._scale.domain();
    this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this.setScaleNice(), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  extendDomain(domain) {
    let temp3;
    const domainLast = domain.length - 1, reverse2 = domain[0] - domain[domainLast] > 0, min4 = reverse2 ? domainLast : 0, max4 = reverse2 ? 0 : domainLast;
    for (const key in this._extend) temp3 = this._extend[key], temp3 > domain[max4] && (domain[max4] = temp3), temp3 < domain[min4] && (domain[min4] = temp3);
  }
  getDomainSpec() {
    return this._domain;
  }
  setDomainMinMax(domain) {
    if (!this._domain) return;
    const { min: min4, max: max4 } = this._domain;
    isValid_default(min4) && (domain[0] = min4), isValid_default(max4) && (domain[1] = max4);
  }
  setZero(zero3) {
    this._zero !== zero3 && (this._zero = zero3, this.updateScaleDomain());
  }
  updateScaleDomain() {
    if (!this.isSeriesDataEnable()) return;
    const data = this.collectData(), domain = this.computeDomain(data);
    this.updateScaleDomainByModel(domain);
  }
  updateScaleDomainByModel(domain) {
    domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this.setScaleNice(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/linear-axis.js
var CartesianLinearAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLinearAxis, this._zero = true, this._nice = true, this._extend = {}, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
  }
  initScales() {
    var _a, _b;
    super.initScales();
    const range2 = [0, 1];
    isValid_default(null === (_a = this._domain) || void 0 === _a ? void 0 : _a.min) && (range2[0] = this._domain.min), isValid_default(null === (_b = this._domain) || void 0 === _b ? void 0 : _b.max) && (range2[1] = this._domain.max), this._scale.domain(range2);
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  axisHelper() {
    const helper = super.axisHelper();
    return helper.setExtendDomain = this.setExtendDomain.bind(this), helper.valueToPosition = this.valueToPosition.bind(this), helper;
  }
};
CartesianLinearAxis.type = ComponentTypeEnum.cartesianLinearAxis, CartesianLinearAxis.specKey = "axes", mixin(CartesianLinearAxis, LinearAxisMixin);
var registerCartesianLinearAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianLinearAxis.type, CartesianLinearAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/mixin/band-axis-mixin.js
var BandAxisMixin = class {
  constructor() {
    this._rawDomainIndex = [];
  }
  dataToPosition(values, cfg = {}) {
    var _a, _b;
    if (0 === values.length || 0 === this._scales.length) return 0;
    const { position, bandScale } = this.getPosition(values);
    return position + bandScale.bandwidth() * (null !== (_b = null !== (_a = cfg.bandPosition) && void 0 !== _a ? _a : this._spec.bandPosition) && void 0 !== _b ? _b : this._defaultBandPosition);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  updateGroupScaleRange() {
    let parentScale = this._scale;
    this._scales.forEach((scale4, i2) => {
      i2 > 0 && (scale4.range([0, parentScale.bandwidth()]), parentScale = scale4);
    });
  }
  getPosition(values) {
    let position = 0, bandScale = this._scale;
    if (1 === this._scales.length || 1 === values.length) position = this.valueToPosition(values[0]);
    else {
      const max4 = Math.min(values.length, this._scales.length);
      for (let i2 = 0; i2 < max4; i2++) position += this._scales[i2].scale(values[i2]);
      bandScale = this._scales[max4 - 1];
    }
    return {
      position,
      bandScale
    };
  }
  calcScales(DEFAULT_BAND_INNER_PADDING, DEFAULT_BAND_OUTER_PADDING) {
    var _a, _b;
    const { bandPadding, paddingInner, paddingOuter } = this._spec, isBandPaddingArray = isArray_default(bandPadding), isPaddingInnerArray = isArray_default(paddingInner), isPaddingOuterArray = isArray_default(paddingOuter);
    for (let i2 = 0; i2 < this._scales.length; i2++) {
      const _padding = isBandPaddingArray ? bandPadding[i2] : bandPadding, _paddingInner = isPaddingInnerArray ? paddingInner[i2] : paddingInner, _paddingOuter = isPaddingOuterArray ? paddingOuter[i2] : paddingOuter;
      this._scales[i2].paddingInner(null !== (_a = null != _paddingInner ? _paddingInner : _padding) && void 0 !== _a ? _a : DEFAULT_BAND_INNER_PADDING, true).paddingOuter(null !== (_b = null != _paddingOuter ? _paddingOuter : _padding) && void 0 !== _b ? _b : DEFAULT_BAND_OUTER_PADDING, true);
    }
  }
  computeBandDomain(data) {
    if (!data.length) return [];
    if (1 === data.length) return data[0].values;
    const tempSet = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < data.length; i2++) for (let j2 = 0; j2 < data[i2].values.length; j2++) tempSet.add(data[i2].values[j2]);
    return Array.from(tempSet);
  }
  updateScaleDomain() {
    var _a;
    if (!this.isSeriesDataEnable()) return;
    !(null === (_a = this._rawDomainIndex) || void 0 === _a ? void 0 : _a.length) && this._scales.length && this._updateRawDomain();
    const userDomain = this._spec.domain;
    for (let i2 = 0; i2 < this._scales.length; i2++) if (userDomain && userDomain.length && 0 === i2) this._scales[i2].domain(userDomain);
    else {
      const data = this.collectData(i2), domain = this.computeDomain(data);
      this._scales[i2].domain(domain.sort((a4, b2) => this._rawDomainIndex[i2][a4] - this._rawDomainIndex[i2][b2]));
    }
    this.transformScaleDomain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  _updateRawDomain() {
    this._rawDomainIndex = [];
    const userDomain = this._spec.domain;
    for (let i2 = 0; i2 < this._scales.length; i2++) if (userDomain && userDomain.length && 0 === i2) this._scales[i2].domain(userDomain);
    else {
      const data = this.collectData(i2, true), domain = this.computeDomain(data);
      this._rawDomainIndex[i2] = {}, domain.forEach((d2, _i) => this._rawDomainIndex[i2][d2] = _i);
    }
  }
  _clearRawDomain() {
    this._rawDomainIndex = [];
  }
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/band-axis.js
var CartesianBandAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  axisHelper() {
    const getScale2 = (depth) => this._scales[depth];
    return {
      isContinuous: false,
      dataToPosition: this.dataToPosition.bind(this),
      getScale: getScale2,
      getBandwidth: (depth) => getScale2(depth).bandwidth(),
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => this._inverse
    };
  }
  transformScaleDomain() {
    this.updateFixedWholeLength();
  }
  updateFixedWholeLength() {
    var _a;
    if (this._scale && (this._spec.bandSize && this._scale.bandwidth(this._spec.bandSize), this._spec.maxBandSize && this._scale.maxBandwidth(this._spec.maxBandSize), this._spec.minBandSize && this._scale.minBandwidth(this._spec.minBandSize), this._scale.isBandwidthFixed() && this._spec.autoRegionSize && (this._spec.bandSize || this._spec.maxBandSize))) {
      const rangeSize = scaleWholeRangeSize(this._scale.domain().length, null !== (_a = this._spec.bandSize) && void 0 !== _a ? _a : this._spec.maxBandSize, this._scale.paddingInner(), this._scale.paddingOuter());
      ["bottom", "top"].includes(this._orient) ? this._regions.forEach((region) => region.setMaxWidth(rangeSize)) : ["left", "right"].includes(this._orient) && this._regions.forEach((region) => region.setMaxHeight(rangeSize));
    }
  }
};
CartesianBandAxis.type = ComponentTypeEnum.cartesianBandAxis, CartesianBandAxis.specKey = "axes", mixin(CartesianBandAxis, BandAxisMixin);
var registerCartesianBandAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianBandAxis.type, CartesianBandAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/time-axis.js
var CartesianTimeAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianTimeAxis, this._zero = false, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s3) => {
          isXAxis(this.getOrient()) ? s3.setXAxisHelper(this.axisHelper()) : s3.setYAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._tick = mergeSpec({}, this._spec.tick, null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[0]);
  }
  _initData() {
    var _a;
    if (super._initData(), null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) {
      const layerTickData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_layer_1_ticks`
      }).parse(this._scale, {
        type: "scale"
      }).transform({
        type: "ticks",
        options: Object.assign(Object.assign({}, this._tickTransformOption("cartesian")), {
          tickCount: this._spec.layers[1].tickCount,
          forceTickCount: this._spec.layers[1].forceTickCount,
          tickStep: this._spec.layers[1].tickStep
        })
      }, false);
      this._layerTickData = new CompilableData(this._option, layerTickData);
    }
  }
  computeData(updateType) {
    super.computeData(updateType), this._layerTickData && (this._layerTickData.getDataView().reRunAllTransform(), this._layerTickData.updateData());
  }
  getLabelFormatMethod() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const timeUtil = TimeUtil.getInstance(), timeFormat1 = (null === (_b = null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) || void 0 === _b ? void 0 : _b.timeFormat) || "%Y%m%d", timeFormatter1 = "local" === ((null === (_d = null === (_c = this._spec.layers) || void 0 === _c ? void 0 : _c[1]) || void 0 === _d ? void 0 : _d.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat, timeFormat0 = (null === (_f = null === (_e = this._spec.layers) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.timeFormat) || "%Y%m%d", timeFormatter0 = "local" === ((null === (_h = null === (_g = this._spec.layers) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat;
    return (value, datum, index, data, layer) => {
      var _a2;
      let timeValue;
      return timeValue = 0 === layer ? timeFormatter0(timeFormat0, value) : timeFormatter1(timeFormat1, value), (null === (_a2 = this._spec.label) || void 0 === _a2 ? void 0 : _a2.formatMethod) ? this._spec.label.formatMethod(timeValue, datum) : timeValue;
    };
  }
  getLabelItems(length2) {
    const items = [];
    return isArray_default(this._tickData.getLatestData()) && items.push(this._tickData.getLatestData().map((obj) => ({
      id: obj.value,
      label: obj.value,
      value: 0 === length2 ? 0 : this.dataToPosition([obj.value]) / length2,
      rawValue: obj.value
    }))), this._layerTickData && isArray_default(this._layerTickData.getLatestData()) && items.push(this._layerTickData.getLatestData().map((obj) => {
      const value = this.dataToPosition([obj.value]);
      return {
        id: obj.value,
        label: obj.value,
        value: value / length2,
        rawValue: obj.value
      };
    })), items;
  }
  transformScaleDomain() {
  }
};
CartesianTimeAxis.type = ComponentTypeEnum.cartesianTimeAxis, CartesianTimeAxis.specKey = "axes";
var registerCartesianTimeAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianTimeAxis.type, CartesianTimeAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/log-axis.js
var CartesianLogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLogAxis, this._zero = false, this._scale = new LogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.base(null !== (_a = this._spec.base) && void 0 !== _a ? _a : 10);
  }
  transformScaleDomain() {
  }
};
CartesianLogAxis.type = ComponentTypeEnum.cartesianLogAxis, CartesianLogAxis.specKey = "axes", mixin(CartesianLogAxis, LinearAxisMixin);
var registerCartesianLogAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianLogAxis.type, CartesianLogAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/cartesian/symlog-axis.js
var CartesianSymlogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianSymlogAxis, this._zero = false, this._scale = new SymlogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.constant(null !== (_a = this._spec.constant) && void 0 !== _a ? _a : 10);
  }
  transformScaleDomain() {
  }
};
CartesianSymlogAxis.type = ComponentTypeEnum.cartesianSymlogAxis, CartesianSymlogAxis.specKey = "axes", mixin(CartesianSymlogAxis, LinearAxisMixin);
var registerCartesianSymlogAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianSymlogAxis.type, CartesianSymlogAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/polar/util/common.js
var getPolarAxisInfo = (spec) => {
  var _a;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : "angle" === spec.orient ? "band" : "linear";
  return {
    axisType,
    componentName: `${ComponentTypeEnum.polarAxis}-${axisType}`
  };
};

// node_modules/@visactor/vchart/esm/component/axis/polar/axis.js
var __rest15 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var PolarAxis = class extends AxisComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarAxis, this.name = ComponentTypeEnum.polarAxis, this._defaultBandPosition = 0, this._defaultBandInnerPadding = 0, this._defaultBandOuterPadding = 0, this.layoutType = "absolute", this.layoutZIndex = LayoutZIndex.Axis, this._tick = void 0, this._center = null, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._orient = "radius", this._groupScales = [], this.effect = {
      scaleUpdate: (param) => {
        this.computeData(null == param ? void 0 : param.value), eachSeries(this._regions, (s3) => {
          "radius" === this.getOrient() ? s3.radiusAxisHelper = this.axisHelper() : s3.angleAxisHelper = this.axisHelper();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      var _a;
      const region = null === (_a = this.getRegions()) || void 0 === _a ? void 0 : _a[0];
      return region ? region.getLayoutStartPoint() : pos;
    };
  }
  get center() {
    return this._center;
  }
  get startAngle() {
    return this._startAngle;
  }
  get endAngle() {
    return this._endAngle;
  }
  getOrient() {
    return this._orient;
  }
  getGroupScales() {
    return this._groupScales;
  }
  static getSpecInfo(chartSpec) {
    var _a, _b;
    const axesSpec = chartSpec[this.specKey];
    if (!axesSpec) return null;
    if (!isArray_default(axesSpec)) {
      if (!isValidPolarAxis(axesSpec)) return null;
      const { axisType, componentName } = getPolarAxisInfo(axesSpec);
      return axesSpec.center = chartSpec.center, axesSpec.startAngle = null !== (_a = chartSpec.startAngle) && void 0 !== _a ? _a : POLAR_START_ANGLE, axesSpec.endAngle = null !== (_b = chartSpec.endAngle) && void 0 !== _b ? _b : isValid_default(chartSpec.startAngle) ? chartSpec.startAngle + 360 : POLAR_END_ANGLE, axesSpec.type = axisType, [{
        spec: axesSpec,
        specPath: [this.specKey],
        type: componentName
      }];
    }
    const specInfos = [];
    let angleAxisIndex;
    const radiusAxisSpecInfos = [];
    return axesSpec.forEach((s3, i2) => {
      var _a2, _b2, _c, _d, _e;
      if (!isValidPolarAxis(s3)) return;
      const { axisType, componentName } = getPolarAxisInfo(s3);
      s3.center = chartSpec.center, s3.startAngle = null !== (_a2 = chartSpec.startAngle) && void 0 !== _a2 ? _a2 : POLAR_START_ANGLE, s3.endAngle = null !== (_b2 = chartSpec.endAngle) && void 0 !== _b2 ? _b2 : isValid_default(chartSpec.startAngle) ? chartSpec.startAngle + 360 : POLAR_END_ANGLE, s3.outerRadius = null !== (_e = null !== (_d = null !== (_c = s3.radius) && void 0 !== _c ? _c : chartSpec.outerRadius) && void 0 !== _d ? _d : chartSpec.radius) && void 0 !== _e ? _e : POLAR_DEFAULT_RADIUS, s3.type = axisType;
      const info = {
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: componentName
      };
      specInfos.push(info), "radius" === s3.orient ? radiusAxisSpecInfos.push(info) : angleAxisIndex = i2;
    }), radiusAxisSpecInfos.forEach((info) => {
      info.angleAxisIndex = angleAxisIndex;
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest15(specInfo, ["spec"]), C2 = Factory2.getComponentInKey(others.type);
    return C2 ? new C2(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.visible && (this._axisStyle = this._getAxisAttributes(), this._gridStyle = this._getGridAttributes()), this._tick = this._spec.tick, this._orient = "angle" === this._spec.orient ? "angle" : "radius", this._center = this._spec.center;
    const chartSpec = this.getChart().getSpec(), startAngle = null !== (_a = this._spec.startAngle) && void 0 !== _a ? _a : chartSpec.startAngle, endAngle = null !== (_b = this._spec.endAngle) && void 0 !== _b ? _b : chartSpec.endAngle;
    this._startAngle = degreeToRadian(null != startAngle ? startAngle : POLAR_START_ANGLE), this._endAngle = degreeToRadian(null != endAngle ? endAngle : isValid_default(startAngle) ? startAngle + 360 : POLAR_END_ANGLE), this._inverse = this._spec.inverse;
  }
  onLayoutEnd(ctx) {
    this.updateScaleRange() && (this.updateSeriesScale(), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "range"
    })), super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _initData() {
    const tickData = this._initTickDataSet(this._tickTransformOption("polar"));
    tickData.target.addListener("change", this._forceLayout.bind(this)), this._tickData = new CompilableData(this._option, tickData);
  }
  _tickTransformOption(coordinateType) {
    return Object.assign(Object.assign({}, super._tickTransformOption(coordinateType)), {
      noDecimal: this._tick.noDecimals,
      startAngle: this.startAngle,
      labelOffset: getAxisLabelOffset(this._spec),
      getRadius: () => this.getOuterRadius()
    });
  }
  afterCompile() {
    var _a;
    const product2 = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
    product2 && product2.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
      false === this._isLayout && this._delegateAxisContainerEvent(product2.getGroupGraphicItem());
    });
  }
  updateScaleRange() {
    const prevRange = this._scale.range();
    let newRange;
    return newRange = "radius" === this.getOrient() ? this._inverse ? [this.computeLayoutOuterRadius(), this.computeLayoutInnerRadius()] : [this.computeLayoutInnerRadius(), this.computeLayoutOuterRadius()] : this._inverse ? [this._endAngle, this._startAngle] : [this._startAngle, this._endAngle], (!prevRange || !newRange || prevRange[0] !== newRange[0] || prevRange[1] !== newRange[1]) && (this._scale.range(newRange), true);
  }
  collectData(depth, rawData) {
    const data = [];
    return eachSeries(this._regions, (s3) => {
      var _a, _b, _c;
      let field5;
      if (field5 = depth > 0 ? null === (_b = null === (_a = s3.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : "radius" === this.getOrient() ? s3.getRadiusField() : s3.getAngleField(), field5 = isArray_default(field5) ? isContinuous(this._scale.type) ? field5 : [field5[0]] : [field5], depth || (this._dataFieldText = s3.getFieldAlias(field5[0])), field5) {
        const viewData = s3.getViewData();
        if (rawData) field5.forEach((f2) => {
          data.push(s3.getRawDataStatisticsByField(f2, false));
        });
        else if (viewData && viewData.latestData && viewData.latestData.length) {
          const seriesData = null === (_c = s3.getViewDataStatistics) || void 0 === _c ? void 0 : _c.call(s3);
          field5.forEach((f2) => {
            var _a2;
            (null === (_a2 = null == seriesData ? void 0 : seriesData.latestData) || void 0 === _a2 ? void 0 : _a2[f2]) && data.push(seriesData.latestData[f2]);
          });
        }
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), data;
  }
  updateSeriesScale() {
    eachSeries(this._regions, (s3) => {
      "radius" === this.getOrient() ? (s3.setRadiusScale(this._scale), s3.radiusAxisHelper = this.axisHelper()) : (s3.setAngleScale(this._scale), s3.angleAxisHelper = this.axisHelper());
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getSeriesStatisticsField(s3) {
    const f2 = "radius" === this.getOrient() ? s3.getRadiusField() : s3.getAngleField();
    return isContinuous(this._scale.type) ? f2 : [f2[0]];
  }
  initGroupScales() {
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      coordToPoint: this.coordToPoint.bind(this),
      pointToCoord: this.pointToCoord.bind(this),
      center: this.getCenter.bind(this),
      getScale: (depth) => this._scales[depth],
      getAxisId: () => this.id
    };
  }
  positionToData(position) {
    const coord = this.pointToCoord(position);
    return "radius" === this.getOrient() ? this.invert(coord.radius) : this.invert(coord.angle);
  }
  coordToPoint(point6) {
    const angle2 = point6.angle, { x: centerX, y: centerY } = this.getCenter(), p2 = polarToCartesian2({
      angle: angle2,
      radius: point6.radius
    });
    return {
      x: p2.x + centerX,
      y: p2.y + centerY
    };
  }
  pointToCoord(point6) {
    const { x: centerX, y: centerY } = this.getCenter();
    let dx = point6.x - centerX, dy = point6.y - centerY;
    const startAngle = this._startAngle, endAngle = this._endAngle, radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius, dy /= radius;
    let radian = Math.atan2(dy, dx);
    if (radian < startAngle) for (; radian <= startAngle; ) radian += 2 * Math.PI;
    if (radian > endAngle) for (; radian >= endAngle; ) radian -= 2 * Math.PI;
    return {
      radius,
      angle: radian
    };
  }
  getCenter() {
    var _a, _b;
    return {
      x: (null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) || this.getRefLayoutRect().width / 2,
      y: (null === (_b = this._center) || void 0 === _b ? void 0 : _b.y) || this.getRefLayoutRect().height / 2
    };
  }
  getOuterRadius() {
    return this.computeLayoutOuterRadius();
  }
  getInnerRadius() {
    return this.computeLayoutInnerRadius();
  }
  tickValues() {
    if (this._tickData) {
      const latestData = this._tickData.getLatestData();
      if (!latestData || isArray_default(latestData)) return latestData || [];
      this.computeData("force");
    }
    return this._scale.ticks();
  }
  updateLayoutAttribute() {
    this._visible && ("radius" === this.getOrient() ? this._layoutRadiusAxis() : this._layoutAngleAxis()), super.updateLayoutAttribute();
  }
  _layoutAngleAxis() {
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), angleRange = this._endAngle - this._startAngle, items = isArray_default(this._tickData.getLatestData()) ? this._tickData.getLatestData().map((obj) => {
      const angle2 = this.dataToPosition([obj.value]);
      return {
        id: obj.value,
        label: obj.value,
        value: (angle2 - this._startAngle) / angleRange,
        rawValue: obj.value
      };
    }) : [], commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      inside: this._spec.inside,
      center: center2,
      radius,
      innerRadius,
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items: items.length ? [items] : [],
      orient: "angle"
    });
    this._spec.grid.visible && (attrs.grid = Object.assign({
      type: "line",
      smoothLink: true,
      items
    }, commonAttrs)), this._update(attrs);
  }
  _layoutRadiusAxis() {
    var _a, _b, _c;
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), endPoint = this.coordToPoint({
      angle: this._startAngle,
      radius
    }), startPoint = this.coordToPoint({
      angle: this._startAngle,
      radius: innerRadius
    }), distance2 = PointService.distancePP(startPoint, endPoint), items = isArray_default(this._tickData.getLatestData()) ? this._tickData.getLatestData().map((obj) => {
      const value = this.dataToPosition([obj.value]);
      return {
        id: obj.value,
        label: obj.value,
        value: (value - innerRadius) / distance2,
        rawValue: obj.value
      };
    }) : [], commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      start: startPoint,
      end: endPoint,
      verticalFactor: -1
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items: items.length ? [items] : [],
      orient: "radius"
    });
    (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) && (attrs.grid = Object.assign({
      items,
      type: (null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.smooth) ? "circle" : "polygon",
      center: center2,
      closed: true,
      sides: null === (_c = this._getRelatedAngleAxis()) || void 0 === _c ? void 0 : _c.tickValues().length,
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }, commonAttrs)), this._update(attrs);
  }
  _getRelatedAngleAxis() {
    const index = this._option.angleAxisIndex;
    if (isValid_default(index)) return this._option.getComponentByIndex(this.specKey, index);
  }
  computeLayoutOuterRadius() {
    var _a;
    const radius = null !== (_a = this._spec.outerRadius) && void 0 !== _a ? _a : this._spec.radius, outerRadius = null != radius ? radius : this.getRefSeriesRadius().outerRadius, { width, height } = this.getRefLayoutRect();
    return Math.min(width, height) / 2 * outerRadius;
  }
  computeLayoutInnerRadius() {
    var _a;
    const innerRadius = null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : this.getRefSeriesRadius().innerRadius, { width, height } = this.getRefLayoutRect();
    return Math.min(width, height) / 2 * innerRadius;
  }
  getRefLayoutRect() {
    return this.getRegions()[0].getLayoutRect();
  }
  getRefSeriesRadius() {
    let outerRadius = POLAR_DEFAULT_RADIUS, innerRadius = 0;
    const chartSpec = this.getChart().getSpec();
    return eachSeries(this.getRegions(), (s3) => {
      const series2 = s3;
      if (isPolarAxisSeries(series2.type)) {
        const { outerRadius: seriesRadius = chartSpec.outerRadius, innerRadius: seriesInnerRadius = chartSpec.innerRadius } = series2;
        isValidNumber_default(seriesRadius) && (outerRadius = seriesRadius), isValidNumber_default(seriesInnerRadius) && (innerRadius = seriesInnerRadius);
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), {
      outerRadius,
      innerRadius
    };
  }
  _update(attrs) {
    const { grid: gridAttrs } = attrs, axisAttrs = __rest15(attrs, ["grid"]);
    if (this._axisMark.getProduct().encode(mergeSpec({}, this._axisStyle, axisAttrs)), this._gridMark) {
      this._gridMark.getProduct().encode(mergeSpec({}, this._gridStyle, gridAttrs));
    }
  }
  invert(value) {
    var _a;
    if ("angle" === this.getOrient() && "band" === this._scale.type) {
      const range2 = this._scale.range(), rangeValue = range2[range2.length - 1] - range2[0], offset = 0.5 === (null !== (_a = this.getSpec().bandPosition) && void 0 !== _a ? _a : this._defaultBandPosition) ? 0 : this._scale.bandwidth() / 2;
      if (range2[0] < 0) {
        const transformedAngle = (value + offset + Math.abs(range2[0])) % rangeValue - Math.abs(range2[0]);
        return this._scale.invert(transformedAngle);
      }
      return this._scale.invert((value + offset) % rangeValue);
    }
    return this._scale.invert(value);
  }
};
PolarAxis.type = ComponentTypeEnum.polarAxis, PolarAxis.specKey = "axes";

// node_modules/@visactor/vchart/esm/component/axis/polar/linear-axis.js
var PolarLinearAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarLinearAxis, this._zero = true, this._nice = true, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
  }
  initScales() {
    super.initScales(), this.setScaleNice();
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
};
PolarLinearAxis.type = ComponentTypeEnum.polarLinearAxis, PolarLinearAxis.specKey = "axes", mixin(PolarLinearAxis, LinearAxisMixin);
var registerPolarLinearAxis = () => {
  registerAxis2(), Factory2.registerComponent(PolarLinearAxis.type, PolarLinearAxis);
};

// node_modules/@visactor/vchart/esm/component/axis/polar/band-axis.js
var PolarBandAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  axisHelper() {
    const helper = super.axisHelper();
    return Object.assign(Object.assign({}, helper), {
      getBandwidth: (depth) => helper.getScale(depth).bandwidth()
    });
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  transformScaleDomain() {
  }
};
PolarBandAxis.type = ComponentTypeEnum.polarBandAxis, PolarBandAxis.specKey = "axes", mixin(PolarBandAxis, BandAxisMixin);
var registerPolarBandAxis = () => {
  registerAxis2(), Factory2.registerComponent(PolarBandAxis.type, PolarBandAxis);
};

// node_modules/@visactor/vchart/esm/component/legend/discrete/util.js
var __rest16 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
function getLegendAttributes(spec, rect) {
  const { title: title3 = {}, item = {}, pager = {}, background = {}, type, id: id2, visible, orient, position, data, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = spec, attrs = __rest16(spec, ["title", "item", "pager", "background", "type", "id", "visible", "orient", "position", "data", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible && (attrs.title = transformLegendTitleAttributes(title3)), isEmpty_default(item.focusIconStyle) || transformToGraphic(item.focusIconStyle), item.shape = transformComponentStyle(item.shape), item.label = transformComponentStyle(item.label), item.value = transformComponentStyle(item.value), item.background = transformComponentStyle(item.background), isPercent(item.maxWidth) && (item.maxWidth = Number(item.maxWidth.substring(0, item.maxWidth.length - 1)) * rect.width / 100), isPercent(item.width) && (item.width = Number(item.width.substring(0, item.width.length - 1)) * rect.width / 100), isPercent(item.height) && (item.height = Number(item.height.substring(0, item.height.length - 1)) * rect.width / 100), attrs.item = item, isEmpty_default(pager.textStyle) || transformToGraphic(pager.textStyle), transformComponentStyle(pager.handler), attrs.pager = pager, background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}

// node_modules/@visactor/vchart/esm/data/transforms/legend-data/discrete/discrete.js
var discreteLegendDataMake = (data, op) => {
  const result2 = [], tempKey = {}, { series: series2, seriesField } = op;
  return series2().forEach((s3) => {
    const field5 = seriesField(s3);
    let infoList;
    infoList = field5 === s3.getSeriesField() ? s3.getSeriesInfoList() : s3.getSeriesInfoInField(field5), infoList.forEach((info) => {
      tempKey[info.key] || (tempKey[info.key] = true, result2.push(info));
    });
  }), result2;
};
var discreteLegendFilter = (data, op) => {
  var _a, _b, _c;
  const { selected, field: field5, data: legendData } = op, selectedData = selected(), legendKeys = legendData();
  if (0 === selectedData.length && legendKeys.length) return [];
  if (selectedData.length === legendKeys.length) return data;
  const selectedFilter = {};
  selectedData.forEach((s3) => {
    selectedFilter[s3] = true;
  });
  const datumField = null !== (_a = field5()) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD;
  return isArray_default(data) && (null === (_b = data[0]) || void 0 === _b ? void 0 : _b.nodes) ? (data[0].nodes = data[0].nodes.filter((d2) => true === selectedFilter[d2.key]), (null === (_c = data[0]) || void 0 === _c ? void 0 : _c.links) && (data[0].links = data[0].links.filter((d2) => true === selectedFilter[d2.source] && true === selectedFilter[d2.target]))) : isValid_default(datumField) && (data = data.filter((d2) => true === selectedFilter[d2[datumField]])), data;
};

// node_modules/@visactor/vchart/esm/component/legend/base-legend.js
var BaseLegend = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Legend, this.layoutLevel = LayoutLevel.Legend, this.specKey = "legends", this._orient = "left", this._visible = true, this._position = "middle", this._preSelectedData = [], this._selectedData = [], this.effect = {
      onSelectedDataChange: () => {
        eachSeries(this._regions, (s3) => {
          var _a;
          null === (_a = s3.getViewData()) || void 0 === _a || _a.markRunning();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }), eachSeries(this._regions, (s3) => {
          s3.reFilterViewData();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  get orient() {
    return this._orient;
  }
  get visible() {
    return this._visible;
  }
  get position() {
    return this._position;
  }
  getLegendData() {
    return this._legendData.getLatestData();
  }
  getSelectedData() {
    return this._selectedData;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._orient = isValidOrient(this._spec.orient) ? this._spec.orient : "left", this._position = null !== (_a = this._spec.position) && void 0 !== _a ? _a : "middle", this._visible = false !== this._spec.visible;
    const { regionId, regionIndex, seriesId, seriesIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionUserIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionUserIndex);
  }
  created() {
    super.created(), this.initData();
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, (null == spec ? void 0 : spec.orient) !== (null == prevSpec ? void 0 : prevSpec.orient) ? (result2.reMake = true, result2) : (isEqual(prevSpec, spec) || (result2.reCompile = true), result2);
  }
  changeRegions(regions) {
  }
  _bindLegendDataChange() {
    this._preSelectedData = this._selectedData.slice(), this._initSelectedData();
  }
  initData() {
    const legendData = this._initLegendData();
    legendData.target.addListener("change", this._bindLegendDataChange.bind(this)), this._legendData = new CompilableData(this._option, legendData), this._initSelectedData(), eachSeries(this._regions, (s3) => {
      s3.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s3.id
      }, () => {
        this._legendData.getDataView().reRunAllTransform();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  setSelectedData(selectedData) {
    var _a, _b, _c;
    const lastData = this._selectedData;
    isNil_default(selectedData) || JSON.stringify(lastData) === JSON.stringify(selectedData) || (this._selectedData = [...selectedData], null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), this.event.emit(ChartEvent.legendSelectedDataChange, {
      model: this
    }), null === (_c = this._legendComponent) || void 0 === _c || _c.setSelected(this._selectedData));
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), this._legendComponent) {
      const { x: x3, y: y3 } = pos;
      isValidNumber_default(x3 * y3) && this._legendComponent.setAttributes({
        x: x3,
        y: y3
      });
    }
  }
  getBoundsInRect(rect, fullSpace) {
    if (!this._visible) return {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    }, attrs = this._getLegendAttributes(rect);
    if (attrs.disableTriggerEvent = this._option.disableTriggerEvent, this._legendComponent) isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
      defaultSelected: this._selectedData
    }));
    else {
      const legend = new (this._getLegendConstructor())(mergeSpec({}, attrs, {
        defaultSelected: this._selectedData
      }));
      legend.name = "legend", this._legendComponent = legend;
      this.getContainer().add(legend), this._option.disableTriggerEvent || this._initEvent(), legend.on("*", (event, type) => this._delegateEvent(this._legendComponent, event, type));
    }
    this._cacheAttrs = attrs;
    const width = isFinite(this._legendComponent.AABBBounds.width()) ? this._legendComponent.AABBBounds.width() : 0, height = isFinite(this._legendComponent.AABBBounds.height()) ? this._legendComponent.AABBBounds.height() : 0;
    if ("normal-inline" !== this.layoutType) {
      const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", position = this._position, { width: rectWidth, height: rectHeight } = fullSpace;
      let offsetX = 0, offsetY = 0;
      "horizontal" === layout2 ? "middle" === position ? offsetX = (rectWidth - width) / 2 : "end" === position && (offsetX = rectWidth - width) : "middle" === position ? offsetY = (rectHeight - height) / 2 : "end" === position && (offsetY = rectHeight - height), this._legendComponent.setAttributes({
        dx: offsetX,
        dy: offsetY
      });
    }
    return result2.x2 = result2.x1 + width, result2.y2 = result2.y1 + height, result2;
  }
  onDataUpdate() {
    var _a, _b;
    if (JSON.stringify(this._preSelectedData) !== JSON.stringify(this._selectedData)) {
      if (this._legendComponent) {
        const attrs = this._getLegendAttributes(this.getLayoutRect());
        isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
          defaultSelected: this._selectedData
        }));
      }
      null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), this.event.emit(ChartEvent.legendSelectedDataChange, {
        model: this
      });
    }
  }
  _getNeedClearVRenderComponents() {
    return [this._legendComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null, this._preSelectedData = null;
  }
};
BaseLegend.specKey = "legends";

// node_modules/@visactor/vchart/esm/component/legend/discrete/legend.js
var DiscreteLegend2 = class extends BaseLegend {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.discreteLegend, this.name = ComponentTypeEnum.discreteLegend;
  }
  static getSpecInfo(chartSpec) {
    const legendSpec = chartSpec[this.specKey];
    if (!legendSpec) return;
    if (!isArray_default(legendSpec)) return legendSpec.type && "discrete" !== legendSpec.type ? void 0 : [{
      spec: legendSpec,
      specIndex: 0,
      specPath: [this.specKey],
      type: ComponentTypeEnum.discreteLegend
    }];
    const specInfos = [];
    return legendSpec.forEach((s3, i2) => {
      s3.type && "discrete" !== s3.type || specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.discreteLegend
      });
    }), specInfos;
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s3) => {
      s3.addViewDataFilter({
        type: "discreteLegendFilter",
        options: {
          selected: () => this._selectedData,
          field: () => this._getSeriesLegendField(s3),
          data: () => this._getLegendDefaultData()
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendFilter", discreteLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendDataMake", discreteLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "discreteLegendDataMake",
      options: {
        series: () => {
          const result2 = [];
          return eachSeries(this._regions, (s3) => {
            result2.push(s3);
          }, {
            specIndex: this._spec.seriesIndex,
            userId: this._spec.seriesId
          }), result2;
        },
        seriesField: (s3) => this._getSeriesLegendField(s3)
      }
    }), legendData;
  }
  _getSeriesLegendField(s3) {
    var _a, _b;
    const defaultField = s3.getSeriesField();
    if (!this._spec.scaleName) return defaultField;
    if (!s3.getRawData()) return defaultField;
    const scaleSpec = this._option.globalScale.getScaleSpec(this._spec.scaleName);
    if (!scaleSpec) return defaultField;
    if (this._spec.field) return this._spec.field;
    if (!isDataDomainSpec(scaleSpec.domain)) return defaultField;
    const seriesData = scaleSpec.domain.find((d2) => d2.dataId === s3.getRawData().name);
    return seriesData && null !== (_b = null === (_a = seriesData.fields) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : defaultField;
  }
  _initSelectedData() {
    this._spec.defaultSelected ? this._selectedData = [...this._spec.defaultSelected] : this._selectedData = this._getLegendDefaultData();
  }
  _getLegendDefaultData() {
    return isFunction_default(this._spec.data) ? this._getLegendItems().map((obj) => obj.label) : this._legendData.getLatestData().map((obj) => obj.key);
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
      if (!series2) return;
      attrs.title.text = getFieldAlias(series2.getRawData(), series2.getSeriesField());
    }
  }
  _getLegendAttributes(rect) {
    const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", attrs = Object.assign(Object.assign({
      layout: layout2,
      items: this._getLegendItems(),
      zIndex: this.layoutZIndex
    }, getLegendAttributes(this._spec, rect)), {
      maxWidth: rect.width,
      maxHeight: rect.height
    });
    return this._addDefaultTitleText(attrs), attrs;
  }
  _getLegendConstructor() {
    return DiscreteLegend;
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener(LegendEvent.legendItemClick, (e3) => {
        const selectedData = get_default(e3, "detail.currentSelected");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendItemClick, {
          model: this,
          value: selectedData,
          event: e3
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemHover, (e3) => {
        const detail = get_default(e3, "detail");
        this.event.emit(ChartEvent.legendItemHover, {
          model: this,
          value: detail,
          event: e3
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemUnHover, (e3) => {
        const detail = get_default(e3, "detail");
        this.event.emit(ChartEvent.legendItemUnHover, {
          model: this,
          value: detail,
          event: e3
        });
      });
    }
  }
  _getLegendItems() {
    const originData = (this._legendData.getLatestData() || []).map((datum) => {
      var _a, _b;
      const fillOpacity = datum.style("fillOpacity"), strokeOpacity = datum.style("strokeOpacity"), opacity = datum.style("opacity"), texture = datum.style("texture");
      return {
        label: datum.key,
        shape: {
          symbolType: null !== (_b = null !== (_a = datum.style("symbolType")) && void 0 !== _a ? _a : datum.shapeType) && void 0 !== _b ? _b : "circle",
          fillOpacity: isValidNumber_default(fillOpacity) ? fillOpacity : 1,
          strokeOpacity: isValidNumber_default(strokeOpacity) ? strokeOpacity : 1,
          opacity: isValidNumber_default(opacity) ? opacity : 1,
          texturePadding: texture ? 1 : null,
          textureSize: texture ? 4 : null,
          texture,
          fill: datum.style("fill"),
          stroke: datum.style("stroke"),
          textureColor: datum.style("textureColor"),
          innerBorder: datum.style("innerBorder"),
          outerBorder: datum.style("outerBorder"),
          lineDash: datum.style("lineDash"),
          lineDashOffset: datum.style("lineDashOffset"),
          lineWidth: datum.style("lineWidth")
        }
      };
    });
    return isFunction_default(this._spec.data) ? this._spec.data(originData, this._option.globalScale.getScale("color"), this._option.globalScale) : originData;
  }
};
DiscreteLegend2.specKey = "legends", DiscreteLegend2.type = ComponentTypeEnum.discreteLegend;
var registerDiscreteLegend = () => {
  Factory2.registerComponent(DiscreteLegend2.type, DiscreteLegend2);
};

// node_modules/@visactor/vchart/esm/data/transforms/legend-data/continuous/continuous.js
var continuousLegendDataMake = (data, op) => {
  const { series: series2, field: field5, scale: scale4 } = op, datumField = field5();
  if (field5 && datumField) {
    let min4 = Number.MAX_VALUE, max4 = Number.MIN_VALUE;
    return series2().forEach((s3) => {
      const statisticData = s3.getRawDataStatisticsByField(datumField, true), seriesMin = null == statisticData ? void 0 : statisticData.min, seriesMax = null == statisticData ? void 0 : statisticData.max;
      isValidNumber_default(seriesMin) && (min4 = seriesMin), isValidNumber_default(seriesMax) && (max4 = seriesMax);
    }), [min4, max4];
  }
  if (scale4) {
    const _scale = scale4();
    return _scale ? _scale.domain() : [];
  }
  return [];
};
var continuousLegendFilter = (data, op) => {
  const { selected, field: field5, data: legendData } = op, selectedRange = selected(), datumField = field5();
  if (selectedRange === legendData()) return data;
  if (datumField && !isEmpty_default(selectedRange)) {
    const [min4, max4] = selectedRange;
    return data.filter((datum) => datum[datumField] >= min4 && datum[datumField] <= max4);
  }
  return data;
};

// node_modules/@visactor/vchart/esm/component/legend/continuous/util.js
var __rest17 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
function getContinuousLegendAttributes(spec) {
  const _a = mergeSpec({}, spec), { title: title3 = {}, handler = {}, rail = {}, track = {}, startText, endText, handlerText, sizeBackground, background = {}, type, id: id2, visible, orient, position, data, defaultSelected, field: field5, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = _a, attrs = __rest17(_a, ["title", "handler", "rail", "track", "startText", "endText", "handlerText", "sizeBackground", "background", "type", "id", "visible", "orient", "position", "data", "defaultSelected", "field", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible && (attrs.title = transformLegendTitleAttributes(title3)), attrs.showHandler = false !== handler.visible, isEmpty_default(handler.style) || (attrs.handlerStyle = transformToGraphic(handler.style)), isValid_default(rail.width) && (attrs.railWidth = rail.width), isValid_default(rail.height) && (attrs.railHeight = rail.height), isEmpty_default(rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(track.style) || (attrs.trackStyle = transformToGraphic(track.style)), attrs.startText = transformComponentStyle(startText), attrs.endText = transformComponentStyle(endText), attrs.handlerText = transformComponentStyle(handlerText), isEmpty_default(sizeBackground) || (attrs.sizeBackground = transformToGraphic(sizeBackground)), background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}
function isContinuousLegend(type) {
  return "color" === type || "size" === type;
}
var ContinuousLegendMap = {
  color: ColorContinuousLegend,
  size: SizeContinuousLegend
};

// node_modules/@visactor/vchart/esm/component/legend/continuous/legend.js
var SINGLE_SEQUENCE = ["#C4E7FF", "#98CAFF", "#75ACFF", "#518FF9", "#2775DC", "#005CBE", "#00429F", "#00287E"];
var SIZE = [2, 10];
var ContinuousLegend = class extends BaseLegend {
  static getSpecInfo(chartSpec) {
    const legendSpec = chartSpec[this.specKey];
    if (!legendSpec) return;
    if (!isArray_default(legendSpec)) return isContinuousLegend(legendSpec.type) ? [{
      spec: legendSpec,
      specIndex: 0,
      specPath: [this.specKey],
      type: "color" === legendSpec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
    }] : void 0;
    const specInfos = [];
    return legendSpec.forEach((s3, i2) => {
      isContinuousLegend(s3.type) && specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: "color" === s3.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.colorLegend, this.name = ComponentTypeEnum.colorLegend;
    const legendName = "color" === this._spec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend;
    this.type = legendName, this.name = legendName;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._field = this._spec.field, this._legendType = this._spec.type;
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s3) => {
      s3.addViewDataFilter({
        type: "continuousLegendFilter",
        options: {
          selected: () => this._selectedData,
          field: () => this._field,
          data: () => this._legendData.getLatestData()
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _getScaleInGlobal() {
    const globalScale = this._option.globalScale;
    let scaleKey = this._spec.scale;
    return scaleKey || (scaleKey = this._legendType), globalScale.getScale(scaleKey);
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendFilter", continuousLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendDataMake", continuousLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "continuousLegendDataMake",
      options: {
        series: () => this._regions.reduce((pre, r2) => (pre.push(...r2.getSeries()), pre), []),
        field: () => this._field,
        scale: this._getScaleInGlobal.bind(this)
      }
    }), legendData;
  }
  _initSelectedData() {
    this._spec.defaultSelected ? this._selectedData = this._spec.defaultSelected.slice() : this._selectedData = this._legendData.getLatestData();
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const field5 = this._field;
      if (field5) {
        const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
        if (!series2) return;
        return void (attrs.title.text = getFieldAlias(series2.getRawData(), field5));
      }
      let scaleKey = this._spec.scale;
      scaleKey || (scaleKey = this._legendType);
      const scaleSpec = this._option.globalScale.getScaleSpec(scaleKey);
      if (!isDataDomainSpec(null == scaleSpec ? void 0 : scaleSpec.domain)) return;
      const dataInfo = scaleSpec.domain[0];
      if (0 === dataInfo.fields.length) return;
      attrs.title.text = getFieldAlias(this._option.dataSet.getDataView(dataInfo.dataId), dataInfo.fields[0]);
    } else ;
  }
  _getLegendAttributes(rect) {
    var _a, _b;
    const layout2 = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", align = "horizontal" === layout2 ? "bottom" : this.layoutOrient;
    let visualMappingRange = [];
    const scale4 = this._getScaleInGlobal();
    scale4 && "linear" === scale4.type && (visualMappingRange = scale4.range()), isEmpty_default(visualMappingRange) && (visualMappingRange = "color" === this._legendType ? SINGLE_SEQUENCE : SIZE);
    let min4 = null !== (_a = this._legendData.getLatestData()[0]) && void 0 !== _a ? _a : 0, max4 = null !== (_b = this._legendData.getLatestData()[1]) && void 0 !== _b ? _b : 1;
    this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] && (min4 = Math.min(0, this._legendData.getLatestData()[0]), max4 = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0]));
    const attrs = Object.assign({
      layout: layout2,
      align,
      zIndex: this.layoutZIndex,
      min: min4,
      max: max4,
      value: this._spec.defaultSelected,
      ["color" === this._legendType ? "colors" : "sizeRange"]: visualMappingRange
    }, getContinuousLegendAttributes(this._spec));
    return this._addDefaultTitleText(attrs), attrs;
  }
  _getLegendConstructor() {
    return ContinuousLegendMap[this._legendType];
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener("change", debounce_default((e3) => {
        const selectedData = get_default(e3, "detail.value");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendFilter, {
          model: this,
          value: selectedData,
          event: e3
        });
      }, 30));
    }
  }
};
ContinuousLegend.specKey = "legends", ContinuousLegend.type = ComponentTypeEnum.continuousLegend;
var registerContinuousLegend = () => {
  Factory2.registerComponent(ContinuousLegend.type, ContinuousLegend);
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/common.js
function escapeHTML(value) {
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\(/g, "&#40;").replace(/  /g, " &nbsp;");
}
var getTooltipContentValue = (field5, datum, params2) => isNil_default(field5) ? field5 : isFunction_default(field5) ? field5(datum, params2) : field5;
var getTooltipPatternValue = (field5, data, params2) => {
  if (isNil_default(field5)) return field5;
  if (isArray_default(field5)) {
    const result2 = [];
    return field5.forEach((item) => {
      if (isFunction_default(item)) {
        const value = item(data, params2);
        isValid_default(value) && result2.push(value);
      } else result2.push(item);
    }), result2;
  }
  return isFunction_default(field5) ? field5(data, params2) : field5;
};
function getFirstDatumFromTooltipData(data) {
  var _a;
  const dimInfoList = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.series) ? [{
    data,
    value: ""
  }] : data;
  for (const { data: dataList } of dimInfoList) for (const { datum: datumList } of dataList) for (const datumItem of null != datumList ? datumList : []) if (datumItem) return datumItem;
}
var getScale = (element, boundingClientRect) => element ? (boundingClientRect || (boundingClientRect = element.getBoundingClientRect()), element.offsetWidth > 0 ? boundingClientRect.width / element.offsetWidth : boundingClientRect.height / element.offsetHeight) : 1;
var measureTooltipText = (text2, style) => {
  var _a;
  let textLines, textConfig;
  "rich" !== (null == text2 ? void 0 : text2.type) && "html" !== (null == text2 ? void 0 : text2.type) ? (text2 = (null != text2 ? text2 : "").toString(), style.multiLine ? (textLines = text2.split("\n"), textLines = textLines.map((line2, i2) => i2 < textLines.length - 1 ? line2 + "\n" : line2)) : textLines = [text2], textConfig = textLines.map((line2) => Object.assign(Object.assign({}, style), {
    text: line2
  }))) : (textConfig = text2.text, textLines = text2);
  const bound2 = getRichTextBounds({
    wordBreak: null !== (_a = style.wordBreak) && void 0 !== _a ? _a : "break-word",
    maxWidth: style.maxWidth ? style.maxWidth : void 0,
    width: 0,
    height: 0,
    textConfig
  });
  return {
    width: bound2.width(),
    height: bound2.height(),
    text: textLines
  };
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/constants.js
var TOOLTIP_EL_CLASS_NAME = "vchart-tooltip-element";
var TOOLTIP_CONTAINER_EL_CLASS_NAME = "vchart-tooltip-container";
var TOOLTIP_MAX_LINE_COUNT = 20;
var TOOLTIP_EMPTY_STRING = "";
var TOOLTIP_OTHERS_LINE = {
  key: "其他",
  value: "..."
};
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  sanitize: escapeHTML
};
var TooltipHandlerType = class {
};
TooltipHandlerType.dom = `${PREFIX}_TOOLTIP_HANDLER_DOM`, TooltipHandlerType.canvas = `${PREFIX}_TOOLTIP_HANDLER_CANVAS`;

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/position.js
var getActualTooltipPositionValue = (position, event) => {
  let result2;
  if (isValid_default(position)) {
    if (isNumber_default(position)) result2 = position;
    else if (isFunction_default(position)) {
      const tooltipPosition = position(event);
      isNumber_default(tooltipPosition) && (result2 = tooltipPosition);
    }
  }
  return result2;
};
var positionType = {
  left: ["left", "middle"],
  right: ["right", "middle"],
  inside: ["middle", "middle"],
  top: ["middle", "top"],
  lt: ["left", "top"],
  tl: ["left", "top"],
  rt: ["right", "top"],
  tr: ["right", "top"],
  bottom: ["middle", "bottom"],
  bl: ["left", "bottom"],
  lb: ["left", "bottom"],
  br: ["right", "bottom"],
  rb: ["right", "bottom"]
};
var getHorizontalPositionType = (position, defaultCase) => {
  var _a, _b;
  return null !== (_b = null === (_a = positionType[position]) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : defaultCase;
};
var getVerticalPositionType = (position, defaultCase) => {
  var _a, _b;
  return null !== (_b = null === (_a = positionType[position]) || void 0 === _a ? void 0 : _a[1]) && void 0 !== _b ? _b : defaultCase;
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/compose.js
var getShowContent = (pattern, data, params2) => {
  var _a, _b, _c, _d, _e;
  if (!data || "mouseout" === (null === (_a = null == params2 ? void 0 : params2.event) || void 0 === _a ? void 0 : _a.type)) return null;
  const patternTitle = getTooltipPatternValue(pattern.title, data, params2), patternContent = array(getTooltipPatternValue(pattern.content, data, params2)), tooltipContent = {
    title: {
      value: null === (_b = null == patternTitle ? void 0 : patternTitle.value) || void 0 === _b ? void 0 : _b.toString(),
      hasShape: false,
      shapeType: void 0,
      shapeHollow: void 0
    },
    content: []
  }, { maxLineCount = TOOLTIP_MAX_LINE_COUNT } = pattern, patternTitleVisible = false !== getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.visible, data, params2);
  if (patternTitle && patternTitleVisible) {
    const datum = getFirstDatumFromTooltipData(data);
    tooltipContent.title = {
      value: getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.value, datum, params2),
      valueStyle: getTooltipContentValue(null == patternTitle ? void 0 : patternTitle.valueStyle, datum, params2),
      hasShape: patternTitle.hasShape
    };
  } else tooltipContent.title = {
    hasShape: false,
    visible: false
  };
  if ("mark" === pattern.activeType) for (const content of null != patternContent ? patternContent : []) {
    const oneLineData = getOneLineData(null === (_c = data[0]) || void 0 === _c ? void 0 : _c.datum[0], content, params2);
    if (false !== oneLineData.visible) {
      if (tooltipContent.content.length === maxLineCount - 1) {
        tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), TOOLTIP_OTHERS_LINE));
        break;
      }
      if (!(tooltipContent.content.length < maxLineCount)) break;
      tooltipContent.content.push(oneLineData);
    }
  }
  else if ("dimension" === pattern.activeType) for (const { data: d2 } of data) {
    for (const { datum, series: series2 } of d2) {
      if (!getTooltipActualActiveType(null === (_d = series2.tooltipHelper) || void 0 === _d ? void 0 : _d.spec).includes("dimension")) continue;
      const contentPatterns = null !== (_e = null == patternContent ? void 0 : patternContent.filter((c4) => isNil_default(c4.seriesId) || c4.seriesId === series2.id)) && void 0 !== _e ? _e : [];
      for (const datumItem of datum) {
        for (const linePattern of contentPatterns) {
          const oneLineData = getOneLineData(datumItem, linePattern, params2);
          if (false !== oneLineData.visible) {
            if (tooltipContent.content.length === maxLineCount - 1) {
              tooltipContent.content.push(Object.assign(Object.assign({}, oneLineData), TOOLTIP_OTHERS_LINE));
              break;
            }
            if (!(tooltipContent.content.length < maxLineCount)) break;
            tooltipContent.content.push(oneLineData);
          }
        }
        if (tooltipContent.content.length >= maxLineCount) break;
      }
      if (tooltipContent.content.length >= maxLineCount) break;
    }
    if (tooltipContent.content.length >= maxLineCount) break;
  }
  return tooltipContent.title && (tooltipContent.content.length > 0 && tooltipContent.content[0].shapeType ? (isNil_default(tooltipContent.title.shapeType) && (tooltipContent.title.shapeType = tooltipContent.content[0].shapeType), isNil_default(tooltipContent.title.shapeColor) && (tooltipContent.title.shapeColor = tooltipContent.content[0].shapeColor)) : tooltipContent.title.hasShape = false), tooltipContent;
};
var getOneLineData = (datum, config2, params2) => {
  const key = getTooltipContentValue(config2.key, datum, params2), value = getTooltipContentValue(config2.value, datum, params2), visible = false !== getTooltipContentValue(config2.visible, datum, params2) && (isValid_default(key) || isValid_default(value)), isKeyAdaptive = getTooltipContentValue(config2.isKeyAdaptive, datum, params2), spaceRow = getTooltipContentValue(config2.spaceRow, datum, params2), shapeType = getTooltipContentValue(config2.shapeType, datum, params2), shapeColor = getTooltipContentValue(config2.shapeColor, datum, params2), shapeFill = getTooltipContentValue(config2.shapeFill, datum, params2), shapeStroke = getTooltipContentValue(config2.shapeStroke, datum, params2), shapeLineWidth = getTooltipContentValue(config2.shapeLineWidth, datum, params2), keyStyle = getTooltipContentValue(config2.keyStyle, datum, params2), valueStyle = getTooltipContentValue(config2.valueStyle, datum, params2);
  return {
    key,
    value,
    visible,
    isKeyAdaptive,
    hasShape: config2.hasShape,
    shapeType,
    shapeFill,
    shapeStroke,
    shapeLineWidth,
    shapeHollow: config2.shapeHollow,
    shapeColor,
    keyStyle,
    valueStyle,
    spaceRow,
    datum
  };
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/pattern.js
var makeDefaultPattern = (series2, activeType, dimensionInfo) => {
  var _a, _b;
  return null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.getDefaultTooltipPattern(activeType, dimensionInfo)) && void 0 !== _b ? _b : null;
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/get-spec.js
var getTooltipSpecForShow = (activeType, globalSpec, series2, dimensionInfo) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const finalSpec = Object.assign(Object.assign({}, globalSpec), {
    activeType
  });
  if ("mark" === activeType && series2) {
    const seriesSpec = null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
    if (isValid_default(seriesSpec.visible) || isValid_default(seriesSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(seriesSpec).includes("mark") : isValid_default(globalSpec.visible) || isValid_default(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes("mark") : finalSpec.visible = true, finalSpec.handler = null !== (_d = null !== (_c = seriesSpec.handler) && void 0 !== _c ? _c : globalSpec.handler) && void 0 !== _d ? _d : void 0, null === (_e = finalSpec.handler) || void 0 === _e ? void 0 : _e.showTooltip) return finalSpec;
  } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
    if (getSeriesListFromDimensionInfo(dimensionInfo).every((series3) => {
      var _a2;
      return !getTooltipActualActiveType(null === (_a2 = series3.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.spec).includes("dimension");
    }) ? finalSpec.visible = false : isValid_default(globalSpec.visible) || isValid_default(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes("dimension") : finalSpec.visible = true, finalSpec.handler = null !== (_f = globalSpec.handler) && void 0 !== _f ? _f : void 0, null === (_g = finalSpec.handler) || void 0 === _g ? void 0 : _g.showTooltip) return finalSpec;
  }
  const defaultPattern = getDefaultTooltipPattern(activeType, series2, dimensionInfo), seriesPattern = getSeriesTooltipPattern(activeType, series2, dimensionInfo), userPattern = mergeSpec({}, cloneDeep(globalSpec[activeType]), seriesPattern), defaultPatternTitle = defaultPattern.title, titleShape = getShapePattern(void 0, userPattern, void 0, defaultPatternTitle);
  if (isValid_default(userPattern.title)) if (isFunction_default(userPattern.title)) {
    const userPatternTitle = userPattern.title;
    userPattern.title = (data, params2) => {
      var _a2;
      const userResult = null !== (_a2 = userPatternTitle(data, params2)) && void 0 !== _a2 ? _a2 : {};
      return Object.assign(Object.assign({}, titleShape), userResult);
    };
  } else userPattern.title = Object.assign(Object.assign(Object.assign({}, defaultPattern.title), titleShape), userPattern.title);
  else userPattern.title = Object.assign(Object.assign({}, defaultPattern.title), titleShape);
  const defaultPatternContent = array(defaultPattern.content);
  if (isValid_default(userPattern.content)) {
    const shapePatternMap = getShapePatternMapOfEachSeries(defaultPatternContent);
    if (isFunction_default(userPattern.content)) {
      const userPatternContent = userPattern.content;
      userPattern.content = (data, params2) => {
        var _a2;
        const newPatternContent = [];
        return array(null !== (_a2 = userPatternContent(data, params2)) && void 0 !== _a2 ? _a2 : []).forEach((userLine) => {
          newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
        }), newPatternContent;
      };
    } else {
      const newPatternContent = [];
      array(userPattern.content).forEach((userLine) => {
        newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
      }), userPattern.content = newPatternContent;
    }
  } else userPattern.content = defaultPatternContent.map((line2) => Object.assign(Object.assign({}, line2), getShapePattern(void 0, userPattern, void 0, line2)));
  return finalSpec[activeType] = Object.assign(Object.assign(Object.assign({}, defaultPattern), userPattern), {
    activeType
  }), finalSpec;
};
var getDefaultTooltipPattern = (activeType, series2, dimensionInfo) => {
  var _a;
  let defaultPattern = {};
  if ("mark" === activeType && series2) defaultPattern = null !== (_a = makeDefaultPattern(series2, "mark")) && void 0 !== _a ? _a : {};
  else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
    const patternList = [];
    dimensionInfo[0].data.forEach((data) => {
      const { series: series3 } = data, mockDimensionInfo = [Object.assign(Object.assign({}, dimensionInfo[0]), {
        data: [data]
      })], pattern = makeDefaultPattern(series3, "dimension", mockDimensionInfo);
      pattern && patternList.push(pattern);
    });
    const defaultPatternContent = [];
    patternList.forEach(({ content }) => {
      isFunction_default(content) ? defaultPatternContent.push(content) : defaultPatternContent.push(...array(content));
    }), defaultPattern = Object.assign(Object.assign({}, patternList[0]), {
      content: defaultPatternContent
    });
  }
  return defaultPattern;
};
var getSeriesTooltipPattern = (activeType, series2, dimensionInfo) => {
  var _a, _b;
  let seriesPattern = {};
  if ("mark" === activeType && series2) {
    const seriesSpec = null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
    seriesPattern = seriesSpec.mark ? cloneDeep(seriesSpec.mark) : {};
  } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
    const seriesPatternList = getSeriesListFromDimensionInfo(dimensionInfo).filter((series3) => {
      var _a2;
      const spec = null === (_a2 = series3.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.spec;
      return isValid_default(null == spec ? void 0 : spec.dimension) && getTooltipActualActiveType(spec).includes("dimension");
    }).map((series3) => series3.tooltipHelper.spec.dimension);
    if (seriesPatternList.length) {
      let seriesPatternContent = [];
      seriesPatternList.every(({ content }) => isNil_default(content)) ? seriesPatternContent = void 0 : seriesPatternList.forEach(({ content }) => {
        isNil_default(content) || (isFunction_default(content) ? null == seriesPatternContent || seriesPatternContent.push(content) : null == seriesPatternContent || seriesPatternContent.push(...array(content)));
      }), seriesPattern = Object.assign(Object.assign({}, seriesPatternList[0]), {
        content: seriesPatternContent
      });
    }
  }
  return seriesPattern;
};
var getSeriesListFromDimensionInfo = memoize((dimensionInfo) => dimensionInfo.reduce((list, cur) => list.concat(cur.data.map((data) => data.series).filter(isValid_default)), []));
var getShapePatternMapOfEachSeries = (content) => {
  const shapePatternMap = {};
  return content.forEach((line2) => {
    var _a;
    const key = null !== (_a = line2.seriesId) && void 0 !== _a ? _a : 0;
    shapePatternMap[key] || (shapePatternMap[key] = line2);
  }), shapePatternMap;
};
var getShapePattern = (userLinePattern, userPattern, shapePatternMap, defaultShapePattern) => {
  var _a, _b;
  const shapePatternFromMap = null !== (_b = null == shapePatternMap ? void 0 : shapePatternMap[null !== (_a = null == userLinePattern ? void 0 : userLinePattern.seriesId) && void 0 !== _a ? _a : 0]) && void 0 !== _b ? _b : null == shapePatternMap ? void 0 : shapePatternMap[0], shapeKeys = new Set([].concat(Object.keys(null != userLinePattern ? userLinePattern : {}), Object.keys(null != userPattern ? userPattern : {}), Object.keys(null != shapePatternFromMap ? shapePatternFromMap : {}), Object.keys(null != defaultShapePattern ? defaultShapePattern : {})).filter((key) => key.toLowerCase().includes("shape"))), shapePattern = {};
  return shapeKeys.forEach((key) => {
    var _a2, _b2, _c;
    const value = null !== (_c = null !== (_b2 = null !== (_a2 = null == userLinePattern ? void 0 : userLinePattern[key]) && void 0 !== _a2 ? _a2 : null == userPattern ? void 0 : userPattern[key]) && void 0 !== _b2 ? _b2 : null == shapePatternFromMap ? void 0 : shapePatternFromMap[key]) && void 0 !== _c ? _c : null == defaultShapePattern ? void 0 : defaultShapePattern[key];
    void 0 !== value && (shapePattern[key] = value);
  }), shapePattern;
};

// node_modules/@visactor/vchart/esm/component/tooltip/interface/common.js
var TooltipResult;
!function(TooltipResult2) {
  TooltipResult2[TooltipResult2.success = 0] = "success", TooltipResult2[TooltipResult2.failed = 1] = "failed";
}(TooltipResult || (TooltipResult = {}));

// node_modules/@visactor/vchart/esm/component/tooltip/handler/utils/attribute.js
var DEFAULT_TEXT_ATTRIBUTES = {
  fontFamily: THEME_CONSTANTS.defaultFontFamily,
  spacing: 10,
  wordBreak: "break-word"
};
function getTextAttributes(style = {}, globalTheme2, defaultAttributes2) {
  var _a, _b;
  return Object.assign(Object.assign({}, null != defaultAttributes2 ? defaultAttributes2 : DEFAULT_TEXT_ATTRIBUTES), {
    fill: null !== (_a = style.fill) && void 0 !== _a ? _a : style.fontColor,
    textAlign: style.textAlign,
    textBaseline: style.textBaseline,
    fontFamily: null !== (_b = style.fontFamily) && void 0 !== _b ? _b : null == globalTheme2 ? void 0 : globalTheme2.fontFamily,
    fontSize: style.fontSize,
    fontWeight: style.fontWeight,
    lineHeight: style.lineHeight,
    spacing: style.spacing,
    multiLine: style.multiLine,
    maxWidth: style.maxWidth,
    wordBreak: style.wordBreak,
    autoWidth: style.autoWidth
  });
}
var getPanelAttributes = (style) => {
  var _a;
  const { backgroundColor, border, shadow } = style, panelAttrs = {
    lineWidth: null !== (_a = null == border ? void 0 : border.width) && void 0 !== _a ? _a : 0,
    shadow: !!shadow
  };
  (null == border ? void 0 : border.color) && (panelAttrs.stroke = border.color), backgroundColor && (panelAttrs.fill = backgroundColor), shadow && (panelAttrs.shadowColor = shadow.color, panelAttrs.shadowBlur = shadow.blur, panelAttrs.shadowOffsetX = shadow.x, panelAttrs.shadowOffsetY = shadow.y, panelAttrs.shadowSpread = shadow.spread);
  const { radius } = null != border ? border : {};
  return isValid_default(radius) && (panelAttrs.cornerRadius = [radius, radius, radius, radius]), panelAttrs;
};
var getTooltipAttributes = (actualTooltip, spec, globalTheme2) => {
  var _a, _b, _c, _d, _e;
  const { style = {}, enterable, transitionDuration } = spec, { panel = {}, titleLabel, shape, keyLabel, valueLabel, spaceRow: commonSpaceRow } = style, padding = normalizePadding(panel.padding), paddingSpec = normalizeLayoutPaddingSpec(panel.padding), titleStyle = getTextAttributes(titleLabel, globalTheme2), keyStyle = getTextAttributes(keyLabel, globalTheme2), valueStyle = getTextAttributes(valueLabel, globalTheme2), shapeStyle = {
    fill: true,
    size: null !== (_a = null == shape ? void 0 : shape.size) && void 0 !== _a ? _a : 8,
    spacing: null !== (_b = null == shape ? void 0 : shape.spacing) && void 0 !== _b ? _b : 6
  }, attributes = {
    panel: getPanelAttributes(panel),
    padding,
    title: {},
    content: [],
    titleStyle: {
      value: titleStyle,
      spaceRow: commonSpaceRow
    },
    contentStyle: {
      shape: shapeStyle,
      key: keyStyle,
      value: valueStyle,
      spaceRow: commonSpaceRow
    },
    hasContentShape: false,
    keyWidth: 0,
    valueWidth: 0,
    enterable,
    transitionDuration
  }, { title: title3 = {}, content = [] } = actualTooltip;
  let containerWidth = paddingSpec.left + paddingSpec.right, containerHeight = paddingSpec.top + paddingSpec.bottom, contentMaxWidth = 0;
  const filteredContent = content.filter((item) => (item.key || item.value) && false !== item.visible), hasContent = !!filteredContent.length;
  let maxKeyWidth = 0, maxAdaptiveKeyWidth = 0, maxValueWidth = 0, maxShapeWidth = 0;
  if (hasContent) {
    const keyWidths = [], adaptiveKeyWidths = [], valueWidths = [], shapeWidths = [];
    attributes.content = filteredContent.map((item, i2) => {
      let itemHeight = 0;
      const { hasShape: actualHasShape, key: actualKey, shapeType: actualShapeType = "", shapeFill: actualShapeFill, shapeStroke: actualShapeStroke, shapeLineWidth: actualShapeLineWidth, shapeSize: actualShapeSize, value: actualValue, isKeyAdaptive: actualIsKeyAdaptive, spaceRow: actualSpaceRow, keyStyle: actualKeyStyle, valueStyle: actualValueStyle, shapeColor: actualShapeColor, shapeHollow: actualShapeHollow } = item, itemAttrs = {
        height: 0,
        spaceRow: null != actualSpaceRow ? actualSpaceRow : commonSpaceRow
      };
      if (isValid_default(actualKey)) {
        const itemKeyStyle = mergeSpec({}, keyStyle, getTextAttributes(actualKeyStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualKey, itemKeyStyle);
        itemAttrs.key = Object.assign(Object.assign({
          width,
          height
        }, itemKeyStyle), {
          text: text2
        }), actualIsKeyAdaptive ? adaptiveKeyWidths.push(width) : keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (isValid_default(actualValue)) {
        const itemValueStyle = mergeSpec({}, valueStyle, getTextAttributes(actualValueStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualValue, itemValueStyle);
        itemAttrs.value = Object.assign(Object.assign({
          width,
          height
        }, itemValueStyle), {
          text: text2
        }), valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (actualHasShape) {
        const shape2 = {
          visible: true,
          symbolType: actualShapeType
        }, adaptiveShapeFill = null != actualShapeFill ? actualShapeFill : actualShapeColor;
        actualShapeHollow ? shape2.stroke = adaptiveShapeFill : shape2.fill = adaptiveShapeFill, shape2.stroke = null != actualShapeStroke ? actualShapeStroke : adaptiveShapeFill, shape2.lineWidth = actualShapeLineWidth, itemAttrs.shape = shape2;
        const shapeWidth = null != actualShapeSize ? actualShapeSize : shapeStyle.size;
        itemHeight = Math.max(shapeWidth, itemHeight), shapeWidths.push(shapeWidth);
      } else itemAttrs.shape = {
        visible: false
      };
      return itemAttrs.height = itemHeight, containerHeight += itemHeight, i2 < filteredContent.length - 1 && (containerHeight += itemAttrs.spaceRow), itemAttrs;
    }), maxKeyWidth = keyWidths.length ? maxInArray(keyWidths) : 0, maxAdaptiveKeyWidth = adaptiveKeyWidths.length ? maxInArray(adaptiveKeyWidths) : 0, maxValueWidth = valueWidths.length ? maxInArray(valueWidths) : 0, maxShapeWidth = shapeWidths.length ? maxInArray(shapeWidths) + shapeStyle.spacing : 0, contentMaxWidth = Math.max(maxShapeWidth + maxKeyWidth + keyStyle.spacing + maxValueWidth + valueStyle.spacing, maxShapeWidth + maxAdaptiveKeyWidth, contentMaxWidth), attributes.hasContentShape = !!shapeWidths.length, attributes.keyWidth = maxKeyWidth, attributes.valueWidth = maxValueWidth;
  }
  let titleMaxWidth = 0, titleMaxHeight = 0;
  const { visible: actualTitleVisible = true, value: actualTitleValue = "", valueStyle: actualTitleValueStyle, spaceRow: actualTitleSpaceRow } = title3;
  attributes.title.visible = actualTitleVisible, attributes.title.spaceRow = null != actualTitleSpaceRow ? actualTitleSpaceRow : commonSpaceRow;
  let titleValueStyle = {};
  const isAutoWidthMode = () => titleValueStyle.autoWidth && false !== titleValueStyle.multiLine;
  if (actualTitleVisible) {
    titleValueStyle = mergeSpec({}, titleStyle, getTextAttributes(actualTitleValueStyle, void 0, {})), isAutoWidthMode() && (titleValueStyle.multiLine = null === (_c = titleValueStyle.multiLine) || void 0 === _c || _c, titleValueStyle.maxWidth = null !== (_d = titleValueStyle.maxWidth) && void 0 !== _d ? _d : hasContent ? Math.ceil(contentMaxWidth) : void 0);
    const { text: text2, width, height } = measureTooltipText(actualTitleValue, titleValueStyle);
    attributes.title.value = Object.assign(Object.assign({
      width: isAutoWidthMode() ? Math.min(width, null !== (_e = titleValueStyle.maxWidth) && void 0 !== _e ? _e : Number.MAX_VALUE) : width,
      height
    }, titleValueStyle), {
      text: text2
    }), titleMaxWidth = attributes.title.value.width, titleMaxHeight = attributes.title.value.height, containerHeight += titleMaxHeight + (hasContent ? attributes.title.spaceRow : 0);
  }
  return attributes.title.width = titleMaxWidth, attributes.title.height = titleMaxHeight, isAutoWidthMode() ? containerWidth += contentMaxWidth || titleMaxWidth : containerWidth += Math.max(titleMaxWidth, contentMaxWidth), hasContent && attributes.content.forEach((item) => {
    var _a2;
    const value = item.value;
    value && (null === (_a2 = value.autoWidth) || void 0 === _a2 || _a2) && (value.width = containerWidth - paddingSpec.left - paddingSpec.right - maxShapeWidth - maxKeyWidth - keyStyle.spacing - valueStyle.spacing, value.maxWidth || (value.maxWidth = Math.ceil(value.width)), attributes.valueWidth = Math.max(attributes.valueWidth, value.width));
  }), attributes.panel.width = containerWidth, attributes.panel.height = containerHeight, attributes;
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/base.js
var BaseTooltipHandler = class {
  get id() {
    return this._id;
  }
  get env() {
    return this._env;
  }
  constructor(tooltipId, component2) {
    this._visible = true, this._id = "", this._attributes = null, this._isReleased = false, this.showTooltip = (activeType, data, params2) => {
      var _a;
      let changePositionOnly = !!params2.changePositionOnly;
      return params2.changePositionOnly && (null === (_a = this._cacheActualTooltip) || void 0 === _a ? void 0 : _a.activeType) === activeType || (changePositionOnly = false, this._clearCacheOfContent()), changePositionOnly && this._cacheViewSpec && this._cacheActualTooltip ? this.changeTooltipPosition(changePositionOnly, data, params2) : this.changeTooltip(true, params2, changePositionOnly, activeType, data);
    }, this._changeTooltip = (visible, params2, changePositionOnly, activeType, data) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      const tooltipSpec = this._component.getSpec();
      if (this._isReleased || !tooltipSpec) return TooltipResult.failed;
      if (!visible) return this._clearAllCache(), tooltipSpec.handler ? null !== (_c = null === (_b = (_a = tooltipSpec.handler).hideTooltip) || void 0 === _b ? void 0 : _b.call(_a, params2)) && void 0 !== _c ? _c : TooltipResult.success : (this._updateTooltip(false, params2), TooltipResult.success);
      if (isNil_default(activeType) || isNil_default(data)) return TooltipResult.failed;
      let spec;
      if (changePositionOnly && this._cacheViewSpec ? spec = this._cacheViewSpec : (spec = getTooltipSpecForShow(activeType, tooltipSpec, params2.model, params2.dimensionInfo), this._cacheViewSpec = spec), false === spec.visible) return TooltipResult.failed;
      if (spec.handler) return null !== (_f = null === (_e = (_d = spec.handler).showTooltip) || void 0 === _e ? void 0 : _e.call(_d, activeType, data, params2)) && void 0 !== _f ? _f : TooltipResult.success;
      const pattern = spec[activeType];
      if (!pattern) return TooltipResult.failed;
      let actualTooltip;
      return changePositionOnly && this._cacheActualTooltip ? actualTooltip = this._cacheActualTooltip : (actualTooltip = this._getActualTooltipContent(pattern, data, params2), actualTooltip.title = null !== (_h = null === (_g = pattern.updateTitle) || void 0 === _g ? void 0 : _g.call(pattern, actualTooltip.title, data, params2)) && void 0 !== _h ? _h : actualTooltip.title, actualTooltip.content = null !== (_k = null === (_j = pattern.updateContent) || void 0 === _j ? void 0 : _j.call(pattern, actualTooltip.content, data, params2)) && void 0 !== _k ? _k : actualTooltip.content), isNil_default(null === (_l = actualTooltip.title) || void 0 === _l ? void 0 : _l.key) && isNil_default(null === (_m = actualTooltip.title) || void 0 === _m ? void 0 : _m.value) && !(null === (_o = actualTooltip.content) || void 0 === _o ? void 0 : _o.length) ? TooltipResult.failed : (this._cacheActualTooltip = actualTooltip, this._changeTooltipPosition(!!changePositionOnly, data, params2));
    }, this._changeTooltipPosition = (changePositionOnly, data, params2) => {
      var _a, _b, _c;
      if (this._isReleased) return TooltipResult.failed;
      const event = params2.event, spec = this._cacheViewSpec, actualTooltip = this._cacheActualTooltip;
      if (!spec || !actualTooltip) return TooltipResult.failed;
      if (spec.enterable) {
        if (!this._isPointerEscaped && this._isPointerMovingToTooltip(params2)) return this._isTooltipPaused || (this._isTooltipPaused = true, this._cachePointerTimer = setTimeout(() => {
          this._isPointerEscaped = true;
        }, 300)), TooltipResult.success;
        this._isTooltipPaused = false, this._isPointerEscaped = false, clearTimeout(this._cachePointerTimer), this._cachePointerPosition = this._getPointerPositionRelativeToTooltipParent(params2);
      }
      const activeType = actualTooltip.activeType;
      if (spec.handler) return null !== (_c = null === (_b = (_a = spec.handler).showTooltip) || void 0 === _b ? void 0 : _b.call(_a, activeType, data, params2)) && void 0 !== _c ? _c : TooltipResult.success;
      const pattern = spec[activeType];
      if (!pattern) return TooltipResult.failed;
      const position = this._getActualTooltipPosition(actualTooltip, params2, this._getTooltipBoxSize(actualTooltip, changePositionOnly));
      actualTooltip.position = position, pattern.updatePosition && (actualTooltip.position = pattern.updatePosition(actualTooltip.position, data, params2));
      let tooltipVisible = false !== (null == pattern ? void 0 : pattern.visible);
      return data && "pointerout" !== event.type && actualTooltip.visible && (actualTooltip.title || actualTooltip.content) || (tooltipVisible = false), this._updateTooltip(tooltipVisible, Object.assign(Object.assign({}, params2), {
        changePositionOnly
      }), actualTooltip), TooltipResult.success;
    }, this._getActualTooltipContent = (pattern, data, params2) => {
      const patternVisible = getTooltipPatternValue(pattern.visible, data, params2);
      let tooltipContent = null;
      tooltipContent = getShowContent(pattern, data, params2);
      return Object.assign(Object.assign({}, tooltipContent), {
        visible: !!isValid_default(tooltipContent) && false !== patternVisible,
        activeType: pattern.activeType,
        data
      });
    }, this._getActualTooltipPosition = (actualTooltip, params2, tooltipBoxSize) => {
      var _a, _b, _c, _d, _e;
      const event = params2.event, invalidPosition = {
        x: 1 / 0,
        y: 1 / 0
      }, { offsetX, offsetY } = this._option, tooltipSpec = this._cacheViewSpec;
      if (!tooltipSpec) return this._cacheTooltipPosition = void 0, invalidPosition;
      const { activeType, data } = actualTooltip, pattern = tooltipSpec[activeType], position = getTooltipPatternValue(pattern.position, data, params2), positionMode = getTooltipPatternValue(pattern.positionMode, data, params2), tooltipParentElement = this._getParentElement(tooltipSpec), { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = null != tooltipBoxSize ? tooltipBoxSize : {}, isCanvas = "canvas" === tooltipSpec.renderMode, canvasRect = null === (_a = null == params2 ? void 0 : params2.chart) || void 0 === _a ? void 0 : _a.getCanvasRect(), canvasWidth = null !== (_b = null == canvasRect ? void 0 : canvasRect.width) && void 0 !== _b ? _b : DEFAULT_CHART_WIDTH, canvasHeight = null !== (_c = null == canvasRect ? void 0 : canvasRect.height) && void 0 !== _c ? _c : DEFAULT_CHART_HEIGHT;
      let isFixedPosition = false;
      const containerSize = {
        width: 0,
        height: 0
      };
      let relativePosOffset = {
        x: 0,
        y: 0
      }, tooltipParentElementRect = {
        x: 0,
        y: 0
      }, chartElementScale = 1, tooltipParentElementScale = 1;
      if (isTrueBrowser(this._env) && !tooltipSpec.confine) {
        if (containerSize.width = window.innerWidth, containerSize.height = window.innerHeight, !isCanvas) {
          tooltipParentElementRect = null !== (_d = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _d ? _d : invalidPosition;
          const chartElement = null !== (_e = this._compiler.getCanvas()) && void 0 !== _e ? _e : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
          relativePosOffset = {
            x: chartElementRect.x - tooltipParentElementRect.x,
            y: chartElementRect.y - tooltipParentElementRect.y
          }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
        }
      } else containerSize.width = canvasWidth, containerSize.height = canvasHeight;
      const tooltipSizeScale = tooltipParentElementScale / chartElementScale;
      let left2, top, right2, bottom, x3, y3;
      if (isObject_default(position)) {
        const { left: posLeft, right: posRight, top: posTop, bottom: posBottom } = position;
        left2 = getActualTooltipPositionValue(posLeft, event), top = getActualTooltipPositionValue(posTop, event), right2 = getActualTooltipPositionValue(posRight, event), bottom = getActualTooltipPositionValue(posBottom, event);
      } else if (isValid_default(position) && "pointer" !== positionMode && "mark" === actualTooltip.activeType) {
        isFixedPosition = true;
        const element = params2.item, model = params2.model, bounds = null == element ? void 0 : element.getBounds(), startPoint = null == model ? void 0 : model.getLayoutStartPoint();
        if (bounds && startPoint) {
          let { x1: x14, y1: y14, x2: x23, y2: y23 } = bounds;
          switch (x14 += startPoint.x, x23 += startPoint.x, y14 += startPoint.y, y23 += startPoint.y, getHorizontalPositionType(position)) {
            case "left":
              left2 = x14 - tooltipBoxWidth * tooltipSizeScale - offsetX;
              break;
            case "right":
              left2 = x23 + offsetX;
              break;
            case "middle":
              left2 = (x14 + x23) / 2 - tooltipBoxWidth * tooltipSizeScale / 2;
          }
          switch (getVerticalPositionType(position)) {
            case "top":
              top = y14 - tooltipBoxHeight * tooltipSizeScale - offsetY;
              break;
            case "bottom":
              top = y23 + offsetY;
              break;
            case "middle":
              top = (y14 + y23) / 2 - tooltipBoxHeight * tooltipSizeScale / 2;
          }
        }
      }
      const { canvasX, canvasY } = event;
      if (isValidNumber_default(left2)) x3 = left2;
      else if (isValidNumber_default(right2)) x3 = canvasWidth - tooltipBoxWidth * tooltipSizeScale - right2;
      else {
        const x05 = canvasX;
        switch (getHorizontalPositionType(position, "right")) {
          case "middle":
            x3 = x05 - tooltipBoxWidth * tooltipSizeScale / 2;
            break;
          case "left":
            x3 = x05 - tooltipBoxWidth * tooltipSizeScale - offsetX;
            break;
          case "right":
            x3 = x05 + offsetX;
        }
      }
      if (isValidNumber_default(top)) y3 = top;
      else if (isValidNumber_default(bottom)) y3 = canvasHeight - tooltipBoxHeight * tooltipSizeScale - bottom;
      else {
        const y05 = canvasY;
        switch (getVerticalPositionType(position, "bottom")) {
          case "middle":
            y3 = y05 - tooltipBoxHeight * tooltipSizeScale / 2;
            break;
          case "top":
            y3 = y05 - tooltipBoxHeight * tooltipSizeScale - offsetY;
            break;
          case "bottom":
            y3 = y05 + offsetY;
        }
      }
      x3 *= chartElementScale, y3 *= chartElementScale, isTrueBrowser(this._env) && (x3 += relativePosOffset.x, y3 += relativePosOffset.y), x3 /= tooltipParentElementScale, y3 /= tooltipParentElementScale;
      const { width: containerWidth, height: containerHeight } = containerSize, isLeftOut = () => x3 * tooltipParentElementScale + tooltipParentElementRect.x < 0, isRightOut = () => (x3 + tooltipBoxWidth) * tooltipParentElementScale + tooltipParentElementRect.x > containerWidth, isTopOut = () => y3 * tooltipParentElementScale + tooltipParentElementRect.y < 0, isBottomOut = () => (y3 + tooltipBoxHeight) * tooltipParentElementScale + tooltipParentElementRect.y > containerHeight, detectLeftFirst = () => {
        isLeftOut() && (isFixedPosition ? x3 = -tooltipParentElementRect.x / tooltipParentElementScale : "middle" === getHorizontalPositionType(position, "right") ? x3 += offsetX + tooltipBoxWidth / 2 : x3 += 2 * offsetX + tooltipBoxWidth);
      }, detectLeftLast = () => {
        isLeftOut() && (x3 = -tooltipParentElementRect.x / tooltipParentElementScale);
      }, detectRightFirst = () => {
        isRightOut() && (isFixedPosition ? x3 = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth : "middle" === getHorizontalPositionType(position, "right") ? x3 -= offsetX + tooltipBoxWidth / 2 : x3 -= 2 * offsetX + tooltipBoxWidth);
      }, detectRightLast = () => {
        isRightOut() && (x3 = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth);
      }, detectTopFirst = () => {
        isTopOut() && (isFixedPosition ? y3 = -tooltipParentElementRect.y / tooltipParentElementScale : "middle" === getVerticalPositionType(position, "bottom") ? y3 += offsetY + tooltipBoxHeight / 2 : y3 += 2 * offsetY + tooltipBoxHeight);
      }, detectTopLast = () => {
        isTopOut() && (y3 = 0 - tooltipParentElementRect.y / tooltipParentElementScale);
      }, detectBottomFirst = () => {
        isBottomOut() && (isFixedPosition ? y3 = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight : "middle" === getVerticalPositionType(position, "bottom") ? y3 -= offsetY + tooltipBoxHeight / 2 : y3 -= 2 * offsetY + tooltipBoxHeight);
      }, detectBottomLast = () => {
        isBottomOut() && (y3 = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight);
      };
      switch (getHorizontalPositionType(position, "right")) {
        case "middle":
          isLeftOut() ? (detectLeftFirst(), detectRightLast()) : (detectRightFirst(), detectLeftLast());
          break;
        case "left":
          detectLeftFirst(), detectRightLast();
          break;
        case "right":
          detectRightFirst(), detectLeftLast();
      }
      switch (getVerticalPositionType(position, "bottom")) {
        case "middle":
          isTopOut() ? (detectTopFirst(), detectBottomLast()) : (detectBottomFirst(), detectTopLast());
          break;
        case "top":
          detectTopFirst(), detectBottomLast();
          break;
        case "bottom":
          detectBottomFirst(), detectTopLast();
      }
      const result2 = {
        x: x3,
        y: y3
      };
      return this._cacheTooltipPosition = result2, this._cacheTooltipSize = {
        width: tooltipBoxWidth,
        height: tooltipBoxHeight
      }, result2;
    }, this._component = component2, this._chartOption = component2.getOption(), this._env = this._chartOption.mode, this._chartContainer = this._chartOption.globalInstance.getContainer(), this._compiler = component2.getCompiler(), this._id = tooltipId, this._initFromSpec();
  }
  hideTooltip(params2) {
    return this.changeTooltip(false, params2);
  }
  release() {
    var _a, _b, _c;
    this._clearAllCache();
    const spec = null !== (_a = this._component.getSpec()) && void 0 !== _a ? _a : {};
    spec.handler ? null === (_c = (_b = spec.handler).release) || void 0 === _c || _c.call(_b) : (this._removeTooltip(), this._isReleased = true);
  }
  _clearAllCache() {
    this._clearCacheOfContent(), this._clearCacheOfPosition();
  }
  _clearCacheOfContent() {
    this._cacheViewSpec = void 0, this._cacheActualTooltip = void 0;
  }
  _clearCacheOfPosition() {
    this._isTooltipPaused = false, this._isPointerEscaped = false, clearTimeout(this._cachePointerTimer), this._cachePointerTimer = -1, this._cachePointerPosition = void 0, this._cacheTooltipPosition = void 0, this._cacheTooltipSize = void 0;
  }
  _throttle(callback) {
    const tooltipSpec = this._component.getSpec();
    let wait;
    return wait = isNumber_default(tooltipSpec.throttleInterval) ? tooltipSpec.throttleInterval : "html" === tooltipSpec.renderMode && tooltipSpec.transitionDuration ? 50 : 10, throttle_default(callback, wait);
  }
  _getDefaultOption() {
    var _a, _b;
    const { offset } = this._component.getSpec();
    return Object.assign(Object.assign({}, DEFAULT_OPTIONS), {
      offsetX: null !== (_a = null == offset ? void 0 : offset.x) && void 0 !== _a ? _a : DEFAULT_OPTIONS.offsetX,
      offsetY: null !== (_b = null == offset ? void 0 : offset.y) && void 0 !== _b ? _b : DEFAULT_OPTIONS.offsetY
    });
  }
  _getTooltipBoxSize(actualTooltip, changePositionOnly) {
    var _a, _b, _c, _d, _e, _f;
    if (!changePositionOnly || isNil_default(this._attributes)) {
      const chartTheme = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
      this._attributes = getTooltipAttributes(actualTooltip, this._component.getSpec(), chartTheme);
    }
    return {
      width: null === (_d = null === (_c = this._attributes) || void 0 === _c ? void 0 : _c.panel) || void 0 === _d ? void 0 : _d.width,
      height: null === (_f = null === (_e = this._attributes) || void 0 === _e ? void 0 : _e.panel) || void 0 === _f ? void 0 : _f.height
    };
  }
  _getPointerPositionRelativeToTooltipParent(params2) {
    var _a, _b;
    let { canvasX: x3, canvasY: y3 } = params2.event;
    const invalidPosition = {
      x: 1 / 0,
      y: 1 / 0
    }, tooltipSpec = this._cacheViewSpec, isCanvas = "canvas" === tooltipSpec.renderMode, tooltipParentElement = this._getParentElement(tooltipSpec);
    let relativePosOffset = {
      x: 0,
      y: 0
    }, tooltipParentElementRect = {
      x: 0,
      y: 0
    }, chartElementScale = 1, tooltipParentElementScale = 1;
    if (isTrueBrowser(this._env) && !tooltipSpec.confine && !isCanvas) {
      tooltipParentElementRect = null !== (_a = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _a ? _a : invalidPosition;
      const chartElement = null !== (_b = this._compiler.getCanvas()) && void 0 !== _b ? _b : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
      relativePosOffset = {
        x: chartElementRect.x - tooltipParentElementRect.x,
        y: chartElementRect.y - tooltipParentElementRect.y
      }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
    }
    return x3 *= chartElementScale, y3 *= chartElementScale, isTrueBrowser(this._env) && (x3 += relativePosOffset.x, y3 += relativePosOffset.y), x3 /= tooltipParentElementScale, y3 /= tooltipParentElementScale, {
      x: x3,
      y: y3
    };
  }
  _isPointerMovingToTooltip(params2) {
    if (!this._cacheTooltipPosition || !this._cacheTooltipSize || !this._cachePointerPosition) return false;
    const { width: tooltipWidth, height: tooltipHeight } = this._cacheTooltipSize, { x: tooltipX = 0, y: tooltipY } = this._cacheTooltipPosition, pos = this._getPointerPositionRelativeToTooltipParent(params2);
    if (pointInRect(pos, {
      x1: tooltipX,
      y1: tooltipY,
      x2: tooltipX + tooltipWidth,
      y2: tooltipY + tooltipHeight
    }, false)) return true;
    const a4 = {
      x: tooltipX,
      y: tooltipY
    }, b2 = {
      x: a4.x + tooltipWidth,
      y: a4.y
    }, c4 = {
      x: a4.x,
      y: a4.y + tooltipHeight
    }, d2 = {
      x: b2.x,
      y: c4.y
    }, oldPos = this._cachePointerPosition;
    return polygonContainPoint([oldPos, a4, b2], pos.x, pos.y) || polygonContainPoint([oldPos, c4, d2], pos.x, pos.y) || polygonContainPoint([oldPos, a4, d2], pos.x, pos.y) || polygonContainPoint([oldPos, b2, c4], pos.x, pos.y);
  }
  _getParentElement(spec) {
    return spec.parentElement;
  }
  getTooltipContainer() {
    return this._container;
  }
  _initFromSpec() {
    this._option = this._getDefaultOption(), this.changeTooltip = this._throttle(this._changeTooltip), this.changeTooltipPosition = this._throttle(this._changeTooltipPosition);
  }
  reInit() {
    this._initFromSpec();
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/util.js
var getPixelPropertyStr = (num, defaultStr) => isValid_default(num) ? isArray_default(num) ? num.map((n2) => `${n2}px`).join(" ") : `${num}px` : null != defaultStr ? defaultStr : "initial";
var pixelPropertyStrToNumber = (str) => {
  const numArr = str.split(" ").map((n2) => Number.isNaN(n2) ? Number.parseFloat(n2.substring(0, n2.length - 2)) : Number.parseFloat(n2));
  return 1 === numArr.length ? numArr[0] : numArr;
};
function getDomStyles(attributes) {
  var _a, _b, _c, _d, _e;
  const { panel = {}, title: titleAttribute, content: contentAttribute, titleStyle = {}, contentStyle = {}, padding, keyWidth, valueWidth, enterable, transitionDuration } = null != attributes ? attributes : {}, { fill: backgroundColor, shadow, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, shadowSpread, cornerRadius, stroke: strokeColor, lineWidth = 0, width = 0, height = 0 } = panel, { value: title3 = {} } = titleStyle, { shape = {}, key = {}, value = {} } = contentStyle, shapeStyle = getShapeStyle(shape), keyStyle = getLabelStyle(key), valueStyle = getLabelStyle(value), { bottom, left: left2, right: right2, top } = normalizeLayoutPaddingSpec(padding);
  return {
    panel: {
      width: getPixelPropertyStr(width + 2 * lineWidth),
      minHeight: getPixelPropertyStr(height + 2 * lineWidth),
      paddingBottom: getPixelPropertyStr(bottom),
      paddingLeft: getPixelPropertyStr(left2),
      paddingRight: getPixelPropertyStr(right2),
      paddingTop: getPixelPropertyStr(top),
      borderColor: strokeColor,
      borderWidth: getPixelPropertyStr(lineWidth),
      borderRadius: getPixelPropertyStr(cornerRadius),
      backgroundColor: backgroundColor ? `${backgroundColor}` : "transparent",
      boxShadow: shadow ? `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowSpread}px ${shadowColor}` : "initial",
      pointerEvents: enterable ? "auto" : "none",
      transitionDuration: transitionDuration ? `${transitionDuration}ms` : "initial",
      transitionProperty: transitionDuration ? "transform" : "initial",
      transitionTimingFunction: transitionDuration ? "ease-out" : "initial"
    },
    title: Object.assign({
      marginTop: "0px",
      marginBottom: (null == contentAttribute ? void 0 : contentAttribute.length) ? getPixelPropertyStr(null == titleAttribute ? void 0 : titleAttribute.spaceRow) : "0px"
    }, getLabelStyle(mergeSpec({}, title3, null == titleAttribute ? void 0 : titleAttribute.value))),
    content: {},
    shapeColumn: {
      common: shapeStyle,
      items: [],
      width: getPixelPropertyStr(shape.size),
      marginRight: getPixelPropertyStr(null !== (_a = shape.spacing) && void 0 !== _a ? _a : 8),
      marginBottom: getPixelPropertyStr(-(null !== (_c = null === (_b = null == contentAttribute ? void 0 : contentAttribute[(null == contentAttribute ? void 0 : contentAttribute.length) - 1]) || void 0 === _b ? void 0 : _b.spaceRow) && void 0 !== _c ? _c : 0))
    },
    keyColumn: {
      common: keyStyle,
      items: null == contentAttribute ? void 0 : contentAttribute.map(({ key: key2, spaceRow }, i2) => Object.assign(Object.assign(Object.assign({
        marginTop: "0px",
        marginBottom: i2 < contentAttribute.length - 1 ? getPixelPropertyStr(spaceRow) : "0px"
      }, keyStyle), getLabelStyle(key2)), (null == key2 ? void 0 : key2.multiLine) ? {
        width: getPixelPropertyStr(Math.ceil(key2.width))
      } : void 0)),
      width: getPixelPropertyStr(keyWidth),
      marginRight: getPixelPropertyStr(null !== (_d = key.spacing) && void 0 !== _d ? _d : 26)
    },
    valueColumn: {
      common: valueStyle,
      items: null == contentAttribute ? void 0 : contentAttribute.map(({ value: value2, spaceRow }, i2) => Object.assign(Object.assign(Object.assign({
        marginTop: "0px",
        marginBottom: i2 < contentAttribute.length - 1 ? getPixelPropertyStr(spaceRow) : "0px"
      }, valueStyle), getLabelStyle(value2)), (null == value2 ? void 0 : value2.multiLine) ? {
        width: getPixelPropertyStr(Math.ceil(value2.width))
      } : void 0)),
      width: getPixelPropertyStr(valueWidth),
      marginRight: getPixelPropertyStr(null !== (_e = value.spacing) && void 0 !== _e ? _e : 0)
    }
  };
}
function getLabelStyle(labelStyle, defaultStyle) {
  if (!labelStyle) return;
  const { fontFamily: labelFont, fontSize: labelFontSize, fill: labelColor, textAlign, lineHeight, fontWeight, multiLine, wordBreak, maxWidth } = mergeSpec({}, defaultStyle, labelStyle), styleObj = {};
  return styleObj.fontFamily = labelFont, styleObj.fontSize = getPixelPropertyStr(labelFontSize), styleObj.color = labelColor, styleObj.textAlign = textAlign, styleObj.lineHeight = getPixelPropertyStr(calculateLineHeight(lineHeight, labelFontSize)), styleObj.fontWeight = fontWeight, styleObj.whiteSpace = multiLine ? "initial" : "nowrap", styleObj.wordBreak = multiLine ? null != wordBreak ? wordBreak : "break-word" : "normal", styleObj.maxWidth = getPixelPropertyStr(maxWidth), styleObj;
}
function getShapeStyle(shapeStyle, defaultStyle) {
  if (!shapeStyle) return;
  const { size } = mergeSpec({}, defaultStyle, shapeStyle), styleObj = {};
  return styleObj.width = getPixelPropertyStr(size), styleObj;
}

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/base-tooltip-model.js
var BaseTooltipModel = class _BaseTooltipModel {
  static isInstance(obj) {
    return !!obj && obj.type === _BaseTooltipModel.type;
  }
  setOption(option) {
    this._option = option, Object.values(this.children).forEach((c4) => c4.setOption(option));
  }
  getParentEl() {
    return _BaseTooltipModel.isInstance(this.parent) ? this.parent.product : this.parent;
  }
  constructor(parent, option, childIndex) {
    this.type = _BaseTooltipModel.type, this._renderContentCache = null, this.children = {}, this.parent = parent, this._option = option, this.childIndex = null != childIndex ? childIndex : 0;
  }
  init(classList, id2) {
  }
  initAll() {
    this.init(), Object.values(this.children).forEach((c4) => c4.initAll());
  }
  setStyle(style) {
    this.product && style && Object.keys(style).forEach((key) => {
      this.product.style[key] !== style[key] && (this.product.style[key] = style[key]);
    });
  }
  setContent(content) {
  }
  setVisibility(visibility) {
    if (!this.product) return;
    const { style } = this.product;
    style.visibility = visibility ? "visible" : "hidden", Object.values(this.children).forEach((c4) => c4.setVisibility(visibility));
  }
  getVisibility() {
    var _a, _b;
    return !!(null === (_b = null === (_a = this.product) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.visibility) && "hidden" !== this.product.style.visibility;
  }
  release() {
    var _a;
    if (Object.values(this.children).forEach((c4) => c4.release()), this.children = {}, this.product) {
      try {
        null === (_a = this.getParentEl()) || void 0 === _a || _a.removeChild(this.product);
      } catch (_b) {
      }
      this.product = null;
    }
  }
  createElement(tag, classList, style, id2) {
    const element = null == domDocument ? void 0 : domDocument.createElement(tag), parentEl = this.getParentEl();
    if (!element || !parentEl) return;
    classList && element.classList.add(...classList), style && Object.keys(style).forEach((key) => {
      element.style[key] = style[key];
    }), id2 && (element.id = id2);
    let ptr = this.childIndex;
    if (_BaseTooltipModel.isInstance(this.parent)) {
      let nextChildIndex = Number.MAX_VALUE;
      for (let i2 = 0; i2 < parentEl.children.length; i2++) {
        const childModel = Object.values(this.parent.children).find((c4) => c4.product === parentEl.children[i2]);
        childModel.childIndex > this.childIndex && childModel.childIndex < nextChildIndex && (nextChildIndex = childModel.childIndex, ptr = i2);
      }
    }
    return ptr >= parentEl.children.length ? parentEl.appendChild(element) : parentEl.insertBefore(element, parentEl.children[ptr]), element;
  }
};
BaseTooltipModel.type = "tooltipModel";

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/style-constants.js
var defaultH2Style = {
  fontSize: "13px",
  marginBottom: "0px",
  fontWeight: "normal"
};
var defaultContainerStyle = {
  boxSizing: "border-box"
};
var defaultContentContainerStyle = {
  display: "flex",
  whiteSpace: "nowrap"
};
var defaultContentColumnStyle = {
  display: "flex",
  flexDirection: "column",
  justifyContent: "space-around",
  fontSize: "0"
};
var defaultKeyStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "left",
  fontWeight: "normal"
};
var defaultAdaptiveKeyStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "left",
  fontWeight: "normal"
};
var defaultValueStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "right",
  fontWeight: "normal"
};
var defaultShapeStyle = {
  lineHeight: "normal"
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/shape-model.js
var ShapeModel = class extends BaseTooltipModel {
  init(classList, id2, tag) {
    if (!this.product) {
      const container2 = this.createElement(null != tag ? tag : "div", [...null != classList ? classList : [], "shape"], void 0, id2);
      this.product = container2;
    }
  }
  setStyle(style, option) {
    super.setStyle(style), this.setSvg(option);
  }
  setContent(option) {
    this.setSvg(option);
  }
  setSvg(option) {
    const html = getSvgHtml(option, this._option.valueToHtml);
    this.product && html !== this._svgHtmlCache && (this._svgHtmlCache = html, this.product.innerHTML = html);
  }
  release() {
    super.release(), this._svgHtmlCache = "";
  }
};
var builtInShape = {
  star: "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z"
};
function getSvgHtml(option, valueToHtml) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (!(null == option ? void 0 : option.hasShape) || !option.symbolType) return "";
  const { symbolType, fill, stroke: stroke2, hollow = false } = option, size = option.size ? valueToHtml(option.size) : "8px", marginTop = option.marginTop ? valueToHtml(option.marginTop) : "0px", lineWidth = option.lineWidth ? valueToHtml(option.lineWidth) + "px" : "0px";
  let fillString = "currentColor";
  const getStroke = () => stroke2 ? valueToHtml(stroke2) : fillString, sizeNumber = pixelPropertyStrToNumber(size), createSymbol2 = (symbolType2) => new Symbol2({
    symbolType: symbolType2,
    size: sizeNumber,
    fill: true
  });
  let symbol = createSymbol2(null !== (_a = builtInShape[symbolType]) && void 0 !== _a ? _a : symbolType);
  const parsedPath = symbol.getParsedPath();
  parsedPath.path || (symbol = createSymbol2(parsedPath.pathStr));
  const pathModel = symbol.getParsedPath().path, path = pathModel.toString(), bounds = pathModel.bounds;
  let viewBox = `${bounds.x1} ${bounds.y1} ${bounds.width()} ${bounds.height()}`;
  if ("0px" !== lineWidth) {
    const [x3, y3, w2, h2] = viewBox.split(" ").map((n2) => Number(n2)), lw = Number(lineWidth.slice(0, -2));
    viewBox = `${x3 - lw / 2} ${y3 - lw / 2} ${w2 + lw} ${h2 + lw}`;
  }
  if (!fill || isString_default(fill) || hollow) return fillString = hollow ? "none" : fill ? valueToHtml(fill) : "currentColor", `
    <svg width="${size}" height="${size}" viewBox="${viewBox}"
      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">
      <path
        d="${path}"
        style="fill: ${fillString}; stroke: ${getStroke()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  if (isObject_default(fill)) {
    fillString = null !== (_b = "gradientColor" + option.index) && void 0 !== _b ? _b : "";
    let gradient = "";
    const stops = (null !== (_c = fill.stops) && void 0 !== _c ? _c : []).map((s3) => `<stop offset="${valueToHtml(s3.offset.toString())}" stop-color="${valueToHtml(s3.color)}"/>`).join("");
    return "radial" === fill.gradient ? gradient = `<radialGradient id="${fillString}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">
      ${stops}
      </radialGradient>` : "linear" === fill.gradient && (gradient = `<linearGradient id="${fillString}" x1="${100 * (null !== (_d = fill.x0) && void 0 !== _d ? _d : 0)}%" y1="${100 * (null !== (_e = fill.y0) && void 0 !== _e ? _e : 0)}%" x2="${100 * (null !== (_f = fill.x1) && void 0 !== _f ? _f : 0)}%" y2="${100 * (null !== (_g = fill.y1) && void 0 !== _g ? _g : 0)}%">
      ${stops}
      </linearGradient>`), `
    <svg width="${size}" height="${size}" viewBox="-0.5 -0.5 1 1"
      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">
      ${gradient}
      <path
        d="${path}"
        style="fill: url(#${fillString}); stroke: ${getStroke()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  }
  return "";
}

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/text-model.js
var TextModel = class extends BaseTooltipModel {
  init(classList, id2, tag) {
    this.product || (this.product = this.createElement(null != tag ? tag : "span", classList, void 0, id2));
  }
  setContent(content, multiLine) {
    if (!this.product) return;
    let html = this._option.valueToHtml(content);
    multiLine && (html = html.replaceAll("\n", "<br>")), html !== this.product.innerHTML && (this.product.innerHTML = html);
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/content-column-model.js
var defaultLabelStyle = {
  overflowWrap: "normal",
  wordWrap: "normal"
};
var ContentColumnModel = class extends BaseTooltipModel {
  constructor(parent, option, className, childIndex) {
    super(parent, option, childIndex), this.className = className;
  }
  init() {
    var _a, _b;
    this.product || (this.product = this.createElement("div", [this.className]));
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
    if ("shape-box" !== this.className || renderContent.some((c4) => c4.hasShape && c4.shapeType)) {
      Object.keys(this.children).forEach((key) => {
        const i2 = toNumber(key);
        i2 >= renderContent.length && (this.children[i2].release(), delete this.children[i2]);
      });
      for (let i2 = 0; i2 < renderContent.length; i2++) if (!this.children[i2]) {
        if ("key-box" === this.className || "value-box" === this.className) {
          const text2 = new TextModel(this.product, this._option, i2);
          text2.init([this.className.substring(0, this.className.indexOf("-"))], void 0, "div"), this.children[i2] = text2;
        } else if ("shape-box" === this.className) {
          const shape = new ShapeModel(this.product, this._option, i2);
          shape.init(["shape"], void 0, "div"), this.children[i2] = shape;
        }
      }
    } else Object.keys(this.children).forEach((key) => {
      const i2 = toNumber(key);
      this.children[i2].release(), delete this.children[i2];
    });
  }
  setStyle() {
    var _a, _b, _c, _d;
    const tooltipStyle = this._option.getTooltipStyle();
    super.setStyle(mergeSpec({}, defaultContentColumnStyle, tooltipStyle.content, this._getContentColumnStyle()));
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [];
    renderContent.forEach((line2, i2) => {
      var _a2, _b2, _c2, _d2, _e;
      let childStyle = {};
      if ("key-box" === this.className) {
        const { key, isKeyAdaptive } = line2;
        childStyle = mergeSpec({}, isKeyAdaptive ? defaultAdaptiveKeyStyle : defaultKeyStyle, Object.assign(Object.assign(Object.assign({
          height: getPixelPropertyStr(contentAttributes[i2].height)
        }, defaultLabelStyle), tooltipStyle.keyColumn.common), null === (_a2 = tooltipStyle.keyColumn.items) || void 0 === _a2 ? void 0 : _a2[i2]));
        isString_default(key) && "" !== (null === (_b2 = null == key ? void 0 : key.trim) || void 0 === _b2 ? void 0 : _b2.call(key)) || isNumber_default(key) || childStyle.visibility ? childStyle.visibility = "visible" : childStyle.visibility = "hidden", this.children[i2].setStyle(childStyle);
      } else "value-box" === this.className ? (childStyle = mergeSpec({}, defaultValueStyle, Object.assign(Object.assign(Object.assign({
        height: getPixelPropertyStr(contentAttributes[i2].height)
      }, defaultLabelStyle), tooltipStyle.valueColumn.common), null === (_c2 = tooltipStyle.valueColumn.items) || void 0 === _c2 ? void 0 : _c2[i2])), this.children[i2].setStyle(childStyle)) : "shape-box" === this.className && (childStyle = mergeSpec({}, defaultShapeStyle, Object.assign(Object.assign({
        height: getPixelPropertyStr(contentAttributes[i2].height + contentAttributes[i2].spaceRow)
      }, tooltipStyle.shapeColumn.common), null === (_d2 = tooltipStyle.shapeColumn.items) || void 0 === _d2 ? void 0 : _d2[i2])), null === (_e = this.children[i2]) || void 0 === _e || _e.setStyle(childStyle, this._getShapeSvgOption(line2, i2)));
    });
  }
  setContent() {
    var _a, _b, _c, _d;
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [];
    renderContent.forEach((line2, i2) => {
      var _a2, _b2, _c2, _d2, _e, _f, _g;
      let childContent;
      if ("key-box" === this.className) {
        const keyContent = line2.key;
        childContent = isString_default(keyContent) && "" !== (null === (_a2 = null == keyContent ? void 0 : keyContent.trim) || void 0 === _a2 ? void 0 : _a2.call(keyContent)) || isNumber_default(keyContent) ? keyContent : TOOLTIP_EMPTY_STRING, null === (_b2 = this.children[i2]) || void 0 === _b2 || _b2.setContent(childContent, null === (_c2 = contentAttributes[i2].key) || void 0 === _c2 ? void 0 : _c2.multiLine);
      } else if ("value-box" === this.className) {
        const valueContent = line2.value;
        childContent = isString_default(valueContent) && "" !== (null === (_d2 = null == valueContent ? void 0 : valueContent.trim) || void 0 === _d2 ? void 0 : _d2.call(valueContent)) || isNumber_default(valueContent) ? valueContent : TOOLTIP_EMPTY_STRING, null === (_e = this.children[i2]) || void 0 === _e || _e.setContent(childContent, null === (_f = contentAttributes[i2].value) || void 0 === _f ? void 0 : _f.multiLine);
      } else "shape-box" === this.className && (childContent = this._getShapeSvgOption(line2, i2), null === (_g = this.children[i2]) || void 0 === _g || _g.setContent(childContent));
    });
  }
  _getContentColumnStyle() {
    var _a, _b;
    const tooltipStyle = this._option.getTooltipStyle();
    switch (this.className) {
      case "shape-box":
        const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
        return Object.assign(Object.assign({}, tooltipStyle.shapeColumn), "shape-box" !== this.className || renderContent.some((c4) => c4.hasShape && c4.shapeType) ? {} : {
          display: "none"
        });
      case "key-box":
        return tooltipStyle.keyColumn;
      case "value-box":
        return tooltipStyle.valueColumn;
    }
  }
  _getShapeSvgOption(line2, index) {
    var _a, _b, _c, _d, _e, _f;
    const tooltipStyle = this._option.getTooltipStyle(), shapeColumn = Object.assign(Object.assign({}, tooltipStyle.shapeColumn), null === (_a = tooltipStyle.shapeColumn.items) || void 0 === _a ? void 0 : _a[index]), keyColumn = Object.assign(Object.assign({}, tooltipStyle.keyColumn), null === (_b = tooltipStyle.keyColumn.items) || void 0 === _b ? void 0 : _b[index]);
    return {
      hasShape: line2.hasShape,
      symbolType: line2.shapeType,
      size: shapeColumn.width,
      fill: null !== (_c = line2.shapeFill) && void 0 !== _c ? _c : line2.shapeColor,
      stroke: line2.shapeStroke,
      lineWidth: line2.shapeLineWidth,
      hollow: line2.shapeHollow,
      marginTop: `calc((${null !== (_e = null !== (_d = keyColumn.lineHeight) && void 0 !== _d ? _d : keyColumn.fontSize) && void 0 !== _e ? _e : "18px"} - ${null !== (_f = shapeColumn.width) && void 0 !== _f ? _f : "8px"}) / 2)`,
      index
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/content-model.js
var ContentModel = class extends BaseTooltipModel {
  init() {
    this.product || (this.product = this.createElement("div", ["container-box"])), this.shapeBox || this._initShapeBox(), this.keyBox || this._initKeyBox(), this.valueBox || this._initValueBox();
  }
  _initShapeBox() {
    const shapeBox = new ContentColumnModel(this.product, this._option, "shape-box", 0);
    shapeBox.init(), this.shapeBox = shapeBox, this.children[shapeBox.childIndex] = shapeBox;
  }
  _initKeyBox() {
    const keyBox = new ContentColumnModel(this.product, this._option, "key-box", 1);
    keyBox.init(), this.keyBox = keyBox, this.children[keyBox.childIndex] = keyBox;
  }
  _initValueBox() {
    const valueBox = new ContentColumnModel(this.product, this._option, "value-box", 2);
    valueBox.init(), this.valueBox = valueBox, this.children[valueBox.childIndex] = valueBox;
  }
  setStyle(style) {
    super.setStyle(mergeSpec({}, defaultContentContainerStyle, style)), Object.values(this.children).forEach((c4) => {
      c4.setStyle();
    });
  }
  setContent() {
    Object.values(this.children).forEach((c4) => {
      c4.setContent();
    });
  }
  release() {
    super.release(), this.shapeBox = null, this.keyBox = null, this.valueBox = null;
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/title-model.js
var TitleModel = class extends BaseTooltipModel {
  init() {
    const tooltipActual = this._option.getTooltipActual();
    this.product || (this.product = this.createElement("h2"));
    const { title: title3 } = tooltipActual;
    (null == title3 ? void 0 : title3.hasShape) && (null == title3 ? void 0 : title3.shapeType) ? this.shape || this._initShape() : this.shape && this._releaseShape(), this.textSpan || this._initTextSpan();
  }
  _initShape() {
    const shape = new ShapeModel(this.product, this._option, 0);
    shape.init(), this.shape = shape, this.children[shape.childIndex] = shape;
  }
  _releaseShape() {
    this.shape && (this.shape.release(), delete this.children[this.shape.childIndex], this.shape = null);
  }
  _initTextSpan() {
    const textSpan = new TextModel(this.product, this._option, 1);
    textSpan.init(), this.textSpan = textSpan, this.children[textSpan.childIndex] = textSpan;
  }
  setStyle(style) {
    var _a, _b, _c, _d;
    const tooltipStyle = this._option.getTooltipStyle(), tooltipActual = this._option.getTooltipActual(), { title: title3 } = tooltipActual;
    super.setStyle(mergeSpec({}, defaultH2Style, tooltipStyle.title, style)), null === (_a = this.shape) || void 0 === _a || _a.setStyle({
      paddingRight: null === (_b = tooltipStyle.shapeColumn.common) || void 0 === _b ? void 0 : _b.marginRight
    }, {
      hasShape: null == title3 ? void 0 : title3.hasShape,
      symbolType: null == title3 ? void 0 : title3.shapeType,
      size: null === (_c = tooltipStyle.shapeColumn.common) || void 0 === _c ? void 0 : _c.width,
      fill: null == title3 ? void 0 : title3.shapeColor,
      hollow: null == title3 ? void 0 : title3.shapeHollow
    }), null === (_d = this.textSpan) || void 0 === _d || _d.setStyle({
      color: "inherit"
    });
  }
  setContent() {
    var _a, _b, _c, _d, _e, _f;
    const tooltipStyle = this._option.getTooltipStyle(), tooltipActual = this._option.getTooltipActual(), tooltipAttributes = this._option.getTooltipAttributes(), { title: title3 } = tooltipActual;
    this.init(), null === (_a = this.shape) || void 0 === _a || _a.setStyle(void 0, {
      hasShape: null == title3 ? void 0 : title3.hasShape,
      symbolType: null == title3 ? void 0 : title3.shapeType,
      size: null === (_b = tooltipStyle.shapeColumn.common) || void 0 === _b ? void 0 : _b.width,
      fill: null == title3 ? void 0 : title3.shapeColor,
      hollow: null == title3 ? void 0 : title3.shapeHollow
    }), null === (_c = this.textSpan) || void 0 === _c || _c.setStyle({
      color: "inherit"
    }), null === (_d = this.textSpan) || void 0 === _d || _d.setContent(null == title3 ? void 0 : title3.value, null === (_f = null === (_e = tooltipAttributes.title) || void 0 === _e ? void 0 : _e.value) || void 0 === _f ? void 0 : _f.multiLine);
  }
  release() {
    super.release(), this.shape = null, this.textSpan = null;
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/model/tooltip-model.js
var TooltipModel = class extends BaseTooltipModel {
  constructor(parent, option, classList, id2) {
    super(parent, option, 0), this.title = null, this.content = null, this._classList = classList, this._id = id2;
  }
  setVisibility(visibility) {
    if (super.setVisibility(visibility), !this.product) return;
    const { classList } = this.product;
    visibility ? classList.add("visible") : classList.remove("visible");
  }
  init() {
    var _a;
    const tooltipActual = this._option.getTooltipActual();
    this.product || this._initPanel(this._classList, this._id);
    const { title: title3 } = tooltipActual;
    false !== (null == title3 ? void 0 : title3.visible) && isValid_default(null == title3 ? void 0 : title3.value) ? this.title || this._initTitle() : this.title && this._releaseTitle();
    (null !== (_a = tooltipActual.content) && void 0 !== _a ? _a : []).length > 0 ? this.content || this._initContent() : this.content && this._releaseContent();
  }
  _initPanel(classList, id2) {
    const panel = this.createElement("div", classList, {
      left: "0",
      top: "0",
      pointerEvents: "none",
      padding: "12px",
      position: "absolute",
      zIndex: "99999999999999",
      fontFamily: "sans-serif",
      fontSize: "11px",
      borderRadius: "3px",
      borderStyle: "solid",
      lineHeight: "initial",
      background: "#fff",
      boxShadow: "2px 2px 4px rgba(0, 0, 0, 0.1)",
      maxWidth: "100wh",
      maxHeight: "100vh"
    }, id2);
    this.product = panel;
  }
  _initTitle() {
    const title3 = new TitleModel(this.product, this._option, 0);
    title3.init(), this.title = title3, this.children[title3.childIndex] = title3;
  }
  _releaseTitle() {
    this.title && (this.title.release(), delete this.children[this.title.childIndex], this.title = null);
  }
  _initContent() {
    const content = new ContentModel(this.product, this._option, 1);
    content.init(), this.content = content, this.children[content.childIndex] = content;
  }
  _releaseContent() {
    this.content && (this.content.release(), delete this.children[this.content.childIndex], this.content = null);
  }
  setStyle() {
    const tooltipStyle = this._option.getTooltipStyle();
    super.setStyle(mergeSpec({}, defaultContainerStyle, tooltipStyle.panel)), Object.values(this.children).forEach((c4) => c4.setStyle());
  }
  setContent() {
    Object.values(this.children).forEach((c4) => {
      c4.setContent();
    });
  }
  release() {
    super.release(), this.title = null, this.content = null;
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/dom/dom-tooltip-handler.js
var DomTooltipHandler = class extends BaseTooltipHandler {
  getVisibility() {
    var _a;
    return !!(null === (_a = this.model) || void 0 === _a ? void 0 : _a.getVisibility());
  }
  setVisibility(_value) {
    var _a;
    _value !== this.getVisibility() && (null === (_a = this.model) || void 0 === _a || _a.setVisibility(_value));
  }
  constructor(tooltipId, component2) {
    super(tooltipId, component2), this.type = TooltipHandlerType.dom, this._tooltipContainer = null == domDocument ? void 0 : domDocument.body, this._initStyle(), this.initEl();
  }
  initEl() {
    const tooltipSpec = this._component.getSpec(), parentElement = tooltipSpec.parentElement;
    if (domDocument && parentElement) {
      for (let i2 = 0; i2 < parentElement.children.length; i2++) if (parentElement.children[i2].classList.contains(TOOLTIP_CONTAINER_EL_CLASS_NAME)) {
        this._container = parentElement.children[i2];
        break;
      }
      this._container || (this._container = domDocument.createElement("div"), this._container.style.position = "relative", this._container.classList.add(TOOLTIP_CONTAINER_EL_CLASS_NAME), parentElement.appendChild(this._container)), this.model = new TooltipModel(this._container, {
        valueToHtml: this._option.sanitize,
        getTooltipStyle: () => this._domStyle,
        getTooltipActual: () => this._tooltipActual,
        getTooltipAttributes: () => this._attributes
      }, [tooltipSpec.className], this.id);
    }
  }
  _removeTooltip() {
    var _a;
    null === (_a = this.model) || void 0 === _a || _a.release(), this._container = null;
  }
  _updateTooltip(visible, params2, actualTooltip) {
    var _a, _b;
    if (visible && this.model) {
      params2.changePositionOnly || (this._tooltipActual = actualTooltip, this._initStyle(), this.model.initAll(), this.model.setStyle(), this.model.setContent()), this.setVisibility(visible);
      let { x: x3 = 0, y: y3 = 0 } = null !== (_a = actualTooltip.position) && void 0 !== _a ? _a : {};
      const el = this.model.product;
      if (el) {
        if (null === (_b = this._cacheViewSpec) || void 0 === _b ? void 0 : _b.updateElement) {
          this._cacheViewSpec.updateElement(el, actualTooltip, params2);
          const position = this._getActualTooltipPosition(actualTooltip, params2, {
            width: el.offsetWidth,
            height: el.offsetHeight
          });
          x3 = position.x, y3 = position.y;
        }
        el.style.transform = `translate3d(${x3}px, ${y3}px, 0)`;
      }
    } else this.setVisibility(visible);
  }
  _initStyle() {
    this._domStyle = getDomStyles(this._attributes);
  }
  _getParentElement(spec) {
    var _a;
    return null !== (_a = this._container) && void 0 !== _a ? _a : super._getParentElement(spec);
  }
  isTooltipShown() {
    return this.getVisibility();
  }
  reInit() {
    super.reInit(), this._initStyle();
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/handler/canvas/canvas-tooltip-handler.js
var CanvasTooltipHandler = class extends BaseTooltipHandler {
  constructor(tooltipId, component2) {
    var _a;
    super(tooltipId, component2), this.type = TooltipHandlerType.canvas, this._tooltipCanvasId = null === (_a = this._chartOption.modeParams) || void 0 === _a ? void 0 : _a.tooltipCanvasId;
  }
  _initTooltipComponent(stage) {
    const layer = this._getLayer(stage);
    this._tooltipComponent = new Tooltip({
      autoCalculatePosition: false,
      autoMeasure: false
    }), layer.add(this._tooltipComponent);
  }
  _getLayer(stage) {
    if (this._layer) return this._layer;
    this._layer = stage.createLayer(this._tooltipCanvasId);
    const layerCanvas = this._layer.layerHandler.canvas.nativeCanvas;
    return layerCanvas && layerCanvas.style && (layerCanvas.style.touchAction = "none", layerCanvas.style.pointerEvents = "none"), this._layer;
  }
  _removeTooltip() {
    this._layer && this._layer.removeAllChild(), this._attributes = null;
  }
  _updateTooltip(visible, params2, actualTooltip) {
    this._visible = visible;
    const stage = this._compiler.getStage();
    if (!stage) return;
    if (!visible) return void (this._tooltipComponent && this._tooltipComponent.attribute.visible && (this._tooltipComponent.hideAll(), this._tooltipComponent.setAttributes({
      visibleAll: false
    })));
    this._tooltipComponent || this._initTooltipComponent(stage);
    const pos = null == actualTooltip ? void 0 : actualTooltip.position;
    params2.changePositionOnly ? isValid_default(pos) && this._tooltipComponent.setAttributes(pos) : this._tooltipComponent.setAttributes(Object.assign(Object.assign({}, this._attributes), pos)), this._tooltipComponent.attribute.visible || (this._tooltipComponent.showAll(), this._tooltipComponent.setAttributes({
      visibleAll: true
    }));
  }
  isTooltipShown() {
    var _a;
    return null === (_a = this._tooltipComponent) || void 0 === _a ? void 0 : _a.attribute.visibleAll;
  }
  release() {
    var _a;
    super.release(), null === (_a = this._layer) || void 0 === _a || _a.release();
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/utils/show-tooltip.js
var getDataArrayFromFieldArray = (fields2, datum) => isValid_default(datum) ? fields2.map((f2) => datum[f2]) : void 0;
var datumContainsArray = (fields2, data) => (datum) => fields2.every((key, i2) => datum[key] === (null == data ? void 0 : data[i2]));
var hasData = (data) => !isNil_default(data) && (isArray_default(data) ? data.length > 0 && data.every(isValid_default) : Object.keys(data).length > 0);
function showTooltip(datum, options, tooltipHandler, componentOptions) {
  var _a, _b, _c, _d, _e;
  const opt = Object.assign({
    regionIndex: 0
  }, options), region = componentOptions.getRegionsInUserIdOrIndex(isValid_default(opt.regionId) ? [opt.regionId] : void 0, isValid_default(opt.regionIndex) ? [opt.regionIndex] : void 0)[0];
  if (!region) return "none";
  const seriesList = region.getSeries(), markInfoList = [];
  seriesList.forEach((series2) => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h;
    const dimensionFields = series2.getDimensionField(), measureFields = series2.getMeasureField(), groupField = series2.getSeriesField(), groupData2 = isValid_default(groupField) ? datum[groupField] : void 0, groupDomain = isValid_default(groupField) && null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = series2.getViewDataStatistics) || void 0 === _a2 ? void 0 : _a2.call(series2)) || void 0 === _b2 ? void 0 : _b2.latestData[groupField]) || void 0 === _c2 ? void 0 : _c2.values) && void 0 !== _d2 ? _d2 : [], dimensionData = getDataArrayFromFieldArray(dimensionFields, datum);
    let measureData = getDataArrayFromFieldArray(measureFields, datum);
    const hasMeasureData = hasData(measureData), isMultiGroups = !hasMeasureData && isValid_default(groupField) && isNil_default(groupData2) && groupDomain.length > 0;
    if ("cartesian" === series2.coordinate) {
      const cartesianSeries = series2, invalidDimensionFields = dimensionFields.map((field5, i2) => [field5, i2]).filter(([, i2]) => isNil_default(null == dimensionData ? void 0 : dimensionData[i2]));
      let dimensionDataList = [null != dimensionData ? dimensionData : []];
      invalidDimensionFields.length > 0 && invalidDimensionFields.forEach(([field5, i2]) => {
        var _a3, _b3, _c3, _d3;
        const domain = null !== (_d3 = null === (_c3 = null === (_b3 = null === (_a3 = series2.getViewDataStatistics) || void 0 === _a3 ? void 0 : _a3.call(series2)) || void 0 === _b3 ? void 0 : _b3.latestData[field5]) || void 0 === _c3 ? void 0 : _c3.values) && void 0 !== _d3 ? _d3 : [], nextList = [];
        dimensionDataList.forEach((dimensionData2) => {
          domain.forEach((value) => {
            var _a4;
            const newData = null !== (_a4 = null == dimensionData2 ? void 0 : dimensionData2.slice()) && void 0 !== _a4 ? _a4 : [];
            newData[i2] = value, nextList.push(newData);
          });
        }), dimensionDataList = nextList;
      }), dimensionDataList.forEach((dimensionData2) => {
        var _a3, _b3;
        if (isMultiGroups) {
          const measureDataList = null === (_a3 = cartesianSeries.getViewData()) || void 0 === _a3 ? void 0 : _a3.latestData.filter(datumContainsArray(dimensionFields, dimensionData2));
          groupDomain.forEach((groupData3) => {
            const originDatum = measureDataList.find((d2) => d2[groupField] === groupData3);
            if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)) return;
            const pos = cartesianSeries.dataToPosition(originDatum);
            isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
              pos,
              data: {
                dimensionFields,
                dimensionData: dimensionData2,
                measureFields,
                measureData,
                hasMeasureData,
                groupField,
                groupData: groupData3
              },
              series: series2
            });
          });
        } else {
          const originDatum = null === (_b3 = cartesianSeries.getViewData()) || void 0 === _b3 ? void 0 : _b3.latestData.find(datumContainsArray(dimensionFields, dimensionData2));
          if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
          const pos = cartesianSeries.dataToPosition(originDatum);
          if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y)) return;
          markInfoList.push({
            pos,
            data: {
              dimensionFields,
              dimensionData: dimensionData2,
              measureFields,
              measureData,
              hasMeasureData,
              groupField,
              groupData: groupData2
            },
            series: series2
          });
        }
      });
    } else if ("polar" === series2.coordinate) if (series2.type === SeriesTypeEnum.pie) {
      const pieSeries = series2, originDatum = null === (_e2 = pieSeries.getViewData()) || void 0 === _e2 ? void 0 : _e2.latestData.find(datumContainsArray(dimensionFields, dimensionData));
      if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
      const pos = pieSeries.dataToCentralPosition(originDatum);
      if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y)) return;
      markInfoList.push({
        pos,
        data: {
          dimensionFields,
          dimensionData,
          measureFields,
          measureData,
          hasMeasureData,
          groupField,
          groupData: groupData2
        },
        series: series2
      });
    } else {
      const polarSeries = series2;
      if (isMultiGroups) {
        const originDatum = (null === (_f = polarSeries.getViewData()) || void 0 === _f ? void 0 : _f.latestData.filter(datumContainsArray(dimensionFields, dimensionData))).find((d2) => d2[groupField] === groupData2);
        groupDomain.forEach((groupData3) => {
          if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)) return;
          const pos = polarSeries.dataToPosition(originDatum);
          isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
            pos,
            data: {
              dimensionFields,
              dimensionData,
              measureFields,
              measureData,
              hasMeasureData,
              groupField,
              groupData: groupData3
            },
            series: series2
          });
        });
      } else {
        const originDatum = null === (_g = polarSeries.getViewData()) || void 0 === _g ? void 0 : _g.latestData.find(datumContainsArray(dimensionFields, dimensionData));
        if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
        const pos = polarSeries.dataToPosition(originDatum);
        if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y)) return;
        markInfoList.push({
          pos,
          data: {
            dimensionFields,
            dimensionData,
            measureFields,
            measureData,
            hasMeasureData,
            groupField,
            groupData: groupData2
          },
          series: series2
        });
      }
    }
    else if ("geo" === series2.coordinate) {
      const gs = series2, originDatum = null === (_h = gs.getViewData()) || void 0 === _h ? void 0 : _h.latestData.find(datumContainsArray(dimensionFields, dimensionData));
      if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))) return;
      const pos = gs.dataToPosition(originDatum);
      if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y)) return;
      markInfoList.push({
        pos,
        data: {
          dimensionFields,
          dimensionData,
          measureFields,
          measureData,
          hasMeasureData,
          groupField,
          groupData: groupData2
        },
        series: series2
      });
    }
  });
  const activeType = null !== (_a = opt.activeType) && void 0 !== _a ? _a : markInfoList.length > 1 ? "dimension" : "mark", regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect(), container2 = componentOptions.globalInstance.getContainer(), containerPos = Object.assign({
    x: 0,
    y: 0
  }, container2 ? getElementAbsolutePosition(container2) : {}), getOriginDatum = (info) => {
    var _a2;
    const { dimensionFields, dimensionData, measureFields, measureData, groupField, groupData: groupData2 } = info.data, originDatum = null === (_a2 = info.series.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.find((datum2) => datumContainsArray(dimensionFields, dimensionData)(datum2) && datumContainsArray(measureFields, measureData)(datum2) && (isNil_default(groupField) || datumContainsArray([groupField], [groupData2])(datum2)));
    return originDatum;
  }, getMockEvent = (originPos) => {
    var _a2, _b2;
    const pos = ((pos2) => ({
      x: Math.min(Math.max(pos2.x, 0), regionRect.width),
      y: Math.min(Math.max(pos2.y, 0), regionRect.height)
    }))(originPos), canvasX = null !== (_a2 = opt.x) && void 0 !== _a2 ? _a2 : regionPos.x + pos.x, canvasY = null !== (_b2 = opt.y) && void 0 !== _b2 ? _b2 : regionPos.y + pos.y;
    return {
      canvasX,
      canvasY,
      clientX: containerPos.x + canvasX,
      clientY: containerPos.y + canvasY
    };
  };
  if ("dimension" === activeType) {
    const firstInfo = markInfoList[0];
    if (!firstInfo) return "none";
    const markInfoSeriesMap = /* @__PURE__ */ new Map();
    markInfoList.forEach((info) => {
      var _a2;
      markInfoSeriesMap.has(info.series) || markInfoSeriesMap.set(info.series, []), null === (_a2 = markInfoSeriesMap.get(info.series)) || void 0 === _a2 || _a2.push(info);
    });
    const mockDimensionInfo = [{
      value: datum[firstInfo.data.dimensionFields[0]],
      data: [...markInfoSeriesMap.keys()].map((series2) => {
        var _a2, _b2;
        return {
          series: series2,
          datum: null !== (_b2 = null === (_a2 = markInfoSeriesMap.get(series2)) || void 0 === _a2 ? void 0 : _a2.map((info) => getOriginDatum(info))) && void 0 !== _b2 ? _b2 : []
        };
      })
    }], mockParams = {
      changePositionOnly: false,
      dimensionInfo: mockDimensionInfo,
      chart: null !== (_b = componentOptions.globalInstance.getChart()) && void 0 !== _b ? _b : void 0,
      datum: void 0,
      model: void 0,
      source: Event_Source_Type.chart,
      event: getMockEvent({
        x: markInfoList.reduce((sum5, info) => sum5 + info.pos.x, 0) / markInfoList.length,
        y: markInfoList.reduce((sum5, info) => sum5 + info.pos.y, 0) / markInfoList.length
      }),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    null === (_c = null == tooltipHandler ? void 0 : tooltipHandler.showTooltip) || void 0 === _c || _c.call(tooltipHandler, activeType, mockDimensionInfo, mockParams);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  if ("mark" === activeType) {
    const info = markInfoList[0];
    if (!info) return "none";
    const mockDatum = Object.assign(Object.assign({}, getOriginDatum(info)), datum), mockParams = {
      changePositionOnly: false,
      chart: null !== (_d = componentOptions.globalInstance.getChart()) && void 0 !== _d ? _d : void 0,
      datum: mockDatum,
      model: info.series,
      source: Event_Source_Type.chart,
      event: getMockEvent(info.pos),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    null === (_e = null == tooltipHandler ? void 0 : tooltipHandler.showTooltip) || void 0 === _e || _e.call(tooltipHandler, activeType, [{
      datum: [mockDatum],
      series: info.series
    }], mockParams);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  return "none";
}

// node_modules/@visactor/vchart/esm/component/tooltip/processor/base.js
var BaseTooltipProcessor = class {
  constructor(component2) {
    this._showTooltipByHandler = (data, params2) => {
      var _a, _b;
      return this.component.event.emit(ChartEvent.tooltipShow, Object.assign(Object.assign({}, params2), {
        tooltipData: data,
        activeType: this.activeType,
        tooltip: this.component
      })), (null === (_a = this.component.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip) && isValid_default(data) ? null !== (_b = this.component.tooltipHandler.showTooltip(this.activeType, data, params2)) && void 0 !== _b ? _b : TooltipResult.success : TooltipResult.failed;
    }, this.component = component2;
  }
  _preprocessDimensionInfo(dimensionInfo) {
    const newDimensionInfo = [];
    if (null == dimensionInfo || dimensionInfo.forEach((info) => {
      const di = Object.assign(Object.assign({}, info), {
        data: info.data.filter(({ series: series2 }) => {
          var _a, _b;
          return false !== (null === (_b = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) || void 0 === _b ? void 0 : _b.visible);
        })
      });
      di.data.length > 0 && newDimensionInfo.push(di);
    }), newDimensionInfo.length > 0) return newDimensionInfo;
  }
  _getDimensionInfo(params2) {
    var _a, _b;
    let targetDimensionInfo;
    const chart = this.component.getChart(), layer = chart.getCompiler().getStage().getLayer(void 0), point6 = {
      x: params2.event.viewX,
      y: params2.event.viewY
    };
    if (layer.globalTransMatrix.transformPoint({
      x: params2.event.viewX,
      y: params2.event.viewY
    }, point6), targetDimensionInfo = [...null !== (_a = getCartesianDimensionInfo(chart, point6)) && void 0 !== _a ? _a : [], ...null !== (_b = getPolarDimensionInfo(chart, point6)) && void 0 !== _b ? _b : []], 0 === targetDimensionInfo.length) targetDimensionInfo = void 0;
    else if (targetDimensionInfo.length > 1) {
      const dimensionAxisInfo = targetDimensionInfo.filter((info) => {
        var _a2;
        const axis2 = info.axis;
        if (!isDiscrete(axis2.getScale().type)) return false;
        let firstSeries;
        for (const region of null !== (_a2 = null == axis2 ? void 0 : axis2.getRegions()) && void 0 !== _a2 ? _a2 : []) {
          for (const series2 of region.getSeries()) if ("cartesian" === series2.coordinate) {
            firstSeries = series2;
            break;
          }
          if (isValid_default(firstSeries)) break;
        }
        return isValid_default(firstSeries) && firstSeries.getDimensionField()[0] === firstSeries.fieldY[0] ? "left" === axis2.getOrient() || "right" === axis2.getOrient() : "bottom" === axis2.getOrient() || "top" === axis2.getOrient();
      });
      targetDimensionInfo = dimensionAxisInfo.length ? dimensionAxisInfo : targetDimensionInfo.slice(0, 1);
    }
    return targetDimensionInfo;
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/dimension-tooltip.js
var DimensionTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "dimension";
  }
  showTooltip(info, params2, changePositionOnly) {
    const newParams = Object.assign(Object.assign({}, params2), {
      dimensionInfo: this._preprocessDimensionInfo(info),
      changePositionOnly
    });
    return this._showTooltipByHandler(info, newParams);
  }
  shouldHandleTooltip(params2, mouseEventData) {
    var _a, _b;
    const { tooltipInfo: info } = mouseEventData;
    if (isNil_default(info)) return false;
    const helper = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
    return !!(null !== (_b = null == helper ? void 0 : helper.activeType) && void 0 !== _b ? _b : this.component.getSpec().activeType).includes("dimension");
  }
  getMouseEventData(params2) {
    var _a;
    return {
      tooltipInfo: this._getDimensionInfo(params2),
      ignore: [...null !== (_a = this.component.getOption().getAllSeries()) && void 0 !== _a ? _a : []].some((model) => {
        var _a2;
        const ignoreTriggers = null === (_a2 = model.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.ignoreTriggerSet.dimension;
        return params2.model && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.model)) || params2.mark && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark));
      })
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/processor/util.js
var isMarkInfo = (info) => isValid_default(info) && !isArray_default(info);
var isDimensionInfo = (info) => isValid_default(info) && isArray_default(info);

// node_modules/@visactor/vchart/esm/component/tooltip/processor/mark-tooltip.js
var MarkTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "mark";
  }
  showTooltip(info, params2, changePositionOnly) {
    const { datum, series: series2, dimensionInfo } = info, tooltipData = [{
      datum: [datum],
      series: series2
    }], newParams = Object.assign(Object.assign({}, params2), {
      dimensionInfo: this._preprocessDimensionInfo(dimensionInfo),
      changePositionOnly
    });
    return this._showTooltipByHandler(tooltipData, newParams);
  }
  shouldHandleTooltip(params2, mouseEventData) {
    var _a;
    const { tooltipInfo: info } = mouseEventData;
    if (isNil_default(info)) return false;
    const helper = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
    return !!(null == helper ? void 0 : helper.activeType.includes("mark"));
  }
  getMouseEventData(params2) {
    var _a;
    let info, ignore;
    if ("series" === (null === (_a = params2.model) || void 0 === _a ? void 0 : _a.modelType)) {
      const series2 = params2.model, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.mark, ignoreTriggers = null == helper ? void 0 : helper.ignoreTriggerSet.mark;
      (null == activeTriggers ? void 0 : activeTriggers.has(params2.model)) || (null == activeTriggers ? void 0 : activeTriggers.has(params2.mark)) ? info = {
        mark: params2.mark,
        datum: params2.datum,
        series: series2,
        dimensionInfo: this._getDimensionInfo(params2)
      } : ((null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.model)) || (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark))) && (ignore = true);
    }
    return {
      tooltipInfo: info,
      ignore
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/tooltip-transformer.js
var TooltipSpecTransformer = class extends BaseComponentSpecTransformer {
  _shouldMergeThemeToSpec() {
    return false;
  }
  _initTheme(spec, chartSpec) {
    const { spec: newSpec, theme: theme2 } = super._initTheme(spec, chartSpec);
    return newSpec.style = mergeSpec({}, this._theme, newSpec.style), {
      spec: newSpec,
      theme: theme2
    };
  }
};

// node_modules/@visactor/vchart/esm/component/tooltip/tooltip.js
var Tooltip3 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = 1, this.type = ComponentTypeEnum.tooltip, this.name = ComponentTypeEnum.tooltip, this.transformerConstructor = TooltipSpecTransformer, this.specKey = "tooltip", this.layoutType = "none", this._alwaysShow = false, this._eventList = [], this._isTooltipShown = false, this._mountEvent = (eType, query, callback) => {
      this.event.on(eType, query, callback), this._eventList.push({
        eventType: eType,
        handler: callback
      });
    }, this._getMouseOutHandler = (needPointerDetection) => (params2) => {
      var _a, _b;
      if (this._alwaysShow) return;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return;
      const browserEnv = isTrueBrowser(this._option.mode), { clientX, clientY } = params2.event;
      browserEnv && this._isPointerOnTooltip(params2) || browserEnv && needPointerDetection && this._isPointerInChart({
        x: clientX,
        y: clientY
      }) || this._handleChartMouseOut(params2);
    }, this._handleChartMouseOut = (params2) => {
      this._alwaysShow || "none" !== this._spec.triggerOff && (this._hideTooltipByHandler(Object.assign({}, params2)), this._cacheInfo = void 0);
    }, this._handleMouseMove = (params2) => {
      if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), this._alwaysShow) return;
      if (this._isPointerOnTooltip(params2)) return;
      const mouseEventData = this._getMouseEventData(params2), { tooltipInfo: { dimension: dimensionInfo }, ignore: { mark: ignoreMark, dimension: ignoreDimension } } = mouseEventData;
      let markTooltipSuccess = false, dimensionTooltipSuccess = false;
      markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params2), markTooltipSuccess || (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params2)), markTooltipSuccess || dimensionTooltipSuccess || isEmptyPos(params2) || (ignoreMark && isMarkInfo(this._cacheInfo) ? markTooltipSuccess = this._showTooltipByMouseEvent("mark", mouseEventData, params2, true) : ignoreDimension && isDimensionInfo(this._cacheInfo) ? dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params2, true) : isValid_default(dimensionInfo) && (dimensionTooltipSuccess = this._showTooltipByMouseEvent("dimension", mouseEventData, params2))), markTooltipSuccess || dimensionTooltipSuccess && !isNil_default(dimensionInfo) || this._handleChartMouseOut(params2);
    }, this._showTooltipByMouseEvent = (activeType, mouseEventData, params2, useCache) => {
      const processor = this._processor[activeType];
      if (!processor.shouldHandleTooltip(params2, {
        tooltipInfo: mouseEventData.tooltipInfo[activeType],
        ignore: mouseEventData.ignore[activeType]
      })) return false;
      let success;
      if (useCache) success = !processor.showTooltip(this._cacheInfo, params2, true);
      else {
        const tooltipInfo = mouseEventData.tooltipInfo[activeType], isSameAsCache = this._isSameAsCacheInfo(tooltipInfo);
        success = !processor.showTooltip(tooltipInfo, params2, isSameAsCache), success && (this._cacheInfo = tooltipInfo);
      }
      success && (this._isTooltipShown = true);
      const vchart = this._option.globalInstance;
      return success && VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), success;
    }, this._getMouseEventData = (params2) => {
      const result2 = {
        tooltipInfo: {},
        ignore: {}
      };
      return Object.keys(this._processor).forEach((activeType) => {
        const { tooltipInfo, ignore } = this._processor[activeType].getMouseEventData(params2);
        result2.tooltipInfo[activeType] = tooltipInfo, result2.ignore[activeType] = ignore;
      }), result2;
    }, this._hideTooltipByHandler = (params2) => {
      var _a, _b, _c;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a))) return TooltipResult.success;
      if (this.event.emit(ChartEvent.tooltipHide, Object.assign(Object.assign({}, params2), {
        source: Event_Source_Type.chart,
        tooltip: this
      })), null === (_c = this.tooltipHandler) || void 0 === _c ? void 0 : _c.hideTooltip) {
        const result2 = this.tooltipHandler.hideTooltip(params2);
        return result2 || (this._isTooltipShown = false), result2;
      }
      return TooltipResult.failed;
    };
  }
  static getSpecInfo(chartSpec) {
    const tooltipSpec = chartSpec[this.specKey];
    if (!tooltipSpec) return null;
    if (!isArray_default(tooltipSpec)) return [{
      spec: tooltipSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.tooltip
    }];
    const specInfos = [];
    return tooltipSpec.forEach((s3, i2) => {
      specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.tooltip
      });
    }), specInfos;
  }
  isTooltipShown() {
    return this._isTooltipShown;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  _registerEvent() {
  }
  _releaseEvent() {
  }
  onLayout(ctx) {
  }
  onLayoutEnd(ctx) {
  }
  onRender(ctx) {
  }
  created() {
    super.created(), this._regions = this._option.getAllRegions(), this._initEvent();
  }
  release() {
    var _a, _b;
    super.release(), this._eventList.forEach(({ eventType, handler }) => {
      this.event.off(eventType, handler);
    }), this._eventList = [], null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), this._isTooltipShown = false;
  }
  beforeRelease() {
    this.event.emit(ChartEvent.tooltipHide, {
      tooltip: this
    }), this.event.emit(ChartEvent.tooltipRelease, {
      tooltip: this
    });
  }
  _initHandler() {
    var _a, _b, _c;
    const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", userTooltipHandler = this._option.globalInstance.getTooltipHandlerByUser();
    if (userTooltipHandler) this.tooltipHandler = userTooltipHandler;
    else {
      const Handler = "canvas" === renderMode ? CanvasTooltipHandler : DomTooltipHandler, id2 = `${this._spec.className}-${null !== (_b = this._option.globalInstance.id) && void 0 !== _b ? _b : 0}-${null !== (_c = this._option.specIndex) && void 0 !== _c ? _c : 0}`;
      this.tooltipHandler = new Handler(id2, this);
    }
  }
  _initProcessor() {
    this._processor = {
      mark: new MarkTooltipProcessor(this),
      dimension: new DimensionTooltipProcessor(this)
    };
  }
  _initEvent() {
    var _a;
    if (this._option.disableTriggerEvent) return;
    const trigger = null !== (_a = this._spec.trigger) && void 0 !== _a ? _a : "hover", mode2 = this._option.mode;
    "hover" === trigger ? (this._mountEvent("pointermove", {
      level: Event_Bubble_Level.chart
    }, this._handleMouseMove), (isMobileLikeMode(mode2) || isMiniAppLikeMode(mode2)) && (this._mountEvent("pointerdown", {
      level: Event_Bubble_Level.chart
    }, this._handleMouseMove), this._mountEvent("pointerup", {
      source: "window"
    }, this._getMouseOutHandler(true))), this._mountEvent("pointerout", {
      source: "canvas"
    }, this._getMouseOutHandler(false))) : "click" === trigger && (this._mountEvent("pointertap", {
      level: Event_Bubble_Level.chart
    }, this._handleMouseMove), this._mountEvent("pointerup", {
      source: "window"
    }, this._getMouseOutHandler(true)));
  }
  reInit(spec) {
    var _a, _b;
    super.reInit(spec), this.tooltipHandler ? null === (_b = (_a = this.tooltipHandler).reInit) || void 0 === _b || _b.call(_a) : this._initHandler();
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec();
    const userSpec = this._spec;
    this._spec = Object.assign(Object.assign({}, userSpec), {
      visible: !isValid_default(userSpec.visible) || userSpec.visible,
      activeType: getTooltipActualActiveType(userSpec),
      renderMode: "html",
      trigger: isValid_default(userSpec.trigger) ? userSpec.trigger : "hover",
      className: isValid_default(userSpec.className) ? userSpec.className : TOOLTIP_EL_CLASS_NAME,
      enterable: !!isValid_default(userSpec.enterable) && userSpec.enterable,
      transitionDuration: isValid_default(userSpec.transitionDuration) ? userSpec.transitionDuration : 150
    }), this._spec.triggerOff = isValid_default(userSpec.triggerOff) ? userSpec.triggerOff : this._spec.trigger, isValid_default(userSpec.renderMode) ? this._spec.renderMode = userSpec.renderMode : isMiniAppLikeMode(this._option.mode) && (this._spec.renderMode = "canvas"), isValid_default(userSpec.mark) && (this._spec.mark = Object.assign(Object.assign({}, cloneDeep(userSpec.mark)), {
      activeType: "mark"
    })), isValid_default(userSpec.dimension) && (this._spec.dimension = Object.assign(Object.assign({}, cloneDeep(userSpec.dimension)), {
      activeType: "dimension"
    })), isValid_default(userSpec.parentElement) ? isString_default(userSpec.parentElement) ? this._spec.parentElement = null === (_a = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === _a ? void 0 : _a.getElementById(userSpec.parentElement) : this._spec.parentElement = userSpec.parentElement : isTrueBrowser(this._option.mode) && (this._spec.parentElement = null == domDocument ? void 0 : domDocument.body), isValid_default(userSpec.confine) ? this._spec.confine = userSpec.confine : this._spec.confine = "canvas" === this._spec.renderMode;
  }
  showTooltip(datum, options) {
    var _a;
    if (this.tooltipHandler || this._initHandler(), this._processor || this._initProcessor(), !(null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip)) return false;
    const result2 = showTooltip(datum, options, this.tooltipHandler, this._option);
    return "none" !== result2 && (this._alwaysShow = !!(null == options ? void 0 : options.alwaysShow)), result2;
  }
  hideTooltip() {
    const params2 = {
      changePositionOnly: false,
      item: void 0,
      datum: void 0,
      source: Event_Source_Type.chart
    };
    return this._alwaysShow = false, !this._hideTooltipByHandler(params2);
  }
  _isSameAsCacheInfo(nextInfo) {
    if (nextInfo === this._cacheInfo) return true;
    if (isNil_default(this._cacheInfo) || isNil_default(nextInfo)) return false;
    if (isDimensionInfo(nextInfo)) {
      if (isMarkInfo(this._cacheInfo)) return false;
      const prevInfo2 = this._cacheInfo;
      return prevInfo2.length === nextInfo.length && nextInfo.every((info, i2) => isSameDimensionInfo(info, prevInfo2[i2]));
    }
    if (isDimensionInfo(this._cacheInfo)) return false;
    const prevInfo = this._cacheInfo;
    return (null == nextInfo ? void 0 : nextInfo.datum) === prevInfo.datum && (null == nextInfo ? void 0 : nextInfo.mark) === prevInfo.mark && (null == nextInfo ? void 0 : nextInfo.series) === prevInfo.series;
  }
  _isPointerInChart(point6) {
    const globalInstance = this._option.globalInstance;
    if (!globalInstance.getChart()) return false;
    const { x: x3, y: y3 } = point6, canvas = globalInstance.getCanvas(), { x: chartX, y: chartY, width: chartWidth, height: chartHeight } = canvas.getBoundingClientRect();
    return x3 >= chartX && x3 <= chartX + chartWidth && y3 >= chartY && y3 <= chartY + chartHeight;
  }
  _isPointerOnTooltip(params2) {
    var _a, _b;
    if (this._spec.enterable && "html" === this._spec.renderMode) {
      const { event } = params2;
      let newTarget;
      if (isValid_default(event.nativeEvent)) {
        const nativeEvent = event.nativeEvent;
        newTarget = nativeEvent.relatedTarget, nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (newTarget = nativeEvent.composedPath()[0]);
      } else newTarget = event.relatedTarget;
      const container2 = null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.getTooltipContainer) || void 0 === _b ? void 0 : _b.call(_a);
      if (isValid_default(container2) && isValid_default(newTarget) && hasParentElement(newTarget, container2)) return true;
    }
    return false;
  }
  getVisible() {
    return false !== this._spec.visible;
  }
};
Tooltip3.type = ComponentTypeEnum.tooltip, Tooltip3.transformerConstructor = TooltipSpecTransformer, Tooltip3.specKey = "tooltip";
var registerTooltip = () => {
  Factory2.registerComponent(Tooltip3.type, Tooltip3);
};

// node_modules/@visactor/vchart/esm/component/crosshair/config.js
function getDefaultCrosshairTriggerEventByMode(mode2) {
  return mode2 === RenderModeEnum["desktop-browser"] || mode2 === RenderModeEnum["desktop-miniApp"] ? {
    click: "pointertap",
    hover: "pointermove",
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : isMobileLikeMode(mode2) || isMiniAppLikeMode(mode2) ? {
    click: "tap",
    hover: ["pointerdown", "pointermove"],
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : null;
}
var LayoutType;
!function(LayoutType2) {
  LayoutType2[LayoutType2.ALL = 3] = "ALL", LayoutType2[LayoutType2.HORIZONTAL = 2] = "HORIZONTAL", LayoutType2[LayoutType2.VERTICAL = 1] = "VERTICAL", LayoutType2[LayoutType2.NONE = 0] = "NONE";
}(LayoutType || (LayoutType = {}));

// node_modules/@visactor/vchart/esm/component/crosshair/base.js
var __rest18 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var ORIENT_MAP = {
  x: ["top", "bottom"],
  y: ["left", "right"],
  category: ["angle"],
  value: ["radius"]
};
var BaseCrossHair = class extends BaseComponent {
  get enableRemain() {
    return "none" === this.triggerOff;
  }
  constructor(spec, options) {
    super(spec, options), this.specKey = "crosshair", this.layoutType = "none", this.gridZIndex = LayoutZIndex.CrossHair_Grid, this.labelZIndex = LayoutZIndex.CrossHair, this.trigger = "hover", this.triggerOff = "hover", this._handleEvent = throttle_default((params2) => {
      if (!this._option) return;
      const { event } = params2, layer = this._option.getCompiler().getStage().getLayer(void 0), point6 = {
        x: event.viewX,
        y: event.viewY
      };
      layer.globalTransMatrix.transformPoint({
        x: event.viewX,
        y: event.viewY
      }, point6);
      const x3 = point6.x - this.getLayoutStartPoint().x, y3 = point6.y - this.getLayoutStartPoint().y;
      this.showDefault = false, this._layoutCrosshair(x3, y3);
    }, 10), this.enable = true, this.showDefault = true;
  }
  _getLimitBounds() {
    var _a, _b;
    if (!this._limitBounds) {
      const { width, height } = null !== (_b = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getCanvasRect()) && void 0 !== _b ? _b : {
        width: 0,
        height: 0
      };
      this._limitBounds = {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height
      };
    }
    return this._limitBounds;
  }
  _showDefaultCrosshair() {
    this.showDefault && this._showDefaultCrosshairBySpec();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._parseCrosshairSpec();
  }
  created() {
    super.created(), this._initEvent();
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  _initEvent() {
    if (this._option.disableTriggerEvent) return;
    const triggerConfig = this._getTriggerEvent();
    if (triggerConfig) {
      const { in: triggerEvent, out: outTriggerEvent } = triggerConfig;
      array(triggerEvent).forEach((eventName, index) => this._registerEvent(eventName, isArray_default(outTriggerEvent) ? outTriggerEvent[index] : outTriggerEvent));
    }
  }
  _registerEvent(inEventName, outEventName) {
    this.event.on(inEventName, {
      source: Event_Source_Type.chart
    }, this._handleEvent), this.event.on(outEventName, {
      level: Event_Bubble_Level.chart
    }, (...arg) => {
      this.enableRemain || this.hide();
    });
  }
  _eventOff(eventName) {
    this.event.off(eventName, this._handleEvent);
  }
  updateLayoutAttribute() {
    this._limitBounds = null, this._showDefaultCrosshair();
  }
  _getTriggerEvent() {
    const { mode: mode2 = RenderModeEnum["desktop-browser"] } = this._option, triggerConfig = getDefaultCrosshairTriggerEventByMode(mode2);
    if (triggerConfig) {
      const trigger = this.trigger || "hover", outTrigger = (trigger2) => "click" === trigger2 ? "clickOut" : "hoverOut";
      if (isArray_default(trigger)) {
        let inResult = [], outResult = [];
        return trigger.forEach((item) => {
          inResult = inResult.concat(triggerConfig[item]), outResult = outResult.concat(triggerConfig[outTrigger(item)]);
        }), {
          in: inResult,
          out: outResult
        };
      }
      return {
        in: triggerConfig[trigger],
        out: triggerConfig[outTrigger(trigger)]
      };
    }
    return null;
  }
  _getAxisInfoByField(field5) {
    var _a, _b;
    const axesComponents = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getComponentsByKey) || void 0 === _b ? void 0 : _b.call(_a, "axes");
    if (!(null == axesComponents ? void 0 : axesComponents.length)) return null;
    let bindingAxesIndex = get_default(this._spec, `${field5}Field.bindingAxesIndex`);
    if (bindingAxesIndex || (bindingAxesIndex = [], axesComponents.forEach((item, index) => {
      ORIENT_MAP[field5].includes(item.getOrient()) && bindingAxesIndex.push(index);
    })), !bindingAxesIndex.length) return null;
    const map4 = /* @__PURE__ */ new Map();
    let x14 = 1 / 0, y14 = 1 / 0, x23 = -1 / 0, y23 = -1 / 0;
    const { x: sx, y: sy } = this.getLayoutStartPoint();
    return bindingAxesIndex.forEach((idx) => {
      x14 = 1 / 0, y14 = 1 / 0, x23 = -1 / 0, y23 = -1 / 0;
      const axis2 = axesComponents.find((axis3) => axis3.getSpecIndex() === idx);
      if (!axis2) return;
      axis2.getRegions().forEach((r2) => {
        const { x: regionStartX, y: regionStartY } = r2.getLayoutStartPoint();
        x14 = Math.min(x14, regionStartX - sx), y14 = Math.min(y14, regionStartY - sy), x23 = Math.max(x23, regionStartX + r2.getLayoutRect().width - sx), y23 = Math.max(y23, regionStartY + r2.getLayoutRect().height - sy);
      }), map4.set(idx, {
        x1: x14,
        y1: y14,
        x2: x23,
        y2: y23,
        axis: axis2
      });
    }), map4;
  }
  changeRegions(regions) {
  }
  onLayoutEnd(ctx) {
    const region = this._regions[0];
    this.setLayoutRect(region.getLayoutRect()), this.setLayoutStartPosition(region.getLayoutStartPoint()), super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  _releaseEvent() {
    const triggerConfig = this._getTriggerEvent();
    if (triggerConfig) {
      const { in: triggerEvent, out: outTriggerEvent } = triggerConfig;
      isArray_default(triggerEvent) ? triggerEvent.forEach((eachTriggerEvent) => this._eventOff(eachTriggerEvent)) : this._eventOff(triggerEvent), isArray_default(outTriggerEvent) ? outTriggerEvent.forEach((eachTriggerEvent) => this._eventOff(eachTriggerEvent)) : this._eventOff(outTriggerEvent);
    }
  }
  _firstSeries() {
    for (let i2 = 0; i2 < this._regions.length; i2++) {
      const series2 = this._regions[i2].getSeries();
      for (let j2 = 0; j2 < series2.length; j2++) {
        const s3 = series2[j2];
        if (s3) return s3;
      }
    }
    return null;
  }
  _parseCrosshairSpec() {
    this._parseFieldInfo();
    const { trigger, triggerOff, labelZIndex, gridZIndex } = this._spec;
    trigger && (this.trigger = trigger), this.triggerOff = triggerOff || this.trigger, void 0 !== labelZIndex && (this.labelZIndex = labelZIndex), void 0 !== gridZIndex && (this.gridZIndex = gridZIndex);
  }
  _parseField(field5, fieldName) {
    var _a, _b, _c, _d;
    const hair = {}, { line: line2 = {}, label = {}, visible } = field5;
    hair.visible = visible, hair.type = line2.type || "line";
    const _e = line2.style || {}, { strokeOpacity, fillOpacity, opacity, stroke: stroke2, fill, lineWidth } = _e, restStyle = __rest18(_e, ["strokeOpacity", "fillOpacity", "opacity", "stroke", "fill", "lineWidth"]), isLineType = "line" === hair.type;
    let finalOpacity = isLineType ? strokeOpacity : fillOpacity;
    if (isNumber_default(opacity) && (finalOpacity = (null != finalOpacity ? finalOpacity : 1) * opacity), hair.style = false === (null == line2 ? void 0 : line2.visible) ? {
      visible: false
    } : Object.assign({
      opacity: finalOpacity,
      pickable: false,
      visible: true
    }, restStyle), isLineType) hair.style.stroke = stroke2 || fill, hair.style.lineWidth = get_default(line2, "width", lineWidth || 2);
    else {
      hair.style.fill = fill || stroke2, (null === (_c = null === (_b = null === (_a = this._spec[fieldName]) || void 0 === _a ? void 0 : _a.line) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.stroke) && (hair.style.stroke = this._spec[fieldName].line.style.stroke);
      const rectSize2 = get_default(line2, "width");
      if ("string" == typeof rectSize2) {
        const percent = parseInt(rectSize2.substring(0, rectSize2.length - 1), 10) / 100;
        hair.style.sizePercent = percent;
      } else "number" != typeof rectSize2 && "function" != typeof rectSize2 || (hair.style.size = rectSize2);
    }
    const labelBackground = label.labelBackground || {}, labelStyle = label.style || {}, _f = labelBackground.style || {}, { fill: rectFill = "rgba(47, 59, 82, 0.9)", stroke: rectStroke, outerBorder } = _f, rectStyle = __rest18(_f, ["fill", "stroke", "outerBorder"]);
    return hair.label = (null == label ? void 0 : label.visible) ? {
      visible: true,
      formatMethod: label.formatMethod,
      minWidth: labelBackground.minWidth,
      maxWidth: labelBackground.maxWidth,
      padding: labelBackground.padding,
      textStyle: Object.assign(Object.assign({
        fontSize: 14,
        pickable: false
      }, labelStyle), {
        fill: null !== (_d = labelStyle.fill) && void 0 !== _d ? _d : "#fff",
        stroke: get_default(labelStyle, "stroke")
      }),
      panel: (isBoolean_default(null == labelBackground ? void 0 : labelBackground.visible) ? null == labelBackground ? void 0 : labelBackground.visible : labelBackground) ? Object.assign({
        visible: true,
        pickable: false,
        fill: rectFill,
        stroke: rectStroke,
        outerBorder: Object.assign({
          stroke: rectFill,
          distance: 0,
          lineWidth: 3
        }, outerBorder)
      }, rectStyle) : {
        visible: false
      },
      zIndex: this.labelZIndex,
      childrenPickable: false,
      pickable: false
    } : {
      visible: false
    }, hair;
  }
  _filterAxisByPoint(axisMap, relativeX, relativeY) {
    return axisMap && axisMap.forEach((item) => {
      const axis2 = item.axis;
      if (outOfBounds(item, relativeX, relativeY) && axisMap.delete(axis2.getSpecIndex()), axis2.type.startsWith("polarAxis")) {
        const center2 = axis2.getCenter(), innerRadius = axis2.getInnerRadius(), outerRadius = axis2.getOuterRadius(), distance2 = PointService.distancePP({
          x: relativeX,
          y: relativeY
        }, center2);
        (distance2 > outerRadius || distance2 < innerRadius) && axisMap.delete(axis2.getSpecIndex());
      }
    }), axisMap;
  }
};
BaseCrossHair.specKey = "crosshair";

// node_modules/@visactor/vchart/esm/component/crosshair/cartesian.js
var CartesianCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    const crosshairSpec = chartSpec[this.specKey];
    if (isNil_default(crosshairSpec)) return;
    if (!isArray_default(crosshairSpec)) return crosshairSpec.xField || crosshairSpec.yField ? [{
      spec: crosshairSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.cartesianCrosshair
    }] : void 0;
    const specInfos = [];
    return crosshairSpec.forEach((s3, i2) => {
      (s3.xField || s3.yField) && specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.cartesianCrosshair
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianCrosshair, this.name = ComponentTypeEnum.cartesianCrosshair, this._currValueX = /* @__PURE__ */ new Map(), this._currValueY = /* @__PURE__ */ new Map();
  }
  _showDefaultCrosshairBySpec() {
    const { xField, yField } = this._spec;
    if ((null == xField ? void 0 : xField.visible) && xField.defaultSelect) {
      const { axisIndex, datum } = xField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 1);
    }
    if ((null == yField ? void 0 : yField.visible) && yField.defaultSelect) {
      const { axisIndex, datum } = yField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 2);
    }
  }
  _defaultCrosshair(axisIndex, datum, tag) {
    const axis2 = this._option.getComponentsByKey("axes").find((c4) => c4.getSpecIndex() === axisIndex);
    axis2 && (1 === tag ? (this._currValueX.clear(), this._currValueX.set(axisIndex, {
      axis: axis2,
      v: datum
    })) : (this._currValueY.clear(), this._currValueY.set(axisIndex, {
      axis: axis2,
      v: datum
    })), this.layoutByValue(tag));
  }
  _findAllAxisContains(relativeX, relativeY) {
    const xAxisMap = this._getAxisInfoByField("x"), yAxisMap = this._getAxisInfoByField("y");
    return {
      xAxisMap: this._filterAxisByPoint(xAxisMap, relativeX, relativeY),
      yAxisMap: this._filterAxisByPoint(yAxisMap, relativeX, relativeY)
    };
  }
  _getValueAt(axis2, p2) {
    let value = axis2.getScale().invert(p2);
    return isContinuous(axis2.getScale().type) && isValidNumber_default(+value) && (value = (+value).toFixed(2)), value;
  }
  clearAxisValue() {
    this._currValueX.clear(), this._currValueY.clear();
  }
  setAxisValue(v2, axis2) {
    isXAxis(axis2.getOrient()) ? this._currValueX.set(axis2.getSpecIndex(), {
      v: v2,
      axis: axis2
    }) : this._currValueY.set(axis2.getSpecIndex(), {
      v: v2,
      axis: axis2
    });
  }
  _getAllAxisValues(axisMap, p2, currValue, vertical) {
    let discrete = false;
    return axisMap.forEach((item) => {
      isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = false : discrete = true);
    }), !!this.enable && (axisMap.forEach((item, id2) => {
      const axis2 = item.axis;
      currValue.set(id2, {
        v: this._getValueAt(axis2, p2 - (vertical ? axis2.getLayoutStartPoint().x - this.getLayoutStartPoint().x : axis2.getLayoutStartPoint().y - this.getLayoutStartPoint().y)),
        axis: axis2
      });
    }), true);
  }
  _layoutCrosshair(relativeX, relativeY) {
    const { xAxisMap, yAxisMap } = this._findAllAxisContains(relativeX, relativeY);
    if (xAxisMap && 0 === xAxisMap.size || yAxisMap && 0 === yAxisMap.size) {
      if (this.enableRemain) return;
      this.hide();
    } else this._currValueX.clear(), this._currValueY.clear(), xAxisMap && xAxisMap.size && this._getAllAxisValues(xAxisMap, relativeX, this._currValueX, true), yAxisMap && yAxisMap.size && this._getAllAxisValues(yAxisMap, relativeY, this._currValueY, false), this.layoutByValue(3);
  }
  hide() {
    this._xCrosshair && this._xCrosshair.hideAll(), this._xTopLabel && this._xTopLabel.hideAll(), this._xBottomLabel && this._xBottomLabel.hideAll(), this._yCrosshair && this._yCrosshair.hideAll(), this._yLeftLabel && this._yLeftLabel.hideAll(), this._yRightLabel && this._yRightLabel.hideAll();
  }
  layoutByValue(tag = 3) {
    var _a, _b, _c, _d;
    if (!this.enable) return;
    const series2 = this._firstSeries();
    if (!series2) return;
    let xCrossHairInfo = {
      height: 0,
      leftPos: 0,
      rightPos: 0,
      topPos: 0,
      x: 0,
      bottom: {
        visible: false,
        text: "",
        dx: 0,
        dy: 0
      },
      top: {
        visible: false,
        text: "",
        dx: 0,
        dy: 0
      },
      visible: false,
      axis: null
    }, yCrossHairInfo = {
      width: 0,
      leftPos: 0,
      topPos: 0,
      bottomPos: 0,
      y: 0,
      left: {
        visible: false,
        text: "",
        dx: 0,
        dy: 0
      },
      right: {
        visible: false,
        text: "",
        dx: 0,
        dy: 0
      },
      visible: false,
      axis: null
    };
    const getRegionArea = (outRegion, currentValue) => {
      currentValue.forEach(({ axis: axis2 }) => {
        axis2.getRegions().forEach((r2) => {
          outRegion.x1 = Math.min(outRegion.x1, r2.getLayoutStartPoint().x), outRegion.y1 = Math.min(outRegion.y1, r2.getLayoutStartPoint().y), outRegion.x2 = Math.max(outRegion.x2, r2.getLayoutStartPoint().x + r2.getLayoutRect().width), outRegion.y2 = Math.max(outRegion.y2, r2.getLayoutStartPoint().y + r2.getLayoutRect().height);
        });
      });
    };
    let x3 = 0, y3 = 0;
    if (this._currValueX.size) {
      const item = Array.from(this._currValueX.values())[0];
      x3 = item.axis.getScale().scale(item.v) + item.axis.getLayoutStartPoint().x - this.getLayoutStartPoint().x, xCrossHairInfo.axis = item.axis;
    }
    if (this._currValueY.size) {
      const item = Array.from(this._currValueY.values())[0];
      y3 = item.axis.getScale().scale(item.v) + item.axis.getLayoutStartPoint().y - this.getLayoutStartPoint().y, yCrossHairInfo.axis = item.axis;
    }
    xCrossHairInfo.visible = !!this._currValueX.size && Number.isFinite(x3), yCrossHairInfo.visible = !!this._currValueY.size && Number.isFinite(y3);
    const xRegion = {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0
    }, yRegion = {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0
    };
    let indexWidth;
    getRegionArea(xRegion, this._currValueX), getRegionArea(yRegion, this._currValueY);
    let valueHeight, offsetWidth = 0, offsetHeight = 0;
    if (this._xHair && this._currValueX.forEach(({ axis: axis2, v: v2 }) => {
      var _a2;
      v2 = null != v2 ? v2 : "";
      const xScale = axis2.getScale();
      if (isDiscrete(xScale.type)) indexWidth = xScale.bandwidth(), 0 === indexWidth && xScale.step && (offsetWidth = xScale.step());
      else if (isContinuous(xScale.type)) {
        const fieldX = series2.fieldX[0], fieldX2 = series2.fieldX2, datum = getDatumByValue(series2.getViewData().latestData, +v2, fieldX, fieldX2);
        if (datum) {
          const startX = series2.dataToPositionX(datum);
          fieldX2 ? (indexWidth = Math.abs(startX - series2.dataToPositionX1(datum)), v2 = `${datum[fieldX]} ~ ${datum[fieldX2]}`) : indexWidth = 1, x3 = startX;
        }
      }
      if (null === (_a2 = this._xHair.label) || void 0 === _a2 ? void 0 : _a2.visible) {
        const labelOffset = getAxisLabelOffset(axis2.getSpec());
        "bottom" === axis2.getOrient() ? (xCrossHairInfo.bottom.visible = true, xCrossHairInfo.bottom.text = v2, xCrossHairInfo.bottom.dx = 0, xCrossHairInfo.bottom.dy = labelOffset) : "top" === axis2.getOrient() && (xCrossHairInfo.top.visible = true, xCrossHairInfo.top.text = v2, xCrossHairInfo.top.dx = 0, xCrossHairInfo.top.dy = -labelOffset);
      }
    }), this._yHair && this._currValueY.forEach(({ axis: axis2, v: v2 }) => {
      var _a2;
      v2 = null != v2 ? v2 : "";
      const yScale = axis2.getScale();
      if (isDiscrete(yScale.type)) valueHeight = yScale.bandwidth(), 0 === valueHeight && yScale.step && (offsetHeight = yScale.step());
      else if (isContinuous(yScale.type)) {
        const fieldY = series2.fieldY[0], fieldY2 = series2.fieldY2, datum = getDatumByValue(series2.getViewData().latestData, +v2, fieldY, fieldY2);
        if (datum) {
          const startY = series2.dataToPositionY(datum);
          fieldY2 ? (valueHeight = Math.abs(startY - series2.dataToPositionY1(datum)), v2 = `${datum[fieldY]} ~ ${datum[fieldY2]}`) : valueHeight = 1, y3 = startY;
        }
      }
      if (null === (_a2 = this._yHair.label) || void 0 === _a2 ? void 0 : _a2.visible) {
        const labelOffset = getAxisLabelOffset(axis2.getSpec());
        "left" === axis2.getOrient() ? (yCrossHairInfo.left.visible = true, yCrossHairInfo.left.text = v2, yCrossHairInfo.left.dx = -labelOffset, yCrossHairInfo.left.dy = 0) : "right" === axis2.getOrient() && (yCrossHairInfo.right.visible = true, yCrossHairInfo.right.text = v2, yCrossHairInfo.right.dx = labelOffset, yCrossHairInfo.right.dy = 0);
      }
    }), this.enableRemain && !xCrossHairInfo.visible && isValid_default(this._cacheXCrossHairInfo)) xCrossHairInfo = this._cacheXCrossHairInfo;
    else if (xCrossHairInfo.leftPos = xRegion.x1, xCrossHairInfo.rightPos = xRegion.x2, xCrossHairInfo.topPos = xRegion.y1, xCrossHairInfo.height = xRegion.y2 - xRegion.y1, xCrossHairInfo.x = x3 + this.getLayoutStartPoint().x, null === (_b = null === (_a = this._xHair) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.formatMethod) {
      const { top, bottom } = xCrossHairInfo;
      bottom.visible && (bottom.text = this._xHair.label.formatMethod(bottom.text, "bottom")), top.visible && (top.text = this._xHair.label.formatMethod(top.text, "top"));
    }
    if (this.enableRemain && !yCrossHairInfo.visible && isValid_default(this._cacheYCrossHairInfo)) yCrossHairInfo = this._cacheYCrossHairInfo;
    else if (yCrossHairInfo.leftPos = yRegion.x1, yCrossHairInfo.topPos = yRegion.y1, yCrossHairInfo.bottomPos = yRegion.y2, yCrossHairInfo.width = yRegion.x2 - yRegion.x1, yCrossHairInfo.y = y3 + this.getLayoutStartPoint().y, null === (_d = null === (_c = this._yHair) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.formatMethod) {
      const { left: left2, right: right2 } = yCrossHairInfo;
      left2.visible && (left2.text = this._yHair.label.formatMethod(left2.text, "left")), right2.visible && (right2.text = this._yHair.label.formatMethod(right2.text, "right"));
    }
    tag && (this._layoutHorizontal(yCrossHairInfo, null != valueHeight ? valueHeight : 0, offsetHeight), this._layoutVertical(xCrossHairInfo, null != indexWidth ? indexWidth : 0, offsetWidth)), this.enableRemain && (this._cacheXCrossHairInfo = Object.assign(Object.assign({}, xCrossHairInfo), {
      _isCache: true
    }), this._cacheYCrossHairInfo = Object.assign(Object.assign({}, yCrossHairInfo), {
      _isCache: true
    }));
  }
  _layoutVertical(crosshairInfo, bandWidth, offsetWidth) {
    var _a, _b;
    if (crosshairInfo._isCache && this.enableRemain || !this._xHair) return;
    const { x: x3, topPos, height, top, bottom, visible } = crosshairInfo;
    if (visible) {
      const type = this._xHair.type;
      let positionAttribute;
      if ("line" === type) positionAttribute = {
        start: {
          x: x3 + bandWidth / 2,
          y: topPos
        },
        end: {
          x: x3 + bandWidth / 2,
          y: topPos + height
        }
      };
      else if ("rect" === type) {
        const extend = this._getRectSize(this._xHair, bandWidth, crosshairInfo.axis), { leftPos, rightPos } = crosshairInfo;
        positionAttribute = {
          start: {
            x: Math.max(x3 - extend / 2 - offsetWidth / 2, leftPos),
            y: topPos
          },
          end: {
            x: Math.min(x3 + bandWidth + extend / 2 + offsetWidth / 2, rightPos),
            y: topPos + height
          }
        };
      }
      if (this._updateCrosshair("x", type, positionAttribute), top.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: x3 + bandWidth / 2,
          y: topPos
        }, top), this._xHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._xHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: "center",
            textBaseline: "bottom"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._xTopLabel, updateAttrs, (label) => {
          label.name = "crosshair-x-top-label", this._xTopLabel = label;
        });
      } else this._xTopLabel && this._xTopLabel.hideAll();
      if (bottom.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: x3 + bandWidth / 2,
          y: topPos + height
        }, bottom), this._xHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_b = this._xHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
            textAlign: "center",
            textBaseline: "top"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._xBottomLabel, updateAttrs, (label) => {
          label.name = "crosshair-x-bottom-label", this._xBottomLabel = label;
        });
      } else this._xBottomLabel && this._xBottomLabel.hideAll();
    }
  }
  _layoutHorizontal(crosshairInfo, bandHeight, offsetHeight) {
    var _a, _b;
    if (crosshairInfo._isCache && this.enableRemain || !this._yHair) return;
    const { leftPos, width, y: y3, left: left2, right: right2, visible } = crosshairInfo;
    if (visible) {
      const type = this._yHair.type;
      let positionAttribute;
      if ("line" === type) positionAttribute = {
        start: {
          x: leftPos,
          y: y3 + bandHeight / 2
        },
        end: {
          x: leftPos + width,
          y: y3 + bandHeight / 2
        }
      };
      else if ("rect" === type) {
        const extend = this._getRectSize(this._yHair, bandHeight, crosshairInfo.axis), { topPos, bottomPos } = crosshairInfo;
        positionAttribute = {
          start: {
            x: leftPos,
            y: Math.max(y3 - extend / 2 - offsetHeight / 2, topPos)
          },
          end: {
            x: leftPos + width,
            y: Math.min(y3 + bandHeight + extend / 2 + offsetHeight / 2, bottomPos)
          }
        };
      }
      if (this._updateCrosshair("y", type, positionAttribute), left2.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: leftPos,
          y: y3 + bandHeight / 2
        }, left2), this._yHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._yHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: "right",
            textBaseline: "middle"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._yLeftLabel, updateAttrs, (label) => {
          label.name = "crosshair-y-left-label", this._yLeftLabel = label;
        });
      } else this._yLeftLabel && this._yLeftLabel.hideAll();
      if (right2.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: leftPos + width,
          y: y3 + bandHeight
        }, right2), this._yHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_b = this._yHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
            textAlign: "left",
            textBaseline: "middle"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._yRightLabel, updateAttrs, (label) => {
          label.name = "crosshair-y-right-label", this._yRightLabel = label;
        });
      } else this._yRightLabel && this._yRightLabel.hideAll();
    }
  }
  _getRectSize(hair, bandSize, axis2) {
    var _a, _b, _c;
    let extend = 0;
    if (null === (_a = hair.style) || void 0 === _a ? void 0 : _a.sizePercent) extend = (hair.style.sizePercent - 1) * bandSize;
    else if ("number" == typeof (null === (_b = hair.style) || void 0 === _b ? void 0 : _b.size)) extend = hair.style.size - bandSize;
    else if ("function" == typeof (null === (_c = hair.style) || void 0 === _c ? void 0 : _c.size)) {
      const axisRect = axis2.getLayoutRect();
      extend = hair.style.size(axisRect, axis2) - bandSize;
    }
    return extend;
  }
  _parseFieldInfo() {
    const { xField, yField } = this._spec;
    xField && xField.visible && (this._xHair = this._parseField(xField, "xField")), yField && yField.visible && (this._yHair = this._parseField(yField, "yField"));
  }
  _updateCrosshair(dim, type, attributes) {
    const container2 = this.getContainer();
    let crosshair2, style;
    "x" === dim ? (crosshair2 = this._xCrosshair, style = this._xHair.style) : (crosshair2 = this._yCrosshair, style = this._yHair.style), crosshair2 ? crosshair2.setAttributes(attributes) : ("line" === type ? crosshair2 = new LineCrosshair(Object.assign(Object.assign({}, attributes), {
      lineStyle: style,
      zIndex: this.gridZIndex + 1,
      disableTriggerEvent: this._option.disableTriggerEvent
    })) : "rect" === type && (crosshair2 = new RectCrosshair(Object.assign(Object.assign({}, attributes), {
      rectStyle: style,
      zIndex: this.gridZIndex,
      disableTriggerEvent: this._option.disableTriggerEvent
    }))), null == container2 || container2.add(crosshair2), "x" === dim ? this._xCrosshair = crosshair2 : this._yCrosshair = crosshair2);
  }
  _updateCrosshairLabel(label, attributes, callback) {
    const container2 = this.getContainer();
    label ? label.setAttributes(attributes) : (callback(label = new Tag(attributes)), null == container2 || container2.add(label)), limitTagInBounds(label, this._getLimitBounds());
  }
  _getNeedClearVRenderComponents() {
    return [this._xCrosshair, this._xTopLabel, this._xBottomLabel, this._yCrosshair, this._yLeftLabel, this._yRightLabel];
  }
};
CartesianCrossHair.specKey = "crosshair", CartesianCrossHair.type = ComponentTypeEnum.cartesianCrosshair;
var registerCartesianCrossHair = () => {
  Factory2.registerComponent(CartesianCrossHair.type, CartesianCrossHair);
};

// node_modules/@visactor/vchart/esm/component/crosshair/polar.js
var __rest19 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var PolarCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    const crosshairSpec = chartSpec[this.specKey];
    if (isNil_default(crosshairSpec)) return;
    if (!isArray_default(crosshairSpec)) return crosshairSpec.categoryField || crosshairSpec.valueField ? [{
      spec: crosshairSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.polarCrosshair
    }] : void 0;
    const specInfos = [];
    return crosshairSpec.forEach((s3, i2) => {
      (s3.categoryField || s3.valueField) && specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.polarCrosshair
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.polarCrosshair, this.name = ComponentTypeEnum.polarCrosshair, this._currValueAngle = /* @__PURE__ */ new Map(), this._currValueRadius = /* @__PURE__ */ new Map();
  }
  _showDefaultCrosshairBySpec() {
    const { categoryField, valueField } = this._spec;
    if ((null == categoryField ? void 0 : categoryField.visible) && categoryField.defaultSelect) {
      const { axisIndex, datum } = categoryField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 1);
    }
    if ((null == valueField ? void 0 : valueField.visible) && valueField.defaultSelect) {
      const { axisIndex, datum } = valueField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 2);
    }
  }
  _defaultCrosshair(axisIndex, datum, tag) {
    const axis2 = this._option.getComponentsByKey("axes").find((c4) => c4.getSpecIndex() === axisIndex);
    if (axis2) {
      if (1 === tag) {
        this._currValueAngle.clear();
        const polarCoord = {
          angle: axis2.valueToPosition(datum),
          radius: axis2.getOuterRadius()
        }, canvasPosition = axis2.coordToPoint(polarCoord);
        this._currValueAngle.set(axisIndex, this._getValueByAxis(axis2, canvasPosition));
      } else {
        this._currValueRadius.clear();
        const polarCoord = {
          angle: axis2.startAngle,
          radius: axis2.valueToPosition(datum)
        }, canvasPosition = axis2.coordToPoint(polarCoord);
        this._currValueRadius.set(axisIndex, this._getValueByAxis(axis2, canvasPosition));
      }
      this.layoutByValue(3);
    }
  }
  hide() {
    this._radiusCrosshair && this._radiusCrosshair.hideAll(), this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll(), this._angleCrosshair && this._angleCrosshair.hideAll(), this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
  }
  _findAllAxisContains(relativeX, relativeY) {
    const angleAxisMap = this._getAxisInfoByField("category"), radiusAxisMap = this._getAxisInfoByField("value");
    return {
      angleAxisMap: this._filterAxisByPoint(angleAxisMap, relativeX, relativeY),
      radiusAxisMap: this._filterAxisByPoint(radiusAxisMap, relativeX, relativeY)
    };
  }
  _getAllAxisValues(axisMap, point6, currValue) {
    let discrete = false;
    return axisMap.forEach((item) => {
      isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = false : discrete = true);
    }), !!this.enable && (axisMap.forEach((item, id2) => {
      const axis2 = item.axis;
      currValue.set(id2, this._getValueByAxis(axis2, point6));
    }), true);
  }
  _getValueByAxis(axis2, point6) {
    const { x: axisStartX, y: axisStartY } = axis2.getLayoutStartPoint(), { x: x3, y: y3 } = this.getLayoutStartPoint();
    let value = axis2.positionToData({
      x: point6.x - (axisStartX - x3),
      y: point6.y - (axisStartY - y3)
    });
    isContinuous(axis2.getScale().type) && isValidNumber_default(+value) && (value = (+value).toFixed(2));
    const center2 = {
      x: axis2.getCenter().x + this.getLayoutStartPoint().x,
      y: axis2.getCenter().y + this.getLayoutStartPoint().y
    };
    return {
      v: value,
      axis: axis2,
      center: center2,
      innerRadius: axis2.getInnerRadius(),
      radius: axis2.getOuterRadius(),
      startAngle: axis2.startAngle,
      endAngle: axis2.endAngle,
      distance: PointService.distancePP(point6, axis2.getCenter()),
      coord: axis2.pointToCoord(point6),
      point: point6
    };
  }
  _layoutCrosshair(relativeX, relativeY) {
    const { angleAxisMap, radiusAxisMap } = this._findAllAxisContains(relativeX, relativeY);
    if (0 !== angleAxisMap.size || 0 !== radiusAxisMap.size) this._currValueAngle.clear(), this._currValueRadius.clear(), angleAxisMap && this._getAllAxisValues(angleAxisMap, {
      x: relativeX,
      y: relativeY
    }, this._currValueAngle), radiusAxisMap && this._getAllAxisValues(radiusAxisMap, {
      x: relativeX,
      y: relativeY
    }, this._currValueRadius), this.layoutByValue(3);
    else {
      if (this.enableRemain) return;
      this.hide();
    }
  }
  layoutByValue(tag = 3) {
    var _a, _b, _c, _d;
    if (!this.enable) return;
    const series2 = this._firstSeries();
    if (!series2) return;
    let angleCrossHairInfo = {
      x: 0,
      y: 0,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      distance: 0,
      startAngle: 0,
      endAngle: 0,
      innerRadius: 0,
      visible: false,
      label: {
        visible: false,
        text: "",
        offset: 0
      }
    }, radiusCrossHairInfo = {
      x: 0,
      y: 0,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      distance: 0,
      startAngle: 0,
      endAngle: 0,
      innerRadius: 0,
      visible: false,
      sides: series2.angleAxisHelper.getScale(0).ticks().length,
      label: {
        visible: false,
        text: "",
        offset: 0
      }
    };
    if (this._angleHair) {
      angleCrossHairInfo.visible = !!this._currValueAngle.size;
      const bandWidth = series2.angleAxisHelper.getBandwidth(0);
      this._currValueAngle.forEach((_a2) => {
        var _b2, { axis: axis2, v: v2, coord } = _a2, rest = __rest19(_a2, ["axis", "v", "coord"]);
        v2 = null != v2 ? v2 : "", mergeSpec(angleCrossHairInfo, rest);
        const angle2 = series2.angleAxisHelper.dataToPosition([v2]);
        angleCrossHairInfo.angle = angle2, (null === (_b2 = this._angleHair.label) || void 0 === _b2 ? void 0 : _b2.visible) && (angleCrossHairInfo.label.visible = true, angleCrossHairInfo.label.text = v2, angleCrossHairInfo.label.offset = getAxisLabelOffset(axis2.getSpec())), angleCrossHairInfo.startAngle = angle2 - bandWidth / 2, angleCrossHairInfo.endAngle = angle2 + bandWidth / 2;
      });
    }
    if (this._radiusHair && (radiusCrossHairInfo.visible = !!this._currValueRadius.size, this._currValueRadius.forEach((_a2) => {
      var _b2, { axis: axis2, v: v2, coord } = _a2, rest = __rest19(_a2, ["axis", "v", "coord"]);
      v2 = null != v2 ? v2 : "", (null === (_b2 = this._radiusHair.label) || void 0 === _b2 ? void 0 : _b2.visible) && (radiusCrossHairInfo.label.visible = true, radiusCrossHairInfo.label.text = v2, radiusCrossHairInfo.label.offset = getAxisLabelOffset(axis2.getSpec())), radiusCrossHairInfo.angle = coord.angle, radiusCrossHairInfo.axis = axis2, mergeSpec(radiusCrossHairInfo, rest);
    })), this.enableRemain && !angleCrossHairInfo.visible && isValid_default(this._cacheAngleCrossHairInfo)) angleCrossHairInfo = this._cacheAngleCrossHairInfo;
    else if ((null === (_b = null === (_a = this._angleHair) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.formatMethod) && angleCrossHairInfo.label.visible) {
      const { label } = angleCrossHairInfo;
      label.text = this._angleHair.label.formatMethod(label.text, "angle");
    }
    if (this.enableRemain && !radiusCrossHairInfo.visible && isValid_default(this._cacheRadiusCrossHairInfo)) radiusCrossHairInfo = this._cacheRadiusCrossHairInfo;
    else if ((null === (_d = null === (_c = this._radiusHair) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.formatMethod) && radiusCrossHairInfo.label.visible) {
      const { label } = radiusCrossHairInfo;
      label.text = this._radiusHair.label.formatMethod(label.text, "radius");
    }
    tag && (this._layoutHorizontal(radiusCrossHairInfo), this._layoutVertical(angleCrossHairInfo)), this.enableRemain && (this._cacheAngleCrossHairInfo = Object.assign(Object.assign({}, angleCrossHairInfo), {
      _isCache: true
    }), this._cacheRadiusCrossHairInfo = Object.assign(Object.assign({}, radiusCrossHairInfo), {
      _isCache: true
    }));
  }
  _layoutVertical(crosshairInfo) {
    var _a;
    if (crosshairInfo._isCache && this.enableRemain) return;
    const container2 = this.getContainer(), { angle: angle2, innerRadius, radius, label, startAngle, endAngle, center: center2, visible } = crosshairInfo;
    if (visible) {
      const crosshairType = "rect" === this._angleHair.type ? "sector" : "line";
      let positionAttrs;
      if (positionAttrs = "sector" === crosshairType ? {
        center: center2,
        innerRadius,
        radius,
        startAngle,
        endAngle
      } : {
        start: polarToCartesian(center2, innerRadius, angle2),
        end: polarToCartesian(center2, radius, angle2)
      }, this._angleCrosshair) this._angleCrosshair.setAttributes(positionAttrs);
      else {
        let crosshair2;
        "line" === crosshairType ? crosshair2 = new LineCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._angleHair.style,
          zIndex: this.gridZIndex
        })) : "sector" === crosshairType && (crosshair2 = new SectorCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          sectorStyle: this._angleHair.style,
          zIndex: this.gridZIndex
        }))), this._angleCrosshair = crosshair2, container2.add(crosshair2);
      }
      if (label.visible) {
        const orient = angleLabelOrientAttribute(angle2), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center2, radius + label.offset, angle2)), this._angleHair.label), label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._angleHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: orient.align,
            textBaseline: orient.baseline
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._angleLabelCrosshair, labelAttrs, (label2) => {
          label2.name = "crosshair-angle-label", this._angleLabelCrosshair = label2;
        });
      } else this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
    }
  }
  _layoutHorizontal(crosshairInfo) {
    var _a;
    if (crosshairInfo._isCache && this.enableRemain) return;
    const { center: center2, startAngle, endAngle, distance: distance2, sides, axis: axis2, label, point: point6, radius, innerRadius, visible } = crosshairInfo, container2 = this.getContainer();
    if (visible) {
      const crosshairType = this._radiusHair.smooth ? "circle" : "polygon";
      let polygonRadius = distance2;
      if ("polygon" === crosshairType) {
        const axisCenter = axis2.getCenter(), curAngle = getAngleByPoint(axisCenter, point6), stepAngle = (endAngle - startAngle) / sides, index = Math.floor((curAngle - startAngle) / stepAngle), preAngle = index * stepAngle + startAngle, nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle), prePoint = polarToCartesian(axisCenter, distance2, preAngle), nextPoint = polarToCartesian(axisCenter, distance2, nextAngle), insertPoint = getIntersectPoint([nextPoint.x, nextPoint.y], [prePoint.x, prePoint.y], [axisCenter.x, axisCenter.y], [point6.x, point6.y]);
        insertPoint && (polygonRadius = clamp_default(PointService.distancePN(point6, insertPoint[0], insertPoint[1]) + distance2, innerRadius, radius));
      }
      const positionAttrs = {
        center: center2,
        startAngle,
        endAngle,
        radius: polygonRadius,
        sides
      };
      if (this._radiusCrosshair) this._radiusCrosshair.setAttributes(positionAttrs);
      else {
        let crosshair2;
        crosshair2 = "polygon" === crosshairType ? new PolygonCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._radiusHair.style,
          zIndex: this.gridZIndex + 1
        })) : new CircleCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._radiusHair.style,
          zIndex: this.gridZIndex
        })), this._radiusCrosshair = crosshair2, container2.add(crosshair2);
      }
      if (label.visible) {
        const orient = radiusLabelOrientAttribute(startAngle), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center2, polygonRadius, startAngle)), this._radiusHair.label), label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._radiusHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: orient.align,
            textBaseline: orient.baseline
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._radiusLabelCrosshair, labelAttrs, (label2) => {
          label2.name = "crosshair-radius-label", this._radiusLabelCrosshair = label2;
        });
      } else this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();
    }
  }
  _parseFieldInfo() {
    var _a;
    const { categoryField, valueField } = this._spec;
    categoryField && categoryField.visible && (this._angleHair = this._parseField(categoryField, "categoryField")), valueField && valueField.visible && (this._radiusHair = this._parseField(valueField, "valueField"), this._radiusHair.smooth = null === (_a = null == valueField ? void 0 : valueField.line) || void 0 === _a ? void 0 : _a.smooth);
  }
  _updateCrosshairLabel(label, labelAttrs, callback) {
    const container2 = this.getContainer();
    label ? label.setAttributes(labelAttrs) : (label = new Tag(labelAttrs), null == container2 || container2.add(label), callback(label)), limitTagInBounds(label, this._getLimitBounds());
  }
  _getNeedClearVRenderComponents() {
    return [this._radiusCrosshair, this._radiusLabelCrosshair, this._angleCrosshair, this._angleLabelCrosshair];
  }
};
PolarCrossHair.specKey = "crosshair", PolarCrossHair.type = ComponentTypeEnum.polarCrosshair;
var registerPolarCrossHair = () => {
  Factory2.registerComponent(PolarCrossHair.type, PolarCrossHair);
};

// node_modules/@visactor/vchart/esm/component/data-zoom/data-filter-base-component.js
var DataFilterBaseComponent = class extends BaseComponent {
  get orient() {
    return this._orient;
  }
  setStartAndEnd(start, end, rangeMode = ["percent", "percent"]) {
    const [startMode = "percent", endMode = "percent"] = rangeMode, startPercent = "percent" === startMode ? start : this._dataToStatePoint(start), endPercent = "percent" === endMode ? end : this._dataToStatePoint(end);
    this._handleChange(startPercent, endPercent, true);
  }
  enableInteraction() {
    this._activeRoam = true;
  }
  disableInteraction() {
    this._activeRoam = false;
  }
  zoomIn(location) {
    this._handleChartZoom({
      zoomDelta: 1.2,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  zoomOut(location) {
    this._handleChartZoom({
      zoomDelta: 0.8,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  _handleChange(start, end, updateComponent) {
    var _a, _b;
    null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.zoomLock) && void 0 !== _b && _b || end - start < this._minSpan || this._maxSpan;
  }
  _isReverse() {
    const axis2 = this._relatedAxisComponent;
    if (!axis2) return false;
    const axisScale = axis2.getScale();
    return axisScale.range()[0] > axisScale.range()[1] && (!axis2.getInverse() || this._isHorizontal);
  }
  _updateRangeFactor(tag, label) {
    const axisScale = this._relatedAxisComponent.getScale(), reverse2 = this._isReverse(), newRangeFactor = reverse2 ? [1 - this._end, 1 - this._start] : [this._start, this._end];
    if (reverse2) switch (tag) {
      case "startHandler":
        axisScale.rangeFactorEnd(newRangeFactor[1]);
        break;
      case "endHandler":
        axisScale.rangeFactorStart(newRangeFactor[0]);
        break;
      default:
        axisScale.rangeFactorStart(newRangeFactor[0], true), axisScale.rangeFactorEnd(newRangeFactor[1]);
    }
    else switch (tag) {
      case "startHandler":
        axisScale.rangeFactorStart(newRangeFactor[0]);
        break;
      case "endHandler":
        axisScale.rangeFactorEnd(newRangeFactor[1]);
        break;
      default:
        axisScale.rangeFactorEnd(newRangeFactor[1], true), axisScale.rangeFactorStart(newRangeFactor[0]);
    }
    const newFactor = axisScale.rangeFactor();
    newFactor ? (this._start = reverse2 ? 1 - newFactor[1] : newFactor[0], this._end = reverse2 ? 1 - newFactor[0] : newFactor[1]) : (this._start = 0, this._end = 1);
  }
  get visible() {
    return this._visible;
  }
  constructor(spec, options) {
    super(spec, options), this.layoutType = "none", this._orient = "left", this._cacheVisibility = void 0, this._stateField = "x", this._activeRoam = true, this._zoomAttr = {
      enable: true,
      rate: 1,
      focus: true
    }, this._dragAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this._scrollAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this.effect = {
      onZoomChange: (tag) => {
        var _a, _b;
        const axis2 = this._relatedAxisComponent;
        if (axis2 && "axis" === this._filterMode) {
          const axisScale = axis2.getScale(), axisSpec = axis2.getSpec();
          this._auto && this._getAxisBandSize(axisSpec) && this._spec.ignoreBandSize && (axisScale.bandwidth("auto"), axisScale.maxBandwidth("auto"), axisScale.minBandwidth("auto")), this._updateRangeFactor(tag, "zoomChange"), null === (_b = null === (_a = this._component) || void 0 === _a ? void 0 : _a.setStartAndEnd) || void 0 === _b || _b.call(_a, this._start, this._end), axis2.effect.scaleUpdate();
        } else eachSeries(this._regions, (s3) => {
          var _a2;
          null === (_a2 = s3.getViewData()) || void 0 === _a2 || _a2.markRunning();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }), eachSeries(this._regions, (s3) => {
          s3.reFilterViewData();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._visible = true, this._handleStateChange = (startValue, endValue, tag) => {
      var _a, _b;
      return this._startValue = startValue, this._endValue = endValue, this._newDomain = this._parseDomainFromState(this._startValue, this._endValue), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a, tag), true;
    }, this._handleChartZoom = (params2) => {
      var _a, _b;
      if (!this._activeRoam) return;
      const { zoomDelta, zoomX, zoomY } = params2, { x: x3, y: y3 } = this._regions[0].getLayoutStartPoint(), { width, height } = this._regions[0].getLayoutRect(), delta = Math.abs(this._start - this._end), zoomRate = null !== (_b = null === (_a = this._spec.roamZoom) || void 0 === _a ? void 0 : _a.rate) && void 0 !== _b ? _b : 1;
      if (delta >= 1 && zoomDelta < 1) return;
      if (delta <= 0.01 && zoomDelta > 1) return;
      const focusLoc = this._isHorizontal ? zoomX : zoomY, totalValue = delta * (zoomDelta - 1) * zoomRate;
      let startValue = totalValue / 2, endValue = totalValue / 2;
      if (focusLoc) {
        const startLoc = this._isHorizontal ? x3 : y3, endLoc = this._isHorizontal ? width : height;
        startValue = Math.abs(startLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue, endValue = Math.abs(endLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue;
      }
      const start = clamp_default(this._start + startValue, 0, 1), end = clamp_default(this._end - endValue, 0, 1);
      this._handleChange(Math.min(start, end), Math.max(start, end), true);
    }, this._handleChartScroll = (params2, e3) => {
      var _a;
      if (!this._activeRoam) return false;
      const { scrollX, scrollY } = params2;
      let value = this._isHorizontal ? scrollX : scrollY;
      const active = this._isHorizontal ? abs(scrollX / scrollY) >= 0.5 : abs(scrollY / scrollX) >= 0.5;
      return this._scrollAttr.reverse || (value = -value), active && this._handleChartMove(value, null !== (_a = this._scrollAttr.rate) && void 0 !== _a ? _a : 1), active;
    }, this._handleChartDrag = (delta, e3) => {
      var _a;
      if (!this._activeRoam) return;
      const [dx, dy] = delta;
      let value = this._isHorizontal ? dx : dy;
      this._dragAttr.reverse && (value = -value), this._handleChartMove(value, null !== (_a = this._dragAttr.rate) && void 0 !== _a ? _a : 1);
    }, this._handleChartMove = (value, rate) => {
      const totalValue = this._isHorizontal ? this.getLayoutRect().width : this.getLayoutRect().height;
      if (Math.abs(value) >= 1e-6) {
        if (value > 0 && this._end < 1) {
          const moveDelta = Math.min(1 - this._end, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        } else if (value < 0 && this._start > 0) {
          const moveDelta = Math.max(-this._start, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        }
      }
    }, this._orient = getOrient(spec), this._isHorizontal = "horizontal" === getDirectionByOrient(this._orient);
  }
  created() {
    super.created(), this._setAxisFromSpec(), this._setRegionsFromSpec(), this._initEvent(), this._initData(), this._initStateScale(), this._setStateFromSpec();
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  _setAxisFromSpec() {
    if (isValid_default(this._spec.axisId) ? this._relatedAxisComponent = this._option.getComponentByUserId(this._spec.axisId) : isValid_default(this._spec.axisIndex) && (this._relatedAxisComponent = this._option.getComponentByIndex("axes", this._spec.axisIndex)), isNil_default(this._spec.field) && !this._relatedAxisComponent) {
      const axes = this._option.getComponentsByKey("axes"), sameOrientAxis = axes.find((cm) => cm._orient === this._orient);
      if (sameOrientAxis) this._relatedAxisComponent = sameOrientAxis;
      else {
        const bandAxis = axes.find((cm) => !isContinuous(cm.getScale().type));
        this._relatedAxisComponent = bandAxis;
      }
    }
    this._relatedAxisComponent && "axis" === this._filterMode && (this._relatedAxisComponent.autoIndentOnce = true);
  }
  _setRegionsFromSpec() {
    var _a, _b;
    this._regions = this._relatedAxisComponent ? this._relatedAxisComponent.getRegions() : this._option.getAllRegions();
    const bindSeriesFilter = this._relatedAxisComponent ? null === (_b = (_a = this._relatedAxisComponent).getBindSeriesFilter) || void 0 === _b ? void 0 : _b.call(_a) : null;
    if (isValid_default(bindSeriesFilter) && (isValid_default(bindSeriesFilter.userId) && (this._seriesUserId = array(bindSeriesFilter.userId)), isValid_default(bindSeriesFilter.specIndex) && (this._seriesIndex = array(bindSeriesFilter.specIndex))), isValid_default(this._spec.seriesId)) {
      const specSeriesId = array(this._spec.seriesId);
      this._seriesUserId ? this._seriesUserId = this._seriesUserId.filter((s3) => specSeriesId.includes(s3)) : this._seriesUserId = specSeriesId;
    }
    if (isValid_default(this._spec.seriesIndex)) {
      const specSeriesIndex = array(this._spec.seriesIndex);
      this._seriesIndex ? this._seriesIndex = this._seriesIndex.filter((s3) => specSeriesIndex.includes(s3)) : this._seriesIndex = specSeriesIndex;
    }
    if (isValid_default(this._spec.regionIndex)) {
      const regionsFromSpec = this._option.getRegionsInIndex(array(this._spec.regionIndex));
      this._regions = this._regions.filter((r2) => regionsFromSpec.includes(r2));
    } else if (isValid_default(this._spec.regionId)) {
      const ids = array(this._spec.regionId);
      this._regions = ids.length ? this._regions.filter((r2) => ids.includes(r2.id)) : [];
    } else ;
  }
  onDataUpdate() {
    const domain = this._computeDomainOfStateScale(isContinuous(this._stateScale.type));
    this._stateScale.domain(domain, true), this._handleChange(this._start, this._end, true);
  }
  _computeDomainOfStateScale(isContinuous2) {
    const domain = this._data.getLatestData().map((d2) => d2[this._stateField]);
    if (isContinuous2) {
      const domainNum = domain.map((n2) => 1 * n2);
      return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [-1 / 0, 1 / 0];
    }
    return domain;
  }
  _initEvent() {
    this._initCommonEvent();
  }
  _initData() {
    const dataCollection = [], stateFields = [], valueFields = [];
    let hasValidateValueField = false;
    if (this._relatedAxisComponent) {
      const originalStateFields = {};
      eachSeries(this._regions, (s3) => {
        var _a, _b;
        const xAxisHelper = "cartesian" === s3.coordinate ? s3.getXAxisHelper() : "polar" === s3.coordinate ? s3.angleAxisHelper : null, yAxisHelper = "cartesian" === s3.coordinate ? s3.getYAxisHelper() : "polar" === s3.coordinate ? s3.radiusAxisHelper : null;
        if (!xAxisHelper || !yAxisHelper) return;
        const stateAxisHelper = xAxisHelper.getAxisId() === this._relatedAxisComponent.id ? xAxisHelper : yAxisHelper.getAxisId() === this._relatedAxisComponent.id ? yAxisHelper : this._isHorizontal ? xAxisHelper : yAxisHelper, valueAxisHelper = stateAxisHelper === xAxisHelper ? yAxisHelper : xAxisHelper, isValidateValueAxis = isContinuous(valueAxisHelper.getScale(0).type);
        isValidateValueAxis && (hasValidateValueField = true), dataCollection.push(s3.getRawData());
        const seriesSpec = s3.getSpec(), xFields = array(seriesSpec.xField), yFields = array(seriesSpec.yField), xField = "cartesian" === s3.coordinate ? xFields[0] : null !== (_a = seriesSpec.angleField) && void 0 !== _a ? _a : seriesSpec.categoryField, yField = "cartesian" === s3.coordinate ? yFields[0] : null !== (_b = seriesSpec.radiusField) && void 0 !== _b ? _b : seriesSpec.valueField;
        if (originalStateFields[s3.id] = "link" === s3.type ? "from_xField" : stateAxisHelper === xAxisHelper ? xField : yField, stateFields.push(originalStateFields[s3.id]), this._valueField) {
          const valueField = "link" === s3.type ? "from_yField" : valueAxisHelper === xAxisHelper ? xField : yField;
          valueFields.push(isValidateValueAxis ? valueField : null);
        }
      }, {
        userId: this._seriesUserId,
        specIndex: this._seriesIndex
      }), this._originalStateFields = originalStateFields;
    } else hasValidateValueField = isNil_default(this._spec.valueField), eachSeries(this._regions, (s3) => {
      dataCollection.push(s3.getRawData()), stateFields.push(this._field), this._valueField && valueFields.push(this._spec.valueField);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
    const { dataSet } = this._option;
    registerDataSetInstanceParser(dataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(dataSet, "dataFilterComputeDomain", dataFilterComputeDomain);
    const data = new DataView(dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.transform({
      type: "dataFilterComputeDomain",
      options: {
        input: {
          dataCollection,
          stateFields,
          valueFields
        },
        output: {
          stateField: this._stateField,
          valueField: this._valueField
        }
      }
    }, false), this._data = new CompilableData(this._option, data), data.reRunAllTransform(), dataSet.multipleDataViewAddListener(dataCollection, "change", this._handleDataCollectionChange.bind(this));
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), true === this._spec.roamZoom || this._spec.roamZoom ? this._zoomAttr = merge({}, this._zoomAttr, this._spec.roamZoom) : this._zoomAttr.enable = false, true === this._spec.roamDrag || this._spec.roamDrag ? this._dragAttr = merge({}, this._dragAttr, this._spec.roamDrag) : this._dragAttr.enable = false, true === this._spec.roamScroll || this._spec.roamScroll ? this._scrollAttr = merge({}, this._scrollAttr, this._spec.roamScroll) : this._scrollAttr.enable = false, this._field = this._spec.field, this._width = this._computeWidth(), this._height = this._computeHeight(), this._visible = null === (_a = this._spec.visible) || void 0 === _a || _a;
  }
  _statePointToData(state) {
    const scale4 = this._stateScale;
    let range2 = scale4.range();
    this._isReverse() && (range2 = range2.slice().reverse());
    const posInRange = range2[0] + (range2[1] - range2[0]) * state;
    return scale4.invert(posInRange);
  }
  _dataToStatePoint(data) {
    const scale4 = this._stateScale, pos = scale4.scale(data);
    let range2 = scale4.range();
    return !this._isHorizontal && isContinuous(scale4.type) && (range2 = range2.slice().reverse()), (pos - range2[0]) / (range2[1] - range2[0]);
  }
  _modeCheck(statePoint, mode2) {
    return "start" === statePoint ? "percent" === mode2 && this._spec.start || "value" === mode2 && this._spec.startValue : "percent" === mode2 && this._spec.end || "value" === mode2 && this._spec.endValue;
  }
  _setStateFromSpec() {
    var _a, _b;
    let start, end;
    if (this._auto = !!this._spec.auto, this._spec.rangeMode) {
      const [startMode, endMode] = this._spec.rangeMode;
      this._modeCheck("start", startMode) && this._modeCheck("end", endMode) && (start = "percent" === startMode ? this._spec.start : this._dataToStatePoint(this._spec.startValue), end = "percent" === endMode ? this._spec.end : this._dataToStatePoint(this._spec.endValue));
    } else start = this._spec.start ? this._spec.start : this._spec.startValue ? this._dataToStatePoint(this._spec.startValue) : 0, end = this._spec.end ? this._spec.end : this._spec.endValue ? this._dataToStatePoint(this._spec.endValue) : 1;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end), this._start = start, this._end = end, this._minSpan = null !== (_a = this._spec.minSpan) && void 0 !== _a ? _a : 0, this._maxSpan = null !== (_b = this._spec.maxSpan) && void 0 !== _b ? _b : 1, isContinuous(this._stateScale.type) && this._stateScale.domain[0] !== this._stateScale.domain[1] && (this._spec.minValueSpan && (this._minSpan = this._spec.minValueSpan / (this._stateScale.domain()[1] - this._stateScale.domain()[0])), this._spec.maxValueSpan && (this._maxSpan = this._spec.maxValueSpan / (this._stateScale.domain()[1] - this._stateScale.domain()[0]))), this._minSpan = Math.max(0, this._minSpan), this._maxSpan = Math.min(this._maxSpan, 1), this._relatedAxisComponent && "axis" === this._filterMode || 0 === this._start && 1 === this._end || (this._newDomain = this._parseDomainFromState(this._startValue, this._endValue));
  }
  _parseFieldOfSeries(s3) {
    var _a;
    return null === (_a = this._originalStateFields) || void 0 === _a ? void 0 : _a[s3.id];
  }
  _initStateScale() {
    const defaultRange = [0, 1];
    if (this._relatedAxisComponent) {
      const scale4 = this._relatedAxisComponent.getScale(), isContinuousScale = isContinuous(scale4.type), domain = this._computeDomainOfStateScale(isContinuousScale);
      if (this._stateScale = scale4.clone(), isContinuousScale) {
        const domainNum = domain.map((n2) => 1 * n2);
        this._stateScale.domain(domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [0, 1], true).range(defaultRange);
      } else this._stateScale.domain(domain, true).range(defaultRange);
    } else this._stateScale = new BandScale(), this._stateScale.domain(this._computeDomainOfStateScale(), true).range(defaultRange);
  }
  init(option) {
    super.init(option), this._addTransformToSeries(), 0 === this._start && 1 === this._end || this.effect.onZoomChange();
  }
  _addTransformToSeries() {
    this._relatedAxisComponent && "axis" === this._filterMode || (registerDataSetInstanceTransform(this._option.dataSet, "dataFilterWithNewDomain", dataFilterWithNewDomain), eachSeries(this._regions, (s3) => {
      s3.addViewDataFilter({
        type: "dataFilterWithNewDomain",
        options: {
          getNewDomain: () => this._newDomain,
          field: () => {
            var _a;
            return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s3);
          },
          isContinuous: () => isContinuous(this._stateScale.type)
        },
        level: TransformLevel.dataZoomFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }));
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._marks.forEach((g3) => {
      g3.getMarks().forEach((m5) => {
        this.initMarkStyleWithSpec(m5, this._spec[m5.name]);
      });
    });
  }
  changeRegions() {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  _parseDomainFromState(startValue, endValue) {
    if (isContinuous(this._stateScale.type)) return [Math.min(endValue, startValue), Math.max(endValue, startValue)];
    const allDomain = this._stateScale.domain(), startIndex = allDomain.indexOf(startValue), endIndex = allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
  }
  _initCommonEvent() {
    var _a, _b, _c, _d, _e, _f, _g;
    const option = {
      delayType: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType) && void 0 !== _b ? _b : "throttle",
      delayTime: isValid_default(null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayType) ? null !== (_e = null === (_d = this._spec) || void 0 === _d ? void 0 : _d.delayTime) && void 0 !== _e ? _e : 30 : 0,
      realTime: null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.realTime) || void 0 === _g || _g
    };
    this._zoomAttr.enable && this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom, option), this._scrollAttr.enable && this.initScrollEventOfRegions(this._regions, null, this._handleChartScroll, option), this._dragAttr.enable && this.initDragEventOfRegions(this._regions, null, this._handleChartDrag, option);
  }
  updateLayoutAttribute() {
    this._visible && this._createOrUpdateComponent(), super.updateLayoutAttribute();
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    super.onLayoutStart(layoutRect, viewRect, ctx);
    const isShown = this._autoUpdate(layoutRect), sizeKey = this._isHorizontal ? "height" : "width";
    this.layout.setLayoutRect({
      [sizeKey]: isShown ? this[`_${sizeKey}`] : 0
    }, {
      [sizeKey]: AttributeLevel.Built_In
    });
  }
  getBoundsInRect(rect) {
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    };
    return this._isHorizontal ? (result2.y2 = result2.y1 + this._height, result2.x2 = result2.x1 + rect.width) : (result2.x2 = result2.x1 + this._width, result2.y2 = result2.y1 + rect.height), result2;
  }
  hide() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.hideAll();
  }
  show() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.showAll();
  }
  _getAxisBandSize(axisSpec) {
    const bandSize = null == axisSpec ? void 0 : axisSpec.bandSize, maxBandSize = null == axisSpec ? void 0 : axisSpec.maxBandSize, minBandSize = null == axisSpec ? void 0 : axisSpec.minBandSize;
    if (bandSize || minBandSize || maxBandSize) return {
      bandSize,
      maxBandSize,
      minBandSize
    };
  }
  _autoUpdate(rect) {
    var _a, _b, _c, _d, _e, _f;
    if (!this._auto) return this._cacheVisibility = void 0, true;
    const axis2 = this._relatedAxisComponent, axisSpec = null == axis2 ? void 0 : axis2.getSpec(), axisScale = null == axis2 ? void 0 : axis2.getScale(), bandSizeResult = this._getAxisBandSize(axisSpec);
    if (isDiscrete(axisScale.type) && (null == rect ? void 0 : rect.height) === (null === (_a = this._cacheRect) || void 0 === _a ? void 0 : _a.height) && (null == rect ? void 0 : rect.width) === (null === (_b = this._cacheRect) || void 0 === _b ? void 0 : _b.width) && this._fixedBandSize === (null == bandSizeResult ? void 0 : bandSizeResult.bandSize)) return this._cacheVisibility;
    let isShown = true;
    if (this._isHorizontal && (null == rect ? void 0 : rect.width) !== (null === (_c = this._cacheRect) || void 0 === _c ? void 0 : _c.width) ? axisScale.range(axis2.getInverse() ? [rect.width, 0] : [0, rect.width]) : (null == rect ? void 0 : rect.height) !== (null === (_d = this._cacheRect) || void 0 === _d ? void 0 : _d.height) && axisScale.range(axis2.getInverse() ? [0, rect.height] : [rect.height, 0]), this._cacheRect = {
      width: null == rect ? void 0 : rect.width,
      height: null == rect ? void 0 : rect.height
    }, this._fixedBandSize = null == bandSizeResult ? void 0 : bandSizeResult.bandSize, isDiscrete(axisScale.type)) {
      bandSizeResult && (this._start || this._end) && this._updateRangeFactor(null, "auto");
      const [start, end] = null !== (_e = axisScale.rangeFactor()) && void 0 !== _e ? _e : [];
      isShown = (!isNil_default(start) || !isNil_default(end)) && !(0 === start && 1 === end);
    } else {
      const [start, end] = null !== (_f = axisScale.rangeFactor()) && void 0 !== _f ? _f : [this._start, this._end];
      isShown = !(0 === start && 1 === end);
    }
    return this.setStartAndEnd(this._start, this._end), isShown ? this.show() : this.hide(), this._cacheVisibility = isShown, isShown;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
mixin(DataFilterBaseComponent, Zoomable);

// node_modules/@visactor/vchart/esm/component/data-zoom/data-zoom/data-zoom-transformer.js
var DataZoomSpecTransformer = class extends BaseComponentSpecTransformer {
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const merge2 = (originalSpec) => {
        const result2 = mergeSpec({
          selectedBackgroundChart: {
            line: {},
            area: {}
          }
        }, this._theme, originalSpec), { selectedBackgroundChart = {} } = originalSpec, { line: line2, area: area2 } = selectedBackgroundChart;
        return line2 && false !== line2.visible && (result2.selectedBackgroundChart.line.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.line.style), {
          visible: true
        })), area2 && false !== area2.visible && (result2.selectedBackgroundChart.area.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.area.style), {
          visible: true
        })), result2;
      }, baseSpec = spec;
      newSpec = isArray_default(baseSpec) ? baseSpec.map((spec2) => merge2(spec2)) : merge2(baseSpec);
    }
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
};

// node_modules/@visactor/vchart/esm/component/data-zoom/data-zoom/data-zoom.js
var DataZoom2 = class extends DataFilterBaseComponent {
  static getSpecInfo(chartSpec) {
    const compSpec = chartSpec[this.specKey];
    if (isNil_default(compSpec)) return;
    if (!isArray_default(compSpec)) return [{
      spec: compSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.dataZoom
    }];
    const specInfos = [];
    return compSpec.forEach((s3, i2) => {
      specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.dataZoom
      });
    }), specInfos;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.dataZoom, this.name = ComponentTypeEnum.dataZoom, this.transformerConstructor = DataZoomSpecTransformer, this.specKey = "dataZoom", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._dataToPositionX = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, xField = this._isHorizontal ? this._stateField : this._valueField;
      return xScale.scale(datum[xField]) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionX2 = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, min4 = xScale.domain()[0];
      return xScale.scale(min4) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionY = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, yField = this._isHorizontal ? this._valueField : this._stateField;
      return yScale.scale(datum[yField]) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._dataToPositionY2 = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, min4 = yScale.domain()[0];
      return yScale.scale(min4) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._valueField = "y", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "filter";
  }
  created() {
    super.created(), this._initValueScale();
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = this._spec.roam, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode), this._backgroundSize = null !== (_b = null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 30, this._middleHandlerSize = this._computeMiddleHandlerSize(), this._width = this._computeWidth(), this._height = this._computeHeight(), isNil_default(null === (_e = null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.startHandler) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size) && (this._spec.startHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize), isNil_default(null === (_h = null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.endHandler) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size) && (this._spec.endHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize);
    const startHandlerVisble = null === (_j = this._spec.startHandler.style.visible) || void 0 === _j || _j, endHandlerVisble = null === (_k = this._spec.endHandler.style.visible) || void 0 === _k || _k;
    this._startHandlerSize = startHandlerVisble ? this._spec.startHandler.style.size : 0, this._endHandlerSize = endHandlerVisble ? this._spec.endHandler.style.size : 0;
  }
  onLayoutEnd(ctx) {
    this._updateScaleRange(), false !== this._cacheVisibility && super.onLayoutEnd(ctx);
  }
  _initValueScale() {
    const domain = this._computeDomainOfValueScale();
    if (domain) {
      const valueScale = new LinearScale();
      valueScale.domain(domain), this._valueScale = valueScale;
    }
  }
  _updateScaleRange() {
    var _a, _b;
    const handlerSize = (this._startHandlerSize + this._endHandlerSize) / 2;
    if (!this._stateScale || !this._valueScale) return;
    let stateScaleRange;
    const defaultSize = this._isHorizontal ? this.getLayoutRect().width - handlerSize : this.getLayoutRect().height - handlerSize, defaultRange = null !== (_b = null === (_a = this._relatedAxisComponent) || void 0 === _a ? void 0 : _a.getScale().range()) && void 0 !== _b ? _b : [0, defaultSize];
    this._isHorizontal ? (stateScaleRange = this._visible ? [0, this._computeWidth() - handlerSize] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([this._computeHeight() - this._middleHandlerSize, 0])) : "left" === this.layoutOrient ? (stateScaleRange = this._visible ? [0, this._computeHeight() - handlerSize] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([this._computeWidth() - this._middleHandlerSize, 0])) : (stateScaleRange = this._visible ? [0, this._computeHeight() - handlerSize] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([0, this._computeWidth() - this._middleHandlerSize])), this._component && false !== this._cacheVisibility && this._component.setAttributes({
      size: {
        width: this._computeWidth(),
        height: this._computeHeight()
      },
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      }
    });
  }
  _computeDomainOfValueScale() {
    const domain = this._data.getLatestData().map((d2) => d2[this._valueField]), domainNum = domain.map((n2) => 1 * n2);
    return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : null;
  }
  _computeMiddleHandlerSize() {
    var _a, _b, _c, _d;
    let size = 0;
    if (null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.middleHandler) || void 0 === _b ? void 0 : _b.visible) {
      const middleHandlerIconSize = null !== (_c = this._spec.middleHandler.icon.style.size) && void 0 !== _c ? _c : 8, middleHandlerBackSize = null !== (_d = this._spec.middleHandler.background.size) && void 0 !== _d ? _d : 40;
      size += Math.max(middleHandlerIconSize, middleHandlerBackSize);
    }
    return size;
  }
  _computeWidth() {
    return false === this._visible ? 0 : isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : this._backgroundSize + this._middleHandlerSize;
  }
  _computeHeight() {
    return false === this._visible ? 0 : isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? this._backgroundSize + this._middleHandlerSize : this.getLayoutRect().height - (this._startHandlerSize + this._endHandlerSize) / 2;
  }
  _isScaleValid(scale4) {
    if (!scale4 || !scale4.domain()) return false;
    const domain = scale4.domain();
    return (!isContinuous(scale4.type) || domain[0] !== domain[1]) && (!isDiscrete(scale4.type) || 1 !== uniqArray(domain).length);
  }
  _getAttrs(isNeedPreview) {
    var _a, _b, _c, _d, _e;
    const spec = null !== (_a = this._spec) && void 0 !== _a ? _a : {};
    return Object.assign({
      zIndex: this.layoutZIndex,
      start: this._start,
      end: this._end,
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      },
      orient: this._orient,
      size: {
        width: this.getLayoutRect().width,
        height: this.getLayoutRect().height
      },
      showDetail: spec.showDetail,
      brushSelect: null !== (_b = spec.brushSelect) && void 0 !== _b && _b,
      zoomLock: null !== (_c = spec.zoomLock) && void 0 !== _c && _c,
      minSpan: this._minSpan,
      maxSpan: this._maxSpan,
      delayType: spec.delayType,
      delayTime: isValid_default(spec.delayType) ? null !== (_d = spec.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_e = spec.realTime) || void 0 === _e || _e,
      previewData: isNeedPreview && this._data.getLatestData(),
      previewPointsX: isNeedPreview && this._dataToPositionX,
      previewPointsY: isNeedPreview && this._dataToPositionY
    }, this._getComponentAttrs());
  }
  _createOrUpdateComponent() {
    if (this._visible) {
      const xScale = this._isHorizontal ? this._stateScale : this._valueScale, yScale = this._isHorizontal ? this._valueScale : this._stateScale, isNeedPreview = this._isScaleValid(xScale) && this._isScaleValid(yScale), attrs = this._getAttrs(isNeedPreview);
      if (this._component) this._component.setAttributes(attrs);
      else {
        const container2 = this.getContainer();
        this._component = new DataZoom(attrs), this._isHorizontal ? isNeedPreview && this._component.setPreviewPointsY1(this._dataToPositionY2) : isNeedPreview && this._component.setPreviewPointsX1(this._dataToPositionX2), this._component.setStatePointToData((state) => this._statePointToData(state)), this._component.addEventListener("change", (e3) => {
          const { start, end, tag } = e3.detail;
          this._handleChange(start, end, void 0, tag);
        }), container2.add(this._component), this._updateScaleRange();
      }
    }
  }
  _handleChange(start, end, updateComponent, tag) {
    super._handleChange(start, end, updateComponent), updateComponent && this._component && this._component.setStartAndEnd(start, end), this._start = start, this._end = end;
    this._handleStateChange(this._statePointToData(start), this._statePointToData(end), tag) && this.event.emit(ChartEvent.dataZoomChange, {
      model: this,
      value: {
        filterData: "axis" !== this._filterMode,
        start,
        end,
        startValue: this._startValue,
        endValue: this._endValue,
        newDomain: this._newDomain
      }
    });
  }
  _handleDataCollectionChange() {
    var _a;
    const data = this._data.getDataView();
    if (data.reRunAllTransform(), null === (_a = this._component) || void 0 === _a || _a.setPreviewData(data.latestData), this._valueScale) {
      const domain = this._computeDomainOfValueScale();
      domain && this._valueScale.domain(domain);
    }
  }
  _getComponentAttrs() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { middleHandler = {}, startText = {}, endText = {}, backgroundChart = {}, selectedBackgroundChart = {} } = this._spec;
    return {
      backgroundStyle: transformToGraphic(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.style),
      startHandlerStyle: transformToGraphic(null === (_b = this._spec.startHandler) || void 0 === _b ? void 0 : _b.style),
      middleHandlerStyle: middleHandler.visible ? {
        visible: true,
        icon: transformToGraphic(null === (_c = middleHandler.icon) || void 0 === _c ? void 0 : _c.style),
        background: {
          size: null === (_d = middleHandler.background) || void 0 === _d ? void 0 : _d.size,
          style: transformToGraphic(null === (_e = middleHandler.background) || void 0 === _e ? void 0 : _e.style)
        }
      } : {
        visible: false
      },
      endHandlerStyle: transformToGraphic(null === (_f = this._spec.endHandler) || void 0 === _f ? void 0 : _f.style),
      startTextStyle: {
        padding: startText.padding,
        formatMethod: startText.formatMethod,
        textStyle: transformToGraphic(startText.style)
      },
      endTextStyle: {
        padding: endText.padding,
        formatMethod: endText.formatMethod,
        textStyle: transformToGraphic(endText.style)
      },
      selectedBackgroundStyle: transformToGraphic(this._spec.selectedBackground.style),
      dragMaskStyle: transformToGraphic(null === (_g = this._spec.dragMask) || void 0 === _g ? void 0 : _g.style),
      backgroundChartStyle: {
        line: mergeSpec(transformToGraphic(null === (_h = backgroundChart.line) || void 0 === _h ? void 0 : _h.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_j = backgroundChart.area) || void 0 === _j ? void 0 : _j.style))
      },
      selectedBackgroundChartStyle: {
        line: mergeSpec(transformToGraphic(null === (_k = selectedBackgroundChart.line) || void 0 === _k ? void 0 : _k.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_l = selectedBackgroundChart.area) || void 0 === _l ? void 0 : _l.style))
      },
      disableTriggerEvent: this._option.disableTriggerEvent
    };
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
DataZoom2.type = ComponentTypeEnum.dataZoom, DataZoom2.transformerConstructor = DataZoomSpecTransformer, DataZoom2.specKey = "dataZoom";
var registerDataZoom2 = () => {
  Factory2.registerComponent(DataZoom2.type, DataZoom2);
};

// node_modules/@visactor/vchart/esm/component/data-zoom/scroll-bar/scroll-bar.js
var ScrollBar2 = class extends DataFilterBaseComponent {
  static getSpecInfo(chartSpec) {
    const compSpec = chartSpec[this.specKey];
    if (isNil_default(compSpec)) return;
    if (!isArray_default(compSpec)) return [{
      spec: compSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.scrollBar
    }];
    const specInfos = [];
    return compSpec.forEach((s3, i2) => {
      specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.scrollBar
      });
    }), specInfos;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.scrollBar, this.name = ComponentTypeEnum.scrollBar, this.specKey = "scrollBar", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "axis";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = false, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode);
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    this._updateScaleRange(), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a), super.onLayoutEnd(ctx);
  }
  _updateScaleRange() {
    this._component && this._component.setAttributes({
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height
    });
  }
  _computeWidth() {
    return isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : SCROLL_BAR_DEFAULT_SIZE;
  }
  _computeHeight() {
    return isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? SCROLL_BAR_DEFAULT_SIZE : this.getLayoutRect().height;
  }
  _getAttrs() {
    var _a, _b, _c, _d, _e, _f;
    return Object.assign({
      zIndex: this.layoutZIndex,
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height,
      range: [this._start, this._end],
      direction: this._isHorizontal ? "horizontal" : "vertical",
      delayType: null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType,
      delayTime: isValid_default(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.delayType) ? null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.realTime) || void 0 === _f || _f
    }, this._getComponentAttrs());
  }
  _createOrUpdateComponent() {
    const attrs = this._getAttrs();
    if (this._component) this._component.setAttributes(attrs);
    else {
      const container2 = this.getContainer();
      this._component = new ScrollBar(attrs), this._component.addEventListener("scroll", (e3) => {
        const value = e3.detail.value;
        this._handleChange(value[0], value[1]);
      }), container2.add(this._component);
    }
  }
  _handleChange(start, end, updateComponent) {
    super._handleChange(start, end, updateComponent), updateComponent && this._component && this._component.setAttribute("range", [start, end]), this._start = start, this._end = end;
    this._handleStateChange(this._statePointToData(start), this._statePointToData(end)) && this.event.emit(ChartEvent.scrollBarChange, {
      model: this,
      value: {
        filterData: "axis" !== this._filterMode,
        start: this._start,
        end: this._end,
        startValue: this._startValue,
        endValue: this._endValue,
        newDomain: this._newDomain
      }
    });
  }
  _handleDataCollectionChange() {
  }
  _initCommonEvent() {
    super._initCommonEvent(), this._component && this._component.on("scroll", (e3) => {
      const value = e3.detail.value;
      this._handleChange(value[0], value[1]);
    });
  }
  _getComponentAttrs() {
    const { rail, slider: slider2, innerPadding } = this._spec, attrs = {};
    return isNil_default(innerPadding) || (attrs.padding = innerPadding), isEmpty_default(null == rail ? void 0 : rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(null == slider2 ? void 0 : slider2.style) || (attrs.sliderStyle = transformToGraphic(slider2.style)), attrs.disableTriggerEvent = this._option.disableTriggerEvent, attrs;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
ScrollBar2.type = ComponentTypeEnum.scrollBar, ScrollBar2.specKey = "scrollBar";
var registerScrollBar = () => {
  Factory2.registerComponent(ScrollBar2.type, ScrollBar2);
};

// node_modules/@visactor/vchart/esm/component/indicator/util.js
var indicatorMapper = (data, op) => {
  const { datum, title: title3, content } = op, mappedData = [], datumResult = datum.call(null);
  return title3.visible && mappedData.push({
    type: "title",
    index: 0,
    datum: datumResult,
    spec: title3
  }), array(content).forEach((c4, i2) => {
    c4.visible && mappedData.push({
      type: "content",
      index: i2,
      datum: datumResult,
      spec: c4
    });
  }), mappedData;
};

// node_modules/@visactor/vchart/esm/component/indicator/indicator.js
var Indicator2 = class _Indicator extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.indicator, this.name = ComponentTypeEnum.indicator, this.specKey = "indicator", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Indicator, this.layoutLevel = LayoutLevel.Indicator, this._gap = 0, this._activeDatum = null;
  }
  static getSpecInfo(chartSpec) {
    if (this.type !== _Indicator.type) return null;
    const indicatorSpec = chartSpec[this.specKey];
    if (!isArray_default(indicatorSpec)) return false === indicatorSpec.visible ? [] : [{
      spec: indicatorSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.indicator
    }];
    const specInfos = [];
    return indicatorSpec.forEach((s3, i2) => {
      s3 && false !== s3.visible && specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.indicator
      });
    }), specInfos;
  }
  created() {
    super.created(), this.initData(), this.initEvent();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._gap = this._spec.gap || 0, this._title = this._spec.title, this._content = array(this._spec.content), this._regions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  initEvent() {
    if (this._option.disableTriggerEvent) return;
    "none" !== this._spec.trigger && ("hover" === this._spec.trigger ? (this.event.on("hovered", (params2) => {
      params2.model && !this.isRelativeModel(params2.model) || this.updateDatum(params2.value[0]);
    }), this.event.on("unhovered", (params2) => {
      params2.model && !this.isRelativeModel(params2.model) || this.updateDatum(null);
    })) : (this.event.on("selected", (params2) => {
      params2.model && !this.isRelativeModel(params2.model) || this.updateDatum(params2.value[0]);
    }), this.event.on("unselected", (params2) => {
      params2.model && !this.isRelativeModel(params2.model) || this.updateDatum(null);
    })));
  }
  updateDatum(datum) {
    this._activeDatum = datum, this._displayData.updateData();
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs);
  }
  initData() {
    registerDataSetInstanceTransform(this._option.dataSet, "indicatorFilter", indicatorMapper);
    const displayData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    displayData.transform({
      type: "indicatorFilter",
      options: {
        title: this._title,
        content: this._content,
        datum: () => this._activeDatum
      }
    }), displayData.target.addListener("change", this.updateDatum.bind(this)), this._displayData = new CompilableData(this._option, displayData);
  }
  updateLayoutAttribute() {
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs), super.updateLayoutAttribute();
  }
  _getIndicatorAttrs() {
    const region = this._regions[0], { width, height } = region.getLayoutRect(), { x: x3, y: y3 } = region.getLayoutStartPoint(), contentComponentSpec = [];
    return array(this._spec.content).forEach((eachItem) => {
      const contentSpec = mergeSpec({}, this._theme.content, eachItem);
      contentComponentSpec.push({
        visible: false !== contentSpec.visible && (!contentSpec.field || null !== this._activeDatum),
        space: contentSpec.space || this._gap,
        autoLimit: contentSpec.autoLimit,
        autoFit: contentSpec.autoFit,
        fitPercent: contentSpec.fitPercent,
        style: Object.assign(Object.assign({}, transformToGraphic(contentSpec.style)), {
          text: this._createText(contentSpec.field, contentSpec.style.text)
        })
      });
    }), {
      visible: false !== this._spec.visible && (false !== this._spec.fixed || null !== this._activeDatum),
      size: {
        width,
        height
      },
      zIndex: this.layoutZIndex,
      x: x3,
      y: y3,
      dx: this._spec.offsetX ? getActualNumValue(this._spec.offsetX, this._computeLayoutRadius()) : 0,
      dy: this._spec.offsetY ? getActualNumValue(this._spec.offsetY, this._computeLayoutRadius()) : 0,
      limitRatio: this._spec.limitRatio || 1 / 0,
      title: {
        visible: false !== this._spec.title.visible && (!isValid_default(this._spec.title.field) || null !== this._activeDatum),
        space: this._spec.title.space || this._gap,
        autoLimit: this._spec.title.autoLimit,
        autoFit: this._spec.title.autoFit,
        fitPercent: this._spec.title.fitPercent,
        style: Object.assign(Object.assign({}, transformToGraphic(this._spec.title.style)), {
          text: this._createText(this._spec.title.field, this._spec.title.style.text)
        })
      },
      content: contentComponentSpec
    };
  }
  _createOrUpdateIndicatorComponent(attrs) {
    if (this._indicatorComponent) isEqual(attrs, this._cacheAttrs) || this._indicatorComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), indicator2 = new Indicator(attrs);
      indicator2.name = "indicator", container2.add(indicator2), this._indicatorComponent = indicator2, this._indicatorComponent.on("*", (event, type) => this._delegateEvent(this._indicatorComponent, event, type));
    }
    return this._cacheAttrs = attrs, this._indicatorComponent;
  }
  _createText(field5, text2) {
    var _a;
    return field5 ? this._activeDatum ? this._activeDatum[field5] : "" : isFunction_default(text2) ? null !== (_a = text2(this._activeDatum, void 0)) && void 0 !== _a ? _a : "" : null != text2 ? text2 : "";
  }
  _computeLayoutRadius() {
    const region = this._regions[0], { width, height } = region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  isRelativeModel(model) {
    return eachSeries(this._regions, (s3) => model === s3) || this._regions.includes(model);
  }
  _getNeedClearVRenderComponents() {
    return [this._indicatorComponent];
  }
  clear() {
    this._cacheAttrs = null, super.clear();
  }
};
Indicator2.type = ComponentTypeEnum.indicator, Indicator2.specKey = "indicator";
var registerIndicator = () => {
  Factory2.registerComponent(Indicator2.type, Indicator2);
};

// node_modules/@visactor/vchart/esm/data/transforms/aggregation.js
var markerMin = (_data, opt) => {
  const data = _data[0].latestData;
  return min3(data, opt.field);
};
var markerMax = (_data, opt) => {
  const data = _data[0].latestData;
  return max3(data, opt.field);
};
function markerSum(_data, opt) {
  const data = _data[0].latestData;
  return sum3(data, opt.field);
}
function markerAverage(_data, opt) {
  const data = _data[0].latestData;
  return average(data, opt.field);
}
function markerVariance(_data, opt) {
  const data = _data[0].latestData;
  return variance3(data, opt.field);
}
function markerStandardDeviation(_data, opt) {
  const data = _data[0].latestData;
  return standardDeviation2(data, opt.field);
}
function markerMedian(_data, opt) {
  const data = _data[0].latestData;
  return median3(data, opt.field);
}
function markerAggregation(_data, options) {
  const results = [];
  return options.forEach((option) => {
    const result2 = {
      x: null,
      y: null
    };
    if (isValid_default(option.x)) {
      const x3 = option.x;
      isArray_default(x3) ? result2.x = x3.map((item) => getFinalValue(item, _data, option)) : result2.x = getFinalValue(x3, _data, option);
    }
    if (isValid_default(option.y)) {
      const y3 = option.y;
      isArray_default(y3) ? result2.y = y3.map((item) => getFinalValue(item, _data, option)) : result2.y = getFinalValue(y3, _data, option);
    }
    option.getRefRelativeSeries && (result2.getRefRelativeSeries = option.getRefRelativeSeries), results.push(result2);
  }), results;
}
var aggrMap = {
  min: markerMin,
  max: markerMax,
  sum: markerSum,
  average: markerAverage,
  variance: markerVariance,
  standardDeviation: markerStandardDeviation,
  median: markerMedian
};
function getFinalValue(source, _data, option) {
  const relativeSeries = option.getRelativeSeries(), startSeries = option.getStartRelativeSeries(), endSeries = option.getEndRelativeSeries(), relativeSeriesData = relativeSeries.getData().getLatestData(), startRelativeSeriesData = startSeries.getData().getLatestData(), endRelativeSeriesData = endSeries.getData().getLatestData();
  if (isFunction_default(source)) return source(relativeSeriesData, startRelativeSeriesData, endRelativeSeriesData, relativeSeries, startSeries, endSeries);
  if (isPlainObject_default(source)) {
    const { aggrType, field: field5 } = source;
    return aggrMap[aggrType](_data, {
      field: field5
    });
  }
  return source;
}

// node_modules/@visactor/vchart/esm/constant/marker.js
var AGGR_TYPE = ["sum", "average", "min", "max", "variance", "standardDeviation", "median"];

// node_modules/@visactor/vchart/esm/component/marker/utils.js
var __rest20 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
function isNeedExtendDomain(domain, datum, autoRange) {
  if (!autoRange) return false;
  const domainNum = domain.map((n2) => 1 * n2), min4 = minInArray(domainNum), max4 = maxInArray(domainNum);
  return datum < min4 || datum > max4;
}
function getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let x3;
  return isNumber_default(datum.x) && isNeedExtendDomain(xDomain, datum.x, autoRange) && (null === (_b = null == relativeSeries ? void 0 : (_a = relativeSeries.getXAxisHelper()).setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", datum.x)), x3 = isPercent(datum.x) ? convertPercentToValue(datum.x, regionWidth) + regionStartLayoutStartPoint.x : relativeSeries.getXAxisHelper().dataToPosition([datum.x]) + regionStartLayoutStartPoint.x, x3;
}
function getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let y3;
  return isNumber_default(datum.y) && isNeedExtendDomain(yDomain, datum.y, autoRange) && (null === (_b = null === (_a = relativeSeries.getYAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_yAxis_extend", datum.y)), y3 = isPercent(datum.y) ? convertPercentToValue(datum.y, regionHeight) + regionStartLayoutStartPoint.y : relativeSeries.getYAxisHelper().dataToPosition([datum.y]) + regionStartLayoutStartPoint.y, y3;
}
function convertPercentToValue(percent, relativeLength) {
  return Number(percent.substring(0, percent.length - 1)) * relativeLength / 100;
}
function isAggrSpec(spec) {
  return AGGR_TYPE.includes(spec);
}
function xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
  const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint(), regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width)), regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height)), refSeries = {
    relativeSeries,
    startRelativeSeries,
    endRelativeSeries
  }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, xDomain = relativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = relativeSeries.getYAxisHelper().getScale(0).domain();
  return dataPoints.forEach((datum) => {
    const isValidX = isValid_default(datum.x), isValidY = isValid_default(datum.y);
    if (isValidX && isValidY) {
      const x3 = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y3 = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint);
      lines.push([{
        x: x3,
        y: y3
      }]);
    } else if (isValid_default(datum.x)) {
      const x3 = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y3 = Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height), y14 = Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y);
      lines.push([{
        x: x3,
        y: y3
      }, {
        x: x3,
        y: y14
      }]);
    } else if (isValid_default(datum.y)) {
      const x3 = Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x), y3 = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint), x14 = Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width);
      lines.push([{
        x: x3,
        y: y3
      }, {
        x: x14,
        y: y3
      }]);
    }
  }), lines;
}
function coordinateLayout(data, relativeSeries, autoRange, coordinatesOffset) {
  const points = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, isArrayCoordinatesOffset = isArray_default(coordinatesOffset);
  return dataPoints.forEach((datum, index) => {
    var _a, _b, _c, _d;
    const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, regionStart = refRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = regionStart.getLayoutRect();
    let offsetX = 0, offsetY = 0;
    if (coordinatesOffset) {
      const currentCoordinatesOffset = isArrayCoordinatesOffset ? coordinatesOffset[index] : coordinatesOffset, x3 = currentCoordinatesOffset.x, y3 = currentCoordinatesOffset.y;
      x3 && (offsetX = isPercent(x3) ? Number(x3.substring(0, x3.length - 1)) * regionWidth / 100 : x3), y3 && (offsetY = isPercent(y3) ? Number(y3.substring(0, y3.length - 1)) * regionHeight / 100 : y3);
    }
    const xDomain = refRelativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = refRelativeSeries.getYAxisHelper().getScale(0).domain(), xValue = array(datum.x), yValue = array(datum.y);
    1 === xValue.length && isNumber_default(xValue[0]) && isNeedExtendDomain(xDomain, xValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.getXAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", xValue[0])), 1 === yValue.length && isNumber_default(yValue[0]) && isNeedExtendDomain(yDomain, yValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.getYAxisHelper()) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", yValue[0])), points.push({
      x: refRelativeSeries.getXAxisHelper().dataToPosition(xValue) + regionStartLayoutStartPoint.x + offsetX,
      y: refRelativeSeries.getYAxisHelper().dataToPosition(yValue) + regionStartLayoutStartPoint.y + offsetY
    });
  }), points;
}
function positionLayout(positions, series2, regionRelative) {
  if (regionRelative) {
    const region = series2.getRegion(), { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = region.getLayoutRect();
    return positions.map((position) => {
      let { x: x3, y: y3 } = position;
      return isPercent(x3) && (x3 = convertPercentToValue(x3, regionWidth)), x3 += regionStartX, isPercent(y3) && (y3 = convertPercentToValue(y3, regionHeight)), y3 += regionStartY, {
        x: x3,
        y: y3
      };
    });
  }
  const { width: canvasWidth, height: canvasHeight } = series2.getOption().getChart().getCanvasRect();
  return positions.map((position) => {
    let { x: x3, y: y3 } = position;
    return isPercent(x3) && (x3 = convertPercentToValue(x3, canvasWidth)), isPercent(y3) && (y3 = convertPercentToValue(y3, canvasHeight)), {
      x: x3,
      y: y3
    };
  });
}
function computeClipRange(regions) {
  let minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY2 = -1 / 0;
  return regions.forEach((region) => {
    const regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect();
    regionPos.x < minX && (minX = regionPos.x), regionPos.x + regionRect.width > maxX && (maxX = regionPos.x + regionRect.width), regionPos.y < minY && (minY = regionPos.y), regionPos.y + regionRect.height > maxY2 && (maxY2 = regionPos.y + regionRect.height);
  }), {
    minX,
    maxX,
    minY,
    maxY: maxY2
  };
}
function transformLabelAttributes(label) {
  const { labelBackground = {}, style, shape } = label, restLabel = __rest20(label, ["labelBackground", "style", "shape"]);
  if (false !== label.visible) {
    const labelAttrs = restLabel;
    return (null == shape ? void 0 : shape.visible) ? labelAttrs.shape = Object.assign({
      visible: true
    }, transformToGraphic(shape.style)) : labelAttrs.shape = {
      visible: false
    }, false !== labelBackground.visible ? (labelAttrs.panel = Object.assign({
      visible: true
    }, transformToGraphic(labelBackground.style)), isValid_default(labelBackground.padding) && (labelAttrs.padding = normalizePadding(labelBackground.padding))) : (labelAttrs.panel = {
      visible: false
    }, labelAttrs.padding = 0), style && (labelAttrs.textStyle = transformToGraphic(style)), labelAttrs;
  }
  return {
    visible: false
  };
}

// node_modules/@visactor/vchart/esm/component/marker/base-marker.js
var BaseMarker = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this._layoutOffsetX = 0, this._layoutOffsetY = 0;
  }
  getRelativeSeries() {
    return this._relativeSeries;
  }
  created() {
    super.created(), this.initEvent(), this._bindSeries(), this._initDataView();
  }
  _getAllRelativeSeries() {
    return {
      getRelativeSeries: () => this._relativeSeries,
      getStartRelativeSeries: () => this._startRelativeSeries,
      getEndRelativeSeries: () => this._endRelativeSeries
    };
  }
  _getFieldInfoFromSpec(dim, spec, relativeSeries) {
    const field5 = "x" === dim ? relativeSeries.getSpec().xField : relativeSeries.getSpec().yField;
    return isString_default(spec) && isAggrSpec(spec) ? {
      field: field5,
      aggrType: spec
    } : spec;
  }
  _processSpecX(specX) {
    const relativeSeries = this._relativeSeries;
    return Object.assign({
      x: this._getFieldInfoFromSpec("x", specX, relativeSeries)
    }, this._getAllRelativeSeries());
  }
  _processSpecY(specY) {
    const relativeSeries = this._relativeSeries;
    return Object.assign({
      y: this._getFieldInfoFromSpec("y", specY, relativeSeries)
    }, this._getAllRelativeSeries());
  }
  _processSpecXY(specX, specY) {
    const relativeSeries = this._relativeSeries;
    return Object.assign({
      x: this._getFieldInfoFromSpec("x", specX, relativeSeries),
      y: this._getFieldInfoFromSpec("y", specY, relativeSeries)
    }, this._getAllRelativeSeries());
  }
  _processSpecCoo(spec) {
    var _a;
    return (null !== (_a = spec.coordinates) && void 0 !== _a ? _a : array(spec.coordinate)).map((coordinate) => {
      const refRelativeSeries = this._getSeriesByIdOrIndex(coordinate.refRelativeSeriesId, coordinate.refRelativeSeriesIndex), { xField, yField } = refRelativeSeries.getSpec(), { xFieldDim, xFieldIndex, yFieldDim, yFieldIndex } = coordinate;
      let bindXField = xField;
      isValid_default(xFieldIndex) && (bindXField = array(xField)[xFieldIndex]), xFieldDim && array(xField).includes(xFieldDim) && (bindXField = xFieldDim);
      let bindYField = yField;
      isValid_default(yFieldIndex) && (bindYField = array(yField)[yFieldIndex]), yFieldDim && array(yField).includes(yFieldDim) && (bindYField = yFieldDim);
      const option = Object.assign({
        x: void 0,
        y: void 0
      }, this._getAllRelativeSeries());
      return isString_default(coordinate[bindXField]) && isAggrSpec(coordinate[bindXField]) ? option.x = {
        field: bindXField,
        aggrType: coordinate[bindXField]
      } : option.x = array(bindXField).map((field5) => coordinate[field5]), isString_default(coordinate[bindYField]) && isAggrSpec(coordinate[bindYField]) ? option.y = {
        field: bindYField,
        aggrType: coordinate[bindYField]
      } : option.y = array(bindYField).map((field5) => coordinate[field5]), option.getRefRelativeSeries = () => refRelativeSeries, option;
    });
  }
  updateLayoutAttribute() {
    var _a, _b, _c;
    if (null === (_a = this._spec.visible) || void 0 === _a || _a) {
      if (!this._markerComponent) {
        const markerComponent = this._createMarkerComponent();
        markerComponent.name = null !== (_b = this._spec.name) && void 0 !== _b ? _b : this.type, markerComponent.id = null !== (_c = this._spec.id) && void 0 !== _c ? _c : `${this.type}-${this.id}`, this._markerComponent = markerComponent, this.getContainer().add(this._markerComponent), this._markerComponent.on("*", (event, type) => this._delegateEvent(this._markerComponent, event, type));
      }
      this._markerLayout();
    }
    super.updateLayoutAttribute();
  }
  _getSeriesByIdOrIndex(seriesUserId, seriesIndex) {
    var _a, _b;
    let series2;
    return series2 = null === (_a = this._option.getSeriesInUserIdOrIndex(isValid_default(seriesUserId) ? [seriesUserId] : [], [seriesIndex])) || void 0 === _a ? void 0 : _a[0], series2 || (series2 = null !== (_b = this._relativeSeries) && void 0 !== _b ? _b : this._getFirstSeries()), series2;
  }
  _bindSeries() {
    const spec = this._spec;
    this._relativeSeries = this._getSeriesByIdOrIndex(spec.relativeSeriesId, spec.relativeSeriesIndex), this._startRelativeSeries = this._getSeriesByIdOrIndex(spec.startRelativeSeriesId, spec.startRelativeSeriesIndex), this._endRelativeSeries = this._getSeriesByIdOrIndex(spec.endRelativeSeriesId, spec.endRelativeSeriesIndex);
  }
  initEvent() {
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  clear() {
    super.clear(), this._firstSeries = null;
  }
  _getFirstSeries() {
    var _a;
    if (this._firstSeries) return this._firstSeries;
    const firstSeries = getFirstSeries(this._regions);
    return firstSeries ? (this._firstSeries = firstSeries, firstSeries) : (null === (_a = this._option) || void 0 === _a || _a.onError("need at least one series"), null);
  }
  _getNeedClearVRenderComponents() {
    return [this._markerComponent];
  }
  onLayoutStart(layoutRect, chartViewRect, ctx) {
    isNil_default(this._spec.offsetX) || (this._layoutOffsetX = calcLayoutNumber(this._spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(this._spec.offsetY) || (this._layoutOffsetY = calcLayoutNumber(this._spec.offsetY, chartViewRect.height, chartViewRect)), super.onLayoutStart(layoutRect, chartViewRect, ctx);
  }
};

// node_modules/@visactor/vchart/esm/data/transforms/regression.js
function markerRegression(_data, opt) {
  const data = _data[0].latestData;
  return regression(data, opt.fieldX, opt.fieldY);
}

// node_modules/@visactor/vchart/esm/component/marker/mark-line/util.js
function getInsertPoints(start, end, direction2, offset = 0) {
  const points = [], dy = start.y - end.y, dx = start.x - end.x;
  switch (direction2) {
    case "top":
      points.push(start), points.push({
        x: start.x,
        y: dy > 0 ? start.y - offset - Math.abs(dy) : start.y - offset
      }), points.push({
        x: end.x,
        y: dy > 0 ? end.y - offset : end.y - offset - Math.abs(dy)
      }), points.push(end);
      break;
    case "bottom":
      points.push(start), points.push({
        x: start.x,
        y: dy < 0 ? start.y + offset + Math.abs(dy) : start.y + offset
      }), points.push({
        x: end.x,
        y: dy < 0 ? end.y + offset : end.y + offset + Math.abs(dy)
      }), points.push(end);
      break;
    case "left":
      points.push(start), points.push({
        x: dx > 0 ? start.x - offset - Math.abs(dx) : start.x - offset,
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x - offset : end.x - offset - Math.abs(dx),
        y: end.y
      }), points.push(end);
      break;
    case "right":
      points.push(start), points.push({
        x: dx > 0 ? start.x + offset : start.x + offset + Math.abs(dx),
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x + offset + Math.abs(dx) : end.x + offset,
        y: end.y
      }), points.push(end);
  }
  return points;
}
function getTextOffset(start, end, direction2, offset = 0) {
  const dy = start.y - end.y, dx = start.x - end.x;
  return "bottom" === direction2 ? {
    dx: dx > 0 ? -dx / 2 : Math.abs(dx / 2),
    dy: dy > 0 ? offset : Math.abs(dy) + offset
  } : "top" === direction2 ? {
    dx: dx > 0 ? -Math.abs(dx / 2) : +Math.abs(dx / 2),
    dy: dy > 0 ? -(Math.abs(dy) + offset) : -offset
  } : "left" === direction2 ? {
    dx: dx > 0 ? -dx - offset : -offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : "right" === direction2 ? {
    dx: dx > 0 ? offset : Math.abs(dx) + offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : {};
}

// node_modules/@visactor/vchart/esm/data/transforms/marker-filter.js
function markerFilter(data, options) {
  if (options && options.getRelativeSeries) {
    const series2 = options.getRelativeSeries();
    if (series2) {
      const viewData = series2.getViewData();
      return viewData && viewData.latestData && viewData.latestData.length ? data : [];
    }
  }
  return data;
}

// node_modules/@visactor/vchart/esm/component/marker/mark-line/mark-line.js
var MarkLine2 = class extends BaseMarker {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markLine, this.name = ComponentTypeEnum.markLine, this.specKey = "markLine", this.layoutZIndex = LayoutZIndex.MarkLine;
  }
  static getSpecInfo(chartSpec) {
    const markLineSpec = chartSpec[this.specKey];
    if (isEmpty_default(markLineSpec)) return;
    if (!isArray_default(markLineSpec) && false !== markLineSpec.visible) return [{
      spec: markLineSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.markLine
    }];
    const specInfos = [];
    return markLineSpec.forEach((m5, i2) => {
      false !== m5.visible && specInfos.push({
        spec: m5,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.markLine
      });
    }), specInfos;
  }
  _createMarkerComponent() {
    var _a, _b, _c;
    const { label = {}, startSymbol = {}, endSymbol = {} } = this._spec, markLineAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null !== (_a = this._spec.interactive) && void 0 !== _a && _a,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }],
      lineStyle: null === (_b = this._spec.line) || void 0 === _b ? void 0 : _b.style,
      clipInRange: null !== (_c = this._spec.clip) && void 0 !== _c && _c,
      label: transformLabelAttributes(label)
    };
    startSymbol.visible ? markLineAttrs.startSymbol = Object.assign(Object.assign({}, startSymbol), {
      visible: true,
      style: transformToGraphic(startSymbol.style)
    }) : markLineAttrs.startSymbol = {
      visible: false
    }, endSymbol.visible ? markLineAttrs.endSymbol = Object.assign(Object.assign({}, endSymbol), {
      visible: true,
      style: transformToGraphic(endSymbol.style)
    }) : markLineAttrs.endSymbol = {
      visible: false
    };
    return new MarkLine(markLineAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e, _f, _g;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isValidCoordinates = isValid_default(spec.coordinates), isValidProcess = isValid_default(spec.process), isValidProcessX = isValidProcess && isValid_default(spec.process.x), isValidProcessY = isValidProcess && isValid_default(spec.process.y), isCoordinateLayout = isValidCoordinates && (!isValidProcess || "process" in spec && "xy" in spec.process), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points = [];
    if (this._isXYLayout || isValidCoordinates && isValidProcessX || isValidCoordinates && isValidProcessY) {
      const xyPoints = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      points = 1 === xyPoints.length ? xyPoints[0] : xyPoints.map((point6) => point6[0]);
    } else isCoordinateLayout ? points = coordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData;
    let limitRect;
    if (spec.clip || (null === (_b = spec.label) || void 0 === _b ? void 0 : _b.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    const markerComponentAttr = null !== (_d = null === (_c = this._markerComponent) || void 0 === _c ? void 0 : _c.attribute) && void 0 !== _d ? _d : {}, labelAttrs = Object.assign(Object.assign({}, markerComponentAttr.label), {
      text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_e = markerComponentAttr.label) || void 0 === _e ? void 0 : _e.text
    });
    if ("type-step" === this._spec.type) {
      const { multiSegment, mainSegmentIndex } = this._spec.line || {}, { connectDirection, expandDistance = 0 } = this._spec;
      let expandDistanceValue;
      if (isPercent(expandDistance)) {
        const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint();
        if ("bottom" === connectDirection || "top" === connectDirection) {
          const regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionHeight / 100;
        } else {
          const regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionWidth / 100;
        }
      } else expandDistanceValue = expandDistance;
      const joinPoints = getInsertPoints(points[0], points[1], connectDirection, expandDistanceValue);
      let labelPositionAttrs;
      labelPositionAttrs = multiSegment && isValid_default(mainSegmentIndex) ? {
        position: "middle",
        autoRotate: false,
        refX: 0,
        refY: 0
      } : Object.assign(Object.assign({
        position: "start",
        autoRotate: false
      }, getTextOffset(points[0], points[1], connectDirection, expandDistanceValue)), {
        refX: 0,
        refY: 0
      }), null === (_f = this._markerComponent) || void 0 === _f || _f.setAttributes({
        points: multiSegment ? [[joinPoints[0], joinPoints[1]], [joinPoints[1], joinPoints[2]], [joinPoints[2], joinPoints[3]]] : joinPoints,
        label: Object.assign(Object.assign(Object.assign({}, labelAttrs), labelPositionAttrs), {
          textStyle: Object.assign(Object.assign({}, markerComponentAttr.label.textStyle), {
            textAlign: "center",
            textBaseline: "middle"
          })
        }),
        limitRect,
        multiSegment,
        mainSegmentIndex,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    } else null === (_g = this._markerComponent) || void 0 === _g || _g.setAttributes({
      points,
      label: labelAttrs,
      limitRect,
      dx: this._layoutOffsetX,
      dy: this._layoutOffsetY
    });
  }
  _initDataView() {
    const spec = this._spec, relativeSeries = this._relativeSeries, isXProcess = "x" in spec, isYProcess = "y" in spec, isX1Process = "x1" in spec, isY1Process = "y1" in spec, isCoordinateProcess = "coordinates" in spec, doXProcess = isXProcess && !isYProcess && !isY1Process, doXYY1Process = isXProcess && isYProcess && isY1Process, doYProcess = isYProcess && !isXProcess && !isX1Process, doYXX1Process = isYProcess && isXProcess && isX1Process, doXYProcess = isXProcess && isYProcess && isX1Process && isY1Process;
    if (this._markerData = relativeSeries.getViewData(), !(doXProcess || doYProcess || doXYY1Process || doYXX1Process || doXYProcess || isCoordinateProcess)) return;
    let options;
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerRegression", markerRegression), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter), this._isXYLayout = doXProcess || doXYY1Process || doYProcess || doYXX1Process || doXYProcess;
    let processData = relativeSeries.getViewData(), needAggr = true, needRegr = false;
    if (doXYProcess) {
      const { x: x3, x1: x14, y: y3, y1: y14 } = spec;
      options = [this._processSpecXY(x3, y3), this._processSpecXY(x14, y14)];
    } else if (doXProcess) options = [this._processSpecX(spec.x)];
    else if (doYProcess) options = [this._processSpecY(spec.y)];
    else if (doXYY1Process) {
      const { x: x3, y: y3, y1: y14 } = spec;
      options = [this._processSpecXY(x3, y3), this._processSpecXY(x3, y14)];
    } else if (doYXX1Process) {
      const { x: x3, x1: x14, y: y3 } = spec;
      options = [this._processSpecXY(x3, y3), this._processSpecXY(x14, y3)];
    } else if (isCoordinateProcess) {
      if (options = this._processSpecCoo(spec), needAggr = false, processData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_data`
      }).parse([relativeSeries.getViewData()], {
        type: "dataview"
      }).transform({
        type: "markerAggregation",
        options
      }), spec.process && "x" in spec.process && (options = [this._processSpecX(spec.process.x)], needAggr = true), spec.process && "y" in spec.process && (options = [this._processSpecY(spec.process.y)], needAggr = true), spec.process && "xy" in spec.process) {
        const { xField, yField } = relativeSeries.getSpec();
        options = {
          fieldX: xField,
          fieldY: yField
        }, needRegr = true;
      }
    } else needAggr = false;
    const data = new DataView(this._option.dataSet);
    data.parse([processData], {
      type: "dataview"
    }), needAggr && data.transform({
      type: "markerAggregation",
      options
    }), needRegr && data.transform({
      type: "markerRegression",
      options
    }), (needAggr || needRegr) && data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
MarkLine2.type = ComponentTypeEnum.markLine, MarkLine2.specKey = "markLine";
var registerMarkLine = () => {
  Factory2.registerComponent(MarkLine2.type, MarkLine2);
};

// node_modules/@visactor/vchart/esm/component/title/title.js
var Title3 = class extends BaseComponent {
  get orient() {
    return this._orient;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.title, this.specKey = ComponentTypeEnum.title, this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Title, this.layoutLevel = LayoutLevel.Title, this._orient = "top", this._orient = isValidOrient(spec.orient) ? spec.orient : "top";
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  static getSpecInfo(chartSpec) {
    const titleSpec = chartSpec[this.specKey];
    if (!titleSpec || false === titleSpec.visible) return null;
    if (!isArray_default(titleSpec)) return [{
      spec: titleSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.title
    }];
    const specInfos = [];
    return titleSpec.forEach((s3, i2) => {
      false !== s3.visible && specInfos.push({
        spec: s3,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.title
      });
    }), specInfos;
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return (null == prevSpec ? void 0 : prevSpec.orient) !== (null == spec ? void 0 : spec.orient) && (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  afterSetLayoutStartPoint(pos) {
    isValidNumber_default(pos.x) && this._titleComponent && this._titleComponent.setAttribute("x", pos.x), isValidNumber_default(pos.y) && this._titleComponent && this._titleComponent.setAttribute("y", pos.y), super.afterSetLayoutStartPoint(pos);
  }
  getBoundsInRect(rect) {
    let result2 = {};
    this.setLayoutRect(rect);
    const attrs = this._getTitleAttrs();
    this._createOrUpdateTitleComponent(attrs), result2 = this._getTitleLayoutRect();
    const { x: x3, y: y3 } = this.getLayoutStartPoint();
    return {
      x1: x3,
      y1: y3,
      x2: x3 + result2.width,
      y2: y3 + result2.height
    };
  }
  _getTitleLayoutRect() {
    const titleBounds = this._titleComponent.AABBBounds;
    return {
      width: this._spec.width ? this._spec.width : isValidNumber_default(titleBounds.width()) ? titleBounds.width() : 0,
      height: this._spec.height ? this._spec.height : isValidNumber_default(titleBounds.height()) ? titleBounds.height() : 0
    };
  }
  _getTitleAttrs() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const realWidth = Math.max(0, null !== (_a = this._spec.width) && void 0 !== _a ? _a : this.getLayoutRect().width);
    return Object.assign(Object.assign({}, pickWithout(this._spec, ["padding"])), {
      textType: null !== (_b = this._spec.textType) && void 0 !== _b ? _b : "text",
      text: null !== (_c = this._spec.text) && void 0 !== _c ? _c : "",
      subtextType: null !== (_d = this._spec.subtextType) && void 0 !== _d ? _d : "text",
      subtext: null !== (_e = this._spec.subtext) && void 0 !== _e ? _e : "",
      x: null !== (_f = this._spec.x) && void 0 !== _f ? _f : 0,
      y: null !== (_g = this._spec.y) && void 0 !== _g ? _g : 0,
      width: realWidth,
      height: this._spec.height,
      minWidth: this._spec.minWidth,
      maxWidth: this._spec.maxWidth,
      minHeight: this._spec.minHeight,
      maxHeight: this._spec.maxHeight,
      padding: this._spec.innerPadding,
      align: null !== (_h = this._spec.align) && void 0 !== _h ? _h : "left",
      verticalAlign: null !== (_j = this._spec.verticalAlign) && void 0 !== _j ? _j : "top",
      textStyle: Object.assign({
        width: realWidth
      }, this._spec.textStyle),
      subtextStyle: Object.assign({
        width: realWidth
      }, this._spec.subtextStyle)
    });
  }
  _createOrUpdateTitleComponent(attrs) {
    if (this._titleComponent) isEqual(attrs, this._cacheAttrs) || this._titleComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), title3 = new Title(attrs);
      title3.name = "title", container2.add(title3), this._titleComponent = title3, title3.on("*", (event, type) => this._delegateEvent(title3, event, type));
    }
    return this._cacheAttrs = attrs, this._titleComponent;
  }
  _getNeedClearVRenderComponents() {
    return [this._titleComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null;
  }
};
Title3.type = ComponentTypeEnum.title, Title3.specKey = ComponentTypeEnum.title;
var registerTitle2 = () => {
  Factory2.registerComponent(Title3.type, Title3);
};

// node_modules/@visactor/vchart/esm/component/marker/mark-area/mark-area.js
var MarkArea2 = class extends BaseMarker {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markArea, this.name = ComponentTypeEnum.markArea, this.specKey = "markArea", this.layoutZIndex = LayoutZIndex.MarkArea;
  }
  static getSpecInfo(chartSpec) {
    const markAreaSpec = chartSpec[this.specKey];
    if (isEmpty_default(markAreaSpec)) return;
    if (!isArray_default(markAreaSpec) && false !== markAreaSpec.visible) return [{
      spec: markAreaSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.markArea
    }];
    const specInfos = [];
    return markAreaSpec.forEach((m5, i2) => {
      false !== m5.visible && specInfos.push({
        spec: m5,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.markArea
      });
    }), specInfos;
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d;
    const label = null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}, markAreaAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null !== (_b = this._spec.interactive) && void 0 !== _b && _b,
      points: [{
        x: 0,
        y: 0
      }],
      areaStyle: transformToGraphic(null === (_c = this._spec.area) || void 0 === _c ? void 0 : _c.style),
      clipInRange: null !== (_d = this._spec.clip) && void 0 !== _d && _d,
      label: transformLabelAttributes(label)
    };
    return new MarkArea(markAreaAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isXLayout = isValid_default(spec.x) && isValid_default(spec.x1), isYLayout = isValid_default(spec.y) && isValid_default(spec.y1), isXYLayout = isXLayout && isYLayout, isCoordinateLayout = isValid_default(spec.coordinates), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points = [], lines = [];
    isXYLayout ? (lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), points = [{
      x: lines[0][0].x,
      y: lines[1][0].y
    }, lines[0][0], {
      x: lines[1][0].x,
      y: lines[0][0].y
    }, lines[1][0]]) : isXLayout || isYLayout ? (lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), points = [...lines[0], lines[1][1], lines[1][0]]) : isCoordinateLayout ? points = coordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || (null === (_b = spec.label) || void 0 === _b ? void 0 : _b.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    this._markerComponent && this._markerComponent.setAttributes({
      points,
      label: Object.assign(Object.assign({}, null === (_c = this._markerComponent.attribute) || void 0 === _c ? void 0 : _c.label), {
        text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_e = null === (_d = this._markerComponent.attribute) || void 0 === _d ? void 0 : _d.label) || void 0 === _e ? void 0 : _e.text
      }),
      limitRect,
      dx: this._layoutOffsetX,
      dy: this._layoutOffsetY
    });
  }
  _initDataView() {
    const spec = this._spec, relativeSeries = this._relativeSeries, isXProcess = isValid_default(spec.x) && isValid_default(spec.x1), isYProcess = isValid_default(spec.y) && isValid_default(spec.y1), isXYProcess = isXProcess && isYProcess, isCoordinateProcess = isValid_default(spec.coordinates);
    if (!isXProcess && !isYProcess && !isCoordinateProcess) return null;
    let options;
    isXYProcess ? options = [this._processSpecXY(spec.x, spec.y), this._processSpecXY(spec.x1, spec.y1)] : isXProcess ? options = [this._processSpecX(spec.x), this._processSpecX(spec.x1)] : isYProcess ? options = [this._processSpecY(spec.y), this._processSpecY(spec.y1)] : isCoordinateProcess && (options = this._processSpecCoo(spec));
    const seriesData = relativeSeries.getViewData();
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const data = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.parse([seriesData], {
      type: "dataview"
    }), data.transform({
      type: "markerAggregation",
      options
    }), options && data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
MarkArea2.type = ComponentTypeEnum.markArea, MarkArea2.specKey = "markArea";
var registerMarkArea = () => {
  Factory2.registerComponent(MarkArea2.type, MarkArea2);
};

// node_modules/@visactor/vchart/esm/component/player/utils/transform.js
var rectToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var symbolToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var baseToAttribute = (spec) => Object.assign(Object.assign({}, spec), {
  style: Object.assign({}, transformToGraphic(spec.style))
});
var transformToAttrs = (spec) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  const trackStyle = rectToAttribute(null !== (_b = null === (_a = null == spec ? void 0 : spec.slider) || void 0 === _a ? void 0 : _a.trackStyle) && void 0 !== _b ? _b : {}), railStyle = rectToAttribute(null !== (_d = null === (_c = null == spec ? void 0 : spec.slider) || void 0 === _c ? void 0 : _c.railStyle) && void 0 !== _d ? _d : {}), handlerStyle = symbolToAttribute(null !== (_f = null === (_e = null == spec ? void 0 : spec.slider) || void 0 === _e ? void 0 : _e.handlerStyle) && void 0 !== _f ? _f : {}), start = baseToAttribute(null !== (_h = null === (_g = null == spec ? void 0 : spec.controller) || void 0 === _g ? void 0 : _g.start) && void 0 !== _h ? _h : {}), pause = baseToAttribute(null !== (_k = null === (_j = null == spec ? void 0 : spec.controller) || void 0 === _j ? void 0 : _j.pause) && void 0 !== _k ? _k : {}), backward = baseToAttribute(null !== (_m = null === (_l = null == spec ? void 0 : spec.controller) || void 0 === _l ? void 0 : _l.backward) && void 0 !== _m ? _m : {}), forward = baseToAttribute(null !== (_p = null === (_o = null == spec ? void 0 : spec.controller) || void 0 === _o ? void 0 : _o.forward) && void 0 !== _p ? _p : {});
  return Object.assign(Object.assign({}, spec), {
    direction: spec.direction,
    interval: spec.interval,
    visible: spec.visible,
    orient: spec.orient,
    slider: Object.assign(Object.assign({}, spec.slider), {
      trackStyle,
      railStyle,
      handlerStyle
    }),
    controller: Object.assign(Object.assign({}, spec.controller), {
      start,
      pause,
      backward,
      forward
    })
  });
};
var transformContinuousSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "continuous"
});
var transformDiscreteSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "discrete"
});

// node_modules/@visactor/vchart/esm/component/player/utils/orient.js
var isVertical2 = (orient) => "left" === orient || "right" === orient;
var isHorizontal3 = (orient) => "top" === orient || "bottom" === orient;

// node_modules/@visactor/vchart/esm/component/player/player.js
var Player2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = LayoutZIndex.Player, this.layoutLevel = LayoutLevel.Player, this.specKey = "player", this.type = ComponentTypeEnum.player, this._orient = "bottom", this._getPlayerAttrs = () => {
      var _a, _b;
      const type = this._spec.type, layoutAttrs = {
        size: {
          width: this._width,
          height: this._height
        },
        dx: null !== (_a = this._spec.dx) && void 0 !== _a ? _a : 0 + this._dx,
        dy: null !== (_b = this._spec.dy) && void 0 !== _b ? _b : 0 + this._dy
      };
      return "discrete" === type ? Object.assign(Object.assign(Object.assign({}, transformDiscreteSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent
      }) : Object.assign(Object.assign(Object.assign({}, transformContinuousSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent
      });
    }, this._createOrUpdatePlayerComponent = () => {
      const attrs = Object.assign({}, this._getPlayerAttrs()), container2 = this.getContainer();
      this._playerComponent ? isEqual(attrs, this._cacheAttrs) || (this._cacheAttrs = attrs, this._playerComponent.setAttributes(attrs), this._playerComponent._initAttributes(), this._playerComponent.render()) : ("discrete" === attrs.type ? this._playerComponent = new DiscretePlayer(attrs) : this._playerComponent = new ContinuousPlayer(attrs), this._cacheAttrs = attrs, this._playerComponent.name = "player", container2.add(this._playerComponent), this._initEvent());
    }, this._maxSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      return Math.max(...array(null === (_b = null === (_a = this._spec.controller.start) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.size), ...array(null === (_d = null === (_c = this._spec.controller.pause) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.size), ...array(null === (_f = null === (_e = this._spec.controller.backward) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.size), ...array(null === (_h = null === (_g = this._spec.controller.forward) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size), null !== (_j = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _j ? _j : 10);
    }, this._sliderExceededSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const sliderHeight = null !== (_a = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _a ? _a : 10, controllersHeight = Math.max(...array(null === (_c = null === (_b = this._spec.controller.start) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size), ...array(null === (_e = null === (_d = this._spec.controller.pause) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size), ...array(null === (_g = null === (_f = this._spec.controller.backward) || void 0 === _f ? void 0 : _f.style) || void 0 === _g ? void 0 : _g.size), ...array(null === (_j = null === (_h = this._spec.controller.forward) || void 0 === _h ? void 0 : _h.style) || void 0 === _j ? void 0 : _j.size));
      return sliderHeight >= controllersHeight ? sliderHeight - controllersHeight : 0;
    }, this._initEvent = () => {
      this._option.disableTriggerEvent || (this._option.globalInstance.on(ChartEvent.rendered, () => {
        var _a;
        (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.auto) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnEnd, () => {
        var _a;
        this.event.emit(ChartEvent.playerEnd, {
          model: this
        }), this._alternate && "discrete" === this._spec.type && (this._direction = "default" === this._direction ? "reverse" : "default", this._playerComponent.setAttributes({
          direction: this._direction,
          dataIndex: "reverse" === this._direction ? this._specs.length - 2 : 1
        })), (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.loop) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnChange, (e3) => {
        const { index } = e3.detail, spec = this._specs[index];
        array(spec.data).forEach((data) => {
          var _a, _b;
          null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b || _b.updateData(data.id, data.values);
        }), this.event.emit(ChartEvent.playerChange, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnBackward, (e3) => {
        const { index } = e3.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerBackward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnForward, (e3) => {
        const { index } = e3.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerForward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnPlay, (e3) => {
        const { index } = e3.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPlay, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.OnPause, (e3) => {
        const { index } = e3.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPause, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }));
    };
  }
  get orient() {
    return this._orient;
  }
  set layoutOrient(v2) {
    this._orient = v2;
  }
  static getSpecInfo(chartSpec) {
    const playerSpec = chartSpec[this.specKey];
    return isNil_default(playerSpec) || false === playerSpec.visible ? null : [{
      spec: playerSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.player
    }];
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g;
    super.setAttrFromSpec(), this._orient = null !== (_a = this._spec.orient) && void 0 !== _a ? _a : "bottom", this._specs = null !== (_b = this._spec.specs) && void 0 !== _b ? _b : [], this._direction = null !== (_c = this._spec.direction) && void 0 !== _c ? _c : "default", this._alternate = null !== (_d = this._spec.alternate) && void 0 !== _d && _d, this._dx = null !== (_e = this._spec.dx) && void 0 !== _e ? _e : 0, this._dy = null !== (_f = this._spec.dy) && void 0 !== _f ? _f : 0, this._position = null !== (_g = this._spec.position) && void 0 !== _g ? _g : "middle";
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), isValidNumber_default(pos.x)) {
      const offsetX = isVertical2(this._orient) ? pos.x + this._sliderExceededSize() / 2 : pos.x;
      this._playerComponent && this._playerComponent.setAttribute("x", offsetX);
    }
    if (isValidNumber_default(pos.y)) {
      const offsetY = isHorizontal3(this._orient) ? pos.y + this._sliderExceededSize() / 2 : pos.y;
      this._playerComponent && this._playerComponent.setAttribute("y", offsetY);
    }
  }
  getBoundsInRect(rect, fullSpace) {
    this._width = this._computeWidth(rect), this._height = this._computeHeight(rect), this._dx = this._computeDx(fullSpace), this._dy = this._computeDy(fullSpace);
    const bounds = this._computeLayoutRect(rect, this._width, this._height);
    return this._createOrUpdatePlayerComponent(), bounds;
  }
  changeRegions(regions) {
  }
  onRender(ctx) {
  }
  _getNeedClearVRenderComponents() {
    return [this._playerComponent];
  }
  _computeLayoutRect(rect, width, height) {
    switch (this._orient) {
      case "top":
      case "left":
        return {
          x1: 0,
          y1: 0,
          x2: width,
          y2: height
        };
      case "right":
        return {
          x1: rect.width - width,
          y1: 0,
          x2: rect.width,
          y2: rect.height
        };
      default:
        return {
          x1: 0,
          y1: rect.height - height,
          x2: rect.width,
          y2: rect.height
        };
    }
  }
  _computeWidth(rect) {
    return isNumber_default(this._spec.width) ? Math.min(rect.width, Number(this._spec.width)) : isVertical2(this._orient) ? this._maxSize() : rect.width;
  }
  _computeHeight(rect) {
    return isNumber_default(this._spec.height) ? (this._height = this._spec.height, Math.min(rect.height, Number(this._spec.height))) : isHorizontal3(this._orient) ? this._maxSize() : rect.height;
  }
  _computeDx(rect) {
    return isVertical2(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.width - this._width) / 2 : rect.width - this._width;
  }
  _computeDy(rect) {
    return isHorizontal3(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.height - this._height) / 2 : rect.height - this._height;
  }
};
Player2.specKey = "player", Player2.type = ComponentTypeEnum.player;
var registerPlayer2 = () => {
  Factory2.registerComponent(Player2.type, Player2);
};

// node_modules/@visactor/vchart/esm/component/label/util.js
var labelRuleMap = {
  rect: barLabel,
  symbol: symbolLabel2,
  arc: pieLabel,
  point: pointLabel2,
  "line-data": lineDataLabel2,
  stackLabel,
  line: LineLabel2,
  area: LineLabel2,
  rect3d: barLabel,
  arc3d: pieLabel,
  treemap: treemapLabel
};
function defaultLabelConfig(rule, labelInfo) {
  var _a;
  const { labelSpec } = labelInfo;
  labelSpec.overlap && !isObject_default(labelSpec.overlap) && (labelSpec.overlap = {});
  return (null !== (_a = labelRuleMap[rule]) && void 0 !== _a ? _a : labelRuleMap.point)(labelInfo);
}
function textAttribute(labelInfo, datum, formatMethod, formatter) {
  var _a;
  const { labelMark, series: series2 } = labelInfo, textAttribute2 = {
    text: datum[series2.getMeasureField()[0]],
    data: datum,
    textType: null !== (_a = labelInfo.labelSpec.textType) && void 0 !== _a ? _a : "text"
  }, attributes = Object.keys(labelMark.stateStyle.normal);
  for (const key of attributes) {
    const attr = labelMark.getAttribute(key, datum);
    textAttribute2[key] = attr;
  }
  return formatMethod && (textAttribute2.text = formatMethod(textAttribute2.text, datum, {
    series: series2
  })), formatter && ("pie" === series2.type ? datum._percent_ = (100 * datum[ARC_RATIO]).toFixed(2) + "%" : datum[STACK_FIELD_END_PERCENT] && (datum._percent_ = (100 * datum[STACK_FIELD_END_PERCENT]).toFixed(2) + "%"), textAttribute2.text = substitute(formatter, datum)), textAttribute2;
}
function uniformLabelPosition(position) {
  return isFunction_default(position) ? (datum) => position(datum.data) : position;
}
function symbolLabel2(labelInfo) {
  var _a, _b, _c;
  const { series: series2, labelSpec } = labelInfo, defaultPosition = "horizontal" === series2.direction ? "right" : "top", position = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : defaultPosition;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_c = null === (_b = labelSpec.overlap) || void 0 === _b ? void 0 : _b.strategy) && void 0 !== _c ? _c : symbolLabelOverlapStrategy(),
    avoidBaseMark: "center" !== position
  }, {
    position,
    overlap: overlap2
  };
}
function lineDataLabel2(labelInfo) {
  const result2 = symbolLabel2(labelInfo);
  return isBoolean_default(result2.overlap) || (result2.overlap.avoidBaseMark = false), result2;
}
function symbolLabelOverlapStrategy() {
  return [{
    type: "position",
    position: ["top", "bottom", "right", "left", "top-right", "top-left", "bottom-left", "bottom-right"]
  }];
}
function barLabel(labelInfo) {
  var _a, _b, _c, _d, _e, _f;
  const { series: series2, labelSpec = {} } = labelInfo, originPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", direction2 = null !== (_b = series2.direction) && void 0 !== _b ? _b : "vertical", isInverse = "horizontal" === series2.direction ? null === (_c = series2.getXAxisHelper()) || void 0 === _c ? void 0 : _c.isInverse() : null === (_d = series2.getYAxisHelper()) || void 0 === _d ? void 0 : _d.isInverse();
  let overlap2, position = originPosition;
  isString_default(originPosition) && "inside" !== position && (position = (data) => {
    const { data: datum } = data, dataField = series2.getMeasureField()[0];
    if ("outside" === originPosition) {
      const positionMap = {
        vertical: ["top", "bottom"],
        horizontal: ["right", "left"]
      }, index = (null == datum ? void 0 : datum[dataField]) >= 0 && isInverse || (null == datum ? void 0 : datum[dataField]) < 0 && !isInverse ? 1 : 0;
      return positionMap[direction2][index];
    }
    return "inside-bottom" === originPosition ? "horizontal" === series2.direction ? "inside-left" : "inside-bottom" : "inside-top" === originPosition ? "horizontal" === series2.direction ? "inside-right" : "inside-top" : originPosition;
  }), overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_f = null === (_e = labelSpec.overlap) || void 0 === _e ? void 0 : _e.strategy) && void 0 !== _f ? _f : barLabelOverlapStrategy(series2)
  };
  let smartInvert = false;
  return isString_default(originPosition) && originPosition.includes("inside") && (smartInvert = true), {
    position,
    overlap: overlap2,
    smartInvert
  };
}
function barLabelOverlapStrategy(series2) {
  return [{
    type: "position",
    position: (data) => {
      var _a, _b;
      const { data: datum } = data, dataField = series2.getMeasureField()[0];
      return ("horizontal" === series2.direction ? null === (_a = series2.getXAxisHelper()) || void 0 === _a ? void 0 : _a.isInverse() : null === (_b = series2.getYAxisHelper()) || void 0 === _b ? void 0 : _b.isInverse()) ? (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"] : "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"];
    }
  }];
}
function pointLabel2(labelInfo) {
  const { labelSpec } = labelInfo;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    avoidBaseMark: false
  }, {
    position: "center",
    overlap: overlap2
  };
}
function pieLabel(labelInfo) {
  var _a;
  const { labelSpec } = labelInfo, labelPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", position = labelPosition;
  let smartInvert;
  return smartInvert = labelSpec.smartInvert ? labelSpec.smartInvert : isString_default(labelPosition) && labelPosition.includes("inside"), {
    position,
    smartInvert
  };
}
function stackLabel(labelInfo) {
  const series2 = labelInfo.series, labelSpec = labelInfo.labelSpec || {}, totalData = series2.getTotalData();
  return {
    customLayoutFunc: (labels) => labels.map((label) => {
      const pos = labelSpec.position || "withChange", offset = labelSpec.offset || 0, datum = label.data, attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);
      return attribute.x = ((datum2) => "vertical" === series2.direction ? series2.totalPositionX(datum2, "index", 0.5) : "middle" === pos ? 0.5 * (series2.totalPositionX(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "end" : "start") + offset : "min" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "start" : "end") - offset : series2.totalPositionX(datum2, "end") + (datum2.end >= datum2.start ? offset : -offset))(datum), attribute.y = ((datum2) => "vertical" === series2.direction ? "middle" === pos ? 0.5 * (series2.totalPositionY(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "end" : "start") - offset : "min" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "start" : "end") + offset : series2.totalPositionY(datum2, "end") + (datum2.end >= datum2.start ? -offset : offset) : series2.totalPositionY(datum2, "index", 0.5))(datum), "vertical" === series2.direction ? attribute.textBaseline = "middle" === pos ? pos : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "bottom" : "top" : attribute.textAlign = "middle" === pos ? "center" : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "left" : "right", createText(Object.assign(Object.assign({}, attribute), {
        id: label.id
      }));
    }),
    dataFilter: (labels) => {
      const result2 = [];
      return totalData.forEach((total) => {
        const label = labels.find((labelItem) => {
          var _a;
          return total.index === (null === (_a = labelItem.data) || void 0 === _a ? void 0 : _a[series2.getDimensionField()[0]]);
        });
        label && (label.data = total, result2.push(label));
      }), result2;
    },
    overlap: {
      strategy: []
    }
  };
}
function treemapLabel(labelInfo) {
  const labelSpec = labelInfo.labelSpec;
  return {
    customLayoutFunc: (labels) => labels.map((label) => {
      const datum = label.data, attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);
      return createText(Object.assign(Object.assign({}, attribute), {
        id: label.id,
        pickable: false
      }));
    }),
    overlap: false
  };
}
function LineLabel2(labelInfo) {
  var _a, _b, _c, _d;
  const { labelSpec, series: series2 } = labelInfo, seriesData = null === (_c = null === (_b = null === (_a = series2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(series2).latestData) || void 0 === _b ? void 0 : _b[series2.getSeriesField()]) || void 0 === _c ? void 0 : _c.values, data = seriesData ? seriesData.map((d2, index) => ({
    [series2.getSeriesField()]: d2,
    index
  })) : [];
  return {
    position: null !== (_d = labelSpec.position) && void 0 !== _d ? _d : "end",
    data
  };
}

// node_modules/@visactor/vchart/esm/component/label/base-label.js
var BaseLabelComponent = class extends BaseComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Label, this._regions = options.getRegionsInIndex([options.specIndex]);
  }
  _interactiveConfig(labelSpec) {
    const { interactive } = labelSpec;
    if (true !== interactive) return {
      hover: false,
      select: false
    };
    const result2 = {
      hover: false,
      select: false,
      state: labelSpec.state
    }, { hover, select } = this._option.getChart().getSpec();
    return false === hover && false === hover.enable || (result2.hover = true), false === select && false === select.enable || (result2.select = true), result2;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, isEqual(prevSpec, spec) || (result2.reMake = true), result2;
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
};
BaseLabelComponent.type = ComponentTypeEnum.label;

// node_modules/@visactor/vchart/esm/mark/label.js
var LabelMark = class extends TextMark {
  constructor() {
    super(...arguments), this.skipEncode = false;
  }
  getRule() {
    return this._rule;
  }
  setRule(rule) {
    this._rule = rule;
  }
  getTarget() {
    return this._target;
  }
  setTarget(target) {
    this._target = target, this._rule || this.setRule(target.type);
  }
  getComponent() {
    return this._component;
  }
  setComponent(component2) {
    this._component = component2;
  }
};
LabelMark.type = "text", LabelMark.constructorType = "label";
var registerLabelMark = () => {
  Factory2.registerMark(LabelMark.constructorType, LabelMark), registerTextGraphic2();
};

// node_modules/@visactor/vchart/esm/component/label/label-transformer.js
var LabelSpecTransformer = class extends BaseComponentSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// node_modules/@visactor/vchart/esm/component/label/label.js
var Label2 = class extends BaseLabelComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.specKey = "label", this.transformerConstructor = LabelSpecTransformer, this.layoutZIndex = LayoutZIndex.Label, this._layoutRule = spec.labelLayout || "series";
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    const specInfo = [], regionSpecInfo = (null == chartSpecInfo ? void 0 : chartSpecInfo.region) || [];
    return regionSpecInfo.forEach((regionInfo, i2) => {
      const hasVisibleLabel = (regionInfo.seriesIndexes || []).some((seriesIndex) => {
        const seriesInfo = chartSpecInfo.series[seriesIndex], { markLabelSpec = {} } = seriesInfo;
        return Object.values(markLabelSpec).some((labelSpecList) => Array.isArray(labelSpecList) && ((labelSpecList2) => labelSpecList2.some((labelSpec) => labelSpec.visible))(labelSpecList));
      });
      ("region" !== chartSpec.labelLayout || hasVisibleLabel) && specInfo.push({
        spec: chartSpec,
        type: ComponentTypeEnum.label,
        specInfoPath: ["region", i2, "markLabel"],
        specIndex: i2
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this.initEvent(), this._initTextMark(), this._initLabelComponent(), this._initTextMarkStyle();
  }
  reInit(spec) {
    super.reInit(spec), this._labelInfoMap && this._labelInfoMap.clear(), this._initTextMark(), this._initTextMarkStyle();
  }
  initEvent() {
    this.event.on(ChartEvent.dataZoomChange, () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.disableAnimation();
      }), this.event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    });
    const enableAnimation = () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.enableAnimation();
      }), this.event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    };
    this.event.on("afterElementEncode", (eventParams) => {
      var _a;
      const mark = eventParams.item;
      false === this._option.getChart().getLayoutTag() && (null === (_a = mark.getContext()) || void 0 === _a ? void 0 : _a.model) === this && this._delegateLabelEvent(mark.getGroupGraphicItem());
    });
  }
  _delegateLabelEvent(component2) {
    const textNodes = null == component2 ? void 0 : component2.findAll((node) => "text" === node.type, true).filter((text2) => !text2.__vchart_event);
    textNodes && textNodes.length > 0 && textNodes.forEach((text2) => {
      text2.__vchart_event = true, text2.addEventListener("*", (event, type) => this._delegateEvent(component2, event, type, text2, text2.attribute.data));
    });
  }
  _initTextMark() {
    this._labelInfoMap || (this._labelInfoMap = /* @__PURE__ */ new Map()), this._labelComponentMap || (this._labelComponentMap = /* @__PURE__ */ new Map()), eachSeries(this._regions, (series2) => {
      const { markLabelSpec = {} } = series2.getSpecInfo(), markNames = Object.keys(markLabelSpec), region = series2.getRegion();
      this._labelInfoMap.get(region) || this._labelInfoMap.set(region, []);
      for (let i2 = 0; i2 < markNames.length; i2++) {
        const markName = markNames[i2], mark = series2.getMarkInName(markName);
        mark && markLabelSpec[markName].forEach((spec, index) => {
          if (spec.visible) {
            const info = this._labelInfoMap.get(region), labelMark = this._createMark({
              type: "label",
              name: `${markName}-label-${index}`
            }, {
              noSeparateStyle: true,
              attributeContext: series2.getMarkAttributeContext()
            });
            labelMark.setTarget(mark), info.push({
              labelMark,
              baseMark: mark,
              series: series2,
              labelSpec: spec
            });
          }
        });
      }
    });
  }
  _initLabelComponent() {
    this._labelInfoMap.forEach((regionLabelInfo, region) => {
      if ("region" === this._layoutRule) {
        const component2 = this._createMark({
          type: "component",
          name: `${region.getGroupMark().name}-label-component`
        }, {
          componentType: "label",
          noSeparateStyle: true,
          support3d: this._spec.support3d
        });
        component2 && (component2.setSkipBeforeLayouted(true), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)));
      } else regionLabelInfo.forEach((labelInfo, i2) => {
        const component2 = this._createMark({
          type: "component",
          name: `${labelInfo.labelMark.name}-component`
        }, {
          componentType: "label",
          noSeparateStyle: true,
          support3d: labelInfo.baseMark.getSupport3d()
        });
        component2 && (component2.setSkipBeforeLayouted(true), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)[i2]), labelInfo.labelMark.setComponent(component2));
      });
    });
  }
  _initTextMarkStyle() {
    this._labelInfoMap.forEach((labelInfos) => {
      labelInfos.forEach((info) => {
        var _a, _b;
        const { labelMark, labelSpec, series: series2 } = info;
        if (this.initMarkStyleWithSpec(labelMark, labelSpec, void 0), isFunction_default(null == labelSpec ? void 0 : labelSpec.getStyleHandler)) {
          const styleHandler = labelSpec.getStyleHandler(series2);
          null == styleHandler || styleHandler.call(series2, labelMark);
        }
        (null === (_b = null === (_a = labelMark.stateStyle) || void 0 === _a ? void 0 : _a.normal) || void 0 === _b ? void 0 : _b.lineWidth) && labelMark.setAttribute("stroke", series2.getColorAttribute(), "normal", AttributeLevel.Base_Series);
      });
    });
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute(), this._labelComponentMap.forEach((labelInfoCb, labelComponent) => {
      const labelInfo = labelInfoCb();
      isArray_default(labelInfo) ? this._updateMultiLabelAttribute(labelInfo, labelComponent) : this._updateSingleLabelAttribute(labelInfo, labelComponent);
    });
  }
  _updateMultiLabelAttribute(labelInfo, labelComponent) {
    this._updateLabelComponentAttribute(labelComponent.getProduct(), labelInfo.map(({ baseMark }) => baseMark.getProduct()), labelInfo);
  }
  _updateSingleLabelAttribute(labelInfo, labelComponent) {
    const { baseMark } = labelInfo;
    this._updateLabelComponentAttribute(labelComponent.getProduct(), baseMark.getProduct(), [labelInfo]);
  }
  _updateLabelComponentAttribute(component2, target, labelInfos) {
    const dependCmp = this._option.getAllComponents().filter((cmp) => "totalLabel" === cmp.type);
    component2.target(target).configure({
      interactive: false
    }).depend(dependCmp.map((cmp) => cmp.getMarks()[0].getProduct())).labelStyle((mark, params2) => {
      var _a, _b;
      const labelInfo = labelInfos[params2.labelIndex];
      if (labelInfo) {
        const { labelSpec, labelMark } = labelInfo, rule = labelMark.getRule(), interactive = this._interactiveConfig(labelSpec), centerOffset = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerOffset) && void 0 !== _b ? _b : 0, spec = mergeSpec({
          textStyle: Object.assign({
            pickable: true === labelSpec.interactive
          }, labelSpec.style),
          overlap: {
            avoidMarks: this._option.getAllComponents().filter((cmp) => "totalLabel" === cmp.type).map((cmp) => cmp.getMarks()[0].getProductId())
          },
          x: 0,
          y: 0
        }, defaultLabelConfig(rule, labelInfo), Object.assign(Object.assign(Object.assign({}, pickWithout(labelSpec, ["position", "style", "state", "type"])), interactive), {
          centerOffset
        }));
        return "line" !== rule && "area" !== rule || (spec.type = rule), spec;
      }
    }).encode((datum, element, params2) => {
      if (labelInfos[params2.labelIndex]) {
        const { labelSpec, labelMark } = labelInfos[params2.labelIndex];
        return labelMark.skipEncode ? {
          data: datum
        } : textAttribute(labelInfos[params2.labelIndex], datum, labelSpec.formatMethod, labelSpec.formatter);
      }
    }).size(() => labelInfos[0].series.getRegion().getLayoutRect());
  }
  compileMarks() {
    this.getMarks().forEach((m5) => {
      var _a;
      const labelInfo = this._labelComponentMap.get(m5)();
      let group;
      group = isArray_default(labelInfo) ? labelInfo[0].series.getRegion().getGroupMark().getProduct() : labelInfo.series.getRegion().getGroupMark().getProduct(), m5.compile({
        group
      }), null === (_a = m5.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this,
          labelInfo
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this._labelComponentMap.forEach((info, component2) => {
      const graphicItem = component2.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
};
Label2.type = ComponentTypeEnum.label, Label2.specKey = "label", Label2.transformerConstructor = LabelSpecTransformer;
var registerLabel2 = () => {
  registerLabel(), registerLabelMark(), registerComponentMark(), Factory2.registerComponent(Label2.type, Label2, true);
};

// node_modules/@visactor/vchart/esm/component/label/total-label.js
var TotalLabel = class extends BaseLabelComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.totalLabel, this.name = ComponentTypeEnum.totalLabel, this.specKey = "totalLabel", this.layoutZIndex = LayoutZIndex.Label;
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    var _a;
    const specInfo = [];
    return null === (_a = null == chartSpecInfo ? void 0 : chartSpecInfo.region) || void 0 === _a || _a.forEach((regionInfo, i2) => {
      var _a2;
      null === (_a2 = regionInfo.seriesIndexes) || void 0 === _a2 || _a2.forEach((seriesIndex) => {
        const { spec } = chartSpecInfo.series[seriesIndex], labelSpec = spec[this.specKey];
        (null == labelSpec ? void 0 : labelSpec.visible) && specInfo.push({
          spec: labelSpec,
          type: ComponentTypeEnum.totalLabel,
          specPath: ["series", seriesIndex, this.specKey],
          specIndex: i2
        });
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this._initTextMark(), this._initLabelComponent();
  }
  _initTextMark() {
    var _a;
    const series2 = this._getSeries();
    if (null === (_a = series2.getSpec().totalLabel) || void 0 === _a ? void 0 : _a.visible) {
      const mark = series2.getMarksInType(["rect", "symbol"])[0], textMark = this._createMark({
        type: "label",
        name: `${mark.name}-total-label`
      });
      this._baseMark = mark, this._textMark = textMark, this._initTextMarkStyle();
    }
  }
  _initTextMarkStyle() {
    super.initMarkStyleWithSpec(this._textMark, this._spec), this.setMarkStyle(this._textMark, {
      text: (datum) => datum[STACK_FIELD_TOTAL]
    }, "normal", AttributeLevel.Default);
  }
  _initLabelComponent() {
    const series2 = this._getSeries(), component2 = this._createMark({
      type: "component",
      name: `${series2.name}-total-label-component`
    }, {
      componentType: "label",
      noSeparateStyle: true,
      support3d: this._spec.support3d
    });
    component2 && this._marks.addMark(component2);
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute();
    const series2 = this._getSeries();
    this._marks.forEach((componentMark, index) => {
      componentMark.getProduct().target(this._baseMark.getProduct()).configure({
        interactive: false
      }).labelStyle(() => {
        if (this._baseMark) {
          const { offset, animation, overlap: overlap2 } = this._spec, interactive = this._interactiveConfig(this._spec);
          return mergeSpec({
            textStyle: {
              pickable: true === this._spec.interactive
            },
            position: totalLabelPosition(series2, this._baseMark.type),
            x: 0,
            y: 0
          }, Object.assign({
            offset,
            animation,
            overlap: overlap2,
            dataFilter: (data) => data.filter((d2) => d2.data[STACK_FIELD_TOTAL_TOP])
          }, interactive));
        }
      }).encode((datum) => textAttribute({
        baseMark: this._baseMark,
        labelMark: this._textMark,
        series: series2,
        labelSpec: series2.getSpec().totalLabel
      }, datum, this._spec.formatMethod)).size(() => this._regions[0].getLayoutRect());
    });
  }
  compileMarks() {
    this.getMarks().forEach((m5) => {
      var _a;
      const group = this._regions[0].getGroupMark().getProduct();
      m5.compile({
        group
      }), null === (_a = m5.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this.getMarks().forEach((m5) => {
      const graphicItem = m5.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
  _getSeries() {
    return this._option.getSeriesInIndex([this.getSpecPath()[1]])[0];
  }
};
TotalLabel.type = ComponentTypeEnum.totalLabel, TotalLabel.specKey = "totalLabel";
function totalLabelPosition(series2, type) {
  let position;
  if ("rect" === type) position = "horizontal" === series2.direction ? "right" : "top";
  else position = "top";
  return position;
}
var registerTotalLabel = () => {
  registerLabel(), registerLabelMark(), registerComponentMark(), Factory2.registerComponent(TotalLabel.type, TotalLabel, true);
};

// node_modules/@visactor/vchart/esm/component/marker/mark-point/mark-point.js
var __rest21 = function(s3, e3) {
  var t2 = {};
  for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0 && (t2[p2] = s3[p2]);
  if (null != s3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i2 = 0;
    for (p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]) && (t2[p2[i2]] = s3[p2[i2]]);
  }
  return t2;
};
var MarkPoint2 = class extends BaseMarker {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markPoint, this.name = ComponentTypeEnum.markPoint, this.specKey = "markPoint", this.layoutZIndex = LayoutZIndex.MarkPoint;
  }
  static getSpecInfo(chartSpec) {
    const markPointSpec = chartSpec[this.specKey];
    if (isEmpty_default(markPointSpec)) return;
    if (!isArray_default(markPointSpec) && false !== markPointSpec.visible) return [{
      spec: markPointSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.markPoint
    }];
    const specInfos = [];
    return markPointSpec.forEach((m5, i2) => {
      false !== m5.visible && specInfos.push({
        spec: m5,
        specIndex: i2,
        specPath: [this.specKey, i2],
        type: ComponentTypeEnum.markPoint
      });
    }), specInfos;
  }
  _createMarkerComponent() {
    var _a, _b;
    const { itemContent = {}, itemLine = {} } = this._spec, { text: label = {}, symbol, image, richText: richText2 } = itemContent, restItemContent = __rest21(itemContent, ["text", "symbol", "image", "richText"]), markPointAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null !== (_a = this._spec.interactive) && void 0 !== _a && _a,
      position: {
        x: 0,
        y: 0
      },
      clipInRange: null !== (_b = this._spec.clip) && void 0 !== _b && _b,
      itemContent: Object.assign({
        symbolStyle: transformToGraphic(null == symbol ? void 0 : symbol.style),
        imageStyle: null == image ? void 0 : image.style,
        textStyle: transformLabelAttributes(label),
        richTextStyle: null == richText2 ? void 0 : richText2.style
      }, restItemContent)
    }, { visible, line: line2 = {} } = itemLine, restItemLine = __rest21(itemLine, ["visible", "line"]);
    markPointAttrs.itemLine = false !== visible ? Object.assign(Object.assign({}, restItemLine), {
      visible: true,
      lineStyle: transformToGraphic(line2.style)
    }) : {
      visible: false
    };
    return new MarkPoint(markPointAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e, _f;
    const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, isXYLayout = "x" in spec && "y" in spec, isCoordinateLayout = "coordinate" in spec, isPositionLayout = "position" in spec, autoRange = null !== (_a = null == spec ? void 0 : spec.autoRange) && void 0 !== _a && _a;
    let point6;
    isXYLayout ? point6 = xyLayout(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0] : isCoordinateLayout ? point6 = coordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset)[0] : isPositionLayout && (point6 = positionLayout([spec.position], relativeSeries, spec.regionRelative)[0]);
    const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || (null === (_b = spec.itemContent) || void 0 === _b ? void 0 : _b.confine)) {
      const { minX, maxX, minY, maxY: maxY2 } = computeClipRange([relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    if (this._markerComponent) {
      const attribute = null !== (_c = this._markerComponent.attribute) && void 0 !== _c ? _c : {}, textStyle = null !== (_e = null === (_d = attribute.itemContent) || void 0 === _d ? void 0 : _d.textStyle) && void 0 !== _e ? _e : {};
      this._markerComponent.setAttributes({
        position: point6,
        itemContent: Object.assign(Object.assign({}, attribute.itemContent), {
          textStyle: Object.assign(Object.assign({}, textStyle), {
            text: (null === (_f = this._spec.itemContent.text) || void 0 === _f ? void 0 : _f.formatMethod) ? this._spec.itemContent.text.formatMethod(dataPoints, seriesData) : textStyle.text
          })
        }),
        limitRect,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    }
  }
  _initDataView() {
    const spec = this._spec, relativeSeries = this._relativeSeries, isXYProcess = isValid_default(spec.x) && isValid_default(spec.y), isCoordinateProcess = isValid_default(spec.coordinate);
    if (!isCoordinateProcess && !isXYProcess) return;
    let options;
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter), isXYProcess ? options = [this._processSpecXY(spec.x, spec.y)] : isCoordinateProcess && (options = this._processSpecCoo(spec));
    const data = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.parse([relativeSeries.getViewData()], {
      type: "dataview"
    }), data.transform({
      type: "markerAggregation",
      options
    }), options && data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
MarkPoint2.type = ComponentTypeEnum.markPoint, MarkPoint2.specKey = "markPoint";
var registerMarkPoint = () => {
  Factory2.registerComponent(MarkPoint2.type, MarkPoint2);
};

// node_modules/@visactor/vchart/esm/component/brush/brush.js
var Brush2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this.type = ComponentTypeEnum.brush, this.name = ComponentTypeEnum.brush, this.specKey = "brush", this.layoutZIndex = LayoutZIndex.Brush, this._linkedSeries = [], this._itemMap = {}, this._linkedItemMap = {}, this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, this._needInitOutState = true, this._cacheInteractiveRangeAttrs = [], this._needDisablePickable = false;
  }
  init() {
    const inBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.inBrush), outOfBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.outOfBrush);
    this._option.getAllSeries().forEach((s3) => {
      s3.getActiveMarks().forEach((m5) => {
        m5 && (s3.setMarkStyle(m5, Object.assign({}, inBrushMarkAttr), "inBrush", AttributeLevel.Series), s3.setMarkStyle(m5, Object.assign({}, outOfBrushMarkAttr), "outOfBrush", AttributeLevel.Series));
      });
    });
  }
  static getSpecInfo(chartSpec) {
    const brushSpec = chartSpec[this.specKey];
    if (!isNil_default(brushSpec) && false !== brushSpec.visible) return [{
      spec: brushSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.brush
    }];
  }
  created() {
    super.created(), this.initEvent(), this._bindRegions(), this._bindLinkedSeries(), this._initNeedOperatedItem();
  }
  _extendDataInBrush(elementsMap) {
    const data = [];
    for (const brushName in elementsMap) for (const elementKey in elementsMap[brushName]) data.push(elementsMap[brushName][elementKey].data[0]);
    return data;
  }
  _extendDatumOutOfBrush(elementsMap) {
    const data = [];
    for (const elementKey in elementsMap) data.push(elementsMap[elementKey].data[0]);
    return data;
  }
  _getBrushInteractiveAttr(region) {
    const regionLayoutPosition = region.getLayoutStartPoint(), regionLayoutRect = region.getLayoutRect(), seriesRegionStartX = regionLayoutPosition.x, seriesRegionEndX = seriesRegionStartX + regionLayoutRect.width, seriesRegionStartY = regionLayoutPosition.y, seriesRegionEndY = seriesRegionStartY + regionLayoutRect.height;
    return {
      interactiveRange: {
        minY: seriesRegionStartY,
        maxY: seriesRegionEndY,
        minX: seriesRegionStartX,
        maxX: seriesRegionEndX
      },
      xRange: [seriesRegionStartX, seriesRegionEndX],
      yRange: [seriesRegionStartY, seriesRegionEndY]
    };
  }
  _updateBrushComponent(region, componentIndex) {
    const interactiveAttr = this._getBrushInteractiveAttr(region), brushComponent = this._brushComponents[componentIndex];
    brushComponent.setAttributes(interactiveAttr), this._initMarkBrushState(componentIndex, ""), brushComponent.children[0].removeAllChild(), this._needInitOutState = true;
  }
  _createBrushComponent(region, componentIndex) {
    var _a, _b;
    const interactiveAttr = this._getBrushInteractiveAttr(region), brush2 = new Brush(Object.assign(Object.assign(Object.assign({
      zIndex: this.layoutZIndex,
      brushStyle: transformToGraphic(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.style)
    }, interactiveAttr), this._spec), {
      disableTriggerEvent: this._option.disableTriggerEvent
    }));
    brush2.id = null !== (_b = this._spec.id) && void 0 !== _b ? _b : `brush-${this.id}`, this.getContainer().add(brush2);
    const { brushMode = "single" } = this._spec;
    this._brushComponents.push(brush2), this._cacheInteractiveRangeAttrs.push(interactiveAttr), brush2.addEventListener(IOperateType.drawStart, (e3) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.moveStart, (e3) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.drawing, (e3) => {
      this._needInitOutState && "single" === brushMode && this._initMarkBrushState(componentIndex, "outOfBrush"), this._needInitOutState = false, this._needDisablePickable = true, this._handleBrushChange(ChartEvent.brushChange, region, e3);
    }), brush2.addEventListener(IOperateType.moving, (e3) => {
      this._handleBrushChange(ChartEvent.brushChange, region, e3);
    }), brush2.addEventListener(IOperateType.brushClear, (e3) => {
      this._initMarkBrushState(componentIndex, ""), this._needInitOutState = true, this._needDisablePickable = false, this._handleBrushChange(ChartEvent.brushChange, region, e3), this._handleBrushChange(ChartEvent.brushClear, region, e3);
    }), brush2.addEventListener(IOperateType.drawEnd, (e3) => {
      this._needInitOutState = true, this._needDisablePickable = false, this._handleBrushChange(ChartEvent.brushEnd, region, e3);
    }), brush2.addEventListener(IOperateType.moveEnd, (e3) => {
      this._handleBrushChange(ChartEvent.brushEnd, region, e3);
    });
  }
  _handleBrushChange(eventType, region, e3) {
    const { operateMask } = e3.detail;
    this._reconfigItem(operateMask, region), this._reconfigLinkedItem(operateMask, region), this._emitEvent(eventType, region);
  }
  _emitEvent(eventType, region) {
    this.event.emit(eventType, {
      model: this,
      value: {
        operateType: eventType,
        operateRegion: region,
        inBrushData: this._extendDataInBrush(this._inBrushElementsMap),
        outOfBrushData: this._extendDatumOutOfBrush(this._outOfBrushElementsMap),
        linkInBrushData: this._extendDataInBrush(this._linkedInBrushElementsMap),
        linkOutOfBrushData: this._extendDatumOutOfBrush(this._linkedOutOfBrushElementsMap),
        inBrushElementsMap: this._inBrushElementsMap,
        outOfBrushElementsMap: this._outOfBrushElementsMap,
        linkedInBrushElementsMap: this._linkedInBrushElementsMap,
        linkedOutOfBrushElementsMap: this._linkedOutOfBrushElementsMap
      }
    });
  }
  _transformBrushedMarkAttr(brushedStyle) {
    const styleResult = {};
    return (null == brushedStyle ? void 0 : brushedStyle.symbol) && (styleResult.symbolType = brushedStyle.symbol), (null == brushedStyle ? void 0 : brushedStyle.symbolSize) && (styleResult.size = brushedStyle.symbolSize), (null == brushedStyle ? void 0 : brushedStyle.color) && (styleResult.fill = brushedStyle.color), (null == brushedStyle ? void 0 : brushedStyle.colorAlpha) && (styleResult.fillOpacity = brushedStyle.colorAlpha), Object.assign(Object.assign({}, transformToGraphic(brushedStyle)), styleResult);
  }
  _reconfigItem(operateMask, region) {
    this._itemMap[region.id].forEach((mark) => {
      const grammarMark = mark.getProduct();
      if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
      grammarMark.elements.forEach((el) => {
        var _a, _b, _c;
        const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
        (null === (_a = this._outOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem) ? (el.addState("inBrush"), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._outOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._inBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._outOfBrushElementsMap[elementKey] = el, delete this._inBrushElementsMap[operateMask.name][elementKey]), graphicItem.setAttribute("pickable", !this._needDisablePickable);
      });
    });
  }
  _reconfigLinkedItem(operateMask, region) {
    const regionLayoutPos = region.getLayoutStartPoint(), seriesId = region.getSeries().map((s3) => s3.id);
    this._linkedSeries.forEach((s3) => {
      if (!seriesId.includes(s3.id)) {
        const sRegionLayoutPos = s3.getRegion().getLayoutStartPoint(), regionOffsetX = sRegionLayoutPos.x - regionLayoutPos.x, regionOffsetY = sRegionLayoutPos.y - regionLayoutPos.y;
        this._linkedItemMap[s3.id].forEach((mark) => {
          const grammarMark = mark.getProduct();
          if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
          grammarMark.elements.forEach((el) => {
            var _a, _b, _c;
            const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
            (null === (_a = this._linkedOutOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem, {
              dx: regionOffsetX,
              dy: regionOffsetY
            }) ? (el.addState("inBrush"), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._linkedOutOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._linkedInBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem, {
              dx: regionOffsetX,
              dy: regionOffsetY
            }) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._linkedOutOfBrushElementsMap[elementKey] = el), graphicItem.setAttribute("pickable", !this._needDisablePickable);
          });
        });
      }
    });
  }
  _isBrushContainItem(brushMask, item, linkedOffset) {
    var _a, _b, _c;
    if (!(null == brushMask ? void 0 : brushMask.globalTransMatrix) || !(null === (_a = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _a ? void 0 : _a.points)) return false;
    const points = null !== (_c = null === (_b = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _b ? void 0 : _b.points) && void 0 !== _c ? _c : [], { a: a4, b: b2, c: c4, d: d2, e: e3, f: f2 } = brushMask.globalTransMatrix, dx = (null == linkedOffset ? void 0 : linkedOffset.dx) || 0, dy = (null == linkedOffset ? void 0 : linkedOffset.dy) || 0, pointsCoord = points.map((p2) => ({
      x: a4 * p2.x + c4 * p2.y + e3 + dx,
      y: b2 * p2.x + d2 * p2.y + f2 + dy
    }));
    brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy);
    const x3 = item.globalTransMatrix.e, y3 = item.globalTransMatrix.f;
    let itemBounds = [];
    if ("symbol" === item.type) {
      const { size: itemSize = 0 } = null == item ? void 0 : item.attribute, size = array(itemSize)[0] / 2;
      return itemBounds = [{
        x: x3 - size,
        y: y3 - size
      }, {
        x: x3 + size,
        y: y3 - size
      }, {
        x: x3 + size,
        y: y3 + size
      }, {
        x: x3 - size,
        y: y3 + size
      }], polygonIntersectPolygon(pointsCoord, itemBounds);
    }
    if ("rect" === item.type) {
      const { x1: x14, x2: x23, y1: y14, y2: y23 } = null == item ? void 0 : item.AABBBounds, width = Math.abs(x14 - x23), height = Math.abs(y14 - y23);
      return itemBounds = [{
        x: x3,
        y: y3
      }, {
        x: x3 + width,
        y: y3
      }, {
        x: x3 + width,
        y: y3 + height
      }, {
        x: x3,
        y: y3 + height
      }], polygonIntersectPolygon(pointsCoord, itemBounds);
    }
    return brushMask.globalAABBBounds.intersects(item.globalAABBBounds);
  }
  _bindRegions() {
    isValid_default(this._spec.regionId) && isValid_default(this._spec.regionIndex) && (this._relativeRegions = this._option.getAllRegions()), this._relativeRegions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
  }
  _bindLinkedSeries() {
    isValid_default(this._spec.brushLinkSeriesId) && isValid_default(this._spec.brushLinkSeriesIndex) || (this._linkedSeries = this._option.getSeriesInUserIdOrIndex(array(this._spec.brushLinkSeriesId), array(this._spec.brushLinkSeriesIndex)));
  }
  _initNeedOperatedItem() {
    const seriesUserId = this._spec.seriesId, seriesIndex = this._spec.seriesIndex;
    this._relativeRegions.forEach((r2) => {
      const allMarks = [];
      r2.getSeries().forEach((s3) => {
        (seriesUserId && array(seriesUserId).includes(s3.userId.toString()) || seriesIndex && array(seriesIndex).includes(s3.getSpecIndex()) || !seriesIndex && !seriesUserId) && allMarks.push(...s3.getMarksWithoutRoot()), this._itemMap[r2.id] = allMarks;
      });
    }), this._linkedSeries.forEach((s3) => {
      this._linkedItemMap[s3.id] = s3.getMarksWithoutRoot();
    });
  }
  _initMarkBrushState(componentIndex, stateName) {
    this._brushComponents.forEach((brush2, index) => {
      index !== componentIndex && brush2.children[0].removeAllChild();
    }), this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, this._option.getAllSeries().forEach((s3) => {
      s3.getMarksWithoutRoot().forEach((mark) => {
        const grammarMark = mark.getProduct();
        if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
        grammarMark.elements.forEach((el) => {
          const elementKey = mark.id + "_" + el.key;
          el.removeState("inBrush"), el.removeState("outOfBrush"), el.addState(stateName), this._outOfBrushElementsMap[elementKey] = el, this._linkedOutOfBrushElementsMap[elementKey] = el;
        });
      });
    });
  }
  initEvent() {
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return this._brushComponents;
  }
  _compareSpec(spec, prevSpec) {
    this._brushComponents && this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    });
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  onLayoutEnd(ctx) {
    var _a;
    if (super.onLayoutEnd(ctx), this._option.disableTriggerEvent) return;
    (null === (_a = this._spec.visible) || void 0 === _a || _a) && (this._brushComponents ? this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    }) : (this._brushComponents = [], this._relativeRegions.forEach((region, index) => {
      this._createBrushComponent(region, index);
    })));
  }
  clearGraphic() {
    this._brushComponents && this._brushComponents.forEach((brush2) => {
      brush2._container.incrementalClearChild();
    });
  }
  clear() {
    var _a;
    this._brushComponents && (null === (_a = this.getContainer()) || void 0 === _a || _a.removeChild(this._brushComponents), this._brushComponents.forEach((brush2) => {
      brush2.removeAllChild(), brush2.releaseBrushEvents();
    }), this._brushComponents = null), super.clear();
  }
};
Brush2.type = ComponentTypeEnum.brush, Brush2.specKey = "brush";
var registerBrush = () => {
  Factory2.registerComponent(Brush2.type, Brush2);
};

// node_modules/@visactor/vchart/esm/mark/image.js
var ImageMark = class _ImageMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _ImageMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      lineWidth: 0
    });
  }
};
ImageMark.type = "image";
var registerImageMark = () => {
  Factory2.registerMark(ImageMark.type, ImageMark), registerImageGraphic2();
};

// node_modules/@visactor/vchart/esm/component/custom-mark/custom-mark.js
var CustomMark = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.customMark, this.specKey = "customMark", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.CustomMark, this.layoutLevel = LayoutLevel.CustomMark;
  }
  static getSpecInfo(chartSpec) {
    const spec = chartSpec[this.specKey];
    return spec ? [{
      spec,
      specIndex: 0,
      specPath: [this.specKey],
      type: ComponentTypeEnum.customMark
    }] : null;
  }
  created() {
    super.created(), this.initMarks(), this.initEvent();
  }
  initMarks() {
    this._spec && this._spec.forEach((m5, i2) => {
      this._createExtensionMark(m5, null, `${PREFIX}_series_${this.id}_extensionMark`, i2);
    });
  }
  _createExtensionMark(spec, parentMark, namePrefix, index) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: `${PREFIX}_${index}`
    }, {
      skipBeforeLayouted: true,
      attributeContext: this._getMarkAttributeContext()
    });
    if (mark && (isNil_default(parentMark) ? this._marks.addMark(mark) : parentMark && parentMark.addMark(mark), this.initMarkStyleWithSpec(mark, spec), "group" === spec.type && (namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s3, i2) => {
      this._createExtensionMark(s3, mark, namePrefix, i2);
    })), isValid_default(spec.dataId) || isValidNumber_default(spec.dataIndex))) {
      const dataview = this.getChart().getSeriesData(spec.dataId, spec.dataIndex);
      dataview && (dataview.target.addListener("change", () => {
        mark.getData().updateData();
      }), mark.setDataView(dataview));
    }
  }
  initEvent() {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  onRender(ctx) {
  }
  _getMarkAttributeContext() {
    return {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      }
    };
  }
};
CustomMark.type = ComponentTypeEnum.customMark, CustomMark.specKey = "customMark";
var registerCustomMark = () => {
  registerImageMark(), Factory2.registerComponent(CustomMark.type, CustomMark);
};

// node_modules/@visactor/vchart/esm/component/map-label/layout.js
function overlap(a4, b2, sep = 0) {
  return sep > Math.max(b2.x1 - a4.x2, a4.x1 - b2.x2, b2.y1 - a4.y2, a4.y1 - b2.y2);
}
function bound(rect) {
  return {
    x1: rect.x,
    x2: rect.x + rect.width,
    y1: rect.y,
    y2: rect.y + rect.height
  };
}
function toRect2(bound2) {
  return {
    x: bound2.x1,
    y: bound2.y1,
    width: bound2.x2 - bound2.x1,
    height: bound2.y2 - bound2.y1
  };
}
function layoutByPosition(pairs) {
  var _a;
  if (!pairs || 0 === pairs.length) return [];
  if (1 === pairs.length) return [pairs[0].rect];
  const _pairs = pairs.map((pair) => {
    var _a2;
    return Object.assign(Object.assign({}, pair), {
      bound: bound(pair.rect),
      anchorCandidates: candidatesByOrient(null !== (_a2 = pair.anchors) && void 0 !== _a2 ? _a2 : [], pair.point, pair.rect, pair.offset)
    });
  }), resultBound = [];
  resultBound.push(_pairs[0].bound);
  for (let i2 = 1; i2 <= _pairs.length - 1; i2++) {
    const curPair = _pairs[i2], curBound = curPair.bound;
    let isOverlap2 = resultBound.some((r2) => overlap(r2, curBound));
    if (curPair.anchorCandidates) if (isOverlap2 && (null === (_a = curPair.anchorCandidates) || void 0 === _a ? void 0 : _a.length) > 0) {
      for (let j2 = 0; j2 < curPair.anchorCandidates.length; j2++) {
        const anchor = curPair.anchorCandidates[j2], newBound = {
          x1: anchor.x,
          y1: anchor.y,
          x2: anchor.x + curBound.x2 - curBound.x1,
          y2: anchor.y + curBound.y2 - curBound.y1,
          anchor
        };
        if (!resultBound.some((r2) => overlap(r2, newBound))) {
          resultBound.push(newBound), isOverlap2 = false;
          break;
        }
      }
      isOverlap2 && resultBound.push(curPair.bound);
    } else resultBound.push(curPair.bound);
  }
  return resultBound.map((bound2) => toRect2(bound2));
}
function layoutOuter(pairs, features, dataToPosition) {
  const _points = pairs.map((rect) => rect.pointCoord), { x1: x14, x2: x23, y1: y14, y2: y23 } = getAABBFromPoints(_points), centerPosition = dataToPosition([(x14 + x23) / 2, (y14 + y23) / 2]);
  if (!centerPosition) return [];
  return layoutByPosition(pairs.map((pair) => {
    const rect = pair.rect, targetPoint = isPointWithinFeatures(features, pair.pointCoord) ? dataToPosition(nearestPoint(features, [pair.pointCoord.x, pair.pointCoord.y], uniformDegree(lineDegree(pair.point, centerPosition)))) : pair.point;
    targetPoint && (rect.x = targetPoint.x, rect.y = targetPoint.y);
    const degree = uniformDegree(lineDegree(pair.point, centerPosition));
    let position;
    const anchors = [];
    return degree >= -45 && degree < 45 ? (position = "top", anchors.push("left", "right")) : degree >= 45 && degree < 135 ? position = "right" : degree >= -135 && degree < -45 ? (position = "left", anchors.push("left")) : (position = "bottom", anchors.push("left", "right")), pair.anchors = anchors, pair.offset = 20, pair.rect = placeRectByOrient(pair.rect, position, 0), pair;
  }));
}
function uniformDegree(degree) {
  return degree > 180 ? degree - 360 : degree;
}
function lineDegree(start, end) {
  return 180 * Math.atan2(start.y - end.y, start.x - end.x) / Math.PI + 90;
}
function nearestPoint(features, origin, bearing, distance2 = 200) {
  const count = 5621 / distance2;
  let curOrigin = origin;
  for (let i2 = 1; i2 <= count; i2++) {
    const dest = destination(curOrigin, distance2, bearing);
    if (!isPointWithinFeatures(features, dest)) return [dest.x, dest.y];
    curOrigin = [dest.x, dest.y];
  }
  return origin;
}
function isPointWithinFeatures(features, p2) {
  for (let i2 = 0; i2 < features.length; i2++) {
    if (isPointInPolygon(p2, features[i2])) return true;
  }
  return false;
}
function placeRectByOrient(rect, position, offset = 0) {
  const result2 = Object.assign({}, rect);
  return "top" === position ? (result2.x -= rect.width / 2, result2.y -= offset + rect.height / 2) : "bottom" === position ? (result2.x -= rect.width / 2, result2.y += offset - rect.height / 2) : "left" === position ? (result2.x -= offset + rect.width, result2.y -= rect.height / 2) : "right" === position && (result2.x += offset, result2.y -= rect.height / 2), result2;
}
function candidatesByOrient(positions, anchor, rect, offset = 0) {
  const candidates = [];
  return positions.forEach((p2) => {
    const { x: x3, y: y3 } = placeRectByOrient(Object.assign(Object.assign({}, anchor), {
      width: rect.width,
      height: rect.height
    }), p2, offset);
    candidates.push({
      x: x3,
      y: y3
    });
  }), candidates;
}

// node_modules/@visactor/vchart/esm/component/map-label/component.js
var MapLabelComponent = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.mapLabel, this.name = ComponentTypeEnum.mapLabel, this.specKey = "mapLabel", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.MarkPoint, this._activeDatum = [];
  }
  static getSpecInfo(chartSpec) {
    const labelSpec = chartSpec[this.specKey];
    return labelSpec && labelSpec.visible && !isValid_default(labelSpec.series) ? [{
      spec: labelSpec,
      specPath: [this.specKey],
      type: ComponentTypeEnum.mapLabel
    }] : null;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d;
    this.nameField = null !== (_a = this._spec.nameField) && void 0 !== _a ? _a : null === (_b = this._series) || void 0 === _b ? void 0 : _b.getDimensionField()[0], this.valueField = null !== (_c = this._spec.valueField) && void 0 !== _c ? _c : null === (_d = this._series) || void 0 === _d ? void 0 : _d.getMeasureField()[0];
  }
  created() {
    super.created(), false != !!this._spec.visible && (this.initRelatedInfo(), this.initData(), this.initEvent());
  }
  initRelatedInfo() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this._series = this._option.getSeriesInUserIdOrIndex([this._spec.seriesId])[0], "outer" === this._spec.position && (this._map = null === (_b = null === (_a = this._regions[0].getSeriesInType("map")[0]) || void 0 === _a ? void 0 : _a.getMapViewData()) || void 0 === _b ? void 0 : _b.latestData, this._longitudeField = null === (_e = null === (_d = (_c = this._regions[0]).getSpec) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.longitudeField, this._latitudeField = null === (_h = null === (_g = (_f = this._regions[0]).getSpec) || void 0 === _g ? void 0 : _g.call(_f)) || void 0 === _h ? void 0 : _h.latitudeField);
  }
  initData() {
    const series2 = this._series;
    if (!series2) return;
    const seriesData = series2.getViewData();
    if (seriesData) {
      const data = new DataView(this._option.dataSet, {
        name: `${this.name}_data`
      });
      data.parse([seriesData], {
        type: "dataview"
      }), data.transform({
        type: "copyDataView",
        level: TransformLevel.copyDataView
      }, false), this._data = new CompilableData(this._option, data), data.target.addListener("change", () => {
        "hover" !== this._spec.trigger && "click" !== this._spec.trigger && (this._activeDatum = this._data.getLatestData());
      });
    }
  }
  initEvent() {
    this.event.on("zoom", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e3) => (this.handleZoom(e3), true)), this.event.on("panmove", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e3) => (this.handlePan(e3), true));
    const trigger = this._spec.trigger;
    "none" !== trigger && ("hover" === trigger ? (this.event.on("hovered", {
      filter: (params2) => this._isRelativeSeries(params2.model)
    }, (params2) => {
      this._updateDatum(params2.value);
    }), this.event.on("unhovered", () => {
      this._updateDatum([]);
    })) : "click" === trigger && (this.event.on("selected", {
      filter: (params2) => this._isRelativeSeries(params2.model)
    }, (params2) => {
      this._updateDatum(params2.value);
    }), this.event.on("unselected", () => {
      this._updateDatum([]);
    })));
  }
  handlePan(e3) {
    const { delta } = e3;
    this._markerComponents.forEach((marker) => {
      marker.translate(delta[0], delta[1]);
    });
  }
  handleZoom(e3) {
    this._updateMarkerLayoutAttribute();
  }
  _updateDatum(datum) {
    this._activeDatum = datum, this._markerComponents.forEach((marker, index) => {
      var _a;
      const markerDatum = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData()[index];
      this._activeDatum.includes(markerDatum) ? marker.setAttribute("visible", true) : marker.setAttribute("visible", false);
    });
  }
  dataToPosition(datum) {
    return this._series.dataToPosition(datum);
  }
  updateLayoutAttribute() {
    var _a;
    const markData = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData();
    markData && 0 !== markData.length && (super.updateLayoutAttribute(), this._updateMarkerLayoutAttribute());
  }
  _updateMarkerLayoutAttribute() {
    var _a;
    const layoutPairInfo = [], markerMarks = [];
    this._markerComponents || (this._markerComponents = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData().map((data, index) => {
      var _a2;
      const cmp = new MarkPoint({
        position: void 0
      });
      return cmp && (cmp.name = `${this.name}_marker_${index}`, cmp.id = null !== (_a2 = this._spec.id) && void 0 !== _a2 ? _a2 : `${this.name}_marker_${this.id}`, cmp.setAttribute("zIndex", this.layoutZIndex)), cmp;
    }));
    this._markerComponents.forEach((marker, index) => {
      marker.removeAllChild();
      const { pairInfo, contentMarks } = this._evaluateMarker(this._data.getLatestData()[index], index);
      pairInfo && layoutPairInfo.push(pairInfo), contentMarks && markerMarks.push(contentMarks);
    });
    const positionedRects = this._layoutLabels(layoutPairInfo);
    this._layoutMarkers(positionedRects, markerMarks), this._renderMarkers();
  }
  _evaluateMarker(data, index) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let contentItemCount = 0, paddingWidth = 0, paddingHeight = 0, contentWidth = 0, contentHeight = 0;
    const position = this._spec.position || "top", offset = this._spec.offset, padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0;
    paddingWidth += ((null == padding ? void 0 : padding.left) || 0) + ((null == padding ? void 0 : padding.right) || 0), paddingHeight += ((null == padding ? void 0 : padding.top) || 0) + ((null == padding ? void 0 : padding.bottom) || 0);
    const contentMarks = {}, positionAttr = this.dataToPosition(data), container2 = createGroup({});
    if (container2.name = `${this.name}_marker_itemContainer_${index}`, contentMarks.container = container2, null === (_b = this._spec.background) || void 0 === _b ? void 0 : _b.visible) {
      const labelBackground = createRect(transformToGraphic(Object.assign({}, this._spec.background.style)));
      labelBackground.setAttributes(positionAttr), contentMarks.labelBackground = labelBackground, container2.appendChild(labelBackground);
    }
    if (null === (_c = this._spec.icon) || void 0 === _c ? void 0 : _c.visible) {
      const icon = createSymbol(transformToGraphic(Object.assign({}, this._spec.icon.style)));
      icon.setAttributes(positionAttr), icon.setAttribute("symbolType", null === (_d = this._spec.icon.style) || void 0 === _d ? void 0 : _d.shape);
      const iconBound = icon.AABBBounds, iconHeight = null !== (_e = (null == iconBound ? void 0 : iconBound.y2) - (null == iconBound ? void 0 : iconBound.y1)) && void 0 !== _e ? _e : 0, iconWidth = null !== (_f = (null == iconBound ? void 0 : iconBound.x2) - (null == iconBound ? void 0 : iconBound.x1)) && void 0 !== _f ? _f : 0;
      contentMarks.icon = icon, container2.appendChild(icon), contentHeight = iconHeight, contentWidth += iconWidth, contentItemCount++;
    }
    if (null === (_g = this._spec.nameLabel) || void 0 === _g ? void 0 : _g.visible) {
      const nameLabel = createText(transformToGraphic(Object.assign({}, this._spec.nameLabel.style)));
      nameLabel.setAttributes(positionAttr), nameLabel.setAttribute("text", data[this.nameField]);
      const nameLabelBound = nameLabel.AABBBounds, nameLabelHeight = null !== (_h = (null == nameLabelBound ? void 0 : nameLabelBound.y2) - (null == nameLabelBound ? void 0 : nameLabelBound.y1)) && void 0 !== _h ? _h : 0, nameLabelWidth = null !== (_j = (null == nameLabelBound ? void 0 : nameLabelBound.x2) - (null == nameLabelBound ? void 0 : nameLabelBound.x1)) && void 0 !== _j ? _j : 0;
      contentMarks.nameLabel = nameLabel, container2.appendChild(nameLabel), contentHeight = Math.max(contentHeight, nameLabelHeight), contentWidth += nameLabelWidth, contentItemCount++;
    }
    if ((null === (_k = this._spec.valueLabel) || void 0 === _k ? void 0 : _k.visible) && isValid_default(data[this.valueField])) {
      const valueLabel = createText(transformToGraphic(Object.assign({}, this._spec.valueLabel.style)));
      valueLabel.setAttributes(positionAttr), valueLabel.setAttribute("text", data[this.valueField]);
      const valueLabelBound = valueLabel.AABBBounds, valueLabelHeight = null !== (_l = (null == valueLabelBound ? void 0 : valueLabelBound.y2) - (null == valueLabelBound ? void 0 : valueLabelBound.y1)) && void 0 !== _l ? _l : 0, valueLabelWidth = null !== (_m = (null == valueLabelBound ? void 0 : valueLabelBound.x2) - (null == valueLabelBound ? void 0 : valueLabelBound.x1)) && void 0 !== _m ? _m : 0;
      contentMarks.valueLabel = valueLabel, container2.appendChild(valueLabel), contentHeight = Math.max(contentHeight, valueLabelHeight), contentWidth += valueLabelWidth, contentItemCount++;
    }
    const firstValidMark = Object.values(contentMarks).find((m5) => !!m5 && "group" !== m5.type), anchor = {
      x: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("x"),
      y: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("y")
    }, itemRect = {
      x: anchor.x,
      y: anchor.y,
      width: 0,
      height: 0
    };
    itemRect.width = paddingWidth + contentWidth + (contentItemCount - 1) * space, itemRect.height = paddingHeight + contentHeight;
    const pairInfo = {
      rect: itemRect,
      point: anchor,
      index
    };
    if ("outer" !== position) {
      const anchors = ["top", "right", "left", "bottom"].filter((a4) => a4 !== position);
      pairInfo.rect = placeRectByOrient(itemRect, position, offset), pairInfo.anchors = anchors, pairInfo.offset = offset;
    } else pairInfo.pointCoord = {
      x: +(null == data ? void 0 : data[this._longitudeField]),
      y: +(null == data ? void 0 : data[this._latitudeField])
    };
    return {
      pairInfo,
      contentMarks
    };
  }
  _layoutMarkers(positionedRects, contentMarks) {
    var _a, _b, _c;
    for (let i2 = 0; i2 < contentMarks.length; i2++) {
      if (!positionedRects[i2] || !contentMarks[i2]) return;
      const { icon, nameLabel, valueLabel, labelBackground, container: container2 } = contentMarks[i2], itemRect = positionedRects[i2], padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0, curY = itemRect.height / 2;
      let curX = (null == padding ? void 0 : padding.left) || 0;
      [icon, nameLabel, valueLabel].forEach((item, index) => {
        var _a2, _b2;
        if (item) {
          const bounds = item.AABBBounds;
          let offset = 0;
          "symbol" === item.type && (offset += (null !== (_a2 = bounds.x2 - bounds.x1) && void 0 !== _a2 ? _a2 : 0) / 2), item.setAttributes({
            x: curX + offset,
            y: curY
          }), curX += null !== (_b2 = bounds.x2 - bounds.x1) && void 0 !== _b2 ? _b2 : 0, 2 !== index && (curX += space);
        }
      }), null == labelBackground || labelBackground.setAttributes({
        x: 0,
        y: 0,
        width: itemRect.width,
        height: itemRect.height
      }), null == container2 || container2.setAttributes({
        dx: -itemRect.width / 2,
        dy: -itemRect.height / 2
      });
      const datum = this._data.getLatestData()[i2], anchor = this.dataToPosition(datum), regionPos = this.getRegions()[0].getLayoutStartPoint(), showLeader = !(!(null === (_b = this._spec.leader) || void 0 === _b ? void 0 : _b.visible) || !(icon || nameLabel || valueLabel));
      this._markerComponents[i2].setAttributes({
        x: regionPos.x,
        y: regionPos.y,
        position: anchor,
        visible: this._activeDatum.includes(datum),
        itemContent: {
          refX: 0,
          type: "custom",
          renderCustomCallback: () => container2,
          autoRotate: false,
          offsetX: itemRect.x + itemRect.width / 2 - anchor.x,
          offsetY: itemRect.y + itemRect.height / 2 - anchor.y
        },
        itemLine: {
          visible: showLeader,
          type: "type-po",
          lineStyle: transformToGraphic(Object.assign({}, null === (_c = this._spec.leader) || void 0 === _c ? void 0 : _c.style)),
          startSymbol: {
            visible: false
          }
        }
      });
    }
  }
  _renderMarkers() {
    if (this._markerComponents && this._markerComponents.length) for (let i2 = 0; i2 < this._markerComponents.length; i2++) this.getContainer().add(this._markerComponents[i2]);
  }
  _layoutLabels(rects) {
    return "outer" === this._spec.position && this._map ? layoutOuter(rects, this._map, (coord) => this._series.dataToPosition({
      [this._longitudeField]: coord[0],
      [this._latitudeField]: coord[1]
    })) : layoutByPosition(rects);
  }
  _isRelativeModel(model) {
    var _a, _b, _c;
    const id2 = null !== (_b = null === (_a = this._series.getXAxisHelper()) || void 0 === _a ? void 0 : _a.getAxisId()) && void 0 !== _b ? _b : null === (_c = this._series.getCoordinateHelper()) || void 0 === _c ? void 0 : _c.getCoordinateId();
    return (null == model ? void 0 : model.id) === id2;
  }
  _isRelativeSeries(model) {
    return (null == model ? void 0 : model.id) === this._series.id;
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _getNeedClearVRenderComponents() {
    return this._markerComponents;
  }
};
MapLabelComponent.type = ComponentTypeEnum.mapLabel, MapLabelComponent.specKey = "mapLabel";
var registerMapLabel = () => {
  Factory2.registerComponent(MapLabelComponent.type, MapLabelComponent);
};

// node_modules/@visactor/vchart/esm/layout/grid-layout/grid-layout.js
var GridLayout2 = class {
  constructor(gridInfo, ctx) {
    this._chartLayoutRect = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    }, this._col = 1, this._row = 1, this._elementMap = /* @__PURE__ */ new Map(), this.standardizationSpec(gridInfo), this._gridInfo = gridInfo, this._col = gridInfo.col, this._row = gridInfo.row, this._colSize = new Array(this._col).fill(null), this._rowSize = new Array(this._row).fill(null), this._colElements = new Array(this._col).fill([]), this._rowElements = new Array(this._row).fill([]), this._onError = null == ctx ? void 0 : ctx.onError, this.initUserSetting();
  }
  standardizationSpec(gridInfo) {
    var _a, _b, _c;
    gridInfo.col = null !== (_a = gridInfo.col) && void 0 !== _a ? _a : 1, gridInfo.row = null !== (_b = gridInfo.row) && void 0 !== _b ? _b : 1, gridInfo.elements = null !== (_c = gridInfo.elements) && void 0 !== _c ? _c : [];
  }
  initUserSetting() {
    this._gridInfo.colWidth && this.setSizeFromUserSetting(this._gridInfo.colWidth, this._colSize, this._col, this._chartLayoutRect.width), this._gridInfo.rowHeight && this.setSizeFromUserSetting(this._gridInfo.rowHeight, this._rowSize, this._row, this._chartLayoutRect.height), this._colSize.forEach((c4, i2) => {
      c4 || (this._colSize[i2] = {
        value: 0,
        isUserSetting: false,
        isLayoutSetting: false
      });
    }), this._rowSize.forEach((r2, i2) => {
      r2 || (this._rowSize[i2] = {
        value: 0,
        isUserSetting: false,
        isLayoutSetting: false
      });
    });
  }
  setSizeFromUserSetting(userSetting, gridSize, gridMax, maxSize) {
    userSetting.forEach((userSet) => {
      userSet.index < 0 && userSet.index >= gridMax || (isValidNumber_default(userSet.size) ? gridSize[userSet.index] = {
        value: +userSet.size,
        isUserSetting: true,
        isLayoutSetting: false
      } : isFunction_default(userSet.size) && (gridSize[userSet.index] = {
        value: userSet.size(maxSize),
        isUserSetting: true,
        isLayoutSetting: false
      }));
    });
  }
  clearLayoutSize() {
    this._colSize.forEach((c4) => {
      c4.isLayoutSetting = false, c4.isUserSetting || (c4.value = 0);
    }), this._rowSize.forEach((r2) => {
      r2.isLayoutSetting = false, r2.isUserSetting || (r2.value = 0);
    });
  }
  getItemGridInfo(item) {
    var _a;
    const mapResult = this._elementMap.get(item);
    if (mapResult) return mapResult;
    let result2;
    return result2 = null === (_a = this._gridInfo.elements) || void 0 === _a ? void 0 : _a.find((e3) => {
      var _a2;
      if ("modelId" in e3 && isValid_default(e3.modelId)) {
        if (isValid_default(item.model.userId) && item.model.userId === e3.modelId) return true;
      } else if ("modelKey" in e3 && isValid_default(e3.modelKey) && "modelIndex" in e3 && isValid_default(e3.modelIndex)) {
        if ((null !== (_a2 = item.model.specKey) && void 0 !== _a2 ? _a2 : item.model.type) === e3.modelKey && item.model.getSpecIndex() === e3.modelIndex) return true;
      }
      return false;
    }), result2 || (result2 = {
      col: 0,
      colSpan: 1,
      row: 0,
      rowSpan: 1
    }), this._elementMap.set(item, result2), result2;
  }
  getSizeFromGird(spec, type) {
    var _a;
    const sizeList = "col" === type ? this._colSize : this._rowSize;
    let result2 = 0;
    for (let index = spec[type]; index < spec[type] + (null !== (_a = spec[`${type}Span`]) && void 0 !== _a ? _a : 1); index++) result2 += sizeList[index].value;
    return result2;
  }
  getSizeFromUser(spec, type) {
    var _a, _b;
    const sizeList = "col" === type ? this._colSize : this._rowSize;
    if (!(null === (_a = sizeList[spec[type]]) || void 0 === _a ? void 0 : _a.isUserSetting)) return;
    let result2 = 0;
    for (let index = spec[type]; index < spec[type] + (null !== (_b = spec[`${type}Span`]) && void 0 !== _b ? _b : 1); index++) {
      if (!sizeList[index].isUserSetting) return;
      result2 += sizeList[index].value;
    }
    return result2;
  }
  setItemLayoutSizeToGrid(item, gridSpec) {
    if (isColItem(item)) {
      if (gridSpec.colSpan && gridSpec.colSpan > 1) return;
      if (this._colSize[gridSpec.col].isUserSetting) return;
      this._colSize[gridSpec.col].value = Math.max(this._colSize[gridSpec.col].value, item.getLayoutRect().width + item.layoutPaddingLeft + item.layoutPaddingRight), this._colSize[gridSpec.col].isLayoutSetting = true;
    } else {
      if (gridSpec.rowSpan && gridSpec.rowSpan > 1) return;
      if (this._rowSize[gridSpec.row].isUserSetting) return;
      this._rowSize[gridSpec.row].value = Math.max(this._rowSize[gridSpec.row].value, item.getLayoutRect().height + item.layoutPaddingTop + item.layoutPaddingBottom), this._rowSize[gridSpec.row].isLayoutSetting = true;
    }
  }
  layoutGrid(type) {
    const gridSize = "col" === type ? this._colSize : this._rowSize;
    let unSetSize = "col" === type ? this._chartLayoutRect.width : this._chartLayoutRect.height;
    const willSize = [];
    gridSize.forEach((s3) => {
      s3.isUserSetting || s3.isLayoutSetting ? unSetSize -= s3.value : willSize.push(s3);
    }), unSetSize < 0 && console.warn(`layout content ${type} size bigger than chart`), willSize.forEach((s3) => s3.value = unSetSize / willSize.length);
  }
  getItemPosition(item) {
    const gridSpec = this.getItemGridInfo(item), point6 = {
      x: this._chartLayoutRect.x,
      y: this._chartLayoutRect.y
    };
    for (let col = 0; col < gridSpec.col; col++) point6.x += this._colSize[col].value;
    for (let row = 0; row < gridSpec.row; row++) point6.y += this._rowSize[row].value;
    return point6.x += item.layoutPaddingLeft + item.layoutOffsetX, point6.y += item.layoutPaddingTop + item.layoutOffsetY, point6;
  }
  getItemLayoutRect(item) {
    var _a, _b;
    const gridSpec = this.getItemGridInfo(item);
    return {
      width: (null !== (_a = this.getSizeFromGird(gridSpec, "col")) && void 0 !== _a ? _a : this._chartLayoutRect.width) - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: (null !== (_b = this.getSizeFromGird(gridSpec, "row")) && void 0 !== _b ? _b : this._chartLayoutRect.height) - item.layoutPaddingTop - item.layoutPaddingBottom
    };
  }
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._chartLayoutRect = chartLayoutRect, this._chartViewBox = chartViewBox, this.clearLayoutSize(), items.sort((a4, b2) => b2.layoutLevel - a4.layoutLevel);
    const normalItems = items.filter((item) => "normal" === item.layoutType && false !== item.getModelVisible()), normalItemsCol = normalItems.filter((item) => isColItem(item)), normalItemsRow = normalItems.filter((item) => !isColItem(item));
    normalItems.forEach((item) => {
      this.layoutOneItem(item, "user", false);
    });
    const regionsRelative = items.filter((x3) => "region-relative" === x3.layoutType), regionsRelativeCol = regionsRelative.filter((item) => isColItem(item)), regionsRelativeRow = regionsRelative.filter((item) => !isColItem(item));
    regionsRelativeCol.forEach((item) => this.layoutOneItem(item, "user", false)), this.layoutGrid("col"), normalItemsRow.forEach((item) => this.layoutOneItem(item, "colGrid", false)), regionsRelativeRow.forEach((item) => {
      this.layoutOneItem(item, "colGrid", false);
    }), this.layoutGrid("row"), regionsRelativeRow.forEach((item) => {
      this.layoutOneItem(item, "grid", false);
    }), normalItemsCol.forEach((item) => this.layoutOneItem(item, "grid", false)), regionsRelativeCol.forEach((item) => {
      this.layoutOneItem(item, "grid", true);
    }), this.layoutGrid("col"), items.filter((x3) => "region" === x3.layoutType).forEach((item) => this.layoutOneItem(item, "grid", false)), this.layoutAbsoluteItems(items.filter((x3) => "absolute" === x3.layoutType)), items.filter((x3) => "absolute" !== x3.layoutType).forEach((item) => {
      item.setLayoutStartPosition(this.getItemPosition(item));
    });
  }
  layoutAbsoluteItems(absoluteItems) {
    absoluteItems.forEach((item) => {
      item.absoluteLayoutInRect(this._chartLayoutRect);
    });
  }
  layoutOneItem(item, sizeType, ignoreTag) {
    var _a, _b;
    const sizeCallRow = "rowGrid" === sizeType || "grid" === sizeType ? this.getSizeFromGird.bind(this) : this.getSizeFromUser.bind(this), sizeCallCol = "colGrid" === sizeType || "grid" === sizeType ? this.getSizeFromGird.bind(this) : this.getSizeFromUser.bind(this), gridSpec = this.getItemGridInfo(item), computeRect = {
      width: (null !== (_a = sizeCallCol(gridSpec, "col")) && void 0 !== _a ? _a : this._chartLayoutRect.width) - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: (null !== (_b = sizeCallRow(gridSpec, "row")) && void 0 !== _b ? _b : this._chartLayoutRect.height) - item.layoutPaddingTop - item.layoutPaddingBottom
    }, rect = item.computeBoundsInRect(computeRect);
    isValidNumber_default(rect.width) || (rect.width = computeRect.width), isValidNumber_default(rect.height) || (rect.height = computeRect.height), item.setLayoutRect("grid" !== sizeType ? rect : computeRect), this.setItemLayoutSizeToGrid(item, gridSpec);
  }
};
function isColItem(item) {
  return "left" === item.layoutOrient || "right" === item.layoutOrient;
}
GridLayout2.type = "grid";
var registerGridLayout = () => {
  Factory2.registerLayout(GridLayout2.type, GridLayout2);
};

// node_modules/@visactor/vchart/esm/layout/layout3d/index.js
var Layout3d = class extends Layout {
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._layoutInit(_chart, items, chartLayoutRect, chartViewBox), this._layoutNormalItems(items);
    const layoutTemp = {
      left: this.leftCurrent,
      top: this.topCurrent,
      right: this.rightCurrent,
      bottom: this.bottomCurrent
    }, absoluteItem = items.filter((x3) => "absolute" === x3.layoutType), zItems = absoluteItem.filter((i2) => "z" === i2.layoutOrient);
    let extraWH = {
      width: 0,
      height: 0
    };
    if (zItems.length) {
      extraWH = zItems[0].getLayoutRect();
    }
    this.leftCurrent += extraWH.width / 8, this.rightCurrent -= extraWH.width / 8, this.topCurrent += extraWH.height / 8, this.bottomCurrent -= extraWH.height / 8;
    const { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
    this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems), this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp);
    const absoluteItemExceptZAxis = absoluteItem.filter((i2) => "z" !== i2.layoutOrient);
    this.layoutAbsoluteItems(absoluteItemExceptZAxis);
    const xAxis = relativeItems.filter((item) => "axes" === item.model.specKey && isXAxis(item.layoutOrient))[0], yAxis = relativeItems.filter((item) => "axes" === item.model.specKey && isYAxis(item.layoutOrient))[0];
    if (xAxis && zItems.length) {
      const sp = xAxis.getLayoutStartPoint(), lr = xAxis.getLayoutRect(), zRect = {
        x: "left" === yAxis.layoutOrient ? sp.x + lr.width : sp.x,
        y: sp.y,
        width: this._chartLayoutRect.width,
        height: this._chartLayoutRect.height
      };
      zItems[0].model.directionStr = "left" === yAxis.layoutOrient ? "r2l" : "l2r";
      const xRect = xAxis.getLayoutRect(), yRect = yAxis.getLayoutRect(), box3d = {
        length: zItems[0].getLayoutRect().width,
        width: xRect.width,
        height: yRect.height
      };
      xAxis.model.setLayout3dBox && xAxis.model.setLayout3dBox(box3d), yAxis.model.setLayout3dBox && yAxis.model.setLayout3dBox(box3d), zItems[0].model.setLayout3dBox && zItems[0].model.setLayout3dBox(box3d), this.layoutZAxisItems(zItems, zRect);
    }
  }
  layoutZAxisItems(zItems, zRect) {
    zItems.forEach((item) => {
      item.absoluteLayoutInRect(zRect);
    });
  }
  getItemComputeLayoutRect(item, extraOffset) {
    extraOffset || (extraOffset = {
      offsetLeft: 0,
      offsetRight: 0,
      offsetTop: 0,
      offsetBottom: 0
    });
    return {
      width: this.rightCurrent - this.leftCurrent - item.layoutPaddingLeft - item.layoutPaddingRight - (extraOffset.offsetLeft + extraOffset.offsetRight),
      height: this.bottomCurrent - this.topCurrent - item.layoutPaddingTop - item.layoutPaddingBottom - (extraOffset.offsetTop + extraOffset.offsetBottom)
    };
  }
  _checkAutoIndent(items) {
    const result2 = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    }, rightCurrent = this._chartViewBox.x2 - this._chartViewBox.x1 - this.rightCurrent, bottomCurrent = this._chartViewBox.y2 - this._chartViewBox.y1 - this.bottomCurrent;
    return items.forEach((i2) => {
      if (!i2.getModelVisible() || !i2.autoIndent) return;
      const vOrH = "left" === i2.layoutOrient || "right" === i2.layoutOrient, outer = i2.getLastComputeOutBounds();
      vOrH ? (result2.top = Math.max(result2.top, outer.y1 - this.topCurrent), result2.bottom = Math.max(result2.bottom, outer.y2 - bottomCurrent)) : (result2.left = Math.max(result2.left, outer.x1 - this.leftCurrent), result2.right = Math.max(result2.right, outer.x2 - rightCurrent));
    }), result2;
  }
};
Layout3d.type = "layout3d";
var registerLayout3d = () => {
  Factory2.registerLayout(Layout3d.type, Layout3d);
};

// node_modules/@visactor/vchart/esm/component/poptip/index.js
var registerPoptip = () => {
  loadPoptip();
};

// node_modules/@visactor/vchart/esm/vchart-all.js
VChart.useRegisters([registerLineChart, registerAreaChart, registerBarChart, registerScatterChart, registerPieChart, registerRoseChart, registerRadarChart, registerHistogramChart, registerMapChart, registerGaugeChart, registerWordCloudChart, registerWordCloudShapeChart, registerFunnelChart, registerWaterfallChart, registerBoxplotChart, registerCircularProgressChart, registerLinearProgressChart, registerRangeColumnChart, registerRangeAreaChart, registerSunburstChart, registerCirclePackingChart, registerTreemapChart, registerSankeyChart, registerHeatmapChart, registerSequenceChart, registerCorrelationChart, registerCommonChart, registerBar3dChart, registerPie3dChart, registerHistogram3dChart, registerFunnel3dChart, registerRangeColumn3dChart, registerWordCloud3dChart, registerWordCloudShape3dChart, registerCartesianLinearAxis, registerCartesianBandAxis, registerCartesianTimeAxis, registerCartesianLogAxis, registerCartesianSymlogAxis, registerPolarBandAxis, registerPolarLinearAxis, registerDiscreteLegend, registerContinuousLegend, registerTooltip, registerCartesianCrossHair, registerPolarCrossHair, registerDataZoom2, registerScrollBar, registerIndicator, registerGeoCoordinate, registerMarkPoint, registerMarkLine, registerMarkArea, registerTitle2, registerPlayer2, registerLabel2, registerTotalLabel, registerBrush, registerCustomMark, registerMapLabel, registerPoptip, registerGridLayout, registerLayout3d]);

// node_modules/@visactor/vchart/esm/index.js
var esm_default = VChart;

export {
  isNil_default,
  pickWithout,
  isEqual,
  lightTheme,
  esm_default
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-2QAZGZQ3.js.map
