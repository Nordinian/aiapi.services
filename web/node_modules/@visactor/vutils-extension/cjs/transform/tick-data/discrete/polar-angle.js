"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.polarAngleAxisDiscreteTicks = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../util"), polarAngleAxisDiscreteTicks = (scale, op) => {
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, getRadius: getRadius, labelOffset: labelOffset, labelGap: labelGap = 0, labelStyle: labelStyle} = op, radius = null == getRadius ? void 0 : getRadius();
    if (!radius) return (0, util_1.convertDomainToTickData)(scale.domain());
    let scaleTicks;
    if ((0, vutils_1.isValid)(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if ((0, 
    vutils_1.isValid)(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if ((0, 
    vutils_1.isValid)(tickCount)) {
        const range = scale.range(), rangeSize = Math.abs(range[range.length - 1] - range[0]), count = (0, 
        vutils_1.isFunction)(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(count);
    } else if (op.sampling) {
        const domain = scale.domain(), range = scale.range(), labelBoundsList = (0, util_1.getPolarAngleLabelBounds)(scale, domain, op), rangeStart = (0, 
        vutils_1.minInArray)(range), rangeEnd = (0, vutils_1.maxInArray)(range), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, {step: step, delCount: delCount} = getStep(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce(((min, curBounds) => Math.min(min, curBounds.width(), curBounds.height())), Number.MAX_VALUE) / incrementUnit));
        scaleTicks = scale.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
    } else scaleTicks = scale.domain();
    return (0, util_1.convertDomainToTickData)(scaleTicks);
};

exports.polarAngleAxisDiscreteTicks = polarAngleAxisDiscreteTicks;

const getStep = (domain, labelBoundsList, labelGap, defaultStep) => {
    let step = defaultStep;
    do {
        let success = !0;
        step++;
        let ptr = 0;
        do {
            ptr + step < domain.length && (0, util_1.labelOverlap)(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), 
            ptr += step;
        } while (success && ptr < domain.length);
        if (success) break;
    } while (step <= domain.length);
    let delCount = 0;
    if (domain.length > 2) {
        let ptr = domain.length - domain.length % step;
        for (ptr >= domain.length && (ptr -= step); ptr > 0 && (0, util_1.labelOverlap)(labelBoundsList[0], labelBoundsList[ptr]); ) delCount++, 
        ptr -= step;
    }
    return {
        step: step,
        delCount: delCount
    };
};
//# sourceMappingURL=polar-angle.js.map