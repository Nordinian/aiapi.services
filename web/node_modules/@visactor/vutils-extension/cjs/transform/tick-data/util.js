"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isAxisHorizontal = exports.getPolarAngleLabelBounds = exports.getCartesianLabelBounds = exports.MIN_TICK_GAP = exports.hasOverlap = exports.intersect = exports.labelDistance = exports.labelOverlap = exports.convertDomainToTickData = void 0;

const vutils_1 = require("@visactor/vutils"), text_1 = require("../../utils/text"), polar_1 = require("../../utils/polar"), convertDomainToTickData = domain => domain.map(((t, index) => ({
    index: index,
    value: t
})));

exports.convertDomainToTickData = convertDomainToTickData;

const labelOverlap = (prevLabel, nextLabel, gap = 0) => {
    const prevBounds = new vutils_1.AABBBounds(prevLabel).expand(gap / 2), nextBounds = new vutils_1.AABBBounds(nextLabel).expand(gap / 2);
    return prevBounds.intersects(nextBounds);
};

exports.labelOverlap = labelOverlap;

const labelDistance = (prevLabel, nextLabel) => {
    let horizontal = 0;
    prevLabel.x2 < nextLabel.x1 ? horizontal = nextLabel.x1 - prevLabel.x2 : nextLabel.x2 < prevLabel.x1 && (horizontal = prevLabel.x1 - nextLabel.x2);
    let vertical = 0;
    return prevLabel.y2 < nextLabel.y1 ? vertical = nextLabel.y1 - prevLabel.y2 : nextLabel.y2 < prevLabel.y1 && (vertical = prevLabel.y1 - nextLabel.y2), 
    [ horizontal, vertical ];
};

function intersect(a, b, sep) {
    return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);
}

function hasOverlap(items, pad) {
    for (let b, i = 1, n = items.length, a = items[0]; i < n; a = b, ++i) if (b = items[i], 
    intersect(a.AABBBounds, b.AABBBounds, pad)) return !0;
    return !1;
}

exports.labelDistance = labelDistance, exports.intersect = intersect, exports.hasOverlap = hasOverlap, 
exports.MIN_TICK_GAP = 12;

const getCartesianLabelBounds = (scale, domain, op) => {
    var _a;
    const {labelStyle: labelStyle, axisOrientType: axisOrientType, labelFlush: labelFlush, labelFormatter: labelFormatter, startAngle: startAngle = 0} = op;
    let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
    "vertical" === labelStyle.direction && (labelAngle += (0, vutils_1.degreeToRadian)(90));
    const isHorizontal = [ "bottom", "top" ].includes(axisOrientType), isVertical = [ "left", "right" ].includes(axisOrientType);
    let scaleX = 1, scaleY = 0;
    isHorizontal || (isVertical ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), 
    scaleY = -Math.sin(startAngle)));
    const textMeasure = (0, text_1.initTextMeasure)(labelStyle), labelBoundsList = domain.map(((v, i) => {
        var _a, _b;
        const str = labelFormatter ? labelFormatter(v) : `${v}`, {width: width, height: height} = textMeasure.quickMeasure(str), textWidth = Math.max(width, exports.MIN_TICK_GAP), textHeight = Math.max(height, exports.MIN_TICK_GAP), pos = scale.scale(v), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
        let align, baseline, textX = baseTextX, textY = baseTextY;
        align = labelFlush && isHorizontal && 0 === i ? "left" : labelFlush && isHorizontal && i === domain.length - 1 ? "right" : null !== (_a = labelStyle.textAlign) && void 0 !== _a ? _a : "center", 
        "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), 
        baseline = labelFlush && isVertical && 0 === i ? "top" : labelFlush && isVertical && i === domain.length - 1 ? "bottom" : null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", 
        "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
        const bounds = (new vutils_1.AABBBounds).set(textX, textY, textX + textWidth, textY + textHeight);
        return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
    }));
    return labelBoundsList;
};

exports.getCartesianLabelBounds = getCartesianLabelBounds;

const getPolarAngleLabelBounds = (scale, domain, op) => {
    var _a;
    const {labelStyle: labelStyle, getRadius: getRadius, labelOffset: labelOffset, labelFormatter: labelFormatter} = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure = (0, 
    text_1.initTextMeasure)(labelStyle);
    return domain.map((v => {
        const str = labelFormatter ? labelFormatter(v) : `${v}`, {width: width, height: height} = textMeasure.quickMeasure(str), textWidth = Math.max(width, exports.MIN_TICK_GAP), textHeight = Math.max(height, exports.MIN_TICK_GAP), angle = scale.scale(v);
        let textX = 0, textY = 0;
        const orient = (0, polar_1.angleLabelOrientAttribute)(angle), {x: x, y: y} = (0, 
        vutils_1.polarToCartesian)({
            x: 0,
            y: 0
        }, radius + labelOffset, angle);
        textX = x + ("right" === orient.align ? -textWidth : "center" === orient.align ? -textWidth / 2 : 0), 
        textY = y + ("bottom" === orient.baseline ? -textHeight : "middle" === orient.baseline ? -textHeight / 2 : 0);
        return (new vutils_1.AABBBounds).set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
    }));
};

exports.getPolarAngleLabelBounds = getPolarAngleLabelBounds;

const isAxisHorizontal = axisOrientType => [ "bottom", "top", "z" ].includes(axisOrientType);

exports.isAxisHorizontal = isAxisHorizontal;
//# sourceMappingURL=util.js.map