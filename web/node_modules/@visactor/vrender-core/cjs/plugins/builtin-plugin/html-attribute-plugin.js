"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.HtmlAttributePlugin = void 0;

const generator_1 = require("../../common/generator"), application_1 = require("../../application"), graphic_1 = require("../../graphic");

class HtmlAttributePlugin {
    constructor() {
        this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage => {
            stage && stage === this.pluginService.stage && this.drawHTML(context.stage.renderService);
        })), application_1.application.graphicService.hooks.onRelease.tap(this.key, (graphic => {
            this.removeDom(graphic);
        }));
    }
    deactivate(context) {
        context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item => item.name !== this.key));
    }
    drawHTML(renderService) {
        "browser" === application_1.application.global.env && renderService.renderTreeRoots.sort(((a, b) => {
            var _a, _b;
            return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);
        })).forEach((group => {
            this.renderGroupHTML(group);
        }));
    }
    renderGroupHTML(group) {
        this.renderGraphicHTML(group), group.forEachChildren((g => {
            g.isContainer ? this.renderGroupHTML(g) : this.renderGraphicHTML(g);
        }));
    }
    removeDom(graphic) {
        graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach((item => {
            item.dom && item.dom.parentElement.removeChild(item.dom);
        })), graphic.bindDom.clear());
    }
    renderGraphicHTML(graphic) {
        const {html: html} = graphic.attribute;
        if (!html) return void (graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach((item => {
            item.dom && item.dom.parentElement.removeChild(item.dom);
        })), graphic.bindDom.clear()));
        const stage = graphic.stage;
        if (!stage) return;
        const {dom: dom, container: container, width: width, height: height, style: style, anchorType: anchorType = "boundsLeftTop"} = html;
        graphic.bindDom || (graphic.bindDom = new Map);
        const lastDom = graphic.bindDom.get(dom);
        if (lastDom && (!container || container === lastDom.container)) return;
        let nativeDom, nativeContainer;
        graphic.bindDom.forEach((({wrapGroup: wrapGroup}) => {
            application_1.application.global.removeDom(wrapGroup);
        })), "string" == typeof dom ? (nativeDom = (new DOMParser).parseFromString(dom, "text/html").firstChild, 
        nativeDom.lastChild && (nativeDom = nativeDom.lastChild.firstChild)) : nativeDom = dom;
        const _container = container || (!0 === stage.params.enableHtmlAttribute ? null : stage.params.enableHtmlAttribute);
        nativeContainer = _container ? "string" == typeof _container ? application_1.application.global.getElementById(_container) : _container : graphic.stage.window.getContainer();
        const wrapGroup = application_1.application.global.createDom({
            tagName: "div",
            width: width,
            height: height,
            style: style,
            parent: nativeContainer
        });
        wrapGroup && (wrapGroup.appendChild(nativeDom), graphic.bindDom.set(dom, {
            dom: nativeDom,
            container: container,
            wrapGroup: wrapGroup
        })), wrapGroup.style.pointerEvents = "none", wrapGroup.style.position || (wrapGroup.style.position = "absolute", 
        nativeContainer.style.position = "relative");
        let left = 0, top = 0;
        const b = graphic.globalAABBBounds;
        if ("position" === anchorType || b.empty()) {
            const matrix = graphic.globalTransMatrix;
            left = matrix.e, top = matrix.f;
        } else left = b.x1, top = b.y1;
        const containerTL = application_1.application.global.getElementTopLeft(nativeContainer, !1), windowTL = stage.window.getTopLeft(!1), offsetX = left + windowTL.left - containerTL.left, offsetTop = top + windowTL.top - containerTL.top;
        wrapGroup.style.left = `${offsetX}px`, wrapGroup.style.top = `${offsetTop}px`;
    }
}

exports.HtmlAttributePlugin = HtmlAttributePlugin;
//# sourceMappingURL=html-attribute-plugin.js.map
