"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.defaultImageBackgroundRenderContribution = exports.DefaultImageBackgroundRenderContribution = void 0;

const graphic_1 = require("../../../../graphic"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums"), vutils_1 = require("@visactor/vutils"), utils_1 = require("../../../../common/utils"), rect_1 = require("../../../../common/shape/rect");

class DefaultImageBackgroundRenderContribution extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        const {background: background, backgroundMode: backgroundMode = graphicAttribute.backgroundMode, backgroundFit: backgroundFit = graphicAttribute.backgroundFit} = graphic.attribute;
        if (background) if (graphic.backgroundImg) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = (0, graphic_1.getTheme)(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
            }
            const b = graphic.AABBBounds;
            this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), 
            graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else if ((0, vutils_1.isObject)(background)) {
            const {stroke: stroke, fill: fill, lineWidth: lineWidth = 1, cornerRadius: cornerRadius = 0, expandX: expandX = 0, expandY: expandY = 0} = background;
            if (!stroke && !fill) return;
            context.beginPath();
            const {x: x, y: y, width: width, height: height} = getActualPosition(graphic);
            cornerRadius ? (0, rect_1.createRectPath)(context, x - expandX, y - expandY, width + 2 * expandX, height + 2 * expandY, cornerRadius) : context.rect(x - expandX, y - expandY, width + 2 * expandX, height + 2 * expandY), 
            context.globalAlpha = 1, fill && (context.fillStyle = fill, context.fill()), stroke && lineWidth > 0 && (context.lineWidth = lineWidth, 
            context.strokeStyle = stroke, context.stroke());
        } else {
            context.beginPath();
            const b = graphic.AABBBounds;
            context.rect(x, y, b.width(), b.height()), context.fillStyle = background, context.globalAlpha = 1, 
            context.fill();
        }
    }
}

function getActualPosition(graphic) {
    const boundsPadding = (0, utils_1.parsePadding)(graphic.attribute.boundsPadding), bounds = graphic.AABBBounds;
    let x = bounds.x1, y = bounds.y1, width = bounds.width(), height = bounds.height();
    return (0, vutils_1.isNumber)(boundsPadding) ? (x += boundsPadding, y += boundsPadding, 
    width -= 2 * boundsPadding, height -= 2 * boundsPadding) : (x += boundsPadding[3], 
    y += boundsPadding[0], width -= boundsPadding[1] + boundsPadding[3], height -= boundsPadding[0] + boundsPadding[2]), 
    {
        x: x,
        y: y,
        width: width,
        height: height
    };
}

exports.DefaultImageBackgroundRenderContribution = DefaultImageBackgroundRenderContribution, 
exports.defaultImageBackgroundRenderContribution = new DefaultImageBackgroundRenderContribution;
//# sourceMappingURL=image-contribution-render.js.map
