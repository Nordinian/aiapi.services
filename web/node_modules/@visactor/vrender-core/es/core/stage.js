import { AABBBounds, Bounds, Point, isString } from "@visactor/vutils";

import { VWindow } from "./window";

import { EventSystem } from "../event";

import { container } from "../container";

import { RenderService } from "../render";

import { Group, Theme } from "../graphic";

import { PickerService } from "../picker/constants";

import { PluginService } from "../plugins/constants";

import { AutoRenderPlugin } from "../plugins/builtin-plugin/auto-render-plugin";

import { ViewTransform3dPlugin } from "../plugins/builtin-plugin/3dview-transform-plugin";

import { IncrementalAutoRenderPlugin } from "../plugins/builtin-plugin/incremental-auto-render-plugin";

import { HtmlAttributePlugin } from "../plugins/builtin-plugin/html-attribute-plugin";

import { DirtyBoundsPlugin } from "../plugins/builtin-plugin/dirty-bounds-plugin";

import { FlexLayoutPlugin } from "../plugins/builtin-plugin/flex-layout-plugin";

import { defaultTicker } from "../animate/default-ticker";

import { SyncHook } from "../tapable";

import { DirectionalLight } from "./light";

import { OrthoCamera } from "./camera";

import { LayerService } from "./constants";

import { DefaultTimeline } from "../animate";

import { application } from "../application";

import { isBrowserEnv } from "../env-check";

const DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    X: 0,
    Y: 0,
    BACKGROUND: "white"
};

export class Stage extends Group {
    set viewBox(b) {
        this._viewBox.setValue(b.x1, b.y1, b.x2, b.y2);
    }
    get viewBox() {
        return this._viewBox;
    }
    get x() {
        return this._viewBox.x1;
    }
    set x(x) {
        this._viewBox.translate(x - this._viewBox.x1, 0);
    }
    get y() {
        return this._viewBox.y1;
    }
    set y(y) {
        this._viewBox.translate(0, y - this._viewBox.y1);
    }
    get width() {
        return this.window.width;
    }
    set width(w) {
        this.resize(w, this.height);
    }
    get viewWidth() {
        return this._viewBox.width();
    }
    set viewWidth(w) {
        this.resizeView(w, this.viewHeight);
    }
    get viewHeight() {
        return this._viewBox.height();
    }
    set viewHeight(h) {
        this.resizeView(this.viewWidth, h);
    }
    get height() {
        return this.window.height;
    }
    set height(h) {
        this.resize(this.width, h);
    }
    get dpr() {
        return this.window.dpr;
    }
    set dpr(r) {
        this.setDpr(r);
    }
    get background() {
        var _a;
        return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
    }
    set background(b) {
        this._background = b;
    }
    get defaultLayer() {
        return this.at(0);
    }
    get eventSystem() {
        return this._eventSystem;
    }
    constructor(params = {}) {
        var _a;
        super({}), this._onVisibleChange = visible => {
            this._skipRender < 0 || (visible ? (this.dirtyBounds && this.dirtyBounds.setValue(0, 0, this._viewBox.width(), this._viewBox.height()), 
            this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0) : this._skipRender = 1);
        }, this.beforeRender = stage => {
            this._beforeRender && this._beforeRender(stage);
        }, this.afterRender = stage => {
            this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb => cb(stage))), 
            this._afterNextRenderCbs = null;
        }, this.params = params, this.theme = new Theme, this.hooks = {
            beforeRender: new SyncHook([ "stage" ]),
            afterRender: new SyncHook([ "stage" ])
        }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), 
        this.window = container.get(VWindow), this.renderService = container.get(RenderService), 
        this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), 
        this.pluginService.active(this, params), this.window.create({
            width: params.width,
            height: params.height,
            container: params.container,
            dpr: params.dpr || this.global.devicePixelRatio,
            canvasControled: !1 !== params.canvasControled,
            title: params.title || "",
            canvas: params.canvas
        }), this._viewBox = new AABBBounds, params.viewBox ? this._viewBox.setValue(params.viewBox.x1, params.viewBox.y1, params.viewBox.x2, params.viewBox.y2) : this._viewBox.setValue(0, 0, this.width, this.height), 
        this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height), 
        this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, 
        this.appendChild(this.layerService.createLayer(this, {
            main: !0
        })), this.nextFrameRenderLayerSet = new Set, this.willNextFrameRender = !1, this.stage = this, 
        this.renderStyle = params.renderStyle, params.autoRender && this.enableAutoRender(), 
        !1 === params.disableDirtyBounds && this.enableDirtyBounds(), params.enableHtmlAttribute && this.enableHtmlAttribute(params.enableHtmlAttribute), 
        params.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), 
        this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params.beforeRender, 
        this._afterRender = params.afterRender, this.ticker = params.ticker || defaultTicker, 
        this.supportInteractiveLayer = !1 !== params.interactiveLayer, this.timeline = new DefaultTimeline, 
        this.ticker.addTimeline(this.timeline), this.timeline.pause(), params.optimize || (params.optimize = {}), 
        this.optmize(params.optimize), params.background && isString(this._background) && this._background.includes("/") && this.setAttributes({
            background: this._background
        });
    }
    tryInitEventSystem() {
        this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
            targetElement: this.window,
            resolution: this.window.dpr || this.global.devicePixelRatio,
            rootNode: this,
            global: this.global,
            supportsPointerEvents: this.params.supportsPointerEvents,
            supportsTouchEvents: this.params.supportsTouchEvents,
            viewport: {
                viewBox: this._viewBox,
                get x() {
                    return this.viewBox.x1;
                },
                get y() {
                    return this.viewBox.y1;
                },
                get width() {
                    return this.viewBox.width();
                },
                get height() {
                    return this.viewBox.height();
                }
            }
        }, this.params.event)));
    }
    preventRender(prevent) {
        prevent ? this._skipRender = -1 / 0 : !1 !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
    }
    optmize(params) {
        this.optmizeRender(params.skipRenderWithOutRange), this.params.optimize = params;
    }
    optmizeRender(skipRenderWithOutRange = !1) {
        skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, 
        this.window.onVisibleChange(this._onVisibleChange));
    }
    getTimeline() {
        return this.timeline;
    }
    get3dOptions(options) {
        const {center: center = {
            x: this.width / 2,
            y: this.height / 2,
            z: 0,
            dx: 0,
            dy: 0,
            dz: 0
        }, light: light = {}, alpha: alpha = 0, beta: beta = 0, camera: camera, fieldRatio: fieldRatio = 1, fieldDepth: fieldDepth} = options;
        return Object.assign(Object.assign({}, options), {
            center: center,
            light: light,
            alpha: alpha,
            beta: beta,
            camera: camera,
            fieldRatio: fieldRatio,
            fieldDepth: fieldDepth
        });
    }
    set3dOptions(options) {
        var _a, _b, _c, _d, _e, _f;
        this.option3d = options;
        const options3d = this.get3dOptions(options), {light: light, center: center, camera: camera, alpha: alpha, beta: beta, fieldRatio: fieldRatio, fieldDepth: fieldDepth} = options3d, {dir: dir = [ 1, 1, -1 ], color: color = "white", ambient: ambient} = light, centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_c = center.y) && void 0 !== _c ? _c : this.height / 2) + (null !== (_d = center.dy) && void 0 !== _d ? _d : 0), centerVec3 = [ centerX, centerY, (null !== (_e = center.z) && void 0 !== _e ? _e : 0) + (null !== (_f = center.dz) && void 0 !== _f ? _f : 0) ];
        let cameraX = 0, cameraY = 0, cameraZ = 0;
        camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, 
        cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new DirectionalLight(dir, color, ambient);
        const cameraParams = {
            left: 0,
            right: this.width,
            top: 0,
            bottom: this.height,
            fieldRatio: fieldRatio,
            fieldDepth: fieldDepth,
            viewParams: {
                pos: [ cameraX, cameraY, cameraZ ],
                center: centerVec3,
                up: [ 0, 1, 0 ]
            }
        };
        this.camera ? this.camera.params = cameraParams : this.camera = new OrthoCamera(cameraParams), 
        options.enableView3dTransform && this.enableView3dTransform();
    }
    setBeforeRender(cb) {
        this._beforeRender = cb;
    }
    setAfterRender(cb) {
        this._afterRender = cb;
    }
    afterNextRender(cb) {
        this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
    }
    enableView3dTransform() {
        this.view3dTranform || (this.view3dTranform = !0, this.pluginService.register(new ViewTransform3dPlugin));
    }
    disableView3dTranform() {
        this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    enableAutoRender() {
        this.autoRender || (this.autoRender = !0, this.pluginService.register(new AutoRenderPlugin));
    }
    disableAutoRender() {
        this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    enableIncrementalAutoRender() {
        this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new IncrementalAutoRenderPlugin));
    }
    disableIncrementalAutoRender() {
        this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    enableDirtyBounds() {
        if (this.dirtyBounds) return;
        this.dirtyBounds = new Bounds;
        let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
        plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin, 
        this.pluginService.register(plugin));
    }
    disableDirtyBounds() {
        this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    enableLayout() {
        this._enableLayout || (this._enableLayout = !0, this.pluginService.register(new FlexLayoutPlugin));
    }
    disableLayout() {
        this._enableLayout && (this._enableLayout = !1, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    enableHtmlAttribute(container) {
        this.htmlAttribute || (this.htmlAttribute = container, this.pluginService.register(new HtmlAttributePlugin));
    }
    disableHtmlAttribute() {
        this.htmlAttribute && (this.htmlAttribute = !1, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach((plugin => {
            this.pluginService.unRegister(plugin);
        })));
    }
    tryUpdateAABBBounds() {
        const viewBox = this._viewBox;
        return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), 
        this._AABBBounds;
    }
    combineLayer(ILayer1, ILayer2) {
        throw new Error("暂不支持");
    }
    createLayer(canvasId, layerMode) {
        const layer = this.layerService.createLayer(this, {
            main: !1,
            layerMode: layerMode,
            canvasId: canvasId
        });
        return this.appendChild(layer), layer;
    }
    sortLayer(cb) {
        const children = this.children;
        children.sort(cb), this.removeAllChild(), children.forEach((c => {
            this.appendChild(c);
        }));
    }
    removeLayer(ILayerId) {
        return this.removeChild(this.findChildByUid(ILayerId));
    }
    tryInitInteractiveLayer() {
        this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), 
        this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = !1, 
        this.nextFrameRenderLayerSet.add(this.interactiveLayer));
    }
    clearViewBox(color) {
        this.window.clearViewBox(this._viewBox, color);
    }
    render(layers, params) {
        this.ticker.start(), this.timeline.resume();
        const state = this.state;
        this.state = "rendering", this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params, 
        this.hooks.beforeRender.call(this), this.renderLayerList(this.children), this.combineLayersToWindow(), 
        this.nextFrameRenderLayerSet.clear(), this.hooks.afterRender.call(this)), this.state = state, 
        this._skipRender && this._skipRender++;
    }
    combineLayersToWindow() {}
    renderNextFrame(layers, force) {
        this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer => {
            this.nextFrameRenderLayerSet.add(layer);
        })), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()((() => {
            this._doRenderInThisFrame(), this.willNextFrameRender = !1;
        })));
    }
    _doRenderInThisFrame() {
        this.timeline.resume(), this.ticker.start();
        const state = this.state;
        this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), 
        this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), 
        this.combineLayersToWindow(), this.hooks.afterRender.call(this), this.nextFrameRenderLayerSet.clear()), 
        this.state = state, this._skipRender && this._skipRender++;
    }
    renderLayerList(layerList, params) {
        const list = [];
        for (let i = 0; i < layerList.length; i++) {
            let l = layerList[i];
            "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
        }
        list.forEach((layer => {
            layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, 
            layer.render({
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
            }, Object.assign({
                renderStyle: this.renderStyle
            }, params)));
        })), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && this.interactiveLayer.render({
            renderService: this.renderService,
            updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
        }, Object.assign({
            renderStyle: this.renderStyle
        }, params));
    }
    resizeWindow(w, h, rerender = !0) {
        this.window.resize(w, h), rerender && this.render();
    }
    resize(w, h, rerender = !0) {
        this.window.resize(w, h), this.forEachChildren((c => {
            c.resize(w, h);
        })), this._subView || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), 
        this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();
    }
    resizeView(w, h, rerender = !0) {
        this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), 
        this.forEachChildren((c => {
            c.resizeView(w, h);
        })), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
            right: this.width,
            bottom: this.height
        })), rerender && this.render();
    }
    setViewBox(x, y, w, h, rerender) {
        let isRerender = !0;
        "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), 
        !1 === rerender && (isRerender = !1)), this.forEachChildren((c => {
            c.resizeView(this.viewBox.width(), this.viewBox.height());
        })), isRerender && this.render();
    }
    setDpr(dpr, rerender = !0) {
        this.forEachChildren((c => {
            c.setDpr(dpr);
        })), rerender && this.render();
    }
    setOrigin(x, y) {
        throw new Error("暂不支持");
    }
    export(type) {
        throw new Error("暂不支持");
    }
    pick(x, y) {
        this.pickerService || (this.pickerService = container.get(PickerService));
        const result = this.pickerService.pick(this.children, new Point(x, y), {
            bounds: this.AABBBounds
        });
        return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;
    }
    startAnimate(t) {
        throw new Error("暂不支持");
    }
    setToFrame(t) {
        throw new Error("暂不支持");
    }
    release() {
        super.release(), this.eventSystem && this.eventSystem.release(), this.pluginService.release(), 
        this.forEach((layer => {
            layer.release();
        })), this.interactiveLayer && this.interactiveLayer.release(), this.window.release();
    }
    setStage(stage) {}
    dirty(b, matrix) {
        matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), 
        this.dirtyBounds.union(b);
    }
    getLayer(name) {
        return this.children.filter((layer => layer.name === name))[0];
    }
    renderTo(window, params) {
        this.forEachChildren(((layer, i) => {
            layer.drawTo(window, Object.assign(Object.assign({}, params), {
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                clear: 0 === i,
                updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
            }));
        }));
    }
    renderToNewWindow(fullImage = !0, viewBox) {
        const window = container.get(VWindow);
        if (fullImage) window.create({
            width: this.viewWidth,
            height: this.viewHeight,
            dpr: this.window.dpr,
            canvasControled: !0,
            offscreen: !0,
            title: ""
        }); else {
            const width = viewBox ? viewBox.width() : Math.min(this.viewWidth, this.window.width - this.x), height = viewBox ? viewBox.height() : Math.min(this.viewHeight, this.window.height - this.y);
            window.create({
                width: width,
                height: height,
                dpr: this.window.dpr,
                canvasControled: !0,
                offscreen: !0,
                title: ""
            });
        }
        const x = viewBox ? -viewBox.x1 : 0, y = viewBox ? -viewBox.y1 : 0;
        return this.renderTo(window, {
            x: x,
            y: y,
            width: viewBox ? viewBox.x2 : window.width,
            height: viewBox ? viewBox.y2 : window.height
        }), window;
    }
    toCanvas(fullImage = !0, viewBox) {
        const c = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
    }
    setCursor(mode) {
        this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
    }
    getCursor() {
        return this._cursor;
    }
}
//# sourceMappingURL=stage.js.map
