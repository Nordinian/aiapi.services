{"version":3,"sources":["../src/component/label/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["import type { WaterfallSeries } from './../../series/waterfall/waterfall';\nimport type { Datum } from '../../typings/common';\nimport { Direction } from '../../typings/space';\nimport type { ILabelInfo } from './label';\nimport type { BaseLabelAttrs, LabelItem, OverlapAttrs, Strategy } from '@visactor/vrender-components';\nimport type { ICartesianSeries } from '../../series/interface';\nimport { isBoolean, isFunction, isObject, isString, substitute } from '@visactor/vutils';\nimport { createText } from '@visactor/vrender-core';\nimport type { IWaterfallSeriesSpec } from '../../series/waterfall/interface';\nimport type { ILabelSpec } from './interface';\nimport { ARC_RATIO } from '../../constant';\nimport { STACK_FIELD_END_PERCENT } from '../../constant';\n\nexport const labelRuleMap = {\n  rect: barLabel,\n  symbol: symbolLabel,\n  arc: pieLabel,\n  point: pointLabel,\n  'line-data': lineDataLabel,\n  stackLabel: stackLabel,\n  line: LineLabel,\n  area: LineLabel,\n  rect3d: barLabel,\n  arc3d: pieLabel,\n  treemap: treemapLabel\n};\n\nexport function defaultLabelConfig(rule: string, labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n  if (labelSpec.overlap && !isObject(labelSpec.overlap)) {\n    labelSpec.overlap = {};\n  }\n  const processor = labelRuleMap[rule] ?? labelRuleMap.point;\n  return processor(labelInfo);\n}\n\nexport function textAttribute(\n  labelInfo: ILabelInfo,\n  datum: Datum,\n  formatMethod?: ILabelSpec['formatMethod'],\n  formatter?: ILabelSpec['formatter']\n) {\n  const { labelMark, series } = labelInfo;\n  const field = series.getMeasureField()[0];\n  const textAttribute = { text: datum[field], data: datum, textType: labelInfo.labelSpec.textType ?? 'text' } as any;\n\n  const attributes = Object.keys(labelMark.stateStyle.normal);\n\n  for (const key of attributes) {\n    const attr = labelMark.getAttribute(key as any, datum);\n    textAttribute[key] = attr;\n  }\n\n  if (formatMethod) {\n    textAttribute.text = formatMethod(textAttribute.text, datum, { series });\n  }\n\n  if (formatter) {\n    if (series.type === 'pie') {\n      datum._percent_ = (datum[ARC_RATIO] * 100).toFixed(2) + '%';\n    } else if (datum[STACK_FIELD_END_PERCENT]) {\n      datum._percent_ = (datum[STACK_FIELD_END_PERCENT] * 100).toFixed(2) + '%';\n    }\n    textAttribute.text = substitute(formatter, datum);\n  }\n  return textAttribute;\n}\n\nfunction uniformLabelPosition(position?: ILabelSpec['position']) {\n  if (isFunction(position)) {\n    return (datum: Datum) => {\n      return position(datum.data);\n    };\n  }\n  return position;\n}\n\n/**\n * symbol 图元标签规则。\n */\nexport function symbolLabel(labelInfo: ILabelInfo) {\n  const { series, labelSpec } = labelInfo;\n\n  // encode position config\n  const defaultPosition = (series as ICartesianSeries).direction === 'horizontal' ? 'right' : 'top';\n  const position = uniformLabelPosition(labelSpec.position) ?? defaultPosition;\n\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      strategy: (labelSpec.overlap as OverlapAttrs)?.strategy ?? symbolLabelOverlapStrategy(),\n      avoidBaseMark: position !== 'center'\n    };\n  }\n\n  return { position, overlap };\n}\n\nexport function lineDataLabel(labelInfo: ILabelInfo) {\n  const result = symbolLabel(labelInfo);\n  if (!isBoolean(result.overlap)) {\n    result.overlap.avoidBaseMark = false;\n  }\n  return result;\n}\n\nfunction symbolLabelOverlapStrategy() {\n  const strategy: Strategy[] = [\n    {\n      type: 'position',\n      position: ['top', 'bottom', 'right', 'left', 'top-right', 'top-left', 'bottom-left', 'bottom-right']\n    }\n  ];\n\n  return strategy;\n}\n\n/**\n *\n */\nexport function barLabel(labelInfo: ILabelInfo) {\n  const { series, labelSpec = {} as ILabelSpec } = labelInfo;\n\n  // encode position config\n  const originPosition = uniformLabelPosition(labelSpec.position) ?? 'outside';\n  const direction = (series as ICartesianSeries).direction ?? 'vertical';\n  const isInverse =\n    (series as ICartesianSeries).direction === 'horizontal'\n      ? (series as ICartesianSeries).getXAxisHelper()?.isInverse()\n      : (series as ICartesianSeries).getYAxisHelper()?.isInverse();\n\n  let position = originPosition as BaseLabelAttrs['position'];\n\n  if (isString(originPosition) && position !== 'inside') {\n    position = (data: Datum) => {\n      const { data: datum } = data;\n      const dataField = series.getMeasureField()[0];\n      if (originPosition === 'outside') {\n        const positionMap = { vertical: ['top', 'bottom'], horizontal: ['right', 'left'] };\n        const index = (datum?.[dataField] >= 0 && isInverse) || (datum?.[dataField] < 0 && !isInverse) ? 1 : 0;\n        return positionMap[direction][index];\n      }\n      if (originPosition === 'inside-bottom') {\n        return (series as ICartesianSeries).direction === 'horizontal' ? 'inside-left' : 'inside-bottom';\n      }\n      if (originPosition === 'inside-top') {\n        return (series as ICartesianSeries).direction === 'horizontal' ? 'inside-right' : 'inside-top';\n      }\n      return originPosition;\n    };\n  }\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      strategy: (labelSpec.overlap as OverlapAttrs)?.strategy ?? barLabelOverlapStrategy(series as ICartesianSeries)\n    };\n  }\n\n  // encode smartInvert\n  let smartInvert = false;\n  if (isString(originPosition) && originPosition.includes('inside')) {\n    smartInvert = true;\n  }\n\n  return { position, overlap, smartInvert };\n}\n\nfunction barLabelOverlapStrategy(series: ICartesianSeries) {\n  const strategy: Strategy[] = [\n    {\n      type: 'position',\n      position: (data: any) => {\n        const { data: datum } = data;\n        const dataField = series.getMeasureField()[0];\n        const isInverse =\n          (series as ICartesianSeries).direction === 'horizontal'\n            ? (series as ICartesianSeries).getXAxisHelper()?.isInverse()\n            : (series as ICartesianSeries).getYAxisHelper()?.isInverse();\n        if (isInverse) {\n          if (datum?.[dataField] >= 0) {\n            return series.direction === 'horizontal' ? ['left', 'inside-left'] : ['bottom', 'inside-bottom'];\n          }\n          return series.direction === 'horizontal' ? ['right', 'inside-right'] : ['top', 'inside-top'];\n        }\n        if (datum?.[dataField] >= 0) {\n          return series.direction === 'horizontal' ? ['right', 'inside-right'] : ['top', 'inside-top'];\n        }\n        return series.direction === 'horizontal' ? ['left', 'inside-left'] : ['bottom', 'inside-bottom'];\n      }\n    }\n  ];\n\n  return strategy;\n}\n\n/**\n * 无关图元，指定x/y坐标的标签配置规则\n */\nexport function pointLabel(labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      avoidBaseMark: false\n    };\n  }\n\n  return { position: 'center', overlap };\n}\n\n/**\n * pie 图元标签配置规则\n */\n\nexport function pieLabel(labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n  // encode position config\n  const labelPosition = uniformLabelPosition(labelSpec.position) ?? 'outside';\n  const position = labelPosition as BaseLabelAttrs['position'];\n\n  // encode smartInvert\n  let smartInvert;\n  if (labelSpec.smartInvert) {\n    smartInvert = labelSpec.smartInvert;\n  } else {\n    smartInvert = isString(labelPosition) && labelPosition.includes('inside');\n  }\n\n  return { position, smartInvert };\n}\n\n/**\n * 瀑布图堆积标签配置规则\n */\n\nexport function stackLabel(labelInfo: ILabelInfo) {\n  const series = labelInfo.series as WaterfallSeries;\n  const labelSpec = labelInfo.labelSpec || ({} as IWaterfallSeriesSpec['stackLabel']);\n  const totalData = series.getTotalData();\n  return {\n    customLayoutFunc: (labels: LabelItem[]) => {\n      return labels.map(label => {\n        const pos = labelSpec.position || 'withChange';\n        const offset = labelSpec.offset || 0;\n\n        const datum = label.data;\n        const attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);\n        const x = (datum: any) => {\n          if (series.direction === Direction.vertical) {\n            return series.totalPositionX(datum, 'index', 0.5);\n          }\n          if (pos === 'middle') {\n            return (series.totalPositionX(datum, 'end') + series.totalPositionY(datum, 'start')) * 0.5;\n          } else if (pos === 'max') {\n            return series.totalPositionX(datum, datum.end >= datum.start ? 'end' : 'start') + offset;\n          } else if (pos === 'min') {\n            return series.totalPositionX(datum, datum.end >= datum.start ? 'start' : 'end') - offset;\n          }\n          return series.totalPositionX(datum, 'end') + (datum.end >= datum.start ? offset : -offset);\n        };\n        const y = (datum: any) => {\n          if (series.direction === Direction.vertical) {\n            if (pos === 'middle') {\n              return (series.totalPositionY(datum, 'end') + series.totalPositionY(datum, 'start')) * 0.5;\n            } else if (pos === 'max') {\n              return series.totalPositionY(datum, datum.end >= datum.start ? 'end' : 'start') - offset;\n            } else if (pos === 'min') {\n              return series.totalPositionY(datum, datum.end >= datum.start ? 'start' : 'end') + offset;\n            }\n            return series.totalPositionY(datum, 'end') + (datum.end >= datum.start ? -offset : offset);\n          }\n          return series.totalPositionY(datum, 'index', 0.5);\n        };\n        attribute.x = x(datum);\n        attribute.y = y(datum);\n        if (series.direction === Direction.vertical) {\n          attribute.textBaseline =\n            pos === 'middle'\n              ? pos\n              : (pos === 'withChange' && datum.end - datum.start >= 0) || pos === 'max'\n              ? 'bottom'\n              : 'top';\n        } else {\n          attribute.textAlign =\n            pos === 'middle'\n              ? 'center'\n              : (pos === 'withChange' && datum.end - datum.start >= 0) || pos === 'max'\n              ? 'left'\n              : 'right';\n        }\n        return createText({ ...attribute, id: label.id });\n      });\n    },\n    dataFilter: (labels: LabelItem[]) => {\n      const result: LabelItem[] = [];\n      totalData.forEach((total: any) => {\n        const label = labels.find(labelItem => {\n          return total.index === labelItem.data?.[series.getDimensionField()[0]];\n        });\n        if (label) {\n          label.data = total;\n          result.push(label);\n        }\n      });\n      return result;\n    },\n    overlap: {\n      strategy: [] as any\n    }\n  };\n}\n\n/**\n * treemap 非叶子节点标签配置规则\n */\nexport function treemapLabel(labelInfo: ILabelInfo) {\n  const labelSpec = labelInfo.labelSpec;\n  return {\n    customLayoutFunc: (labels: LabelItem[]) => {\n      return labels.map(label => {\n        const datum = label.data;\n        const attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);\n        return createText({ ...attribute, id: label.id, pickable: false });\n      });\n    },\n    overlap: false\n  };\n}\n\n/**\n * line 图元标签\n */\n\nexport function LineLabel(labelInfo: ILabelInfo) {\n  const { labelSpec, series } = labelInfo;\n\n  const seriesData = series.getViewDataStatistics?.().latestData?.[series.getSeriesField()]?.values;\n  const data = seriesData ? seriesData.map((d: Datum, index: number) => ({ [series.getSeriesField()]: d, index })) : [];\n  return { position: labelSpec.position ?? 'end', data };\n}\n"]}