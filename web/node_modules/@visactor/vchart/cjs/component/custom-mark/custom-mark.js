"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerCustomMark = exports.CustomMark = void 0;

const base_component_1 = require("../base/base-component"), type_1 = require("../interface/type"), constant_1 = require("../../constant"), vutils_1 = require("@visactor/vutils"), factory_1 = require("../../core/factory"), image_1 = require("../../mark/image");

class CustomMark extends base_component_1.BaseComponent {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.customMark, this.specKey = "customMark", 
        this.layoutType = "none", this.layoutZIndex = constant_1.LayoutZIndex.CustomMark, 
        this.layoutLevel = constant_1.LayoutLevel.CustomMark;
    }
    static getSpecInfo(chartSpec) {
        const spec = chartSpec[this.specKey];
        return spec ? [ {
            spec: spec,
            specIndex: 0,
            specPath: [ this.specKey ],
            type: type_1.ComponentTypeEnum.customMark
        } ] : null;
    }
    created() {
        super.created(), this.initMarks(), this.initEvent();
    }
    initMarks() {
        this._spec && this._spec.forEach(((m, i) => {
            this._createExtensionMark(m, null, `${constant_1.PREFIX}_series_${this.id}_extensionMark`, i);
        }));
    }
    _createExtensionMark(spec, parentMark, namePrefix, index) {
        var _a;
        const mark = this._createMark({
            type: spec.type,
            name: `${constant_1.PREFIX}_${index}`
        }, {
            skipBeforeLayouted: !0,
            attributeContext: this._getMarkAttributeContext()
        });
        if (mark && ((0, vutils_1.isNil)(parentMark) ? this._marks.addMark(mark) : parentMark && parentMark.addMark(mark), 
        this.initMarkStyleWithSpec(mark, spec), "group" === spec.type && (namePrefix = `${namePrefix}_${index}`, 
        null === (_a = spec.children) || void 0 === _a || _a.forEach(((s, i) => {
            this._createExtensionMark(s, mark, namePrefix, i);
        }))), (0, vutils_1.isValid)(spec.dataId) || (0, vutils_1.isValidNumber)(spec.dataIndex))) {
            const dataview = this.getChart().getSeriesData(spec.dataId, spec.dataIndex);
            dataview && (dataview.target.addListener("change", (() => {
                mark.getData().updateData();
            })), mark.setDataView(dataview));
        }
    }
    initEvent() {}
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return (0, vutils_1.isEqual)(prevSpec, spec) || (result.reMake = !0), result.change = !0, 
        result.reRender = !0, result;
    }
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return [];
    }
    onRender(ctx) {}
    _getMarkAttributeContext() {
        return {
            vchart: this._option.globalInstance,
            globalScale: (key, value) => {
                var _a;
                return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
            }
        };
    }
}

exports.CustomMark = CustomMark, CustomMark.type = type_1.ComponentTypeEnum.customMark, 
CustomMark.specKey = "customMark";

const registerCustomMark = () => {
    (0, image_1.registerImageMark)(), factory_1.Factory.registerComponent(CustomMark.type, CustomMark);
};

exports.registerCustomMark = registerCustomMark;
//# sourceMappingURL=custom-mark.js.map
