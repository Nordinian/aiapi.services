"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTooltipHandler = void 0;

const base_1 = require("../../../constant/base"), constants_1 = require("./constants"), env_1 = require("../../../util/env"), common_1 = require("./utils/common"), position_1 = require("./utils/position"), compose_1 = require("./utils/compose"), get_spec_1 = require("./utils/get-spec"), common_2 = require("../interface/common"), vutils_1 = require("@visactor/vutils"), attribute_1 = require("./utils/attribute");

class BaseTooltipHandler {
    get id() {
        return this._id;
    }
    get env() {
        return this._env;
    }
    constructor(tooltipId, component) {
        this._visible = !0, this._id = "", this._attributes = null, this._isReleased = !1, 
        this.showTooltip = (activeType, data, params) => {
            var _a;
            let changePositionOnly = !!params.changePositionOnly;
            return params.changePositionOnly && (null === (_a = this._cacheActualTooltip) || void 0 === _a ? void 0 : _a.activeType) === activeType || (changePositionOnly = !1, 
            this._clearCacheOfContent()), changePositionOnly && this._cacheViewSpec && this._cacheActualTooltip ? this.changeTooltipPosition(changePositionOnly, data, params) : this.changeTooltip(!0, params, changePositionOnly, activeType, data);
        }, this._changeTooltip = (visible, params, changePositionOnly, activeType, data) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            const tooltipSpec = this._component.getSpec();
            if (this._isReleased || !tooltipSpec) return common_2.TooltipResult.failed;
            if (!visible) return this._clearAllCache(), tooltipSpec.handler ? null !== (_c = null === (_b = (_a = tooltipSpec.handler).hideTooltip) || void 0 === _b ? void 0 : _b.call(_a, params)) && void 0 !== _c ? _c : common_2.TooltipResult.success : (this._updateTooltip(!1, params), 
            common_2.TooltipResult.success);
            if ((0, vutils_1.isNil)(activeType) || (0, vutils_1.isNil)(data)) return common_2.TooltipResult.failed;
            let spec;
            if (changePositionOnly && this._cacheViewSpec ? spec = this._cacheViewSpec : (spec = (0, 
            get_spec_1.getTooltipSpecForShow)(activeType, tooltipSpec, params.model, params.dimensionInfo), 
            this._cacheViewSpec = spec), !1 === spec.visible) return common_2.TooltipResult.failed;
            if (spec.handler) return null !== (_f = null === (_e = (_d = spec.handler).showTooltip) || void 0 === _e ? void 0 : _e.call(_d, activeType, data, params)) && void 0 !== _f ? _f : common_2.TooltipResult.success;
            const pattern = spec[activeType];
            if (!pattern) return common_2.TooltipResult.failed;
            let actualTooltip;
            return changePositionOnly && this._cacheActualTooltip ? actualTooltip = this._cacheActualTooltip : (actualTooltip = this._getActualTooltipContent(pattern, data, params), 
            actualTooltip.title = null !== (_h = null === (_g = pattern.updateTitle) || void 0 === _g ? void 0 : _g.call(pattern, actualTooltip.title, data, params)) && void 0 !== _h ? _h : actualTooltip.title, 
            actualTooltip.content = null !== (_k = null === (_j = pattern.updateContent) || void 0 === _j ? void 0 : _j.call(pattern, actualTooltip.content, data, params)) && void 0 !== _k ? _k : actualTooltip.content), 
            (0, vutils_1.isNil)(null === (_l = actualTooltip.title) || void 0 === _l ? void 0 : _l.key) && (0, 
            vutils_1.isNil)(null === (_m = actualTooltip.title) || void 0 === _m ? void 0 : _m.value) && !(null === (_o = actualTooltip.content) || void 0 === _o ? void 0 : _o.length) ? common_2.TooltipResult.failed : (this._cacheActualTooltip = actualTooltip, 
            this._changeTooltipPosition(!!changePositionOnly, data, params));
        }, this._changeTooltipPosition = (changePositionOnly, data, params) => {
            var _a, _b, _c;
            if (this._isReleased) return common_2.TooltipResult.failed;
            const event = params.event, spec = this._cacheViewSpec, actualTooltip = this._cacheActualTooltip;
            if (!spec || !actualTooltip) return common_2.TooltipResult.failed;
            if (spec.enterable) {
                if (!this._isPointerEscaped && this._isPointerMovingToTooltip(params)) return this._isTooltipPaused || (this._isTooltipPaused = !0, 
                this._cachePointerTimer = setTimeout((() => {
                    this._isPointerEscaped = !0;
                }), 300)), common_2.TooltipResult.success;
                this._isTooltipPaused = !1, this._isPointerEscaped = !1, clearTimeout(this._cachePointerTimer), 
                this._cachePointerPosition = this._getPointerPositionRelativeToTooltipParent(params);
            }
            const activeType = actualTooltip.activeType;
            if (spec.handler) return null !== (_c = null === (_b = (_a = spec.handler).showTooltip) || void 0 === _b ? void 0 : _b.call(_a, activeType, data, params)) && void 0 !== _c ? _c : common_2.TooltipResult.success;
            const pattern = spec[activeType];
            if (!pattern) return common_2.TooltipResult.failed;
            const position = this._getActualTooltipPosition(actualTooltip, params, this._getTooltipBoxSize(actualTooltip, changePositionOnly));
            actualTooltip.position = position, pattern.updatePosition && (actualTooltip.position = pattern.updatePosition(actualTooltip.position, data, params));
            let tooltipVisible = !1 !== (null == pattern ? void 0 : pattern.visible);
            return data && "pointerout" !== event.type && actualTooltip.visible && (actualTooltip.title || actualTooltip.content) || (tooltipVisible = !1), 
            this._updateTooltip(tooltipVisible, Object.assign(Object.assign({}, params), {
                changePositionOnly: changePositionOnly
            }), actualTooltip), common_2.TooltipResult.success;
        }, this._getActualTooltipContent = (pattern, data, params) => {
            const patternVisible = (0, common_1.getTooltipPatternValue)(pattern.visible, data, params);
            let tooltipContent = null;
            tooltipContent = (0, compose_1.getShowContent)(pattern, data, params);
            return Object.assign(Object.assign({}, tooltipContent), {
                visible: !!(0, vutils_1.isValid)(tooltipContent) && !1 !== patternVisible,
                activeType: pattern.activeType,
                data: data
            });
        }, this._getActualTooltipPosition = (actualTooltip, params, tooltipBoxSize) => {
            var _a, _b, _c, _d, _e;
            const event = params.event, invalidPosition = {
                x: 1 / 0,
                y: 1 / 0
            }, {offsetX: offsetX, offsetY: offsetY} = this._option, tooltipSpec = this._cacheViewSpec;
            if (!tooltipSpec) return this._cacheTooltipPosition = void 0, invalidPosition;
            const {activeType: activeType, data: data} = actualTooltip, pattern = tooltipSpec[activeType], position = (0, 
            common_1.getTooltipPatternValue)(pattern.position, data, params), positionMode = (0, 
            common_1.getTooltipPatternValue)(pattern.positionMode, data, params), tooltipParentElement = this._getParentElement(tooltipSpec), {width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0} = null != tooltipBoxSize ? tooltipBoxSize : {}, isCanvas = "canvas" === tooltipSpec.renderMode, canvasRect = null === (_a = null == params ? void 0 : params.chart) || void 0 === _a ? void 0 : _a.getCanvasRect(), canvasWidth = null !== (_b = null == canvasRect ? void 0 : canvasRect.width) && void 0 !== _b ? _b : base_1.DEFAULT_CHART_WIDTH, canvasHeight = null !== (_c = null == canvasRect ? void 0 : canvasRect.height) && void 0 !== _c ? _c : base_1.DEFAULT_CHART_HEIGHT;
            let isFixedPosition = !1;
            const containerSize = {
                width: 0,
                height: 0
            };
            let relativePosOffset = {
                x: 0,
                y: 0
            }, tooltipParentElementRect = {
                x: 0,
                y: 0
            }, chartElementScale = 1, tooltipParentElementScale = 1;
            if ((0, env_1.isTrueBrowser)(this._env) && !tooltipSpec.confine) {
                if (containerSize.width = window.innerWidth, containerSize.height = window.innerHeight, 
                !isCanvas) {
                    tooltipParentElementRect = null !== (_d = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _d ? _d : invalidPosition;
                    const chartElement = null !== (_e = this._compiler.getCanvas()) && void 0 !== _e ? _e : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
                    relativePosOffset = {
                        x: chartElementRect.x - tooltipParentElementRect.x,
                        y: chartElementRect.y - tooltipParentElementRect.y
                    }, chartElementScale = (0, common_1.getScale)(chartElement, chartElementRect), tooltipParentElementScale = (0, 
                    common_1.getScale)(tooltipParentElement, tooltipParentElementRect);
                }
            } else containerSize.width = canvasWidth, containerSize.height = canvasHeight;
            const tooltipSizeScale = tooltipParentElementScale / chartElementScale;
            let left, top, right, bottom, x, y;
            if ((0, vutils_1.isObject)(position)) {
                const {left: posLeft, right: posRight, top: posTop, bottom: posBottom} = position;
                left = (0, position_1.getActualTooltipPositionValue)(posLeft, event), top = (0, 
                position_1.getActualTooltipPositionValue)(posTop, event), right = (0, position_1.getActualTooltipPositionValue)(posRight, event), 
                bottom = (0, position_1.getActualTooltipPositionValue)(posBottom, event);
            } else if ((0, vutils_1.isValid)(position) && "pointer" !== positionMode && "mark" === actualTooltip.activeType) {
                isFixedPosition = !0;
                const element = params.item, model = params.model, bounds = null == element ? void 0 : element.getBounds(), startPoint = null == model ? void 0 : model.getLayoutStartPoint();
                if (bounds && startPoint) {
                    let {x1: x1, y1: y1, x2: x2, y2: y2} = bounds;
                    switch (x1 += startPoint.x, x2 += startPoint.x, y1 += startPoint.y, y2 += startPoint.y, 
                    (0, position_1.getHorizontalPositionType)(position)) {
                      case "left":
                        left = x1 - tooltipBoxWidth * tooltipSizeScale - offsetX;
                        break;

                      case "right":
                        left = x2 + offsetX;
                        break;

                      case "middle":
                        left = (x1 + x2) / 2 - tooltipBoxWidth * tooltipSizeScale / 2;
                    }
                    switch ((0, position_1.getVerticalPositionType)(position)) {
                      case "top":
                        top = y1 - tooltipBoxHeight * tooltipSizeScale - offsetY;
                        break;

                      case "bottom":
                        top = y2 + offsetY;
                        break;

                      case "middle":
                        top = (y1 + y2) / 2 - tooltipBoxHeight * tooltipSizeScale / 2;
                    }
                }
            }
            const {canvasX: canvasX, canvasY: canvasY} = event;
            if ((0, vutils_1.isValidNumber)(left)) x = left; else if ((0, vutils_1.isValidNumber)(right)) x = canvasWidth - tooltipBoxWidth * tooltipSizeScale - right; else {
                const x0 = canvasX;
                switch ((0, position_1.getHorizontalPositionType)(position, "right")) {
                  case "middle":
                    x = x0 - tooltipBoxWidth * tooltipSizeScale / 2;
                    break;

                  case "left":
                    x = x0 - tooltipBoxWidth * tooltipSizeScale - offsetX;
                    break;

                  case "right":
                    x = x0 + offsetX;
                }
            }
            if ((0, vutils_1.isValidNumber)(top)) y = top; else if ((0, vutils_1.isValidNumber)(bottom)) y = canvasHeight - tooltipBoxHeight * tooltipSizeScale - bottom; else {
                const y0 = canvasY;
                switch ((0, position_1.getVerticalPositionType)(position, "bottom")) {
                  case "middle":
                    y = y0 - tooltipBoxHeight * tooltipSizeScale / 2;
                    break;

                  case "top":
                    y = y0 - tooltipBoxHeight * tooltipSizeScale - offsetY;
                    break;

                  case "bottom":
                    y = y0 + offsetY;
                }
            }
            x *= chartElementScale, y *= chartElementScale, (0, env_1.isTrueBrowser)(this._env) && (x += relativePosOffset.x, 
            y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale;
            const {width: containerWidth, height: containerHeight} = containerSize, isLeftOut = () => x * tooltipParentElementScale + tooltipParentElementRect.x < 0, isRightOut = () => (x + tooltipBoxWidth) * tooltipParentElementScale + tooltipParentElementRect.x > containerWidth, isTopOut = () => y * tooltipParentElementScale + tooltipParentElementRect.y < 0, isBottomOut = () => (y + tooltipBoxHeight) * tooltipParentElementScale + tooltipParentElementRect.y > containerHeight, detectLeftFirst = () => {
                isLeftOut() && (isFixedPosition ? x = -tooltipParentElementRect.x / tooltipParentElementScale : "middle" === (0, 
                position_1.getHorizontalPositionType)(position, "right") ? x += offsetX + tooltipBoxWidth / 2 : x += 2 * offsetX + tooltipBoxWidth);
            }, detectLeftLast = () => {
                isLeftOut() && (x = -tooltipParentElementRect.x / tooltipParentElementScale);
            }, detectRightFirst = () => {
                isRightOut() && (isFixedPosition ? x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth : "middle" === (0, 
                position_1.getHorizontalPositionType)(position, "right") ? x -= offsetX + tooltipBoxWidth / 2 : x -= 2 * offsetX + tooltipBoxWidth);
            }, detectRightLast = () => {
                isRightOut() && (x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth);
            }, detectTopFirst = () => {
                isTopOut() && (isFixedPosition ? y = -tooltipParentElementRect.y / tooltipParentElementScale : "middle" === (0, 
                position_1.getVerticalPositionType)(position, "bottom") ? y += offsetY + tooltipBoxHeight / 2 : y += 2 * offsetY + tooltipBoxHeight);
            }, detectTopLast = () => {
                isTopOut() && (y = 0 - tooltipParentElementRect.y / tooltipParentElementScale);
            }, detectBottomFirst = () => {
                isBottomOut() && (isFixedPosition ? y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight : "middle" === (0, 
                position_1.getVerticalPositionType)(position, "bottom") ? y -= offsetY + tooltipBoxHeight / 2 : y -= 2 * offsetY + tooltipBoxHeight);
            }, detectBottomLast = () => {
                isBottomOut() && (y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight);
            };
            switch ((0, position_1.getHorizontalPositionType)(position, "right")) {
              case "middle":
                isLeftOut() ? (detectLeftFirst(), detectRightLast()) : (detectRightFirst(), detectLeftLast());
                break;

              case "left":
                detectLeftFirst(), detectRightLast();
                break;

              case "right":
                detectRightFirst(), detectLeftLast();
            }
            switch ((0, position_1.getVerticalPositionType)(position, "bottom")) {
              case "middle":
                isTopOut() ? (detectTopFirst(), detectBottomLast()) : (detectBottomFirst(), detectTopLast());
                break;

              case "top":
                detectTopFirst(), detectBottomLast();
                break;

              case "bottom":
                detectBottomFirst(), detectTopLast();
            }
            const result = {
                x: x,
                y: y
            };
            return this._cacheTooltipPosition = result, this._cacheTooltipSize = {
                width: tooltipBoxWidth,
                height: tooltipBoxHeight
            }, result;
        }, this._component = component, this._chartOption = component.getOption(), this._env = this._chartOption.mode, 
        this._chartContainer = this._chartOption.globalInstance.getContainer(), this._compiler = component.getCompiler(), 
        this._id = tooltipId, this._initFromSpec();
    }
    hideTooltip(params) {
        return this.changeTooltip(!1, params);
    }
    release() {
        var _a, _b, _c;
        this._clearAllCache();
        const spec = null !== (_a = this._component.getSpec()) && void 0 !== _a ? _a : {};
        spec.handler ? null === (_c = (_b = spec.handler).release) || void 0 === _c || _c.call(_b) : (this._removeTooltip(), 
        this._isReleased = !0);
    }
    _clearAllCache() {
        this._clearCacheOfContent(), this._clearCacheOfPosition();
    }
    _clearCacheOfContent() {
        this._cacheViewSpec = void 0, this._cacheActualTooltip = void 0;
    }
    _clearCacheOfPosition() {
        this._isTooltipPaused = !1, this._isPointerEscaped = !1, clearTimeout(this._cachePointerTimer), 
        this._cachePointerTimer = -1, this._cachePointerPosition = void 0, this._cacheTooltipPosition = void 0, 
        this._cacheTooltipSize = void 0;
    }
    _throttle(callback) {
        const tooltipSpec = this._component.getSpec();
        let wait;
        return wait = (0, vutils_1.isNumber)(tooltipSpec.throttleInterval) ? tooltipSpec.throttleInterval : "html" === tooltipSpec.renderMode && tooltipSpec.transitionDuration ? 50 : 10, 
        (0, vutils_1.throttle)(callback, wait);
    }
    _getDefaultOption() {
        var _a, _b;
        const {offset: offset} = this._component.getSpec();
        return Object.assign(Object.assign({}, constants_1.DEFAULT_OPTIONS), {
            offsetX: null !== (_a = null == offset ? void 0 : offset.x) && void 0 !== _a ? _a : constants_1.DEFAULT_OPTIONS.offsetX,
            offsetY: null !== (_b = null == offset ? void 0 : offset.y) && void 0 !== _b ? _b : constants_1.DEFAULT_OPTIONS.offsetY
        });
    }
    _getTooltipBoxSize(actualTooltip, changePositionOnly) {
        var _a, _b, _c, _d, _e, _f;
        if (!changePositionOnly || (0, vutils_1.isNil)(this._attributes)) {
            const chartTheme = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
            this._attributes = (0, attribute_1.getTooltipAttributes)(actualTooltip, this._component.getSpec(), chartTheme);
        }
        return {
            width: null === (_d = null === (_c = this._attributes) || void 0 === _c ? void 0 : _c.panel) || void 0 === _d ? void 0 : _d.width,
            height: null === (_f = null === (_e = this._attributes) || void 0 === _e ? void 0 : _e.panel) || void 0 === _f ? void 0 : _f.height
        };
    }
    _getPointerPositionRelativeToTooltipParent(params) {
        var _a, _b;
        let {canvasX: x, canvasY: y} = params.event;
        const invalidPosition = {
            x: 1 / 0,
            y: 1 / 0
        }, tooltipSpec = this._cacheViewSpec, isCanvas = "canvas" === tooltipSpec.renderMode, tooltipParentElement = this._getParentElement(tooltipSpec);
        let relativePosOffset = {
            x: 0,
            y: 0
        }, tooltipParentElementRect = {
            x: 0,
            y: 0
        }, chartElementScale = 1, tooltipParentElementScale = 1;
        if ((0, env_1.isTrueBrowser)(this._env) && !tooltipSpec.confine && !isCanvas) {
            tooltipParentElementRect = null !== (_a = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _a ? _a : invalidPosition;
            const chartElement = null !== (_b = this._compiler.getCanvas()) && void 0 !== _b ? _b : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
            relativePosOffset = {
                x: chartElementRect.x - tooltipParentElementRect.x,
                y: chartElementRect.y - tooltipParentElementRect.y
            }, chartElementScale = (0, common_1.getScale)(chartElement, chartElementRect), tooltipParentElementScale = (0, 
            common_1.getScale)(tooltipParentElement, tooltipParentElementRect);
        }
        return x *= chartElementScale, y *= chartElementScale, (0, env_1.isTrueBrowser)(this._env) && (x += relativePosOffset.x, 
        y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale, 
        {
            x: x,
            y: y
        };
    }
    _isPointerMovingToTooltip(params) {
        if (!this._cacheTooltipPosition || !this._cacheTooltipSize || !this._cachePointerPosition) return !1;
        const {width: tooltipWidth, height: tooltipHeight} = this._cacheTooltipSize, {x: tooltipX = 0, y: tooltipY} = this._cacheTooltipPosition, pos = this._getPointerPositionRelativeToTooltipParent(params);
        if ((0, vutils_1.pointInRect)(pos, {
            x1: tooltipX,
            y1: tooltipY,
            x2: tooltipX + tooltipWidth,
            y2: tooltipY + tooltipHeight
        }, !1)) return !0;
        const a = {
            x: tooltipX,
            y: tooltipY
        }, b = {
            x: a.x + tooltipWidth,
            y: a.y
        }, c = {
            x: a.x,
            y: a.y + tooltipHeight
        }, d = {
            x: b.x,
            y: c.y
        }, oldPos = this._cachePointerPosition;
        return (0, vutils_1.polygonContainPoint)([ oldPos, a, b ], pos.x, pos.y) || (0, 
        vutils_1.polygonContainPoint)([ oldPos, c, d ], pos.x, pos.y) || (0, vutils_1.polygonContainPoint)([ oldPos, a, d ], pos.x, pos.y) || (0, 
        vutils_1.polygonContainPoint)([ oldPos, b, c ], pos.x, pos.y);
    }
    _getParentElement(spec) {
        return spec.parentElement;
    }
    getTooltipContainer() {
        return this._container;
    }
    _initFromSpec() {
        this._option = this._getDefaultOption(), this.changeTooltip = this._throttle(this._changeTooltip), 
        this.changeTooltipPosition = this._throttle(this._changeTooltipPosition);
    }
    reInit() {
        this._initFromSpec();
    }
}

exports.BaseTooltipHandler = BaseTooltipHandler;
//# sourceMappingURL=base.js.map
