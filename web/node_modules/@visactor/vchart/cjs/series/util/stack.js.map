{"version":3,"sources":["../src/series/util/stack.ts"],"names":[],"mappings":";;;AACA,4CAAqD;AAErD,SAAgB,kBAAkB,CAChC,UAA2B,EAC3B,YAAqB,EACrB,OAOC;IAED,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QAEhC,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC;QACnC,IAAI,YAAY,EAAE;YAChB,UAAU,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC,OAAO,EAAE,CAAC;SAC3C;QAED,IAAI,KAAa,CAAC;QAClB,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,EAAE,EAAE;;YAE3C,MAAM,YAAY,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,YAAY,CAAC;YAC9C,MAAM,WAAW,GAAG,MAAA,MAAA,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,EAAC,QAAQ,mDAAG,CAAC,CAAC,CAAC;YACxD,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,SAAS,EAAE,CAAC;YAGlD,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;gBAClD,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBACrE,MAAM,EAAE,GAAG,IAAA,yBAAiB,EAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,EAAE,WAAW,CAAC,CAAC;gBACvE,IAAI,CAAC,GAAG,IAAA,yBAAiB,EAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,WAAW,CAAC,CAAC;gBAElE,IAAI,KAAK,KAAK,CAAC,IAAI,MAAM,KAAK,CAAC,EAAE;oBAC/B,KAAK,GAAG,EAAE,CAAC;iBACZ;gBAED,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;gBAC9B,IAAI,MAAM,GAAG,YAAY,EAAE;oBACzB,MAAM,GAAG,YAAY,CAAC;iBACvB;gBAED,IAAI,IAAI,GAAG,CAAC,CAAC;gBACb,IAAI,CAAC,GAAG,EAAE,EAAE;oBACV,IAAI,GAAG,CAAC,CAAC,CAAC;iBACX;qBAAM,IAAI,CAAC,KAAK,EAAE,EAAE;oBACnB,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACnE;gBACD,CAAC,GAAG,KAAK,GAAG,IAAI,GAAG,MAAM,CAAC;gBAC1B,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;gBAC3B,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACrB,KAAK,GAAG,CAAC,CAAC;aACX;QACH,CAAC,CAAC,CAAC;KACJ;IACD,KAAK,MAAM,GAAG,IAAI,UAAU,CAAC,KAAK,EAAE;QAClC,kBAAkB,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;KAClE;AACH,CAAC;AAzDD,gDAyDC","file":"stack.js","sourcesContent":["import type { IStackCacheNode } from '../../util/data';\nimport { valueInScaleRange } from '../../util/scale';\n\nexport function stackWithMinHeight(\n  stackCache: IStackCacheNode,\n  stackInverse: boolean,\n  context: {\n    isVertical: boolean;\n    start: string;\n    end: string;\n    startMethod: string;\n    endMethod: string;\n    axisHelper: string;\n  }\n) {\n  if (stackCache.values.length > 0) {\n    // stack one group\n    let seriesInfo = stackCache.series;\n    if (stackInverse) {\n      seriesInfo = seriesInfo.slice().reverse();\n    }\n    // temp\n    let lastY: number;\n    seriesInfo.forEach(({ s, values }, sIndex) => {\n      // stack info in series\n      const barMinHeight = s.getSpec().barMinHeight;\n      const seriesScale = s[context.axisHelper].getScale?.(0);\n      const inverse = s[context.axisHelper].isInverse();\n\n      // stack\n      for (let index = 0; index < values.length; index++) {\n        const obj = values[stackInverse ? values.length - 1 - index : index];\n        const y1 = valueInScaleRange(s[context.startMethod](obj), seriesScale);\n        let y = valueInScaleRange(s[context.endMethod](obj), seriesScale);\n\n        if (index === 0 && sIndex === 0) {\n          lastY = y1;\n        }\n\n        let height = Math.abs(y1 - y);\n        if (height < barMinHeight) {\n          height = barMinHeight;\n        }\n\n        let flag = 1;\n        if (y < y1) {\n          flag = -1;\n        } else if (y === y1) {\n          flag = context.isVertical ? (inverse ? 1 : -1) : inverse ? -1 : 1;\n        }\n        y = lastY + flag * height;\n        obj[context.start] = lastY;\n        obj[context.end] = y;\n        lastY = y;\n      }\n    });\n  }\n  for (const key in stackCache.nodes) {\n    stackWithMinHeight(stackCache.nodes[key], stackInverse, context);\n  }\n}\n"]}