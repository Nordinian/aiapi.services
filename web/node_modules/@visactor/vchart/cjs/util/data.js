"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.stackGroup = exports.stack = exports.stackOffsetSilhouette = exports.stackTotal = exports.getRegionStackGroup = exports.getFieldAlias = exports.mergeFields = void 0;

const constant_1 = require("../constant"), type_1 = require("./type"), math_1 = require("./math");

function mergeFields(targetFields, mergeFields) {
    for (let i = 0; i < mergeFields.length; i++) {
        const element = mergeFields[i], _target = findFields(targetFields, element.key);
        _target ? _target.operations = [ ...new Set(_target.operations.concat(element.operations)) ] : targetFields.push(element);
    }
    return targetFields;
}

function findFields(list, fieldKey) {
    return list.find((i => i.key === fieldKey));
}

function getFieldAlias(dataView, field) {
    var _a;
    if (!dataView) return null != field ? field : null;
    const fields = dataView.getFields();
    return fields && fields[field] ? null !== (_a = fields[field].alias) && void 0 !== _a ? _a : field : null != field ? field : null;
}

function getRegionStackGroup(region, setInitialValue, filter) {
    const stackValueGroup = {};
    return region.getSeries().forEach((s => {
        var _a;
        const stackData = s.getStackData(), stackValue = s.getStackValue(), stackValueField = s.getStackValueField(), filterEnable = !filter || filter(s);
        stackData && stackValueField && filterEnable && (stackValueGroup[stackValue] = null !== (_a = stackValueGroup[stackValue]) && void 0 !== _a ? _a : {
            nodes: {}
        }, stackGroup(s, stackData, stackValueGroup[stackValue], stackValueField, setInitialValue));
    })), stackValueGroup;
}

function stackTotal(stackData, valueField) {
    if ("values" in stackData && stackData.values.length) {
        const total = (0, math_1.sum)(stackData.values, valueField), percent = (0, math_1.max)(stackData.values, constant_1.STACK_FIELD_END_PERCENT);
        stackData.values.forEach((v => {
            v[constant_1.STACK_FIELD_TOTAL] = total, v[constant_1.STACK_FIELD_TOTAL_PERCENT] = percent, 
            delete v[constant_1.STACK_FIELD_TOTAL_TOP];
        }));
        stackData.values.reduce(((max, current) => current[constant_1.STACK_FIELD_END] > max[constant_1.STACK_FIELD_END] ? current : max))[constant_1.STACK_FIELD_TOTAL_TOP] = !0;
    } else for (const key in stackData.nodes) stackTotal(stackData.nodes[key], valueField);
}

function stackOffsetSilhouette(stackCache) {
    if (!stackCache.values.length) return;
    const centerValue = stackCache.values[stackCache.values.length - 1][constant_1.STACK_FIELD_END] / 2;
    for (let j = 0; j < stackCache.values.length; j++) stackCache.values[j][constant_1.STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][constant_1.STACK_FIELD_START] - centerValue, 
    stackCache.values[j][constant_1.STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][constant_1.STACK_FIELD_END] - centerValue;
}

function stack(stackCache, stackInverse, hasPercent) {
    if (stackCache.values.length > 0) {
        let positiveStart = 0, negativeStart = 0, sign = 1, value = 0;
        const maxLength = stackCache.values.length;
        for (let index = 0; index < maxLength; index++) {
            const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
            value = v[constant_1.STACK_FIELD_END], value >= 0 ? (v[constant_1.STACK_FIELD_START] = positiveStart, 
            positiveStart += v[constant_1.STACK_FIELD_END], v[constant_1.STACK_FIELD_END] = positiveStart) : (v[constant_1.STACK_FIELD_START] = negativeStart, 
            negativeStart += v[constant_1.STACK_FIELD_END], v[constant_1.STACK_FIELD_END] = negativeStart);
        }
        if (hasPercent) for (let index = 0; index < maxLength; index++) {
            const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
            value = v[constant_1.STACK_FIELD_END];
            const denominator = value >= 0 ? positiveStart : negativeStart;
            sign = value >= 0 ? 1 : -1, v[constant_1.STACK_FIELD_START_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[constant_1.STACK_FIELD_START] / denominator) * sign, 
            v[constant_1.STACK_FIELD_END_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[constant_1.STACK_FIELD_END] / denominator) * sign;
        }
    }
    for (const key in stackCache.nodes) stack(stackCache.nodes[key], stackInverse, hasPercent);
}

function stackGroup(s, stackData, stackCache, valueField, setInitialValue) {
    if ("values" in stackData) return setInitialValue && stackData.values.forEach((v => v[constant_1.STACK_FIELD_END] = (0, 
    type_1.toValidNumber)(v[valueField]))), stackCache.values.push(...stackData.values), 
    void stackCache.series.push({
        s: s,
        values: stackData.values
    });
    for (const key in stackData.nodes) !stackCache.nodes[key] && (stackCache.nodes[key] = {
        values: [],
        series: [],
        nodes: {}
    }), stackGroup(s, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue);
}

exports.mergeFields = mergeFields, exports.getFieldAlias = getFieldAlias, exports.getRegionStackGroup = getRegionStackGroup, 
exports.stackTotal = stackTotal, exports.stackOffsetSilhouette = stackOffsetSilhouette, 
exports.stack = stack, exports.stackGroup = stackGroup;
//# sourceMappingURL=data.js.map
