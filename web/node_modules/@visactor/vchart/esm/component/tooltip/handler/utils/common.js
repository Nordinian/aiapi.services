import { isFunction, isObject, isString, isNil, isArray, isValid } from "@visactor/vutils";

import { getRichTextBounds } from "@visactor/vrender-core";

export function escapeHTML(value) {
    return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\(/g, "&#40;").replace(/  /g, " &nbsp;");
}

export const getTooltipContentValue = (field, datum, params) => isNil(field) ? field : isFunction(field) ? field(datum, params) : field;

export const getTooltipPatternValue = (field, data, params) => {
    if (isNil(field)) return field;
    if (isArray(field)) {
        const result = [];
        return field.forEach((item => {
            if (isFunction(item)) {
                const value = item(data, params);
                isValid(value) && result.push(value);
            } else result.push(item);
        })), result;
    }
    return isFunction(field) ? field(data, params) : field;
};

export function getFirstDatumFromTooltipData(data) {
    var _a;
    const dimInfoList = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.series) ? [ {
        data: data,
        value: ""
    } ] : data;
    for (const {data: dataList} of dimInfoList) for (const {datum: datumList} of dataList) for (const datumItem of null != datumList ? datumList : []) if (datumItem) return datumItem;
}

export function pickFirstValidValue(isValid, ...elements) {
    for (const ele of elements) if (isValid(ele)) return ele;
}

export function convertToColorString(color, defaultColor = "#000") {
    return color ? isString(color) ? color : isObject(color) && color.stops && color.stops[0] && color.stops[0].color || defaultColor : defaultColor;
}

export const getScale = (element, boundingClientRect) => element ? (boundingClientRect || (boundingClientRect = element.getBoundingClientRect()), 
element.offsetWidth > 0 ? boundingClientRect.width / element.offsetWidth : boundingClientRect.height / element.offsetHeight) : 1;

export const measureTooltipText = (text, style) => {
    var _a;
    let textLines, textConfig;
    "rich" !== (null == text ? void 0 : text.type) && "html" !== (null == text ? void 0 : text.type) ? (text = (null != text ? text : "").toString(), 
    style.multiLine ? (textLines = text.split("\n"), textLines = textLines.map(((line, i) => i < textLines.length - 1 ? line + "\n" : line))) : textLines = [ text ], 
    textConfig = textLines.map((line => Object.assign(Object.assign({}, style), {
        text: line
    })))) : (textConfig = text.text, textLines = text);
    const bound = getRichTextBounds({
        wordBreak: null !== (_a = style.wordBreak) && void 0 !== _a ? _a : "break-word",
        maxWidth: style.maxWidth ? style.maxWidth : void 0,
        width: 0,
        height: 0,
        textConfig: textConfig
    });
    return {
        width: bound.width(),
        height: bound.height(),
        text: textLines
    };
};
//# sourceMappingURL=common.js.map
