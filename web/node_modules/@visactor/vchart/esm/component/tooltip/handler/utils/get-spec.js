import { mergeSpec } from "../../../../util/spec/merge-spec";

import { makeDefaultPattern } from "./pattern";

import { getTooltipActualActiveType } from "../../utils/common";

import { memoize, isValid, array, isFunction, isNil, cloneDeep } from "@visactor/vutils";

export const getTooltipSpecForShow = (activeType, globalSpec, series, dimensionInfo) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const finalSpec = Object.assign(Object.assign({}, globalSpec), {
        activeType: activeType
    });
    if ("mark" === activeType && series) {
        const seriesSpec = null !== (_b = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        if (isValid(seriesSpec.visible) || isValid(seriesSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(seriesSpec).includes("mark") : isValid(globalSpec.visible) || isValid(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes("mark") : finalSpec.visible = !0, 
        finalSpec.handler = null !== (_d = null !== (_c = seriesSpec.handler) && void 0 !== _c ? _c : globalSpec.handler) && void 0 !== _d ? _d : void 0, 
        null === (_e = finalSpec.handler) || void 0 === _e ? void 0 : _e.showTooltip) return finalSpec;
    } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        if (getSeriesListFromDimensionInfo(dimensionInfo).every((series => {
            var _a;
            return !getTooltipActualActiveType(null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec).includes("dimension");
        })) ? finalSpec.visible = !1 : isValid(globalSpec.visible) || isValid(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes("dimension") : finalSpec.visible = !0, 
        finalSpec.handler = null !== (_f = globalSpec.handler) && void 0 !== _f ? _f : void 0, 
        null === (_g = finalSpec.handler) || void 0 === _g ? void 0 : _g.showTooltip) return finalSpec;
    }
    const defaultPattern = getDefaultTooltipPattern(activeType, series, dimensionInfo), seriesPattern = getSeriesTooltipPattern(activeType, series, dimensionInfo), userPattern = mergeSpec({}, cloneDeep(globalSpec[activeType]), seriesPattern), defaultPatternTitle = defaultPattern.title, titleShape = getShapePattern(void 0, userPattern, void 0, defaultPatternTitle);
    if (isValid(userPattern.title)) if (isFunction(userPattern.title)) {
        const userPatternTitle = userPattern.title;
        userPattern.title = (data, params) => {
            var _a;
            const userResult = null !== (_a = userPatternTitle(data, params)) && void 0 !== _a ? _a : {};
            return Object.assign(Object.assign({}, titleShape), userResult);
        };
    } else userPattern.title = Object.assign(Object.assign(Object.assign({}, defaultPattern.title), titleShape), userPattern.title); else userPattern.title = Object.assign(Object.assign({}, defaultPattern.title), titleShape);
    const defaultPatternContent = array(defaultPattern.content);
    if (isValid(userPattern.content)) {
        const shapePatternMap = getShapePatternMapOfEachSeries(defaultPatternContent);
        if (isFunction(userPattern.content)) {
            const userPatternContent = userPattern.content;
            userPattern.content = (data, params) => {
                var _a;
                const newPatternContent = [];
                return array(null !== (_a = userPatternContent(data, params)) && void 0 !== _a ? _a : []).forEach((userLine => {
                    newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
                })), newPatternContent;
            };
        } else {
            const newPatternContent = [];
            array(userPattern.content).forEach((userLine => {
                newPatternContent.push(Object.assign(Object.assign({}, getShapePattern(userLine, userPattern, shapePatternMap)), userLine));
            })), userPattern.content = newPatternContent;
        }
    } else userPattern.content = defaultPatternContent.map((line => Object.assign(Object.assign({}, line), getShapePattern(void 0, userPattern, void 0, line))));
    return finalSpec[activeType] = Object.assign(Object.assign(Object.assign({}, defaultPattern), userPattern), {
        activeType: activeType
    }), finalSpec;
};

const getDefaultTooltipPattern = (activeType, series, dimensionInfo) => {
    var _a;
    let defaultPattern = {};
    if ("mark" === activeType && series) defaultPattern = null !== (_a = makeDefaultPattern(series, "mark")) && void 0 !== _a ? _a : {}; else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        const patternList = [];
        dimensionInfo[0].data.forEach((data => {
            const {series: series} = data, mockDimensionInfo = [ Object.assign(Object.assign({}, dimensionInfo[0]), {
                data: [ data ]
            }) ], pattern = makeDefaultPattern(series, "dimension", mockDimensionInfo);
            pattern && patternList.push(pattern);
        }));
        const defaultPatternContent = [];
        patternList.forEach((({content: content}) => {
            isFunction(content) ? defaultPatternContent.push(content) : defaultPatternContent.push(...array(content));
        })), defaultPattern = Object.assign(Object.assign({}, patternList[0]), {
            content: defaultPatternContent
        });
    }
    return defaultPattern;
}, getSeriesTooltipPattern = (activeType, series, dimensionInfo) => {
    var _a, _b;
    let seriesPattern = {};
    if ("mark" === activeType && series) {
        const seriesSpec = null !== (_b = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        seriesPattern = seriesSpec.mark ? cloneDeep(seriesSpec.mark) : {};
    } else if ("dimension" === activeType && (null == dimensionInfo ? void 0 : dimensionInfo.length)) {
        const seriesPatternList = getSeriesListFromDimensionInfo(dimensionInfo).filter((series => {
            var _a;
            const spec = null === (_a = series.tooltipHelper) || void 0 === _a ? void 0 : _a.spec;
            return isValid(null == spec ? void 0 : spec.dimension) && getTooltipActualActiveType(spec).includes("dimension");
        })).map((series => series.tooltipHelper.spec.dimension));
        if (seriesPatternList.length) {
            let seriesPatternContent = [];
            seriesPatternList.every((({content: content}) => isNil(content))) ? seriesPatternContent = void 0 : seriesPatternList.forEach((({content: content}) => {
                isNil(content) || (isFunction(content) ? null == seriesPatternContent || seriesPatternContent.push(content) : null == seriesPatternContent || seriesPatternContent.push(...array(content)));
            })), seriesPattern = Object.assign(Object.assign({}, seriesPatternList[0]), {
                content: seriesPatternContent
            });
        }
    }
    return seriesPattern;
}, getSeriesListFromDimensionInfo = memoize((dimensionInfo => dimensionInfo.reduce(((list, cur) => list.concat(cur.data.map((data => data.series)).filter(isValid))), []))), getShapePatternMapOfEachSeries = content => {
    const shapePatternMap = {};
    return content.forEach((line => {
        var _a;
        const key = null !== (_a = line.seriesId) && void 0 !== _a ? _a : 0;
        shapePatternMap[key] || (shapePatternMap[key] = line);
    })), shapePatternMap;
}, getShapePattern = (userLinePattern, userPattern, shapePatternMap, defaultShapePattern) => {
    var _a, _b;
    const shapePatternFromMap = null !== (_b = null == shapePatternMap ? void 0 : shapePatternMap[null !== (_a = null == userLinePattern ? void 0 : userLinePattern.seriesId) && void 0 !== _a ? _a : 0]) && void 0 !== _b ? _b : null == shapePatternMap ? void 0 : shapePatternMap[0], shapeKeys = new Set([].concat(Object.keys(null != userLinePattern ? userLinePattern : {}), Object.keys(null != userPattern ? userPattern : {}), Object.keys(null != shapePatternFromMap ? shapePatternFromMap : {}), Object.keys(null != defaultShapePattern ? defaultShapePattern : {})).filter((key => key.toLowerCase().includes("shape")))), shapePattern = {};
    return shapeKeys.forEach((key => {
        var _a, _b, _c;
        const value = null !== (_c = null !== (_b = null !== (_a = null == userLinePattern ? void 0 : userLinePattern[key]) && void 0 !== _a ? _a : null == userPattern ? void 0 : userPattern[key]) && void 0 !== _b ? _b : null == shapePatternFromMap ? void 0 : shapePatternFromMap[key]) && void 0 !== _c ? _c : null == defaultShapePattern ? void 0 : defaultShapePattern[key];
        void 0 !== value && (shapePattern[key] = value);
    })), shapePattern;
};
//# sourceMappingURL=get-spec.js.map
