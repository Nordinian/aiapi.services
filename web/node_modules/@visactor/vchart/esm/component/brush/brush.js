import { AttributeLevel, ChartEvent, LayoutZIndex } from "../../constant";

import { BaseComponent } from "../base/base-component";

import { ComponentTypeEnum } from "../interface/type";

import { Brush as BrushComponent, IOperateType as BrushEvent } from "@visactor/vrender-components";

import { array, isNil, polygonIntersectPolygon, isValid } from "@visactor/vutils";

import { transformToGraphic } from "../../util/style";

import { isEqual } from "@visactor/vutils";

import { Factory } from "../../core/factory";

const IN_BRUSH_STATE = "inBrush", OUT_BRUSH_STATE = "outOfBrush";

export class Brush extends BaseComponent {
    constructor() {
        super(...arguments), this.layoutType = "none", this.type = ComponentTypeEnum.brush, 
        this.name = ComponentTypeEnum.brush, this.specKey = "brush", this.layoutZIndex = LayoutZIndex.Brush, 
        this._linkedSeries = [], this._itemMap = {}, this._linkedItemMap = {}, this._inBrushElementsMap = {}, 
        this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, 
        this._needInitOutState = !0, this._cacheInteractiveRangeAttrs = [], this._needDisablePickable = !1;
    }
    init() {
        const inBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.inBrush), outOfBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.outOfBrush);
        this._option.getAllSeries().forEach((s => {
            s.getActiveMarks().forEach((m => {
                m && (s.setMarkStyle(m, Object.assign({}, inBrushMarkAttr), "inBrush", AttributeLevel.Series), 
                s.setMarkStyle(m, Object.assign({}, outOfBrushMarkAttr), "outOfBrush", AttributeLevel.Series));
            }));
        }));
    }
    static getSpecInfo(chartSpec) {
        const brushSpec = chartSpec[this.specKey];
        if (!isNil(brushSpec) && !1 !== brushSpec.visible) return [ {
            spec: brushSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.brush
        } ];
    }
    created() {
        super.created(), this.initEvent(), this._bindRegions(), this._bindLinkedSeries(), 
        this._initNeedOperatedItem();
    }
    _extendDataInBrush(elementsMap) {
        const data = [];
        for (const brushName in elementsMap) for (const elementKey in elementsMap[brushName]) data.push(elementsMap[brushName][elementKey].data[0]);
        return data;
    }
    _extendDatumOutOfBrush(elementsMap) {
        const data = [];
        for (const elementKey in elementsMap) data.push(elementsMap[elementKey].data[0]);
        return data;
    }
    _getBrushInteractiveAttr(region) {
        const regionLayoutPosition = region.getLayoutStartPoint(), regionLayoutRect = region.getLayoutRect(), seriesRegionStartX = regionLayoutPosition.x, seriesRegionEndX = seriesRegionStartX + regionLayoutRect.width, seriesRegionStartY = regionLayoutPosition.y, seriesRegionEndY = seriesRegionStartY + regionLayoutRect.height;
        return {
            interactiveRange: {
                minY: seriesRegionStartY,
                maxY: seriesRegionEndY,
                minX: seriesRegionStartX,
                maxX: seriesRegionEndX
            },
            xRange: [ seriesRegionStartX, seriesRegionEndX ],
            yRange: [ seriesRegionStartY, seriesRegionEndY ]
        };
    }
    _updateBrushComponent(region, componentIndex) {
        const interactiveAttr = this._getBrushInteractiveAttr(region), brushComponent = this._brushComponents[componentIndex];
        brushComponent.setAttributes(interactiveAttr), this._initMarkBrushState(componentIndex, ""), 
        brushComponent.children[0].removeAllChild(), this._needInitOutState = !0;
    }
    _createBrushComponent(region, componentIndex) {
        var _a, _b;
        const interactiveAttr = this._getBrushInteractiveAttr(region), brush = new BrushComponent(Object.assign(Object.assign(Object.assign({
            zIndex: this.layoutZIndex,
            brushStyle: transformToGraphic(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.style)
        }, interactiveAttr), this._spec), {
            disableTriggerEvent: this._option.disableTriggerEvent
        }));
        brush.id = null !== (_b = this._spec.id) && void 0 !== _b ? _b : `brush-${this.id}`, 
        this.getContainer().add(brush);
        const {brushMode: brushMode = "single"} = this._spec;
        this._brushComponents.push(brush), this._cacheInteractiveRangeAttrs.push(interactiveAttr), 
        brush.addEventListener(BrushEvent.drawStart, (e => {
            this._emitEvent(ChartEvent.brushStart, region);
        })), brush.addEventListener(BrushEvent.moveStart, (e => {
            this._emitEvent(ChartEvent.brushStart, region);
        })), brush.addEventListener(BrushEvent.drawing, (e => {
            this._needInitOutState && "single" === brushMode && this._initMarkBrushState(componentIndex, "outOfBrush"), 
            this._needInitOutState = !1, this._needDisablePickable = !0, this._handleBrushChange(ChartEvent.brushChange, region, e);
        })), brush.addEventListener(BrushEvent.moving, (e => {
            this._handleBrushChange(ChartEvent.brushChange, region, e);
        })), brush.addEventListener(BrushEvent.brushClear, (e => {
            this._initMarkBrushState(componentIndex, ""), this._needInitOutState = !0, this._needDisablePickable = !1, 
            this._handleBrushChange(ChartEvent.brushChange, region, e), this._handleBrushChange(ChartEvent.brushClear, region, e);
        })), brush.addEventListener(BrushEvent.drawEnd, (e => {
            this._needInitOutState = !0, this._needDisablePickable = !1, this._handleBrushChange(ChartEvent.brushEnd, region, e);
        })), brush.addEventListener(BrushEvent.moveEnd, (e => {
            this._handleBrushChange(ChartEvent.brushEnd, region, e);
        }));
    }
    _handleBrushChange(eventType, region, e) {
        const {operateMask: operateMask} = e.detail;
        this._reconfigItem(operateMask, region), this._reconfigLinkedItem(operateMask, region), 
        this._emitEvent(eventType, region);
    }
    _emitEvent(eventType, region) {
        this.event.emit(eventType, {
            model: this,
            value: {
                operateType: eventType,
                operateRegion: region,
                inBrushData: this._extendDataInBrush(this._inBrushElementsMap),
                outOfBrushData: this._extendDatumOutOfBrush(this._outOfBrushElementsMap),
                linkInBrushData: this._extendDataInBrush(this._linkedInBrushElementsMap),
                linkOutOfBrushData: this._extendDatumOutOfBrush(this._linkedOutOfBrushElementsMap),
                inBrushElementsMap: this._inBrushElementsMap,
                outOfBrushElementsMap: this._outOfBrushElementsMap,
                linkedInBrushElementsMap: this._linkedInBrushElementsMap,
                linkedOutOfBrushElementsMap: this._linkedOutOfBrushElementsMap
            }
        });
    }
    _transformBrushedMarkAttr(brushedStyle) {
        const styleResult = {};
        return (null == brushedStyle ? void 0 : brushedStyle.symbol) && (styleResult.symbolType = brushedStyle.symbol), 
        (null == brushedStyle ? void 0 : brushedStyle.symbolSize) && (styleResult.size = brushedStyle.symbolSize), 
        (null == brushedStyle ? void 0 : brushedStyle.color) && (styleResult.fill = brushedStyle.color), 
        (null == brushedStyle ? void 0 : brushedStyle.colorAlpha) && (styleResult.fillOpacity = brushedStyle.colorAlpha), 
        Object.assign(Object.assign({}, transformToGraphic(brushedStyle)), styleResult);
    }
    _reconfigItem(operateMask, region) {
        this._itemMap[region.id].forEach((mark => {
            const grammarMark = mark.getProduct();
            if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
            grammarMark.elements.forEach((el => {
                var _a, _b, _c;
                const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
                (null === (_a = this._outOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem) ? (el.addState("inBrush"), 
                this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), 
                this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, 
                delete this._outOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._inBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem) && (el.removeState("inBrush"), 
                el.addState("outOfBrush"), this._outOfBrushElementsMap[elementKey] = el, delete this._inBrushElementsMap[operateMask.name][elementKey]), 
                graphicItem.setAttribute("pickable", !this._needDisablePickable);
            }));
        }));
    }
    _reconfigLinkedItem(operateMask, region) {
        const regionLayoutPos = region.getLayoutStartPoint(), seriesId = region.getSeries().map((s => s.id));
        this._linkedSeries.forEach((s => {
            if (!seriesId.includes(s.id)) {
                const sRegionLayoutPos = s.getRegion().getLayoutStartPoint(), regionOffsetX = sRegionLayoutPos.x - regionLayoutPos.x, regionOffsetY = sRegionLayoutPos.y - regionLayoutPos.y;
                this._linkedItemMap[s.id].forEach((mark => {
                    const grammarMark = mark.getProduct();
                    if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
                    grammarMark.elements.forEach((el => {
                        var _a, _b, _c;
                        const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
                        (null === (_a = this._linkedOutOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem, {
                            dx: regionOffsetX,
                            dy: regionOffsetY
                        }) ? (el.addState("inBrush"), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), 
                        this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, 
                        delete this._linkedOutOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._linkedInBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem, {
                            dx: regionOffsetX,
                            dy: regionOffsetY
                        }) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._linkedOutOfBrushElementsMap[elementKey] = el), 
                        graphicItem.setAttribute("pickable", !this._needDisablePickable);
                    }));
                }));
            }
        }));
    }
    _isBrushContainItem(brushMask, item, linkedOffset) {
        var _a, _b, _c;
        if (!(null == brushMask ? void 0 : brushMask.globalTransMatrix) || !(null === (_a = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _a ? void 0 : _a.points)) return !1;
        const points = null !== (_c = null === (_b = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _b ? void 0 : _b.points) && void 0 !== _c ? _c : [], {a: a, b: b, c: c, d: d, e: e, f: f} = brushMask.globalTransMatrix, dx = (null == linkedOffset ? void 0 : linkedOffset.dx) || 0, dy = (null == linkedOffset ? void 0 : linkedOffset.dy) || 0, pointsCoord = points.map((p => ({
            x: a * p.x + c * p.y + e + dx,
            y: b * p.x + d * p.y + f + dy
        })));
        brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy);
        const x = item.globalTransMatrix.e, y = item.globalTransMatrix.f;
        let itemBounds = [];
        if ("symbol" === item.type) {
            const {size: itemSize = 0} = null == item ? void 0 : item.attribute, size = array(itemSize)[0] / 2;
            return itemBounds = [ {
                x: x - size,
                y: y - size
            }, {
                x: x + size,
                y: y - size
            }, {
                x: x + size,
                y: y + size
            }, {
                x: x - size,
                y: y + size
            } ], polygonIntersectPolygon(pointsCoord, itemBounds);
        }
        if ("rect" === item.type) {
            const {x1: x1, x2: x2, y1: y1, y2: y2} = null == item ? void 0 : item.AABBBounds, width = Math.abs(x1 - x2), height = Math.abs(y1 - y2);
            return itemBounds = [ {
                x: x,
                y: y
            }, {
                x: x + width,
                y: y
            }, {
                x: x + width,
                y: y + height
            }, {
                x: x,
                y: y + height
            } ], polygonIntersectPolygon(pointsCoord, itemBounds);
        }
        return brushMask.globalAABBBounds.intersects(item.globalAABBBounds);
    }
    _bindRegions() {
        isValid(this._spec.regionId) && isValid(this._spec.regionIndex) && (this._relativeRegions = this._option.getAllRegions()), 
        this._relativeRegions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
    }
    _bindLinkedSeries() {
        isValid(this._spec.brushLinkSeriesId) && isValid(this._spec.brushLinkSeriesIndex) || (this._linkedSeries = this._option.getSeriesInUserIdOrIndex(array(this._spec.brushLinkSeriesId), array(this._spec.brushLinkSeriesIndex)));
    }
    _initNeedOperatedItem() {
        const seriesUserId = this._spec.seriesId, seriesIndex = this._spec.seriesIndex;
        this._relativeRegions.forEach((r => {
            const allMarks = [];
            r.getSeries().forEach((s => {
                (seriesUserId && array(seriesUserId).includes(s.userId.toString()) || seriesIndex && array(seriesIndex).includes(s.getSpecIndex()) || !seriesIndex && !seriesUserId) && allMarks.push(...s.getMarksWithoutRoot()), 
                this._itemMap[r.id] = allMarks;
            }));
        })), this._linkedSeries.forEach((s => {
            this._linkedItemMap[s.id] = s.getMarksWithoutRoot();
        }));
    }
    _initMarkBrushState(componentIndex, stateName) {
        this._brushComponents.forEach(((brush, index) => {
            index !== componentIndex && brush.children[0].removeAllChild();
        })), this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, 
        this._linkedOutOfBrushElementsMap = {}, this._option.getAllSeries().forEach((s => {
            s.getMarksWithoutRoot().forEach((mark => {
                const grammarMark = mark.getProduct();
                if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length) return;
                grammarMark.elements.forEach((el => {
                    const elementKey = mark.id + "_" + el.key;
                    el.removeState("inBrush"), el.removeState("outOfBrush"), el.addState(stateName), 
                    this._outOfBrushElementsMap[elementKey] = el, this._linkedOutOfBrushElementsMap[elementKey] = el;
                }));
            }));
        }));
    }
    initEvent() {}
    onRender(ctx) {}
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return this._brushComponents;
    }
    _compareSpec(spec, prevSpec) {
        this._brushComponents && this._relativeRegions.forEach(((region, index) => {
            this._updateBrushComponent(region, index);
        }));
        const result = super._compareSpec(spec, prevSpec);
        return isEqual(prevSpec, spec) || (result.reRender = !0, result.reMake = !0), result;
    }
    onLayoutEnd(ctx) {
        var _a;
        if (super.onLayoutEnd(ctx), this._option.disableTriggerEvent) return;
        (null === (_a = this._spec.visible) || void 0 === _a || _a) && (this._brushComponents ? this._relativeRegions.forEach(((region, index) => {
            this._updateBrushComponent(region, index);
        })) : (this._brushComponents = [], this._relativeRegions.forEach(((region, index) => {
            this._createBrushComponent(region, index);
        }))));
    }
    clearGraphic() {
        this._brushComponents && this._brushComponents.forEach((brush => {
            brush._container.incrementalClearChild();
        }));
    }
    clear() {
        var _a;
        this._brushComponents && (null === (_a = this.getContainer()) || void 0 === _a || _a.removeChild(this._brushComponents), 
        this._brushComponents.forEach((brush => {
            brush.removeAllChild(), brush.releaseBrushEvents();
        })), this._brushComponents = null), super.clear();
    }
}

Brush.type = ComponentTypeEnum.brush, Brush.specKey = "brush";

export const registerBrush = () => {
    Factory.registerComponent(Brush.type, Brush);
};
//# sourceMappingURL=brush.js.map
