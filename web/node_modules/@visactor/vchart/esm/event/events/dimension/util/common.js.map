{"version":3,"sources":["../src/event/events/dimension/util/common.ts"],"names":[],"mappings":"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","file":"common.js","sourcesContent":["/* eslint-disable max-depth */\nimport type { IChart } from '../../../../chart/interface';\nimport type { IDimensionData, IDimensionInfo } from '../interface';\nimport { isNil, array, isValid, isValidNumber } from '@visactor/vutils';\nimport type { AxisComponent } from '../../../../component/axis/base-axis';\nimport type { CoordinateType, ILayoutPoint } from '../../../../typings';\nimport { isDiscrete } from '@visactor/vscale';\nimport type { ICartesianLinearAxisSpec } from '../../../../component';\nimport type { Maybe } from '@visactor/vutils';\n\nconst isInBound = (pos: ILayoutPoint, min: ILayoutPoint, max: ILayoutPoint): boolean =>\n  pos.x >= min.x && pos.x <= max.x && pos.y >= min.y && pos.y <= max.y;\n\nexport const isInRegionBound = (chart: IChart, axis: AxisComponent, pos: ILayoutPoint) => {\n  const regionList = chart.getRegionsInIds(array(axis.layout.layoutBindRegionID));\n  return regionList?.some(region => {\n    const rect = region.getLayoutRect();\n    const startPoint = region.getLayoutStartPoint();\n    return isInBound(\n      pos,\n      { x: startPoint.x, y: startPoint.y },\n      { x: rect.width + startPoint.x, y: rect.height + startPoint.y }\n    );\n  });\n};\n\nexport const isSameDimensionInfo = (a?: IDimensionInfo, b?: IDimensionInfo): boolean => {\n  if (a === b) {\n    return true;\n  }\n  if (isNil(a) || isNil(b)) {\n    return false;\n  }\n  if (a.value !== b.value) {\n    return false;\n  }\n  if (a.axis?.id !== b.axis?.id) {\n    return false;\n  }\n  return true;\n};\n\n/** 给定维度项的值，获取对应维度数据 */\nexport const getDimensionData = (\n  value: any,\n  axis: AxisComponent,\n  coordinate: CoordinateType,\n  getDimensionField: (series: any) => string | string[]\n): IDimensionData[] => {\n  const scale = axis.getScale();\n  const isDiscreteAxis = isDiscrete(scale.type);\n\n  const data: IDimensionData[] = [];\n  const regions = axis.getRegions(); // TODO: 直接从轴里取系列\n  for (const region of regions) {\n    const seriesList = region.getSeries();\n    for (const series of seriesList) {\n      if (series.coordinate === coordinate) {\n        const dimensionField = array(getDimensionField(series));\n        const viewData = series.getViewData()?.latestData;\n        if (dimensionField && viewData) {\n          if (isDiscreteAxis) {\n            data.push({\n              series,\n              datum: viewData.filter(\n                (datum: any) => datum[dimensionField[0]]?.toString() === value?.toString() // 获取该维度项所对应的数据\n              )\n            });\n          } else {\n            // 连续轴\n            if (isValid(dimensionField[1])) {\n              // 直方图情况，根据范围取 datum\n              data.push({\n                series,\n                datum: viewData.filter((datum: any) => {\n                  if (datum[dimensionField[0]]?.toString() === value?.toString()) {\n                    return true;\n                  }\n                  return (\n                    isValid(datum[dimensionField[0]]) &&\n                    isValid(datum[dimensionField[1]]) &&\n                    value >= datum[dimensionField[0]] &&\n                    value < datum[dimensionField[1]]\n                  );\n                })\n              });\n            } else {\n              // 散点图情况，依据轴上的配置判断\n              const range = (axis.getSpec() as ICartesianLinearAxisSpec).tooltipFilterRange;\n              const rangeArr = (isValidNumber(range) ? [-range, range] : range) as Maybe<[number, number]>;\n              let datums: any[] = [];\n              if (rangeArr) {\n                // 根据范围取 datum\n                viewData.forEach((datum: any) => {\n                  if (isValid(datum[dimensionField[0]])) {\n                    const delta = datum[dimensionField[0]] - value;\n                    if (delta >= rangeArr[0] && delta <= rangeArr[1]) {\n                      datums.push(datum);\n                    }\n                  }\n                });\n              } else {\n                // 根据最近距离取 datum\n                let minDelta = Infinity;\n                let deltaSign = 0;\n                viewData.forEach((datum: any) => {\n                  if (isValid(datum[dimensionField[0]])) {\n                    const delta = Math.abs(datum[dimensionField[0]] - value);\n                    const sign = Math.sign(datum[dimensionField[0]] - value);\n                    if (delta < minDelta) {\n                      minDelta = delta;\n                      datums = [datum];\n                      deltaSign = sign;\n                    } else if (delta === minDelta && sign === deltaSign) {\n                      datums.push(datum);\n                    }\n                  }\n                });\n              }\n              data.push({\n                series,\n                datum: datums\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return data;\n};\n\nexport const getAxis = <T extends AxisComponent>(\n  chart: IChart,\n  filter: (cmp: T) => boolean,\n  pos: ILayoutPoint\n): T[] | null => {\n  const axesComponents = chart\n    .getAllComponents()\n    .filter(c => c.specKey === 'axes' && filter(c as T) && isInRegionBound(chart, c as T, pos)) as T[];\n  if (!axesComponents.length) {\n    return null;\n  }\n  return axesComponents;\n};\n"]}