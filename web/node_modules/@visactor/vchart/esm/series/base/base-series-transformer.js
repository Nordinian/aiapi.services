import { BaseModelSpecTransformer } from "../../model/base-model-transformer";

import { array, get, isValid, mergeSpec, transformSeriesThemeToMerge } from "../../util";

import { getDirectionFromSeriesSpec } from "../util/spec";

export class BaseSeriesSpecTransformer extends BaseModelSpecTransformer {
    constructor() {
        super(...arguments), this.markLabelSpec = {};
    }
    getLabelSpec(markName) {
        return this.markLabelSpec[markName];
    }
    setLabelSpec(markName, label) {
        this.markLabelSpec[markName] = array(label);
    }
    addLabelSpec(markName, label, head = !1) {
        this.markLabelSpec[markName] || (this.markLabelSpec[markName] = []), head ? this.markLabelSpec[markName].unshift(label) : this.markLabelSpec[markName].push(label);
    }
    getTheme(spec, chartSpec) {
        var _a;
        const direction = getDirectionFromSeriesSpec(spec), chartTheme = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getTheme(), {markByName: markByName, mark: mark} = chartTheme, type = this._option.type, theme = transformSeriesThemeToMerge(get(chartTheme, `series.${type}`), type, mark, markByName), themeWithDirection = transformSeriesThemeToMerge(get(chartTheme, `series.${type}_${direction}`), `${type}_${direction}`, mark, markByName);
        return mergeSpec({}, theme, themeWithDirection);
    }
    transformSpec(spec, chartSpec, chartSpecInfo) {
        const result = super.transformSpec(spec, chartSpec, chartSpecInfo);
        return this._transformLabelSpec(result.spec), Object.assign(Object.assign({}, result), {
            markLabelSpec: this.markLabelSpec
        });
    }
    _transformLabelSpec(spec) {}
    _addMarkLabelSpec(spec, markName, labelSpecKey = "label", styleHandlerName = "initLabelMarkStyle", hasAnimation, head) {
        const labelSpec = null == spec ? void 0 : spec[labelSpecKey];
        (null == labelSpec ? void 0 : labelSpec.visible) && this.addLabelSpec(markName, Object.assign(Object.assign({
            animation: null != hasAnimation ? hasAnimation : spec.animation
        }, labelSpec), {
            getStyleHandler: series => {
                var _a;
                return null === (_a = series[styleHandlerName]) || void 0 === _a ? void 0 : _a.bind(series);
            }
        }), head);
    }
    _getDefaultSpecFromChart(chartSpec) {
        var _a;
        const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, {outerRadius: outerRadius, innerRadius: innerRadius} = chartSpec;
        return isValid(outerRadius) && (spec.outerRadius = outerRadius), isValid(innerRadius) && (spec.innerRadius = innerRadius), 
        Object.keys(spec).length > 0 ? spec : void 0;
    }
}
//# sourceMappingURL=base-series-transformer.js.map
