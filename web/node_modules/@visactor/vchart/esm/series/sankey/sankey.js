import { CartesianSeries } from "../cartesian/cartesian";

import { SeriesTypeEnum } from "../interface/type";

import { registerSankeyTransforms } from "@visactor/vgrammar-sankey";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { registerFadeInOutAnimation } from "../../animation/config";

import { registerDataSetInstanceTransform } from "../../data/register";

import { sankeyFormat, sankeyLayout, collectHierarchyField } from "../../data/transforms/sankey";

import { sankeyNodes } from "../../data/transforms/sankey-nodes";

import { sankeyLinks } from "../../data/transforms/sankey-links";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { DataView } from "@visactor/vdataset";

import { LayoutZIndex, AttributeLevel, Event_Bubble_Level, DEFAULT_DATA_INDEX } from "../../constant";

import { SeriesData } from "../base/series-data";

import { SankeySeriesTooltipHelper } from "./tooltip-helper";

import { Bounds, array, isNil } from "@visactor/vutils";

import { registerSankeyAnimation } from "./animation";

import { ColorOrdinalScale } from "../../scale/color-ordinal-scale";

import { registerRectMark } from "../../mark/rect";

import { registerTextMark } from "../../mark/text";

import { registerLinkPathMark } from "../../mark/link-path";

import { sankeySeriesMark } from "./constant";

import { flatten } from "../../data/transforms/flatten";

import { Factory } from "../../core/factory";

import { TransformLevel } from "../../data/initialize";

import { addDataKey, initKeyMap } from "../../data/transforms/data-key";

export class SankeySeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.sankey, this._nodeLayoutZIndex = LayoutZIndex.Node, 
        this._labelLayoutZIndex = LayoutZIndex.Label, this._viewBox = new Bounds, this._handleAdjacencyClick = params => {
            const element = params.item;
            element && element.mark.id().includes("node") ? this._handleNodeAdjacencyClick(element) : element && element.mark.id().includes("link") ? this._handleLinkAdjacencyClick(element) : this._handleClearEmpty();
        }, this._handleRelatedClick = params => {
            const element = params.item;
            element && element.mark.id().includes("node") ? this._handleNodeRelatedClick(element) : element && element.mark.id().includes("link") ? this._handleLinkRelatedClick(element) : this._handleClearEmpty();
        }, this._handleClearEmpty = () => {
            const nodeVGrammarMark = this._nodeMark.getProduct();
            if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
            const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
            if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
            const allLinkElements = linkVGrammarMark.elements, labelVGrammarMark = this._labelMark.getProduct();
            if (!labelVGrammarMark || !labelVGrammarMark.elements || !labelVGrammarMark.elements.length) return;
            const allLabelElements = labelVGrammarMark.elements;
            allNodeElements.forEach((el => {
                el.clearStates();
            })), allLinkElements.forEach((el => {
                el.clearStates();
            })), allLabelElements.forEach((el => {
                el.clearStates();
            }));
        }, this._handleNodeAdjacencyClick = element => {
            const nodeDatum = element.getDatum(), highlightNodes = [ nodeDatum.key ];
            if (this._linkMark) {
                const vGrammarMark = this._linkMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach(((linkEl, i) => {
                    linkEl.clearStates();
                    const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
                    if (array(linkDatum[father]).includes(nodeDatum.key)) {
                        let ratio;
                        if (highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                        highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), 
                        "parents" === father) {
                            const originalDatum = linkDatum.datum;
                            ratio = (originalDatum ? originalDatum.filter((entry => entry.parents.some((par => par.key === nodeDatum.key)))).reduce(((sum, d) => sum + d.value), 0) : 0) / linkDatum.value;
                        }
                        linkEl.addState("selected", {
                            ratio: ratio
                        });
                    } else linkDatum.target === nodeDatum.key ? highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source) : linkEl.useStates([ "blur" ]);
                }));
            }
            if (this._nodeMark) {
                const vGrammarMark = this._nodeMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach((el => {
                    el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                }));
            }
            if (this._labelMark) {
                const vGrammarMark = this._labelMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach((el => {
                    el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                }));
            }
        }, this._handleLinkAdjacencyClick = element => {
            const curLinkDatum = element.getDatum(), highlightNodes = [ curLinkDatum.source, curLinkDatum.target ];
            if (this._linkMark) {
                const vGrammarMark = this._linkMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach((linkEl => {
                    linkEl.clearStates(), linkEl === element ? linkEl.addState("selected", {
                        ratio: 1
                    }) : linkEl.useStates([ "blur" ]);
                }));
            }
            if (this._nodeMark) {
                const vGrammarMark = this._nodeMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach((el => {
                    el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                }));
            }
            if (this._labelMark) {
                const vGrammarMark = this._labelMark.getProduct();
                if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                vGrammarMark.elements.forEach((el => {
                    el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                }));
            }
        }, this._handleNodeRelatedClick = element => {
            var _a;
            const nodeDatum = element.getDatum(), nodeVGrammarMark = this._nodeMark.getProduct();
            if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
            const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
            if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
            const allLinkElements = linkVGrammarMark.elements;
            if ("source" === ((null === (_a = allLinkElements[0].getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
                const highlightNodes = [ nodeDatum.key ], highlightLinks = [];
                if (allLinkElements.forEach(((linkEl, i) => {
                    var _a, _b, _c, _d;
                    linkEl.clearStates();
                    const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
                    if (array(linkDatum[father]).includes(nodeDatum.key)) {
                        if (highlightLinks.includes(null !== (_a = linkDatum.key) && void 0 !== _a ? _a : linkDatum.index) || highlightLinks.push(null !== (_b = linkDatum.key) && void 0 !== _b ? _b : linkDatum.index), 
                        highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                        !highlightNodes.includes(linkDatum.target)) {
                            highlightNodes.push(linkDatum.target);
                            let targetNodeSourceLinks = allNodeElements.find((nodeElement => nodeElement.data[0].key === linkDatum.target)).data[0].sourceLinks;
                            for (;(null == targetNodeSourceLinks ? void 0 : targetNodeSourceLinks.length) > 0; ) {
                                const newTargetNodeSourceLinks = [];
                                return targetNodeSourceLinks.forEach((targetNodeSourceLinkDatum => {
                                    var _a, _b;
                                    if (!highlightLinks.includes(null !== (_a = targetNodeSourceLinkDatum.key) && void 0 !== _a ? _a : targetNodeSourceLinkDatum.index) && (highlightLinks.push(null !== (_b = targetNodeSourceLinkDatum.key) && void 0 !== _b ? _b : targetNodeSourceLinkDatum.index), 
                                    !highlightNodes.includes(targetNodeSourceLinkDatum.target))) {
                                        highlightNodes.push(targetNodeSourceLinkDatum.target);
                                        const sourceNodeTemp = allNodeElements.find((nodeElement => nodeElement.data[0].key === targetNodeSourceLinkDatum.target));
                                        newTargetNodeSourceLinks.push(sourceNodeTemp.data[0].targetLinks);
                                    }
                                })), void (targetNodeSourceLinks = newTargetNodeSourceLinks);
                            }
                        }
                    } else if (linkDatum.target === nodeDatum.key && (highlightLinks.includes(null !== (_c = linkDatum.key) && void 0 !== _c ? _c : linkDatum.index) || highlightLinks.push(null !== (_d = linkDatum.key) && void 0 !== _d ? _d : linkDatum.index), 
                    !highlightNodes.includes(linkDatum.source))) {
                        highlightNodes.push(linkDatum.source);
                        let sourceNodeTargetLinks = allNodeElements.find((nodeElement => nodeElement.data[0].key === linkDatum.source)).data[0].targetLinks;
                        for (;(null == sourceNodeTargetLinks ? void 0 : sourceNodeTargetLinks.length) > 0; ) {
                            const newSourceNodeTargetLinks = [];
                            return sourceNodeTargetLinks.forEach((sourceNodeTargetLinkDatum => {
                                var _a, _b;
                                if (!highlightLinks.includes(null !== (_a = sourceNodeTargetLinkDatum.key) && void 0 !== _a ? _a : sourceNodeTargetLinkDatum.index) && (highlightLinks.push(null !== (_b = sourceNodeTargetLinkDatum.key) && void 0 !== _b ? _b : sourceNodeTargetLinkDatum.index), 
                                !highlightNodes.includes(sourceNodeTargetLinkDatum.source))) {
                                    highlightNodes.push(sourceNodeTargetLinkDatum.source);
                                    const sourceNodeTemp = allNodeElements.find((nodeElement => nodeElement.data[0].key === sourceNodeTargetLinkDatum.source));
                                    newSourceNodeTargetLinks.push(sourceNodeTemp.data[0].targetLinks);
                                }
                            })), void (sourceNodeTargetLinks = newSourceNodeTargetLinks);
                        }
                    }
                })), this._linkMark) {
                    const vGrammarMark = this._linkMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach(((linkEl, i) => {
                        var _a;
                        linkEl.clearStates(), highlightLinks.includes(null !== (_a = linkEl.getDatum().key) && void 0 !== _a ? _a : linkEl.getDatum().index) ? linkEl.useStates([ "selected" ]) : linkEl.useStates([ "blur" ]);
                    }));
                }
                if (this._nodeMark) {
                    const vGrammarMark = this._nodeMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                    }));
                }
                if (this._labelMark) {
                    const vGrammarMark = this._labelMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                    }));
                }
            } else {
                const highlightNodes = [ nodeDatum.key ], upstreamLinks = nodeDatum.targetLinks.reduce(((res, link) => (array(link.datum).forEach((dividedLink => {
                    const parents = dividedLink.parents, len = parents.length;
                    for (let i = 0; i < len; i++) {
                        const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : nodeDatum.key, value = dividedLink.value, existingItem = res.find((item => item.source === source && item.target === target));
                        existingItem ? existingItem.value += value : res.push({
                            source: source,
                            target: target,
                            value: value
                        });
                    }
                })), res)), []);
                if (allLinkElements.forEach(((linkEl, i) => {
                    linkEl.clearStates();
                    const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source", originalDatum = linkDatum.datum, selectedDatum = originalDatum ? originalDatum.filter((entry => entry[father].some((par => par.key === nodeDatum.key)))) : null, upSelectedLink = upstreamLinks.find((upLink => upLink.source === linkDatum.source && upLink.target === linkDatum.target));
                    if (selectedDatum && selectedDatum.length) {
                        highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                        highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
                        const ratio = selectedDatum.reduce(((sum, d) => sum + d.value), 0) / linkDatum.value;
                        return linkEl.useStates([ "selected" ]), void linkEl.addState("selected", {
                            ratio: ratio
                        });
                    }
                    if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                    highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), 
                    linkEl.useStates([ "selected" ]), void linkEl.addState("selected", {
                        ratio: upSelectedLink.value / linkDatum.value
                    });
                    linkEl.useStates([ "blur" ]);
                })), this._nodeMark) {
                    const vGrammarMark = this._nodeMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                    }));
                }
                if (this._labelMark) {
                    const vGrammarMark = this._labelMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                    }));
                }
            }
        }, this._handleLinkRelatedClick = element => {
            var _a;
            const nodeVGrammarMark = this._nodeMark.getProduct();
            if (!nodeVGrammarMark || !nodeVGrammarMark.elements || !nodeVGrammarMark.elements.length) return;
            const allNodeElements = nodeVGrammarMark.elements, linkVGrammarMark = this._linkMark.getProduct();
            if (!linkVGrammarMark || !linkVGrammarMark.elements || !linkVGrammarMark.elements.length) return;
            const allLinkElements = linkVGrammarMark.elements;
            if ("source" === ((null === (_a = element.getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
                if (this._linkMark) {
                    const vGrammarMark = this._linkMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((linkEl => {
                        linkEl.clearStates();
                    }));
                }
                if (this._nodeMark) {
                    const vGrammarMark = this._nodeMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates();
                    }));
                }
                if (this._labelMark) {
                    const vGrammarMark = this._labelMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates();
                    }));
                }
            } else {
                const curLinkDatum = element.getDatum(), highlightNodes = [ curLinkDatum.source, curLinkDatum.target ], upstreamLinks = [];
                if (array(curLinkDatum.datum).forEach((dividedLink => {
                    const parents = dividedLink.parents, len = parents.length;
                    for (let i = 0; i < len - 1; i++) {
                        const source = parents[i].key, target = parents[i + 1].key, value = dividedLink.value, existingItem = upstreamLinks.find((item => item.source === source && item.target === target));
                        upstreamLinks.push({
                            source: parents[i].key,
                            target: parents[i + 1].key,
                            value: dividedLink.value
                        }), existingItem ? existingItem.value += value : upstreamLinks.push({
                            source: source,
                            target: target,
                            value: value
                        });
                    }
                })), allLinkElements.forEach((linkEl => {
                    linkEl.clearStates();
                    const linkDatum = linkEl.getDatum(), originalDatum = linkDatum.datum;
                    if (linkDatum.source === curLinkDatum.source && linkDatum.target === curLinkDatum.target) return linkEl.useStates([ "selected" ]), 
                    void linkEl.addState("selected", {
                        ratio: 1
                    });
                    const selectedDatum = originalDatum ? originalDatum.filter((entry => {
                        const parentKeysList = entry.parents.map((item => item.key));
                        return parentKeysList.includes(curLinkDatum.source) && parentKeysList.includes(curLinkDatum.target);
                    })) : null;
                    if (selectedDatum && selectedDatum.length) {
                        highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                        highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
                        const val = selectedDatum.filter((entry => entry.parents.some(((par, index) => {
                            var _a;
                            return par.key === curLinkDatum.source && (null === (_a = entry.parents[index + 1]) || void 0 === _a ? void 0 : _a.key) === curLinkDatum.target;
                        })))).reduce(((sum, d) => sum + d.value), 0), ratio = val / linkDatum.value;
                        return linkEl.useStates([ "selected" ]), void linkEl.addState("selected", {
                            ratio: ratio
                        });
                    }
                    const upSelectedLink = upstreamLinks.find((upLink => upLink.source === linkDatum.source && upLink.target === linkDatum.target));
                    if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                    highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), 
                    linkEl.useStates([ "selected" ]), void linkEl.addState("selected", {
                        ratio: upSelectedLink.value / linkDatum.value
                    });
                    linkEl.useStates([ "blur" ]);
                })), allNodeElements.forEach((el => {
                    el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                })), this._labelMark) {
                    const vGrammarMark = this._labelMark.getProduct();
                    if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
                    vGrammarMark.elements.forEach((el => {
                        el.clearStates(), highlightNodes.includes(el.getDatum().key) || el.useStates([ "blur" ]);
                    }));
                }
            }
        };
    }
    getCategoryField() {
        return this._categoryField;
    }
    setCategoryField(f) {
        return this._categoryField = f, this._categoryField;
    }
    getValueField() {
        return this._valueField;
    }
    setValueField(f) {
        return this._valueField = f, this._valueField;
    }
    setAttrFromSpec() {
        var _a, _b, _c;
        super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), 
        this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : this._spec.categoryField), 
        this._labelLimit = null !== (_c = null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.limit) && void 0 !== _c ? _c : 100;
    }
    initData() {
        var _a, _b, _c, _d;
        super.initData();
        const viewData = this.getViewData(), rawData = this.getRawData();
        if (rawData && viewData) {
            registerDataSetInstanceTransform(this._dataSet, "sankeyLayout", sankeyLayout), registerDataSetInstanceTransform(this._dataSet, "sankeyFormat", sankeyFormat), 
            rawData.transform({
                type: "sankeyFormat"
            }, !1), viewData.transform({
                type: "sankeyLayout",
                options: {
                    view: () => ({
                        x0: this._viewBox.x1,
                        x1: this._viewBox.x2,
                        y0: this._viewBox.y1,
                        y1: this._viewBox.y2
                    }),
                    sourceField: this._spec.sourceField,
                    targetField: this._spec.targetField,
                    valueField: this._spec.valueField,
                    direction: this._spec.direction,
                    nodeAlign: null !== (_a = this._spec.nodeAlign) && void 0 !== _a ? _a : "justify",
                    nodeGap: null !== (_b = this._spec.nodeGap) && void 0 !== _b ? _b : 8,
                    nodeWidth: null !== (_c = this._spec.nodeWidth) && void 0 !== _c ? _c : 10,
                    linkWidth: this._spec.linkWidth,
                    minStepWidth: this._spec.minStepWidth,
                    minNodeHeight: null !== (_d = this._spec.minNodeHeight) && void 0 !== _d ? _d : 4,
                    minLinkHeight: this._spec.minLinkHeight,
                    iterations: this._spec.iterations,
                    nodeKey: this._spec.nodeKey,
                    linkSortBy: this._spec.linkSortBy,
                    nodeSortBy: this._spec.nodeSortBy,
                    setNodeLayer: this._spec.setNodeLayer
                },
                level: TransformLevel.sankeyLayout
            });
            const {dataSet: dataSet} = this._option;
            registerDataSetInstanceTransform(dataSet, "sankeyNodes", sankeyNodes), registerDataSetInstanceTransform(dataSet, "flatten", flatten);
            const nodesDataView = new DataView(dataSet, {
                name: `sankey-node-${this.id}-data`
            });
            nodesDataView.parse([ this.getViewData() ], {
                type: "dataview"
            }), nodesDataView.transform({
                type: "sankeyNodes"
            }), nodesDataView.transform({
                type: "flatten",
                options: {
                    callback: node => {
                        if (node.datum) {
                            const nodeData = node.datum[node.depth];
                            return Object.assign(Object.assign({}, node), nodeData);
                        }
                        return node;
                    }
                }
            }, !1), nodesDataView.transform({
                type: "addVChartProperty",
                options: {
                    beforeCall: initKeyMap.bind(this),
                    call: addDataKey
                }
            }, !1), this._nodesSeriesData = new SeriesData(this._option, nodesDataView), registerDataSetInstanceTransform(dataSet, "sankeyLinks", sankeyLinks);
            const linksDataView = new DataView(dataSet, {
                name: `sankey-link-${this.id}-data`
            });
            linksDataView.parse([ this.getViewData() ], {
                type: "dataview"
            }), linksDataView.transform({
                type: "sankeyLinks"
            }), linksDataView.transform({
                type: "addVChartProperty",
                options: {
                    beforeCall: initKeyMap.bind(this),
                    call: addDataKey
                }
            }, !1), this._linksSeriesData = new SeriesData(this._option, linksDataView);
        }
    }
    initMark() {
        var _a, _b, _c;
        const nodeMark = this._createMark(SankeySeries.mark.node, {
            isSeriesMark: !0,
            key: DEFAULT_DATA_INDEX,
            dataView: this._nodesSeriesData.getDataView(),
            dataProductId: this._nodesSeriesData.getProductId(),
            customShape: null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.customShape
        });
        nodeMark && (nodeMark.setZIndex(this._nodeLayoutZIndex), this._nodeMark = nodeMark);
        const linkMark = this._createMark(SankeySeries.mark.link, {
            key: DEFAULT_DATA_INDEX,
            dataView: this._linksSeriesData.getDataView(),
            dataProductId: this._linksSeriesData.getProductId(),
            customShape: null === (_b = this._spec.link) || void 0 === _b ? void 0 : _b.customShape
        });
        if (linkMark && (this._linkMark = linkMark), null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.visible) {
            const labelMark = this._createMark(SankeySeries.mark.label, {
                key: DEFAULT_DATA_INDEX,
                dataView: this._nodesSeriesData.getDataView(),
                dataProductId: this._nodesSeriesData.getProductId()
            });
            labelMark && (this._labelMark = labelMark);
        }
    }
    initMarkStyle() {
        this._initNodeMarkStyle(), this._initLinkMarkStyle(), this._initLabelMarkStyle();
    }
    _initNodeMarkStyle() {
        const nodeMark = this._nodeMark;
        nodeMark && (this.setMarkStyle(nodeMark, {
            x: datum => datum.x0,
            x1: datum => datum.x1,
            y: datum => datum.y0,
            y1: datum => datum.y1,
            fill: datum => {
                var _a, _b, _c, _d;
                return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
            }
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Mark), this._trigger.registerMark(nodeMark));
    }
    _initLinkMarkStyle() {
        var _a;
        const linkMark = this._linkMark;
        linkMark && (this.setMarkStyle(linkMark, {
            x0: datum => datum.x0,
            x1: datum => datum.x1,
            y0: datum => datum.y0,
            y1: datum => datum.y1,
            thickness: datum => datum.thickness,
            fill: datum => {
                var _a, _b, _c, _d, _e, _f;
                const fill = null === (_b = null === (_a = this._spec.link) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill;
                if (fill) return fill;
                const sourceName = this._spec.nodeKey || (null === (_e = null === (_d = null === (_c = this._rawData.latestData[0]) || void 0 === _c ? void 0 : _c.nodes) || void 0 === _d ? void 0 : _d[0]) || void 0 === _e ? void 0 : _e.children) ? datum.source : this.getNodeList()[datum.source];
                return null === (_f = this._colorScale) || void 0 === _f ? void 0 : _f.scale(sourceName);
            },
            direction: null !== (_a = this._spec.direction) && void 0 !== _a ? _a : "horizontal"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._trigger.registerMark(linkMark));
    }
    _initLabelMarkStyle() {
        this._labelMark && ("vertical" === this._spec.direction ? "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x0,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "left",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => (datum.x0 + datum.x1) / 2,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "center",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x1,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "right",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
            x: datum => (datum.x0 + datum.x1) / 2,
            y: datum => datum.y1 >= this._viewBox.y2 ? datum.y0 : datum.y1,
            fill: datum => {
                var _a, _b, _c, _d;
                return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
            },
            text: datum => this._createText(datum),
            limit: this._labelLimit,
            textAlign: "center",
            textBaseline: datum => datum.y1 >= this._viewBox.y2 ? "bottom" : "top"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x0,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "left",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => (datum.x0 + datum.x1) / 2,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "center",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x1,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: "#ffffff",
            text: datum => this._createText(datum),
            limit: datum => {
                var _a;
                return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
            },
            textAlign: "right",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "left" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x0,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: datum => {
                var _a, _b, _c, _d;
                return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
            },
            text: datum => this._createText(datum),
            limit: this._labelLimit,
            textAlign: "right",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "right" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
            x: datum => datum.x1,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: datum => {
                var _a, _b, _c, _d;
                return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
            },
            text: datum => this._createText(datum),
            limit: this._labelLimit,
            textAlign: "left",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
            x: datum => datum.x1 >= this._viewBox.x2 ? datum.x0 : datum.x1,
            y: datum => (datum.y0 + datum.y1) / 2,
            fill: datum => {
                var _a, _b, _c, _d;
                return null !== (_c = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : null === (_d = this._colorScale) || void 0 === _d ? void 0 : _d.scale(this._getNodeNameFromData(datum));
            },
            text: datum => this._createText(datum),
            limit: this._labelLimit,
            textAlign: datum => datum.x1 >= this._viewBox.x2 ? "right" : "left",
            textBaseline: "middle"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._labelMark.setZIndex(this._labelLayoutZIndex), 
        this._trigger.registerMark(this._labelMark));
    }
    _createText(datum) {
        var _a;
        if (isNil(datum) || isNil(datum.datum)) return "";
        let text = datum.datum[this._spec.categoryField] || "";
        return (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.formatMethod) && (text = this._spec.label.formatMethod(text, datum.datum)), 
        text;
    }
    initAnimation() {
        var _a, _b, _c, _d, _e;
        const animationParams = {
            direction: this.direction,
            growFrom: () => {
                var _a, _b;
                return "horizontal" === this.direction ? null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).scale(0) : null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).scale(0);
            }
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._nodeMark && this._nodeMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("sankeyNode")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("node", this._spec, this._markAttributeContext))), 
        this._linkMark && this._linkMark.setAnimationConfig(animationConfig(null === (_d = Factory.getAnimationInKey("sankeyLinkPath")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("link", this._spec, this._markAttributeContext))), 
        this._labelMark && this._labelMark.setAnimationConfig(animationConfig(null === (_e = Factory.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext)));
    }
    initEvent() {
        var _a, _b, _c;
        super.initEvent(), null === (_a = this._nodesSeriesData.getDataView()) || void 0 === _a || _a.target.addListener("change", this.nodesSeriesDataUpdate.bind(this)), 
        null === (_b = this._linksSeriesData.getDataView()) || void 0 === _b || _b.target.addListener("change", this.linksSeriesDataUpdate.bind(this));
        const emphasisSpec = null !== (_c = this._spec.emphasis) && void 0 !== _c ? _c : {};
        !0 !== this._option.disableTriggerEvent && (emphasisSpec.enable && "adjacency" === emphasisSpec.effect && ("hover" === emphasisSpec.trigger ? this.event.on("pointerover", {
            level: Event_Bubble_Level.chart
        }, this._handleAdjacencyClick) : this.event.on("pointerdown", {
            level: Event_Bubble_Level.chart
        }, this._handleAdjacencyClick)), emphasisSpec.enable && "related" === emphasisSpec.effect && ("hover" === emphasisSpec.trigger ? this.event.on("pointerover", {
            level: Event_Bubble_Level.chart
        }, this._handleRelatedClick) : this.event.on("pointerdown", {
            level: Event_Bubble_Level.chart
        }, this._handleRelatedClick)));
    }
    nodesSeriesDataUpdate() {
        this._nodesSeriesData.updateData(), this._setNodeOrdinalColorScale();
    }
    linksSeriesDataUpdate() {
        this._linksSeriesData.updateData();
    }
    initTooltip() {
        this._tooltipHelper = new SankeySeriesTooltipHelper(this), this._nodeMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodeMark), 
        this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), 
        this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
    }
    _setNodeOrdinalColorScale() {
        var _a, _b, _c, _d, _e;
        const colorScale = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalScale) || void 0 === _b ? void 0 : _b.getScale("color");
        if (null == colorScale ? void 0 : colorScale._specified) return void (this._colorScale = colorScale);
        let colorDomain, colorRange;
        colorScale && (colorDomain = colorScale.domain(), colorRange = colorScale.range()), 
        colorRange || (colorRange = this._getDataScheme()), colorDomain && !isNil(colorDomain[0]) || (colorDomain = this.getNodeList(), 
        colorDomain.length > 10 && (colorRange = null === (_c = this._getDataScheme()[1]) || void 0 === _c ? void 0 : _c.scheme));
        const ordinalScale = new ColorOrdinalScale;
        null === (_e = (_d = ordinalScale.domain(colorDomain)).range) || void 0 === _e || _e.call(_d, colorRange), 
        this._colorScale = ordinalScale;
    }
    getNodeList() {
        var _a, _b, _c;
        return (null === (_a = this._rawData.latestData[0]) || void 0 === _a ? void 0 : _a.nodes) ? (null === (_b = this._rawData.latestData[0].nodes[0]) || void 0 === _b ? void 0 : _b.children) ? Array.from(this.extractNamesFromTree(this._rawData.latestData[0].nodes, this._spec.categoryField)) : this._rawData.latestData[0].nodes.map(((datum, index) => datum[this._spec.categoryField])) : null === (_c = this._rawData.latestData[0]) || void 0 === _c ? void 0 : _c.values.map(((datum, index) => datum[this._spec.categoryField]));
    }
    _getNodeNameFromData(datum) {
        return (null == datum ? void 0 : datum.datum) ? null == datum ? void 0 : datum.datum[this._spec.categoryField] : datum[this._spec.categoryField];
    }
    extractNamesFromTree(tree, categoryName) {
        const uniqueNames = new Set;
        return tree.forEach((node => {
            if (uniqueNames.add(node[categoryName]), node.children) {
                this.extractNamesFromTree(node.children, categoryName).forEach((name => uniqueNames.add(name)));
            }
        })), uniqueNames;
    }
    getDimensionField() {
        return [ this._spec.categoryField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    getRawDataStatisticsByField(field, isNumeric) {
        var _a;
        if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field]) {
            this._viewDataStatistics && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field]) ? this._rawStatisticsCache[field] = this._viewDataStatistics.latestData[field] : this._rawData && (this._rawStatisticsCache[field] = {
                values: this._collectByField(field)
            });
        }
        return this._rawStatisticsCache[field];
    }
    _collectByField(field) {
        var _a, _b, _c;
        const keyArray = [], rawData = null === (_b = null === (_a = this.getRawData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[0];
        if (!rawData) return [];
        if (rawData.links) (null === (_c = rawData.nodes) || void 0 === _c ? void 0 : _c.length) && rawData.nodes.forEach((node => {
            node[this._seriesField] && keyArray.push(node[this._seriesField]);
        })); else if (rawData.nodes) {
            const set = new Set;
            return collectHierarchyField(set, rawData.nodes, this._seriesField), Array.from(set);
        }
        return keyArray;
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), 
        this.getViewData().reRunAllTransform(), this._nodesSeriesData.updateData(), this._linksSeriesData.updateData();
    }
    getDefaultShapeType() {
        return "square";
    }
    _noAnimationDataKey(datum, index) {}
    getActiveMarks() {
        return [ this._nodeMark, this._linkMark ];
    }
}

SankeySeries.type = SeriesTypeEnum.sankey, SankeySeries.mark = sankeySeriesMark;

export const registerSankeySeries = () => {
    registerSankeyTransforms(), registerRectMark(), registerLinkPathMark(), registerTextMark(), 
    registerSankeyAnimation(), registerFadeInOutAnimation(), Factory.registerSeries(SankeySeries.type, SankeySeries);
};
//# sourceMappingURL=sankey.js.map
