import { STACK_FIELD_END, STACK_FIELD_START_PERCENT, STACK_FIELD_END_PERCENT, STACK_FIELD_END_OffsetSilhouette, STACK_FIELD_START_OffsetSilhouette, STACK_FIELD_TOTAL, STACK_FIELD_TOTAL_PERCENT, STACK_FIELD_TOTAL_TOP, STACK_FIELD_START } from "../constant";

import { toValidNumber } from "./type";

import { max, sum } from "./math";

export function mergeFields(targetFields, mergeFields) {
    for (let i = 0; i < mergeFields.length; i++) {
        const element = mergeFields[i], _target = findFields(targetFields, element.key);
        _target ? _target.operations = [ ...new Set(_target.operations.concat(element.operations)) ] : targetFields.push(element);
    }
    return targetFields;
}

function findFields(list, fieldKey) {
    return list.find((i => i.key === fieldKey));
}

export function getFieldAlias(dataView, field) {
    var _a;
    if (!dataView) return null != field ? field : null;
    const fields = dataView.getFields();
    return fields && fields[field] ? null !== (_a = fields[field].alias) && void 0 !== _a ? _a : field : null != field ? field : null;
}

export function getRegionStackGroup(region, setInitialValue, filter) {
    const stackValueGroup = {};
    return region.getSeries().forEach((s => {
        var _a;
        const stackData = s.getStackData(), stackValue = s.getStackValue(), stackValueField = s.getStackValueField(), filterEnable = !filter || filter(s);
        stackData && stackValueField && filterEnable && (stackValueGroup[stackValue] = null !== (_a = stackValueGroup[stackValue]) && void 0 !== _a ? _a : {
            nodes: {}
        }, stackGroup(s, stackData, stackValueGroup[stackValue], stackValueField, setInitialValue));
    })), stackValueGroup;
}

export function stackTotal(stackData, valueField) {
    if ("values" in stackData && stackData.values.length) {
        const total = sum(stackData.values, valueField), percent = max(stackData.values, STACK_FIELD_END_PERCENT);
        stackData.values.forEach((v => {
            v[STACK_FIELD_TOTAL] = total, v[STACK_FIELD_TOTAL_PERCENT] = percent, delete v[STACK_FIELD_TOTAL_TOP];
        }));
        const maxNode = stackData.values.reduce(((max, current) => current[STACK_FIELD_END] > max[STACK_FIELD_END] ? current : max));
        maxNode[STACK_FIELD_TOTAL_TOP] = !0;
    } else for (const key in stackData.nodes) stackTotal(stackData.nodes[key], valueField);
}

export function stackOffsetSilhouette(stackCache) {
    if (!stackCache.values.length) return;
    const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;
    for (let j = 0; j < stackCache.values.length; j++) stackCache.values[j][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_START] - centerValue, 
    stackCache.values[j][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_END] - centerValue;
}

export function stack(stackCache, stackInverse, hasPercent) {
    if (stackCache.values.length > 0) {
        let positiveStart = 0, negativeStart = 0, sign = 1, value = 0;
        const maxLength = stackCache.values.length;
        for (let index = 0; index < maxLength; index++) {
            const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
            value = v[STACK_FIELD_END], value >= 0 ? (v[STACK_FIELD_START] = positiveStart, 
            positiveStart += v[STACK_FIELD_END], v[STACK_FIELD_END] = positiveStart) : (v[STACK_FIELD_START] = negativeStart, 
            negativeStart += v[STACK_FIELD_END], v[STACK_FIELD_END] = negativeStart);
        }
        if (hasPercent) for (let index = 0; index < maxLength; index++) {
            const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
            value = v[STACK_FIELD_END];
            const denominator = value >= 0 ? positiveStart : negativeStart;
            sign = value >= 0 ? 1 : -1, v[STACK_FIELD_START_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[STACK_FIELD_START] / denominator) * sign, 
            v[STACK_FIELD_END_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[STACK_FIELD_END] / denominator) * sign;
        }
    }
    for (const key in stackCache.nodes) stack(stackCache.nodes[key], stackInverse, hasPercent);
}

export function stackGroup(s, stackData, stackCache, valueField, setInitialValue) {
    if ("values" in stackData) return setInitialValue && stackData.values.forEach((v => v[STACK_FIELD_END] = toValidNumber(v[valueField]))), 
    stackCache.values.push(...stackData.values), void stackCache.series.push({
        s: s,
        values: stackData.values
    });
    for (const key in stackData.nodes) !stackCache.nodes[key] && (stackCache.nodes[key] = {
        values: [],
        series: [],
        nodes: {}
    }), stackGroup(s, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue);
}
//# sourceMappingURL=data.js.map
