import { Event } from "../event/event";

import { getDefaultInteractionConfigByMode } from "./config";

import { isBoolean, isObject, array } from "@visactor/vutils";

import { mergeSpec } from "../util/spec/merge-spec";

import { MarkSet } from "../mark/mark-set";

import { STATE_VALUE_ENUM } from "../compile/mark/interface";

import { Event_Bubble_Level, Event_Source_Type } from "../constant";

export class Trigger {
    get hover() {
        return this._hover;
    }
    get select() {
        return this._select;
    }
    constructor(spec, option) {
        this._fields = null, this._marks = new MarkSet, this._markReverse = new MarkSet, 
        this.onHover = params => {
            this.filterEventMark(params) ? (this._isHovered = !0, this.hoverItem(params)) : this._isHovered && (this._isHovered = !1, 
            this.unhoverItem());
        }, this.onUnHover = params => {
            this.filterEventMark(params) || this.interaction.filterEventMark(params, STATE_VALUE_ENUM.STATE_HOVER) || this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0] && this.unhoverItem();
        }, this.onSelect = params => {
            this.handleSingleEventSelect(params);
        }, this.onUnSelect = params => {
            this.interaction.filterEventMark(params, STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
        }, this._spec = spec, this._option = option, this.event = new Event(option.eventDispatcher, option.mode), 
        this.interaction = option.interaction, this.initConfig(option.mode);
    }
    setStateKeys(fields) {
        this._fields = fields.slice();
    }
    registerMark(mark) {
        this._marks.addMark(mark), this._hover.enable && this.interaction.registerMark(STATE_VALUE_ENUM.STATE_HOVER, mark), 
        this._select.enable && this.interaction.registerMark(STATE_VALUE_ENUM.STATE_SELECTED, mark);
    }
    init() {
        this.initEvent();
    }
    release() {
        this.releaseEvent(), this._marks.clear();
    }
    initEvent() {
        const event = this.event, {enable: hoverEnable, trigger: hoverTrigger, triggerOff: hoverTriggerOff} = this._hover, {enable: selectEnable, trigger: selectTrigger, triggerOff: selectTriggerOff} = this._select;
        hoverEnable && (array(hoverTrigger).forEach((trigger => {
            event.on(trigger, {
                level: Event_Bubble_Level.chart
            }, this.onHover);
        })), hoverTriggerOff && "none" !== hoverTriggerOff && array(hoverTriggerOff).forEach((trigger => {
            event.on(trigger, {
                level: Event_Bubble_Level.vchart,
                source: Event_Source_Type.chart
            }, this.onUnHover);
        }))), selectEnable && (array(selectTrigger).forEach((trigger => {
            event.on(trigger, {
                level: Event_Bubble_Level.mark
            }, this.onSelect);
        })), selectTriggerOff && "none" !== selectTriggerOff && array(selectTriggerOff).forEach((trigger => {
            event.on(trigger, {
                level: Event_Bubble_Level.mark
            }, this.onUnSelect);
        })), selectTriggerOff || array(null != selectTriggerOff ? selectTriggerOff : selectTrigger).forEach((trigger => {
            event.on(trigger, {
                level: Event_Bubble_Level.vchart
            }, this.onUnSelect);
        })));
    }
    releaseEvent() {
        this.event.release();
    }
    initConfig(mode) {
        const defaultConfig = getDefaultInteractionConfigByMode(mode);
        this._hover = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.hover), 
        this._select = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.select);
        const hoverSpec = this._spec.hover;
        isBoolean(hoverSpec) ? this._hover.enable = hoverSpec : isObject(hoverSpec) && (this._hover.enable = !0, 
        this._hover = mergeSpec(this._hover, hoverSpec));
        const selectSpec = this._spec.select;
        isBoolean(selectSpec) ? this._select.enable = selectSpec : isObject(selectSpec) && (this._select.enable = !0, 
        this._select = mergeSpec(this._select, selectSpec));
    }
    hoverItem(params) {
        const {datum: datum} = params, lastEl = this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0];
        params.item !== lastEl && (this.interaction.exchangeEventElement(STATE_VALUE_ENUM.STATE_HOVER, params.item), 
        this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_HOVER), this.event.emit("hovered", {
            model: this._option.model,
            value: [ datum ]
        }));
    }
    unhoverItem() {
        const lastHoveredDatums = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_HOVER);
        this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_HOVER, !0), this.event.emit("unhovered", {
            model: this._option.model,
            value: lastHoveredDatums
        });
    }
    handleSingleEventHover(params) {
        this.filterEventMark(params) ? this.hoverItem(params) : this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_HOVER)[0] && !this.interaction.filterEventMark(params, STATE_VALUE_ENUM.STATE_HOVER) && this.unhoverItem();
    }
    selectItems(datums) {
        this.event.emit("selected", {
            model: this._option.model,
            value: datums
        });
    }
    clearSelectedItems() {
        const lastSelectedItem = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_SELECTED);
        this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_SELECTED, !0), this.event.emit("unselected", {
            model: this._option.model,
            value: lastSelectedItem
        });
    }
    unselectItems(params) {
        const {triggerOff: triggerOff} = this._select;
        "none" !== triggerOff && (this.interaction.removeEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params.item), 
        this.event.emit("unselected", {
            model: this._option.model,
            value: params.item
        }));
    }
    handleSingleEventSelect(params) {
        if (this.filterEventMark(params)) if (params.item.getStates().includes(STATE_VALUE_ENUM.STATE_SELECTED)) this.unselectItems(params); else {
            if ("multiple" === this._select.mode) this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params.item); else this.interaction.exchangeEventElement(STATE_VALUE_ENUM.STATE_SELECTED, params.item);
            this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_SELECTED);
            const items = this.interaction.getEventElementData(STATE_VALUE_ENUM.STATE_SELECTED);
            this.selectItems(items);
        } else this.interaction.filterEventMark(params, STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
    }
    filterEventMark(params) {
        return !(!params.mark || !this._marks.includes(params.mark));
    }
    isDatumEqual(datumA, datumB) {
        return (this._fields ? this._fields : Object.keys(datumA)).every((f => datumA[f] === datumB[f]));
    }
}
//# sourceMappingURL=trigger.js.map
