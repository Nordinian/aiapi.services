import { LinearScale } from "./linear-scale";

import { ScaleEnum } from "./type";

import { d3TicksForLog, forceTicksBaseTransform, parseNiceOptions, ticksBaseTransform } from "./utils/tick-sample";

import { symlog, symexp, nice } from "./utils/utils";

export class SymlogScale extends LinearScale {
    constructor() {
        super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
    }
    clone() {
        return (new SymlogScale).domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).constant(this._const);
    }
    constant(_, slience) {
        return arguments.length ? (this._const = _, this.transformer = symlog(_), this.untransformer = symexp(_), 
        this.rescale(slience)) : this._const;
    }
    d3Ticks(count = 10, options) {
        const d = this.domain(), u = d[0], v = d[d.length - 1];
        return d3TicksForLog(u, v, count, this._const, this.transformer, this.untransformer, options);
    }
    ticks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
    }
    forceTicks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
    }
    stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
    }
    nice(count = 10, option) {
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [], niceType = null;
        if (option) {
            const res = parseNiceOptions(originalDomain, option);
            if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, 
            res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else niceType = "all";
        if (niceType) {
            const niceDomain = nice(originalDomain.slice(), {
                floor: x => Math.floor(x),
                ceil: x => Math.ceil(x)
            });
            return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), 
            this._niceDomain = niceDomain, this.rescale(), this;
        }
        return this;
    }
    niceMin() {
        const maxD = this._domain[this._domain.length - 1];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, 
        this.rescale()), this;
    }
    niceMax() {
        const minD = this._domain[0];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), 
        this;
    }
}
//# sourceMappingURL=symlog-scale.js.map