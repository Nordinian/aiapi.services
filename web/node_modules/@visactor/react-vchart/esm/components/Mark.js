var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import React, { useContext, useEffect } from "react";

import { isNil } from "@visactor/vutils";

import ViewContext from "../context/view";

import { uid } from "../util";

export const Mark = props => {
    const context = useContext(ViewContext), id = React.useRef(isNil(props.id) ? uid("mark") : props.id), updateId = React.useRef(props.updateId);
    return props.updateId !== updateId.current && (updateId.current = props.updateId, 
    context && addOrUpdateMark(context, id.current, props)), useEffect((() => () => {
        context && removeMark(context, id.current);
    }), []), null;
};

const addOrUpdateMark = (view, id, props) => {
    var _a;
    if (!view.renderer) return;
    let mark = view.getMarkById(id);
    const {group: group, glyphType: glyphType, updateId: updateId} = props, others = __rest(props, [ "group", "glyphType", "updateId" ]);
    mark || (mark = view.mark(props.type, null !== (_a = props.group) && void 0 !== _a ? _a : view.rootMark, props.glyphType ? {
        glyphType: props.glyphType
    } : null).name(id)), mark.parse(others), view.runAsync();
}, removeMark = (view, id) => {
    if (view.renderer) {
        view.getMarkById(id);
        view.removeGrammar(id);
    }
};
//# sourceMappingURL=Mark.js.map