"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Morph = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), util_1 = require("../../parse/util"), differ_1 = require("../mark/differ"), enums_1 = require("../enums"), EmptyKey = Symbol.for("key");

class Morph {
    diffGrammar(prevGrammars, nextGrammars) {
        return (0, differ_1.diffSingle)(prevGrammars, nextGrammars, (grammar => {
            var _a;
            return null !== (_a = grammar.id()) && void 0 !== _a ? _a : Symbol();
        }));
    }
    diffMark(prevMarks, nextMarks, runningConfig) {
        const diffResult = {
            enter: [],
            exit: [],
            update: []
        };
        let prevDiffMarks = [], nextDiffMarks = [];
        prevMarks.forEach((mark => {
            mark.markType !== enums_1.GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? prevDiffMarks.push(mark) : diffResult.exit.push({
                prev: [ mark ]
            });
        })), nextMarks.forEach((mark => {
            mark.markType !== enums_1.GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? nextDiffMarks.push(mark) : diffResult.enter.push({
                next: [ mark ]
            });
        }));
        const keyDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark => mark.getMorphConfig().morphKey), (mark => mark.getMorphConfig().morphKey));
        prevDiffMarks = keyDiffResult.prev, nextDiffMarks = keyDiffResult.next, diffResult.update = diffResult.update.concat(keyDiffResult.update);
        const nameDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark => mark.id()), (mark => mark.id()));
        prevDiffMarks = nameDiffResult.prev, nextDiffMarks = nameDiffResult.next, diffResult.update = diffResult.update.concat(nameDiffResult.update);
        const prevParentGroup = (0, differ_1.groupData)(prevDiffMarks, (mark => {
            var _a, _b;
            return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
        })), nextParentGroup = (0, differ_1.groupData)(nextDiffMarks, (mark => {
            var _a, _b;
            return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
        }));
        return Object.keys(nextParentGroup).forEach((groupName => {
            const prevChildren = prevParentGroup.data.get(groupName), nextChildren = nextParentGroup.data.get(groupName);
            if (prevChildren && nextChildren) {
                for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {
                    const prevChild = prevChildren[i], nextChild = nextChildren[i];
                    prevChild && nextChild ? diffResult.update.push({
                        prev: [ prevChild ],
                        next: [ nextChild ]
                    }) : prevChild ? diffResult.exit.push({
                        prev: [ prevChild ]
                    }) : nextChild && diffResult.enter.push({
                        next: [ nextChild ]
                    });
                }
                prevDiffMarks = prevDiffMarks.filter((mark => !prevChildren.includes(mark))), nextDiffMarks = nextDiffMarks.filter((mark => !nextChildren.includes(mark)));
            }
        })), prevDiffMarks.forEach((mark => diffResult.exit.push({
            prev: [ mark ]
        }))), nextDiffMarks.forEach((mark => diffResult.enter.push({
            next: [ mark ]
        }))), diffResult;
    }
    _appendMorphKeyToElements(mark) {
        const config = mark.getMorphConfig();
        if (!(0, vutils_1.isNil)(config.morphElementKey)) {
            const getter = (0, util_1.parseField)(config.morphElementKey);
            mark.elements && mark.elements.forEach((el => {
                el.morphKey = getter(el.getDatum());
            }));
        }
    }
    morph(prevMarks, nextMarks, runningConfig) {
        const prevElements = prevMarks.reduce(((elements, mark) => (this._appendMorphKeyToElements(mark), 
        elements.concat(mark.elements))), []), nextElements = nextMarks.reduce(((elements, mark) => (this._appendMorphKeyToElements(mark), 
        elements.concat(mark.elements))), []), diffResult = (0, differ_1.diffMultiple)(prevElements, nextElements, (element => {
            var _a;
            return null !== (_a = element.morphKey) && void 0 !== _a ? _a : element.key;
        }));
        prevMarks.forEach((mark => {
            var _a, _b;
            return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
        })), nextMarks.forEach((mark => {
            var _a, _b;
            return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
        }));
        const parameters = prevMarks.concat(nextMarks).reduce(((parameters, mark) => (Object.assign(parameters, mark.parameters()), 
        parameters)), {});
        let morphCount = 0;
        const onMorphEnd = () => {
            morphCount -= 1, 0 === morphCount && nextMarks.forEach((mark => {
                var _a, _b;
                null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.enable) || void 0 === _b || _b.call(_a);
            }));
        };
        diffResult.enter.forEach((diff => {
            diff.next.forEach((element => {
                this.doMorph([], [ element ], runningConfig, onMorphEnd, parameters);
            })), morphCount += 1;
        })), diffResult.update.forEach((diff => {
            const divideCount = Math.min(diff.prev.length, diff.next.length), prevDivide = this.divideElements(diff.prev, divideCount), nextDivide = this.divideElements(diff.next, divideCount);
            for (let i = 0; i < divideCount; i++) this.doMorph(prevDivide[i], nextDivide[i], runningConfig, onMorphEnd, parameters), 
            morphCount += 1;
        }));
    }
    diffUpdateByGroup(prev, next, prevKey, nextKey) {
        const prevGroup = (0, differ_1.groupData)(prev, (datum => {
            var _a;
            return null !== (_a = prevKey(datum)) && void 0 !== _a ? _a : EmptyKey;
        })), nextGroup = (0, differ_1.groupData)(next, (datum => {
            var _a;
            return null !== (_a = nextKey(datum)) && void 0 !== _a ? _a : EmptyKey;
        }));
        let prevAfterDiff = prev, nextAfterDiff = next;
        const update = [];
        return nextGroup.keys.forEach((key => {
            if (key !== EmptyKey) {
                const prevKeyData = prevGroup.data.get(key), nextKeyData = nextGroup.data.get(key);
                prevKeyData && nextKeyData && (update.push({
                    prev: prevKeyData,
                    next: nextKeyData
                }), prevAfterDiff = prevAfterDiff.filter((datum => !prevKeyData.includes(datum))), 
                nextAfterDiff = nextAfterDiff.filter((datum => !nextKeyData.includes(datum))));
            }
        })), {
            prev: prevAfterDiff,
            next: nextAfterDiff,
            update: update
        };
    }
    doMorph(prev, next, runningConfig, onEnd, parameters) {
        var _a, _b;
        const morphData = {
            prev: prev.map((element => element.getDatum())),
            next: next.map((element => element.getDatum()))
        }, morphElements = {
            prev: prev.slice(),
            next: next.slice()
        }, easing = runningConfig.animation.easing, delay = (0, util_1.invokeFunctionType)(runningConfig.animation.delay, parameters, morphData, morphElements), duration = (0, 
        util_1.invokeFunctionType)(runningConfig.animation.duration, parameters, morphData, morphElements), oneByOne = (0, 
        util_1.invokeFunctionType)(runningConfig.animation.oneByOne, parameters, morphData, morphElements), splitPath = (0, 
        util_1.invokeFunctionType)(runningConfig.animation.splitPath, parameters, morphData, morphElements), individualDelay = (0, 
        vutils_1.isValidNumber)(oneByOne) && oneByOne > 0 ? index => (0, vutils_1.isNumber)(oneByOne) ? index * oneByOne : !0 === oneByOne ? index * duration : 0 : void 0;
        1 !== prev.length && 0 !== prev.length || 1 !== next.length ? 1 === prev.length && next.length > 1 ? (0, 
        vrender_core_1.oneToMultiMorph)(prev[0].getGraphicItem(), next.map((element => element.getGraphicItem())), {
            delay: delay,
            duration: duration,
            easing: easing,
            onEnd: onEnd,
            individualDelay: individualDelay,
            splitPath: splitPath
        }) : prev.length > 1 && 1 === next.length && (0, vrender_core_1.multiToOneMorph)(prev.map((element => element.getGraphicItem())), next[0].getGraphicItem(), {
            delay: delay,
            duration: duration,
            easing: easing,
            onEnd: onEnd,
            individualDelay: individualDelay,
            splitPath: splitPath
        }) : (0, vrender_core_1.morphPath)(null === (_b = null === (_a = prev[0]) || void 0 === _a ? void 0 : _a.getGraphicItem) || void 0 === _b ? void 0 : _b.call(_a), next[0].getGraphicItem(), {
            delay: delay,
            duration: duration,
            easing: easing,
            onEnd: onEnd
        });
    }
    divideElements(elements, count) {
        const divideLength = Math.floor(elements.length / count);
        return new Array(count).fill(0).map(((i, index) => elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1))));
    }
}

exports.Morph = Morph;
//# sourceMappingURL=morph.js.map
