var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { throttle, PointService, isEqual, array, isArray, isNumber, get, isBoolean } from "@visactor/vutils";

import { RenderModeEnum } from "../../typings/spec/common";

import { BaseComponent } from "../base/base-component";

import { outOfBounds } from "../../util/math";

import { Event_Bubble_Level, Event_Source_Type, LayoutZIndex } from "../../constant";

import { getDefaultCrosshairTriggerEventByMode } from "./config";

const ORIENT_MAP = {
    x: [ "top", "bottom" ],
    y: [ "left", "right" ],
    category: [ "angle" ],
    value: [ "radius" ]
};

export class BaseCrossHair extends BaseComponent {
    get enableRemain() {
        return "none" === this.triggerOff;
    }
    constructor(spec, options) {
        super(spec, options), this.specKey = "crosshair", this.layoutType = "none", this.gridZIndex = LayoutZIndex.CrossHair_Grid, 
        this.labelZIndex = LayoutZIndex.CrossHair, this.trigger = "hover", this.triggerOff = "hover", 
        this._handleEvent = throttle((params => {
            if (!this._option) return;
            const {event: event} = params, layer = this._option.getCompiler().getStage().getLayer(void 0), point = {
                x: event.viewX,
                y: event.viewY
            };
            layer.globalTransMatrix.transformPoint({
                x: event.viewX,
                y: event.viewY
            }, point);
            const x = point.x - this.getLayoutStartPoint().x, y = point.y - this.getLayoutStartPoint().y;
            this.showDefault = !1, this._layoutCrosshair(x, y);
        }), 10), this.enable = !0, this.showDefault = !0;
    }
    _getLimitBounds() {
        var _a, _b;
        if (!this._limitBounds) {
            const {width: width, height: height} = null !== (_b = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getCanvasRect()) && void 0 !== _b ? _b : {
                width: 0,
                height: 0
            };
            this._limitBounds = {
                x1: 0,
                y1: 0,
                x2: width,
                y2: height
            };
        }
        return this._limitBounds;
    }
    _showDefaultCrosshair() {
        this.showDefault && this._showDefaultCrosshairBySpec();
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._parseCrosshairSpec();
    }
    created() {
        super.created(), this._initEvent();
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reMake || isEqual(prevSpec, spec) || (result.reRender = !0, result.reMake = !0), 
        result;
    }
    _initEvent() {
        if (this._option.disableTriggerEvent) return;
        const triggerConfig = this._getTriggerEvent();
        if (triggerConfig) {
            const {in: triggerEvent, out: outTriggerEvent} = triggerConfig;
            array(triggerEvent).forEach(((eventName, index) => this._registerEvent(eventName, isArray(outTriggerEvent) ? outTriggerEvent[index] : outTriggerEvent)));
        }
    }
    _registerEvent(inEventName, outEventName) {
        this.event.on(inEventName, {
            source: Event_Source_Type.chart
        }, this._handleEvent), this.event.on(outEventName, {
            level: Event_Bubble_Level.chart
        }, ((...arg) => {
            this.enableRemain || this.hide();
        }));
    }
    _eventOff(eventName) {
        this.event.off(eventName, this._handleEvent);
    }
    updateLayoutAttribute() {
        this._limitBounds = null, this._showDefaultCrosshair();
    }
    _getTriggerEvent() {
        const {mode: mode = RenderModeEnum["desktop-browser"]} = this._option, triggerConfig = getDefaultCrosshairTriggerEventByMode(mode);
        if (triggerConfig) {
            const trigger = this.trigger || "hover", outTrigger = trigger => "click" === trigger ? "clickOut" : "hoverOut";
            if (isArray(trigger)) {
                let inResult = [], outResult = [];
                return trigger.forEach((item => {
                    inResult = inResult.concat(triggerConfig[item]), outResult = outResult.concat(triggerConfig[outTrigger(item)]);
                })), {
                    in: inResult,
                    out: outResult
                };
            }
            return {
                in: triggerConfig[trigger],
                out: triggerConfig[outTrigger(trigger)]
            };
        }
        return null;
    }
    _getAxisInfoByField(field) {
        var _a, _b;
        const axesComponents = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getComponentsByKey) || void 0 === _b ? void 0 : _b.call(_a, "axes");
        if (!(null == axesComponents ? void 0 : axesComponents.length)) return null;
        let bindingAxesIndex = get(this._spec, `${field}Field.bindingAxesIndex`);
        if (bindingAxesIndex || (bindingAxesIndex = [], axesComponents.forEach(((item, index) => {
            ORIENT_MAP[field].includes(item.getOrient()) && bindingAxesIndex.push(index);
        }))), !bindingAxesIndex.length) return null;
        const map = new Map;
        let x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0;
        const {x: sx, y: sy} = this.getLayoutStartPoint();
        return bindingAxesIndex.forEach((idx => {
            x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0;
            const axis = axesComponents.find((axis => axis.getSpecIndex() === idx));
            if (!axis) return;
            axis.getRegions().forEach((r => {
                const {x: regionStartX, y: regionStartY} = r.getLayoutStartPoint();
                x1 = Math.min(x1, regionStartX - sx), y1 = Math.min(y1, regionStartY - sy), x2 = Math.max(x2, regionStartX + r.getLayoutRect().width - sx), 
                y2 = Math.max(y2, regionStartY + r.getLayoutRect().height - sy);
            })), map.set(idx, {
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                axis: axis
            });
        })), map;
    }
    changeRegions(regions) {}
    onLayoutEnd(ctx) {
        const region = this._regions[0];
        this.setLayoutRect(region.getLayoutRect()), this.setLayoutStartPosition(region.getLayoutStartPoint()), 
        super.onLayoutEnd(ctx);
    }
    onRender(ctx) {}
    _releaseEvent() {
        const triggerConfig = this._getTriggerEvent();
        if (triggerConfig) {
            const {in: triggerEvent, out: outTriggerEvent} = triggerConfig;
            isArray(triggerEvent) ? triggerEvent.forEach((eachTriggerEvent => this._eventOff(eachTriggerEvent))) : this._eventOff(triggerEvent), 
            isArray(outTriggerEvent) ? outTriggerEvent.forEach((eachTriggerEvent => this._eventOff(eachTriggerEvent))) : this._eventOff(outTriggerEvent);
        }
    }
    _firstSeries() {
        for (let i = 0; i < this._regions.length; i++) {
            const series = this._regions[i].getSeries();
            for (let j = 0; j < series.length; j++) {
                const s = series[j];
                if (s) return s;
            }
        }
        return null;
    }
    _parseCrosshairSpec() {
        this._parseFieldInfo();
        const {trigger: trigger, triggerOff: triggerOff, labelZIndex: labelZIndex, gridZIndex: gridZIndex} = this._spec;
        trigger && (this.trigger = trigger), this.triggerOff = triggerOff || this.trigger, 
        void 0 !== labelZIndex && (this.labelZIndex = labelZIndex), void 0 !== gridZIndex && (this.gridZIndex = gridZIndex);
    }
    _parseField(field, fieldName) {
        var _a, _b, _c, _d;
        const hair = {}, {line: line = {}, label: label = {}, visible: visible} = field;
        hair.visible = visible, hair.type = line.type || "line";
        const _e = line.style || {}, {strokeOpacity: strokeOpacity, fillOpacity: fillOpacity, opacity: opacity, stroke: stroke, fill: fill, lineWidth: lineWidth} = _e, restStyle = __rest(_e, [ "strokeOpacity", "fillOpacity", "opacity", "stroke", "fill", "lineWidth" ]), isLineType = "line" === hair.type;
        let finalOpacity = isLineType ? strokeOpacity : fillOpacity;
        if (isNumber(opacity) && (finalOpacity = (null != finalOpacity ? finalOpacity : 1) * opacity), 
        hair.style = !1 === (null == line ? void 0 : line.visible) ? {
            visible: !1
        } : Object.assign({
            opacity: finalOpacity,
            pickable: !1,
            visible: !0
        }, restStyle), isLineType) hair.style.stroke = stroke || fill, hair.style.lineWidth = get(line, "width", lineWidth || 2); else {
            hair.style.fill = fill || stroke, (null === (_c = null === (_b = null === (_a = this._spec[fieldName]) || void 0 === _a ? void 0 : _a.line) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.stroke) && (hair.style.stroke = this._spec[fieldName].line.style.stroke);
            const rectSize = get(line, "width");
            if ("string" == typeof rectSize) {
                const percent = parseInt(rectSize.substring(0, rectSize.length - 1), 10) / 100;
                hair.style.sizePercent = percent;
            } else "number" != typeof rectSize && "function" != typeof rectSize || (hair.style.size = rectSize);
        }
        const labelBackground = label.labelBackground || {}, labelStyle = label.style || {}, _f = labelBackground.style || {}, {fill: rectFill = "rgba(47, 59, 82, 0.9)", stroke: rectStroke, outerBorder: outerBorder} = _f, rectStyle = __rest(_f, [ "fill", "stroke", "outerBorder" ]);
        return hair.label = (null == label ? void 0 : label.visible) ? {
            visible: !0,
            formatMethod: label.formatMethod,
            minWidth: labelBackground.minWidth,
            maxWidth: labelBackground.maxWidth,
            padding: labelBackground.padding,
            textStyle: Object.assign(Object.assign({
                fontSize: 14,
                pickable: !1
            }, labelStyle), {
                fill: null !== (_d = labelStyle.fill) && void 0 !== _d ? _d : "#fff",
                stroke: get(labelStyle, "stroke")
            }),
            panel: (isBoolean(null == labelBackground ? void 0 : labelBackground.visible) ? null == labelBackground ? void 0 : labelBackground.visible : labelBackground) ? Object.assign({
                visible: !0,
                pickable: !1,
                fill: rectFill,
                stroke: rectStroke,
                outerBorder: Object.assign({
                    stroke: rectFill,
                    distance: 0,
                    lineWidth: 3
                }, outerBorder)
            }, rectStyle) : {
                visible: !1
            },
            zIndex: this.labelZIndex,
            childrenPickable: !1,
            pickable: !1
        } : {
            visible: !1
        }, hair;
    }
    _filterAxisByPoint(axisMap, relativeX, relativeY) {
        return axisMap && axisMap.forEach((item => {
            const axis = item.axis;
            if (outOfBounds(item, relativeX, relativeY) && axisMap.delete(axis.getSpecIndex()), 
            axis.type.startsWith("polarAxis")) {
                const center = axis.getCenter(), innerRadius = axis.getInnerRadius(), outerRadius = axis.getOuterRadius(), distance = PointService.distancePP({
                    x: relativeX,
                    y: relativeY
                }, center);
                (distance > outerRadius || distance < innerRadius) && axisMap.delete(axis.getSpecIndex());
            }
        })), axisMap;
    }
}

BaseCrossHair.specKey = "crosshair";
//# sourceMappingURL=base.js.map
