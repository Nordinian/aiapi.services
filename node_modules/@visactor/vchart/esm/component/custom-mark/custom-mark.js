import { BaseComponent } from "../base/base-component";

import { ComponentTypeEnum } from "../interface/type";

import { LayoutLevel, LayoutZIndex, PREFIX } from "../../constant";

import { isEqual, isNil, isValid, isValidNumber } from "@visactor/vutils";

import { Factory } from "../../core/factory";

import { registerImageMark } from "../../mark/image";

export class CustomMark extends BaseComponent {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.customMark, this.specKey = "customMark", 
        this.layoutType = "none", this.layoutZIndex = LayoutZIndex.CustomMark, this.layoutLevel = LayoutLevel.CustomMark;
    }
    static getSpecInfo(chartSpec) {
        const spec = chartSpec[this.specKey];
        return spec ? [ {
            spec: spec,
            specIndex: 0,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.customMark
        } ] : null;
    }
    created() {
        super.created(), this.initMarks(), this.initEvent();
    }
    initMarks() {
        this._spec && this._spec.forEach(((m, i) => {
            this._createExtensionMark(m, null, `${PREFIX}_series_${this.id}_extensionMark`, i);
        }));
    }
    _createExtensionMark(spec, parentMark, namePrefix, index) {
        var _a;
        const mark = this._createMark({
            type: spec.type,
            name: `${PREFIX}_${index}`
        }, {
            skipBeforeLayouted: !0,
            attributeContext: this._getMarkAttributeContext()
        });
        if (mark && (isNil(parentMark) ? this._marks.addMark(mark) : parentMark && parentMark.addMark(mark), 
        this.initMarkStyleWithSpec(mark, spec), "group" === spec.type && (namePrefix = `${namePrefix}_${index}`, 
        null === (_a = spec.children) || void 0 === _a || _a.forEach(((s, i) => {
            this._createExtensionMark(s, mark, namePrefix, i);
        }))), isValid(spec.dataId) || isValidNumber(spec.dataIndex))) {
            const dataview = this.getChart().getSeriesData(spec.dataId, spec.dataIndex);
            dataview && (dataview.target.addListener("change", (() => {
                mark.getData().updateData();
            })), mark.setDataView(dataview));
        }
    }
    initEvent() {}
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return isEqual(prevSpec, spec) || (result.reMake = !0), result.change = !0, result.reRender = !0, 
        result;
    }
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return [];
    }
    onRender(ctx) {}
    _getMarkAttributeContext() {
        return {
            vchart: this._option.globalInstance,
            globalScale: (key, value) => {
                var _a;
                return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
            }
        };
    }
}

CustomMark.type = ComponentTypeEnum.customMark, CustomMark.specKey = "customMark";

export const registerCustomMark = () => {
    registerImageMark(), Factory.registerComponent(CustomMark.type, CustomMark);
};
//# sourceMappingURL=custom-mark.js.map
