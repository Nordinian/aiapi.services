import { Symbol } from "@visactor/vrender-core";

import { isObject, isString } from "@visactor/vutils";

import { BaseTooltipModel } from "./base-tooltip-model";

import { pixelPropertyStrToNumber } from "../util";

export class ShapeModel extends BaseTooltipModel {
    init(classList, id, tag) {
        if (!this.product) {
            const container = this.createElement(null != tag ? tag : "div", [ ...null != classList ? classList : [], "shape" ], void 0, id);
            this.product = container;
        }
    }
    setStyle(style, option) {
        super.setStyle(style), this.setSvg(option);
    }
    setContent(option) {
        this.setSvg(option);
    }
    setSvg(option) {
        const html = getSvgHtml(option, this._option.valueToHtml);
        this.product && html !== this._svgHtmlCache && (this._svgHtmlCache = html, this.product.innerHTML = html);
    }
    release() {
        super.release(), this._svgHtmlCache = "";
    }
}

const builtInShape = {
    star: "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z"
};

function getSvgHtml(option, valueToHtml) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!(null == option ? void 0 : option.hasShape) || !option.symbolType) return "";
    const {symbolType: symbolType, fill: fill, stroke: stroke, hollow: hollow = !1} = option, size = option.size ? valueToHtml(option.size) : "8px", marginTop = option.marginTop ? valueToHtml(option.marginTop) : "0px", lineWidth = option.lineWidth ? valueToHtml(option.lineWidth) + "px" : "0px";
    let fillString = "currentColor";
    const getStroke = () => stroke ? valueToHtml(stroke) : fillString, sizeNumber = pixelPropertyStrToNumber(size), createSymbol = symbolType => new Symbol({
        symbolType: symbolType,
        size: sizeNumber,
        fill: !0
    });
    let symbol = createSymbol(null !== (_a = builtInShape[symbolType]) && void 0 !== _a ? _a : symbolType);
    const parsedPath = symbol.getParsedPath();
    parsedPath.path || (symbol = createSymbol(parsedPath.pathStr));
    const pathModel = symbol.getParsedPath().path, path = pathModel.toString(), bounds = pathModel.bounds;
    let viewBox = `${bounds.x1} ${bounds.y1} ${bounds.width()} ${bounds.height()}`;
    if ("0px" !== lineWidth) {
        const [x, y, w, h] = viewBox.split(" ").map((n => Number(n))), lw = Number(lineWidth.slice(0, -2));
        viewBox = `${x - lw / 2} ${y - lw / 2} ${w + lw} ${h + lw}`;
    }
    if (!fill || isString(fill) || hollow) return fillString = hollow ? "none" : fill ? valueToHtml(fill) : "currentColor", 
    `\n    <svg width="${size}" height="${size}" viewBox="${viewBox}"\n      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">\n      <path\n        d="${path}"\n        style="fill: ${fillString}; stroke: ${getStroke()}; stroke-width: ${lineWidth}"\n      >\n      </path>\n    </svg>`;
    if (isObject(fill)) {
        fillString = null !== (_b = "gradientColor" + option.index) && void 0 !== _b ? _b : "";
        let gradient = "";
        const stops = (null !== (_c = fill.stops) && void 0 !== _c ? _c : []).map((s => `<stop offset="${valueToHtml(s.offset.toString())}" stop-color="${valueToHtml(s.color)}"/>`)).join("");
        return "radial" === fill.gradient ? gradient = `<radialGradient id="${fillString}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">\n      ${stops}\n      </radialGradient>` : "linear" === fill.gradient && (gradient = `<linearGradient id="${fillString}" x1="${100 * (null !== (_d = fill.x0) && void 0 !== _d ? _d : 0)}%" y1="${100 * (null !== (_e = fill.y0) && void 0 !== _e ? _e : 0)}%" x2="${100 * (null !== (_f = fill.x1) && void 0 !== _f ? _f : 0)}%" y2="${100 * (null !== (_g = fill.y1) && void 0 !== _g ? _g : 0)}%">\n      ${stops}\n      </linearGradient>`), 
        `\n    <svg width="${size}" height="${size}" viewBox="-0.5 -0.5 1 1"\n      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">\n      ${gradient}\n      <path\n        d="${path}"\n        style="fill: url(#${fillString}); stroke: ${getStroke()}; stroke-width: ${lineWidth}"\n      >\n      </path>\n    </svg>`;
    }
    return "";
}
//# sourceMappingURL=shape-model.js.map
