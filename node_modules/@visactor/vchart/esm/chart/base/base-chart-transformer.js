import { has, isValid } from "@visactor/vutils";

import { Factory } from "../../core";

import { ComponentTypeEnum } from "../../component/interface";

import { setProperty } from "@visactor/vutils-extension";

export class BaseChartSpecTransformer {
    constructor(option) {
        this._option = option, this.type = option.type, this.seriesType = option.seriesType;
    }
    initChartSpec(chartSpec) {
        return this.transformSpec(chartSpec), this.transformModelSpec(chartSpec);
    }
    transformSpec(chartSpec) {
        chartSpec.region && 0 !== chartSpec.region.length || (chartSpec.region = [ {} ]), 
        has(chartSpec, "tooltip") || (chartSpec.tooltip = {}), isValid(chartSpec.stackInverse) && chartSpec.region.forEach((r => !isValid(r.stackInverse) && (r.stackInverse = chartSpec.stackInverse)));
    }
    transformModelSpec(chartSpec) {
        return this.createSpecInfo(chartSpec, ((constructor, specInfo, chartSpecInfo) => {
            const {spec: spec, specPath: specPath, specInfoPath: specInfoPath, type: type} = specInfo, transformResult = new constructor.transformerConstructor({
                type: type,
                getTheme: this._option.getTheme
            }).transformSpec(spec, chartSpec, chartSpecInfo);
            setProperty(chartSpec, specPath, transformResult.spec), setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), transformResult));
        }));
    }
    createSpecInfo(chartSpec, transform) {
        var _a;
        transform || (transform = (constructor, specInfo, chartSpecInfo) => {
            const {spec: spec, specPath: specPath, specInfoPath: specInfoPath, type: type} = specInfo, transformer = new constructor.transformerConstructor({
                type: type,
                getTheme: this._option.getTheme
            });
            setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), {
                theme: transformer.getTheme(spec, chartSpec)
            }));
        });
        const currentChartSpecInfo = {};
        let region;
        return this.forEachRegionInSpec(chartSpec, transform, currentChartSpecInfo), this.forEachSeriesInSpec(chartSpec, transform, currentChartSpecInfo), 
        null === (_a = currentChartSpecInfo.series) || void 0 === _a || _a.forEach((({spec: {regionId: regionId, regionIndex: regionIndex}}, i) => {
            var _a, _b, _c;
            isValid(regionId) ? region = null === (_a = currentChartSpecInfo.region) || void 0 === _a ? void 0 : _a.find((({spec: spec}) => spec.id === regionId)) : isValid(regionIndex) && (region = null === (_b = currentChartSpecInfo.region) || void 0 === _b ? void 0 : _b[regionIndex]), 
            (region || (region = null === (_c = currentChartSpecInfo.region) || void 0 === _c ? void 0 : _c[0])) && (region.seriesIndexes || (region.seriesIndexes = []), 
            region.seriesIndexes.push(i));
        })), this.forEachComponentInSpec(chartSpec, transform, currentChartSpecInfo), currentChartSpecInfo;
    }
    _isValidSeries(seriesType) {
        return !0;
    }
    _getDefaultSeriesSpec(chartSpec) {
        var _a, _b, _c, _d;
        return {
            dataKey: chartSpec.dataKey,
            hover: chartSpec.hover,
            select: chartSpec.select,
            label: chartSpec.label,
            seriesStyle: chartSpec.seriesStyle,
            animation: null !== (_a = chartSpec.animation) && void 0 !== _a ? _a : this._option.animation,
            animationThreshold: null !== (_b = chartSpec.animationThreshold) && void 0 !== _b ? _b : null === (_d = (_c = this._option).getTheme) || void 0 === _d ? void 0 : _d.call(_c).animationThreshold,
            animationAppear: chartSpec.animationAppear,
            animationDisappear: chartSpec.animationDisappear,
            animationEnter: chartSpec.animationEnter,
            animationUpdate: chartSpec.animationUpdate,
            animationExit: chartSpec.animationExit,
            animationNormal: chartSpec.animationNormal,
            extensionMark: chartSpec.extensionMark,
            large: chartSpec.large,
            largeThreshold: chartSpec.largeThreshold,
            progressiveStep: chartSpec.progressiveStep,
            progressiveThreshold: chartSpec.progressiveThreshold,
            background: chartSpec.seriesBackground,
            invalidType: chartSpec.invalidType,
            seriesField: chartSpec.seriesField,
            morph: chartSpec.morph
        };
    }
    forEachRegionInSpec(chartSpec, callbackfn, chartSpecInfo) {
        var _a;
        return (null !== (_a = chartSpec.region) && void 0 !== _a ? _a : []).map(((spec, index) => callbackfn(Factory.getRegionInType("region"), {
            spec: spec,
            specIndex: index,
            specPath: [ "region", index ],
            type: "region"
        }, chartSpecInfo)));
    }
    forEachSeriesInSpec(chartSpec, callbackfn, chartSpecInfo) {
        var _a;
        return (null !== (_a = chartSpec.series) && void 0 !== _a ? _a : []).map(((spec, index) => callbackfn(Factory.getSeriesInType(spec.type), {
            spec: spec,
            specIndex: index,
            specPath: [ "series", index ],
            type: spec.type
        }, chartSpecInfo)));
    }
    forEachComponentInSpec(chartSpec, callbackfn, chartSpecInfo) {
        var _a, _b, _c, _d;
        const results = [], components = Factory.getComponents();
        let cartesianAxis, polarAxis, geoCoordinate, label, totalLabel;
        const noAxisComponents = [];
        for (let index = 0; index < components.length; index++) {
            const {cmp: cmp, alwaysCheck: alwaysCheck} = components[index];
            cmp.type.startsWith(ComponentTypeEnum.cartesianAxis) ? cartesianAxis = cmp : cmp.type.startsWith(ComponentTypeEnum.polarAxis) ? polarAxis = cmp : cmp.type === ComponentTypeEnum.geoCoordinate ? geoCoordinate = cmp : (alwaysCheck || chartSpec[null !== (_a = cmp.specKey) && void 0 !== _a ? _a : cmp.type]) && (cmp.type === ComponentTypeEnum.label ? label = cmp : cmp.type === ComponentTypeEnum.totalLabel && (totalLabel = cmp), 
            noAxisComponents.push(cmp));
        }
        let hasInitAxis = !1;
        if (cartesianAxis) {
            const infoList = cartesianAxis.getSpecInfo(chartSpec);
            (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = !0, infoList.forEach((info => {
                const cmp = Factory.getComponentInKey(info.type);
                results.push(callbackfn(cmp, info, chartSpecInfo));
            })));
        }
        if (polarAxis && !hasInitAxis) {
            const infoList = polarAxis.getSpecInfo(chartSpec);
            (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = !0, infoList.forEach((info => {
                const cmp = Factory.getComponentInKey(info.type);
                results.push(callbackfn(cmp, info, chartSpecInfo));
            })));
        }
        return geoCoordinate && !hasInitAxis && (null === (_b = geoCoordinate.getSpecInfo(chartSpec)) || void 0 === _b || _b.forEach((info => {
            results.push(callbackfn(geoCoordinate, info, chartSpecInfo));
        }))), label && chartSpecInfo && (null === (_c = label.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _c || _c.forEach((info => {
            results.push(callbackfn(label, info, chartSpecInfo));
        }))), totalLabel && chartSpecInfo && (null === (_d = totalLabel.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _d || _d.forEach((info => {
            results.push(callbackfn(totalLabel, info, chartSpecInfo));
        }))), noAxisComponents.forEach((C => {
            var _a;
            null === (_a = C.getSpecInfo(chartSpec)) || void 0 === _a || _a.forEach((info => {
                results.push(callbackfn(C, info, chartSpecInfo));
            }));
        })), results;
    }
}
//# sourceMappingURL=base-chart-transformer.js.map
