import { ChartEvent } from "../constant/index";

import { getRegionStackGroup, stack, stackOffsetSilhouette, stackTotal } from "../util";

export class Stack {
    constructor(chart) {
        this.stackRegion = ({model: model}) => {
            const series = model.getSeries();
            if (!series.some((s => s.getStack()))) return;
            const hasTotalLabel = series.some((s => {
                var _a, _b;
                return null === (_b = null === (_a = s.getSpec()) || void 0 === _a ? void 0 : _a.totalLabel) || void 0 === _b ? void 0 : _b.visible;
            })), hasPercent = hasTotalLabel || series.some((s => s.getPercent())), hasOffsetSilhouette = series.some((s => s.getStackOffsetSilhouette())), stackValueGroup = getRegionStackGroup(model, !0);
            for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stack(stackValueGroup[stackValue].nodes[key], model.getStackInverse(), hasPercent);
            if (hasOffsetSilhouette) for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackOffsetSilhouette(stackValueGroup[stackValue].nodes[key]);
            hasTotalLabel && model.getSeries().forEach((s => {
                const stackData = s.getStackData(), stackValue = s.getStackValue(), stackValueField = s.getStackValueField();
                stackData && stackValueField && stackTotal(stackValueGroup[stackValue], stackValueField);
            }));
        }, this._chart = chart;
    }
    init() {
        this._chart.getAllRegions().forEach((r => {
            r.event.on(ChartEvent.regionSeriesDataFilterOver, {
                filter: ({model: model}) => (null == model ? void 0 : model.id) === r.id
            }, this.stackRegion);
        }));
    }
    stackAll() {
        this._chart.getAllRegions().forEach((r => {
            this.stackRegion({
                model: r
            });
        }));
    }
}
//# sourceMappingURL=stack.js.map