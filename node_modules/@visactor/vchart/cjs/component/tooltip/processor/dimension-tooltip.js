"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DimensionTooltipProcessor = void 0;

const base_1 = require("./base"), vutils_1 = require("@visactor/vutils");

class DimensionTooltipProcessor extends base_1.BaseTooltipProcessor {
    constructor() {
        super(...arguments), this.activeType = "dimension";
    }
    showTooltip(info, params, changePositionOnly) {
        const newParams = Object.assign(Object.assign({}, params), {
            dimensionInfo: this._preprocessDimensionInfo(info),
            changePositionOnly: changePositionOnly
        });
        return this._showTooltipByHandler(info, newParams);
    }
    shouldHandleTooltip(params, mouseEventData) {
        var _a, _b;
        const {tooltipInfo: info} = mouseEventData;
        if ((0, vutils_1.isNil)(info)) return !1;
        const helper = null === (_a = params.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
        return !!(null !== (_b = null == helper ? void 0 : helper.activeType) && void 0 !== _b ? _b : this.component.getSpec().activeType).includes("dimension");
    }
    getMouseEventData(params) {
        var _a;
        return {
            tooltipInfo: this._getDimensionInfo(params),
            ignore: [ ...null !== (_a = this.component.getOption().getAllSeries()) && void 0 !== _a ? _a : [] ].some((model => {
                var _a;
                const ignoreTriggers = null === (_a = model.tooltipHelper) || void 0 === _a ? void 0 : _a.ignoreTriggerSet.dimension;
                return params.model && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params.model)) || params.mark && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params.mark));
            }))
        };
    }
}

exports.DimensionTooltipProcessor = DimensionTooltipProcessor;
//# sourceMappingURL=dimension-tooltip.js.map
