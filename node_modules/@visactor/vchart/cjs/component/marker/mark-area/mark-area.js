"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerMarkArea = exports.MarkArea = void 0;

const vdataset_1 = require("@visactor/vdataset"), type_1 = require("../../interface/type"), aggregation_1 = require("../../../data/transforms/aggregation"), utils_1 = require("../utils"), register_1 = require("../../../data/register"), vrender_components_1 = require("@visactor/vrender-components"), vutils_1 = require("@visactor/vutils"), style_1 = require("../../../util/style"), base_marker_1 = require("../base-marker"), constant_1 = require("../../../constant"), factory_1 = require("../../../core/factory"), marker_filter_1 = require("../../../data/transforms/marker-filter");

class MarkArea extends base_marker_1.BaseMarker {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.markArea, this.name = type_1.ComponentTypeEnum.markArea, 
        this.specKey = "markArea", this.layoutZIndex = constant_1.LayoutZIndex.MarkArea;
    }
    static getSpecInfo(chartSpec) {
        const markAreaSpec = chartSpec[this.specKey];
        if ((0, vutils_1.isEmpty)(markAreaSpec)) return;
        if (!(0, vutils_1.isArray)(markAreaSpec) && !1 !== markAreaSpec.visible) return [ {
            spec: markAreaSpec,
            specPath: [ this.specKey ],
            type: type_1.ComponentTypeEnum.markArea
        } ];
        const specInfos = [];
        return markAreaSpec.forEach(((m, i) => {
            !1 !== m.visible && specInfos.push({
                spec: m,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: type_1.ComponentTypeEnum.markArea
            });
        })), specInfos;
    }
    _createMarkerComponent() {
        var _a, _b, _c, _d;
        const label = null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}, markAreaAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null !== (_b = this._spec.interactive) && void 0 !== _b && _b,
            points: [ {
                x: 0,
                y: 0
            } ],
            areaStyle: (0, style_1.transformToGraphic)(null === (_c = this._spec.area) || void 0 === _c ? void 0 : _c.style),
            clipInRange: null !== (_d = this._spec.clip) && void 0 !== _d && _d,
            label: (0, utils_1.transformLabelAttributes)(label)
        };
        return new vrender_components_1.MarkArea(markAreaAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d, _e;
        const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isXLayout = (0, 
        vutils_1.isValid)(spec.x) && (0, vutils_1.isValid)(spec.x1), isYLayout = (0, vutils_1.isValid)(spec.y) && (0, 
        vutils_1.isValid)(spec.y1), isXYLayout = isXLayout && isYLayout, isCoordinateLayout = (0, 
        vutils_1.isValid)(spec.coordinates), isPositionLayout = (0, vutils_1.isValid)(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
        let points = [], lines = [];
        isXYLayout ? (lines = (0, utils_1.xyLayout)(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), 
        points = [ {
            x: lines[0][0].x,
            y: lines[1][0].y
        }, lines[0][0], {
            x: lines[1][0].x,
            y: lines[0][0].y
        }, lines[1][0] ]) : isXLayout || isYLayout ? (lines = (0, utils_1.xyLayout)(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange), 
        points = [ ...lines[0], lines[1][1], lines[1][0] ]) : isCoordinateLayout ? points = (0, 
        utils_1.coordinateLayout)(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = (0, 
        utils_1.positionLayout)(spec.positions, relativeSeries, spec.regionRelative));
        const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
        let limitRect;
        if (spec.clip || (null === (_b = spec.label) || void 0 === _b ? void 0 : _b.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = (0, utils_1.computeClipRange)([ startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        this._markerComponent && this._markerComponent.setAttributes({
            points: points,
            label: Object.assign(Object.assign({}, null === (_c = this._markerComponent.attribute) || void 0 === _c ? void 0 : _c.label), {
                text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_e = null === (_d = this._markerComponent.attribute) || void 0 === _d ? void 0 : _d.label) || void 0 === _e ? void 0 : _e.text
            }),
            limitRect: limitRect,
            dx: this._layoutOffsetX,
            dy: this._layoutOffsetY
        });
    }
    _initDataView() {
        const spec = this._spec, relativeSeries = this._relativeSeries, isXProcess = (0, 
        vutils_1.isValid)(spec.x) && (0, vutils_1.isValid)(spec.x1), isYProcess = (0, vutils_1.isValid)(spec.y) && (0, 
        vutils_1.isValid)(spec.y1), isXYProcess = isXProcess && isYProcess, isCoordinateProcess = (0, 
        vutils_1.isValid)(spec.coordinates);
        if (!isXProcess && !isYProcess && !isCoordinateProcess) return null;
        let options;
        isXYProcess ? options = [ this._processSpecXY(spec.x, spec.y), this._processSpecXY(spec.x1, spec.y1) ] : isXProcess ? options = [ this._processSpecX(spec.x), this._processSpecX(spec.x1) ] : isYProcess ? options = [ this._processSpecY(spec.y), this._processSpecY(spec.y1) ] : isCoordinateProcess && (options = this._processSpecCoo(spec));
        const seriesData = relativeSeries.getViewData();
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "markerAggregation", aggregation_1.markerAggregation), 
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "markerFilter", marker_filter_1.markerFilter);
        const data = new vdataset_1.DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        data.parse([ seriesData ], {
            type: "dataview"
        }), data.transform({
            type: "markerAggregation",
            options: options
        }), options && data.transform({
            type: "markerFilter",
            options: this._getAllRelativeSeries()
        }), data.target.on("change", (() => {
            this._markerLayout();
        })), this._markerData = data;
    }
}

exports.MarkArea = MarkArea, MarkArea.type = type_1.ComponentTypeEnum.markArea, 
MarkArea.specKey = "markArea";

const registerMarkArea = () => {
    factory_1.Factory.registerComponent(MarkArea.type, MarkArea);
};

exports.registerMarkArea = registerMarkArea;
//# sourceMappingURL=mark-area.js.map
