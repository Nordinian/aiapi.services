"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerGaugeSeries = exports.GaugeSeries = void 0;

const type_1 = require("../interface/type"), progress_like_1 = require("../polar/progress-like/progress-like"), register_1 = require("../../data/register"), constant_1 = require("../../constant"), utils_1 = require("../../animation/utils"), progress_arc_1 = require("../../mark/progress-arc"), constant_2 = require("./constant"), vutils_1 = require("@visactor/vutils"), factory_1 = require("../../core/factory"), progress_like_2 = require("../polar/progress-like"), gauge_transformer_1 = require("./gauge-transformer");

class GaugeSeries extends progress_like_1.ProgressLikeSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.gauge, this.transformerConstructor = gauge_transformer_1.GaugeSeriesSpecTransformer, 
        this._segmentMark = null, this._trackMark = null, this._stack = !1, this._padAngle = 0;
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._padAngle = (0, vutils_1.degreeToRadian)(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
    }
    initData() {
        var _a;
        super.initData();
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "spiltSegment", ((data, op) => {
            const dataCollect = data.slice();
            return dataCollect.sort(((a, b) => a[this._angleField[0]] - b[this._angleField[0]])), 
            dataCollect.forEach(((datum, i) => {
                datum[constant_1.SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[constant_1.SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][constant_1.SEGMENT_FIELD_END] : void 0;
            })), dataCollect;
        })), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "spiltSegment"
        }, !1);
    }
    initMark() {
        super.initMark(), this._trackMark = this._createMark(GaugeSeries.mark.track, {
            parent: this._arcGroupMark,
            dataView: !1
        }), this._segmentMark = this._createMark(GaugeSeries.mark.segment, {
            parent: this._arcGroupMark,
            isSeriesMark: !0
        });
    }
    initMarkStyle() {
        super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
    }
    initSegmentMarkStyle() {
        var _a;
        const segmentMark = this._segmentMark;
        segmentMark && (this.setMarkStyle(segmentMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._getAngleValueStart.bind(this),
            endAngle: this._getAngleValueEnd.bind(this),
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 200,
            forceShowCap: !0
        }), this._trigger.registerMark(segmentMark));
    }
    initTooltip() {
        super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
    }
    initTrackMarkStyle() {
        var _a;
        const trackMark = this._trackMark;
        trackMark && (this.setMarkStyle(trackMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._startAngle,
            endAngle: this._endAngle,
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            zIndex: 100
        }), this._trigger.registerMark(trackMark));
    }
    _getAngleValueStartWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
        return Math.min(startAngle + this._padAngle / 2, (startAngle + endAngle) / 2);
    }
    _getAngleValueEndWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
        return Math.max(endAngle - this._padAngle / 2, (startAngle + endAngle) / 2);
    }
    _getAngleValueStartWithoutPadAngle(datum) {
        return (0, vutils_1.isValid)(datum[constant_1.SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([ datum[constant_1.SEGMENT_FIELD_START] ]) : this._startAngle;
    }
    _getAngleValueEndWithoutPadAngle(datum) {
        return this.angleAxisHelper.dataToPosition([ datum[constant_1.SEGMENT_FIELD_END] ]);
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._segmentMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
            startAngle: this._startAngle
        }, appearPreset), (0, utils_1.userAnimationConfig)("segment", this._spec, this._markAttributeContext)));
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [];
    }
}

exports.GaugeSeries = GaugeSeries, GaugeSeries.type = type_1.SeriesTypeEnum.gauge, 
GaugeSeries.mark = constant_2.gaugeSeriesMark, GaugeSeries.transformerConstructor = gauge_transformer_1.GaugeSeriesSpecTransformer;

const registerGaugeSeries = () => {
    (0, progress_arc_1.registerProgressArcMark)(), (0, progress_like_2.registerProgressLikeAnimation)(), 
    factory_1.Factory.registerSeries(GaugeSeries.type, GaugeSeries);
};

exports.registerGaugeSeries = registerGaugeSeries;
//# sourceMappingURL=gauge.js.map
