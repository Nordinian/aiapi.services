"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Trigger = void 0;

const event_1 = require("../event/event"), config_1 = require("./config"), vutils_1 = require("@visactor/vutils"), merge_spec_1 = require("../util/spec/merge-spec"), mark_set_1 = require("../mark/mark-set"), interface_1 = require("../compile/mark/interface"), constant_1 = require("../constant");

class Trigger {
    get hover() {
        return this._hover;
    }
    get select() {
        return this._select;
    }
    constructor(spec, option) {
        this._fields = null, this._marks = new mark_set_1.MarkSet, this._markReverse = new mark_set_1.MarkSet, 
        this.onHover = params => {
            this.filterEventMark(params) ? (this._isHovered = !0, this.hoverItem(params)) : this._isHovered && (this._isHovered = !1, 
            this.unhoverItem());
        }, this.onUnHover = params => {
            this.filterEventMark(params) || this.interaction.filterEventMark(params, interface_1.STATE_VALUE_ENUM.STATE_HOVER) || this.interaction.getEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER)[0] && this.unhoverItem();
        }, this.onSelect = params => {
            this.handleSingleEventSelect(params);
        }, this.onUnSelect = params => {
            this.interaction.filterEventMark(params, interface_1.STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
        }, this._spec = spec, this._option = option, this.event = new event_1.Event(option.eventDispatcher, option.mode), 
        this.interaction = option.interaction, this.initConfig(option.mode);
    }
    setStateKeys(fields) {
        this._fields = fields.slice();
    }
    registerMark(mark) {
        this._marks.addMark(mark), this._hover.enable && this.interaction.registerMark(interface_1.STATE_VALUE_ENUM.STATE_HOVER, mark), 
        this._select.enable && this.interaction.registerMark(interface_1.STATE_VALUE_ENUM.STATE_SELECTED, mark);
    }
    init() {
        this.initEvent();
    }
    release() {
        this.releaseEvent(), this._marks.clear();
    }
    initEvent() {
        const event = this.event, {enable: hoverEnable, trigger: hoverTrigger, triggerOff: hoverTriggerOff} = this._hover, {enable: selectEnable, trigger: selectTrigger, triggerOff: selectTriggerOff} = this._select;
        hoverEnable && ((0, vutils_1.array)(hoverTrigger).forEach((trigger => {
            event.on(trigger, {
                level: constant_1.Event_Bubble_Level.chart
            }, this.onHover);
        })), hoverTriggerOff && "none" !== hoverTriggerOff && (0, vutils_1.array)(hoverTriggerOff).forEach((trigger => {
            event.on(trigger, {
                level: constant_1.Event_Bubble_Level.vchart,
                source: constant_1.Event_Source_Type.chart
            }, this.onUnHover);
        }))), selectEnable && ((0, vutils_1.array)(selectTrigger).forEach((trigger => {
            event.on(trigger, {
                level: constant_1.Event_Bubble_Level.mark
            }, this.onSelect);
        })), selectTriggerOff && "none" !== selectTriggerOff && (0, vutils_1.array)(selectTriggerOff).forEach((trigger => {
            event.on(trigger, {
                level: constant_1.Event_Bubble_Level.mark
            }, this.onUnSelect);
        })), selectTriggerOff || (0, vutils_1.array)(null != selectTriggerOff ? selectTriggerOff : selectTrigger).forEach((trigger => {
            event.on(trigger, {
                level: constant_1.Event_Bubble_Level.vchart
            }, this.onUnSelect);
        })));
    }
    releaseEvent() {
        this.event.release();
    }
    initConfig(mode) {
        const defaultConfig = (0, config_1.getDefaultInteractionConfigByMode)(mode);
        this._hover = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.hover), 
        this._select = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.select);
        const hoverSpec = this._spec.hover;
        (0, vutils_1.isBoolean)(hoverSpec) ? this._hover.enable = hoverSpec : (0, vutils_1.isObject)(hoverSpec) && (this._hover.enable = !0, 
        this._hover = (0, merge_spec_1.mergeSpec)(this._hover, hoverSpec));
        const selectSpec = this._spec.select;
        (0, vutils_1.isBoolean)(selectSpec) ? this._select.enable = selectSpec : (0, vutils_1.isObject)(selectSpec) && (this._select.enable = !0, 
        this._select = (0, merge_spec_1.mergeSpec)(this._select, selectSpec));
    }
    hoverItem(params) {
        const {datum: datum} = params, lastEl = this.interaction.getEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER)[0];
        params.item !== lastEl && (this.interaction.exchangeEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER, params.item), 
        this.interaction.reverseEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER), 
        this.event.emit("hovered", {
            model: this._option.model,
            value: [ datum ]
        }));
    }
    unhoverItem() {
        const lastHoveredDatums = this.interaction.getEventElementData(interface_1.STATE_VALUE_ENUM.STATE_HOVER);
        this.interaction.clearEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER, !0), 
        this.event.emit("unhovered", {
            model: this._option.model,
            value: lastHoveredDatums
        });
    }
    handleSingleEventHover(params) {
        this.filterEventMark(params) ? this.hoverItem(params) : this.interaction.getEventElement(interface_1.STATE_VALUE_ENUM.STATE_HOVER)[0] && !this.interaction.filterEventMark(params, interface_1.STATE_VALUE_ENUM.STATE_HOVER) && this.unhoverItem();
    }
    selectItems(datums) {
        this.event.emit("selected", {
            model: this._option.model,
            value: datums
        });
    }
    clearSelectedItems() {
        const lastSelectedItem = this.interaction.getEventElementData(interface_1.STATE_VALUE_ENUM.STATE_SELECTED);
        this.interaction.clearEventElement(interface_1.STATE_VALUE_ENUM.STATE_SELECTED, !0), 
        this.event.emit("unselected", {
            model: this._option.model,
            value: lastSelectedItem
        });
    }
    unselectItems(params) {
        const {triggerOff: triggerOff} = this._select;
        "none" !== triggerOff && (this.interaction.removeEventElement(interface_1.STATE_VALUE_ENUM.STATE_SELECTED, params.item), 
        this.event.emit("unselected", {
            model: this._option.model,
            value: params.item
        }));
    }
    handleSingleEventSelect(params) {
        if (this.filterEventMark(params)) if (params.item.getStates().includes(interface_1.STATE_VALUE_ENUM.STATE_SELECTED)) this.unselectItems(params); else {
            if ("multiple" === this._select.mode) this.interaction.addEventElement(interface_1.STATE_VALUE_ENUM.STATE_SELECTED, params.item); else this.interaction.exchangeEventElement(interface_1.STATE_VALUE_ENUM.STATE_SELECTED, params.item);
            this.interaction.reverseEventElement(interface_1.STATE_VALUE_ENUM.STATE_SELECTED);
            const items = this.interaction.getEventElementData(interface_1.STATE_VALUE_ENUM.STATE_SELECTED);
            this.selectItems(items);
        } else this.interaction.filterEventMark(params, interface_1.STATE_VALUE_ENUM.STATE_SELECTED) || this.clearSelectedItems();
    }
    filterEventMark(params) {
        return !(!params.mark || !this._marks.includes(params.mark));
    }
    isDatumEqual(datumA, datumB) {
        return (this._fields ? this._fields : Object.keys(datumA)).every((f => datumA[f] === datumB[f]));
    }
}

exports.Trigger = Trigger;
//# sourceMappingURL=trigger.js.map
