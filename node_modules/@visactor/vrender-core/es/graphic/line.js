import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { getTheme } from "./theme";

import { application } from "../application";

import { parsePadding, pointsInterpolation } from "../common/utils";

import { CustomPath2D } from "../common/custom-path2d";

import { LINE_NUMBER_TYPE } from "./constants";

const LINE_UPDATE_TAG_KEY = [ "segments", "points", "curveType", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Line extends Graphic {
    constructor(params = {}) {
        super(params), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        if (this.pathProxy) return !0;
        const {points: points, segments: segments} = this.attribute;
        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
    }
    doUpdateAABBBounds() {
        const lineTheme = getTheme(this).line;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application.graphicService.updateLineAABBBounds(attribute, getTheme(this).line, this._AABBBounds, this), {boundsPadding: boundsPadding = lineTheme.boundsPadding} = attribute, paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return getTheme(this).line[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        const attribute = this.attribute, path = new CustomPath2D, segments = attribute.segments, parsePoints = points => {
            if (points && points.length) {
                let isFirst = !0;
                points.forEach((point => {
                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), 
                    isFirst = !1);
                }));
            }
        };
        return segments && segments.length ? segments.forEach((seg => {
            parsePoints(seg.points);
        })) : attribute.points && parsePoints(attribute.points), path;
    }
    clone() {
        return new Line(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Line.NOWORK_ANIMATE_ATTR;
    }
}

Line.NOWORK_ANIMATE_ATTR = Object.assign({
    segments: 1,
    curveType: 1
}, NOWORK_ANIMATE_ATTR);

export function createLine(attributes) {
    return new Line(attributes);
}
//# sourceMappingURL=line.js.map
