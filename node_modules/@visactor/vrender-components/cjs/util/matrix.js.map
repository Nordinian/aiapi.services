{"version":3,"sources":["../src/util/matrix.ts"],"names":[],"mappings":";;;AAKA,SAAgB,KAAK,CAAC,MAAe,EAAE,KAAa;IAClD,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;AAChD,CAAC;AAFD,sBAEC;AAKD,SAAgB,MAAM,CAAC,MAAe;IACpC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC;IACtB,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC,CAAC;AAHD,wBAGC;AAKD,SAAgB,SAAS,CAAC,MAAe;IACvC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC;IACtB,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACxB,IAAI,GAAG,GAAG,CAAC,EAAE;QACX,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAC1B;IACD,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;AAC5C,CAAC;AAPD,8BAOC;AAKD,SAAgB,KAAK,CAAC,OAAgB,EAAE,OAAgB;IACtD,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,OAAO,CAAC;IACzB,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,OAAO,CAAC;IACzB,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;IACjE,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,GAAG,CAAC;IAChD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC;AAND,sBAMC;AAQD,SAAgB,SAAS,CAAC,EAAY,EAAE,EAAY;IAClD,OAAO,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC;AAFD,8BAEC;AAQD,SAAgB,OAAO,CAAC,EAAoB,EAAE,EAAoB,EAAE,MAAe;IACjF,MAAM,GAAG,GAAG,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAC1B,MAAM,gBAAgB,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;IAChD,IAAI,MAAM,EAAE;QACV,IAAI,gBAAgB,EAAE;YACpB,OAAO,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;SAC1B;QACD,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,gBAAgB,EAAE;QACpB,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;AAC3B,CAAC;AAdD,0BAcC","file":"matrix.js","sourcesContent":["export type Vector2 = [number, number];\n\n/**\n * Scales a vec2 by a scalar number\n */\nexport function scale(vector: Vector2, scale: number): [number, number] {\n  return [vector[0] * scale, vector[1] * scale];\n}\n\n/**\n * Calculates the length of a vec2\n */\nexport function length(vector: Vector2) {\n  const [x, y] = vector;\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Normalize a vec2\n */\nexport function normalize(vector: Vector2) {\n  const [x, y] = vector;\n  let len = x * x + y * y;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  return [vector[0] * len, vector[1] * len];\n}\n\n/**\n * Get the angle between two 2D vectors\n */\nexport function angle(vector1: Vector2, vector2: Vector2) {\n  const [x1, y1] = vector1;\n  const [x2, y2] = vector2;\n  const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n  const cosine = mag && (x1 * x2 + y1 * y2) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n\n/**\n * 向量 v1 到 向量 v2 夹角的方向\n * @param  {Array} v1 向量\n * @param  {Array} v2 向量\n * @return {Boolean} >= 0 顺时针 < 0 逆时针\n */\nexport function direction(v1: number[], v2: number[]): number {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * 二维向量 v1 到 v2 的夹角\n * @param v1\n * @param v2\n * @param direct\n */\nexport function angleTo(v1: [number, number], v2: [number, number], direct: boolean): number {\n  const ang = angle(v1, v2);\n  const angleLargeThanPI = direction(v1, v2) >= 0;\n  if (direct) {\n    if (angleLargeThanPI) {\n      return Math.PI * 2 - ang;\n    }\n    return ang;\n  }\n\n  if (angleLargeThanPI) {\n    return ang;\n  }\n  return Math.PI * 2 - ang;\n}\n"]}