"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MarkLine = void 0;

const vutils_1 = require("@visactor/vutils"), segment_1 = require("../segment"), tag_1 = require("../tag"), base_1 = require("./base"), config_1 = require("./config"), limit_shape_1 = require("../util/limit-shape"), register_1 = require("./register");

(0, register_1.loadMarkLineComponent)();

class MarkLine extends base_1.Marker {
    getLine() {
        return this._line;
    }
    getLabel() {
        return this._label;
    }
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, MarkLine.defaultAttributes, attributes)), 
        this.name = "markLine";
    }
    setLabelPos() {
        var _a, _b;
        const {label: label = {}, limitRect: limitRect} = this.attribute, {position: position = "end", refX: refX = 0, refY: refY = 0, confine: confine} = label, points = this._line.getMainSegmentPoints(), labelAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
        let labelPoint;
        if (labelPoint = position.includes("start") || position.includes("Start") ? {
            x: points[0].x + labelOffsetX,
            y: points[0].y + labelOffsetY
        } : position.includes("middle") || position.includes("Middle") ? {
            x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
            y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
        } : {
            x: points[points.length - 1].x + labelOffsetX,
            y: points[points.length - 1].y + labelOffsetY
        }, this._label.setAttributes(Object.assign(Object.assign({}, labelPoint), {
            angle: label.autoRotate ? labelAngle + (null !== (_b = label.refAngle) && void 0 !== _b ? _b : 0) : 0,
            textStyle: Object.assign(Object.assign({}, config_1.DEFAULT_MARK_LINE_TEXT_STYLE_MAP[position]), label.textStyle)
        })), limitRect && confine) {
            const {x: x, y: y, width: width, height: height} = limitRect;
            (0, limit_shape_1.limitShapeInBounds)(this._label, {
                x1: x,
                y1: y,
                x2: x + width,
                y2: y + height
            });
        }
    }
    initMarker(container) {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, label: label, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment} = this.attribute, line = new segment_1.Segment({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment,
            pickable: !1
        });
        line.name = "mark-line-line", this._line = line, container.add(line);
        const markLabel = new tag_1.Tag(Object.assign({}, label));
        markLabel.name = "mark-line-label", this._label = markLabel, container.add(markLabel), 
        this.setLabelPos();
    }
    updateMarker() {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, label: label, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment} = this.attribute;
        this._line && this._line.setAttributes({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment
        }), this._label && this._label.setAttributes(Object.assign({
            dx: 0,
            dy: 0
        }, label)), this.setLabelPos();
    }
    isValidPoints() {
        const {points: points} = this.attribute;
        if (!points || points.length < 2) return !1;
        let validFlag = !0;
        return points.forEach((point => {
            if (point.length) point.forEach((p => {
                (0, vutils_1.isValidNumber)(p.x) && (0, vutils_1.isValidNumber)(p.y) || (validFlag = !1);
            })); else if (!(0, vutils_1.isValidNumber)(point.x) || !(0, vutils_1.isValidNumber)(point.y)) return void (validFlag = !1);
        })), validFlag;
    }
}

exports.MarkLine = MarkLine, MarkLine.defaultAttributes = config_1.DEFAULT_MARK_LINE_THEME;
//# sourceMappingURL=line.js.map
