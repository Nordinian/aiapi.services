import { AABBBounds, degreeToRadian, polarToCartesian } from "@visactor/vutils";

import { initTextMeasure } from "../../utils/text";

import { angleLabelOrientAttribute } from "../../utils/polar";

export const convertDomainToTickData = domain => domain.map(((t, index) => ({
    index: index,
    value: t
})));

export const labelOverlap = (prevLabel, nextLabel, gap = 0) => {
    const prevBounds = new AABBBounds(prevLabel).expand(gap / 2), nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
    return prevBounds.intersects(nextBounds);
};

export const labelDistance = (prevLabel, nextLabel) => {
    let horizontal = 0;
    prevLabel.x2 < nextLabel.x1 ? horizontal = nextLabel.x1 - prevLabel.x2 : nextLabel.x2 < prevLabel.x1 && (horizontal = prevLabel.x1 - nextLabel.x2);
    let vertical = 0;
    return prevLabel.y2 < nextLabel.y1 ? vertical = nextLabel.y1 - prevLabel.y2 : nextLabel.y2 < prevLabel.y1 && (vertical = prevLabel.y1 - nextLabel.y2), 
    [ horizontal, vertical ];
};

export function intersect(a, b, sep) {
    return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);
}

export function hasOverlap(items, pad) {
    for (let b, i = 1, n = items.length, a = items[0]; i < n; a = b, ++i) if (b = items[i], 
    intersect(a.AABBBounds, b.AABBBounds, pad)) return !0;
    return !1;
}

export const MIN_TICK_GAP = 12;

export const getCartesianLabelBounds = (scale, domain, op) => {
    var _a;
    const {labelStyle: labelStyle, axisOrientType: axisOrientType, labelFlush: labelFlush, labelFormatter: labelFormatter, startAngle: startAngle = 0} = op;
    let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
    "vertical" === labelStyle.direction && (labelAngle += degreeToRadian(90));
    const isHorizontal = [ "bottom", "top" ].includes(axisOrientType), isVertical = [ "left", "right" ].includes(axisOrientType);
    let scaleX = 1, scaleY = 0;
    isHorizontal || (isVertical ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), 
    scaleY = -Math.sin(startAngle)));
    const textMeasure = initTextMeasure(labelStyle), labelBoundsList = domain.map(((v, i) => {
        var _a, _b;
        const str = labelFormatter ? labelFormatter(v) : `${v}`, {width: width, height: height} = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), pos = scale.scale(v), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
        let align, baseline, textX = baseTextX, textY = baseTextY;
        align = labelFlush && isHorizontal && 0 === i ? "left" : labelFlush && isHorizontal && i === domain.length - 1 ? "right" : null !== (_a = labelStyle.textAlign) && void 0 !== _a ? _a : "center", 
        "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), 
        baseline = labelFlush && isVertical && 0 === i ? "top" : labelFlush && isVertical && i === domain.length - 1 ? "bottom" : null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", 
        "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
        const bounds = (new AABBBounds).set(textX, textY, textX + textWidth, textY + textHeight);
        return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
    }));
    return labelBoundsList;
};

export const getPolarAngleLabelBounds = (scale, domain, op) => {
    var _a;
    const {labelStyle: labelStyle, getRadius: getRadius, labelOffset: labelOffset, labelFormatter: labelFormatter} = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure = initTextMeasure(labelStyle);
    return domain.map((v => {
        const str = labelFormatter ? labelFormatter(v) : `${v}`, {width: width, height: height} = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), angle = scale.scale(v);
        let textX = 0, textY = 0;
        const orient = angleLabelOrientAttribute(angle), {x: x, y: y} = polarToCartesian({
            x: 0,
            y: 0
        }, radius + labelOffset, angle);
        textX = x + ("right" === orient.align ? -textWidth : "center" === orient.align ? -textWidth / 2 : 0), 
        textY = y + ("bottom" === orient.baseline ? -textHeight : "middle" === orient.baseline ? -textHeight / 2 : 0);
        return (new AABBBounds).set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
    }));
};

export const isAxisHorizontal = axisOrientType => [ "bottom", "top", "z" ].includes(axisOrientType);
//# sourceMappingURL=util.js.map