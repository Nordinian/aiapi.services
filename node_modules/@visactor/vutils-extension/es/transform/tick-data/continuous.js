import { isContinuous } from "@visactor/vscale";

import { isFunction, isValid, last } from "@visactor/vutils";

import { DEFAULT_CONTINUOUS_TICK_COUNT } from "./config";

import { convertDomainToTickData, getCartesianLabelBounds, hasOverlap, intersect } from "./util";

export const continuousTicks = (scale, op) => {
    if (!isContinuous(scale.type)) return convertDomainToTickData(scale.domain());
    const range = scale.range(), rangeSize = Math.abs(range[range.length - 1] - range[0]);
    if (rangeSize < 2) return convertDomainToTickData([ scale.domain()[0] ]);
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, noDecimals: noDecimals = !1, labelStyle: labelStyle} = op;
    let scaleTicks;
    if (isValid(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if (isValid(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if ("d3" === op.tickMode) {
        const count = isFunction(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.d3Ticks(null != count ? count : DEFAULT_CONTINUOUS_TICK_COUNT, {
            noDecimals: noDecimals
        });
    } else {
        const count = isFunction(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(null != count ? count : DEFAULT_CONTINUOUS_TICK_COUNT, {
            noDecimals: noDecimals
        });
    }
    if (op.sampling && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
        const {labelGap: labelGap = 4, labelFlush: labelFlush} = op;
        let items = getCartesianLabelBounds(scale, scaleTicks, op).map(((bounds, i) => ({
            AABBBounds: bounds,
            value: scaleTicks[i]
        })));
        for (;items.length >= 3 && hasOverlap(items, labelGap); ) items = methods.parity(items);
        const ticks = items.map((item => item.value));
        ticks.length < 3 && labelFlush && (ticks.length > 1 && ticks.pop(), last(ticks) !== last(scaleTicks) && ticks.push(last(scaleTicks))), 
        scaleTicks = ticks;
    }
    return convertDomainToTickData(scaleTicks);
};

const methods = {
    parity: function(items) {
        return items.filter(((item, i) => i % 2 == 0));
    },
    greedy: function(items, sep) {
        let a;
        return items.filter(((b, i) => (!i || !intersect(a.AABBBounds, b.AABBBounds, sep)) && (a = b, 
        !0)));
    }
};
//# sourceMappingURL=continuous.js.map